

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mzzf">
  <meta name="keywords" content="">
  
    <meta name="description" content="深入理解 Kubernetes API Server：核心机制与实践Kubernetes API Server (kube-apiserver) 是 Kubernetes 控制平面的核心组件，扮演着集群”大脑”的角色。它是所有管理操作的入口点，负责处理 REST 请求、验证请求、执行业务逻辑并将结果持久化到 etcd。理解 API Server 的工作原理对于有效管理和扩展 Kubernetes">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 Kubernetes API Server：核心机制与实践">
<meta property="og:url" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/index.html">
<meta property="og:site_name" content="Mzzf&#39;s Blog">
<meta property="og:description" content="深入理解 Kubernetes API Server：核心机制与实践Kubernetes API Server (kube-apiserver) 是 Kubernetes 控制平面的核心组件，扮演着集群”大脑”的角色。它是所有管理操作的入口点，负责处理 REST 请求、验证请求、执行业务逻辑并将结果持久化到 etcd。理解 API Server 的工作原理对于有效管理和扩展 Kubernetes">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317001413236.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317141928036.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317001401046.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317145348516.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317141918159.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317001019487.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317001025889.png">
<meta property="article:published_time" content="2025-03-16T16:09:25.000Z">
<meta property="article:modified_time" content="2025-04-27T09:53:00.100Z">
<meta property="article:author" content="Mzzf">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mfzzf.github.io/2025/03/17/kubernetes-API-server/image-20250317001413236.png">
  
  
  
  <title>深入理解 Kubernetes API Server：核心机制与实践 - Mzzf&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mfzzf.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mzzf&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解 Kubernetes API Server：核心机制与实践"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-17 00:09" pubdate>
          2025年3月17日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          66 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解 Kubernetes API Server：核心机制与实践</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="深入理解-Kubernetes-API-Server：核心机制与实践"><a href="#深入理解-Kubernetes-API-Server：核心机制与实践" class="headerlink" title="深入理解 Kubernetes API Server：核心机制与实践"></a>深入理解 Kubernetes API Server：核心机制与实践</h1><p>Kubernetes API Server (kube-apiserver) 是 Kubernetes 控制平面的核心组件，扮演着集群”大脑”的角色。它是所有管理操作的入口点，负责处理 REST 请求、验证请求、执行业务逻辑并将结果持久化到 etcd。理解 API Server 的工作原理对于有效管理和扩展 Kubernetes 集群至关重要。本文将深入探讨其核心功能、访问控制流程、限流机制、高可用性、多租户实现以及 API 对象的内部实现。</p>
<span id="more"></span>

<h2 id="1-API-Server-核心功能与架构"><a href="#1-API-Server-核心功能与架构" class="headerlink" title="1. API Server 核心功能与架构"></a>1. API Server 核心功能与架构</h2><p>kube-apiserver 主要承担以下职责：</p>
<ul>
<li><strong>提供统一的 REST API 入口</strong>：为集群内外的客户端（如 <code>kubectl</code>、控制器、调度器等）提供一致的 CRUD (创建、读取、更新、删除) 和 Watch 操作接口。</li>
<li><strong>集群状态的网关</strong>：作为唯一直接与 etcd 交互的组件，负责集群状态的持久化和读取。</li>
<li><strong>请求处理流水线</strong>：执行认证、授权、准入控制等一系列检查和处理步骤。</li>
<li><strong>API 注册与发现</strong>：支持 API Group 和 Versioning，允许扩展自定义资源 (CRD)。</li>
</ul>
<img src="/2025/03/17/kubernetes-API-server/image-20250317001413236.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001413236">

<p><em>图：API Server 在 Kubernetes 架构中的位置</em></p>
<h2 id="2-API-请求处理流程"><a href="#2-API-请求处理流程" class="headerlink" title="2. API 请求处理流程"></a>2. API 请求处理流程</h2><p>当一个请求到达 <code>kube-apiserver</code> 时，它会经过一系列的处理 Handler（过滤器），最终到达具体的 API 资源处理逻辑。</p>
<img src="/2025/03/17/kubernetes-API-server/image-20250317141928036.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317141928036">

<p><em>图：API Server 请求处理链</em></p>
<p>这个流程主要包括：</p>
<ol>
<li><strong>Panic Recovery</strong>: 捕获处理过程中的 panic，防止 apiserver 崩溃。</li>
<li><strong>Request Timeout</strong>: 为请求设置超时时间。</li>
<li><strong>Authentication (认证)</strong>: 验证请求者的身份是谁。</li>
<li><strong>Audit (审计)</strong>: 记录请求的详细信息。</li>
<li><strong>Impersonation (模拟)</strong>: 允许一个用户临时扮演另一个用户的身份。</li>
<li><strong>Max-in-flight &#x2F; Rate Limiting (限流)</strong>: 限制并发请求数量或速率，防止过载 (APF 机制在此生效)。</li>
<li><strong>Authorization (授权)</strong>: 检查认证通过的用户是否有权限执行请求的操作。</li>
<li><strong>Admission Control (准入控制)</strong>: 在对象持久化之前，进行最后的验证或修改。</li>
</ol>
<img src="/2025/03/17/kubernetes-API-server/image-20250317001401046.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001401046">

<p><em>图：访问控制三大环节：认证、授权、准入控制</em></p>
<p>接下来，我们将详细探讨访问控制的三个关键环节。</p>
<h2 id="3-认证-Authentication-你是谁？"><a href="#3-认证-Authentication-你是谁？" class="headerlink" title="3. 认证 (Authentication) - 你是谁？"></a>3. 认证 (Authentication) - 你是谁？</h2><p>认证是确定请求来源身份的过程。Kubernetes 支持多种认证机制，API Server 会按顺序尝试配置的认证器，一旦某个认证器成功识别用户身份，后续的认证器就不会再执行。</p>
<img src="/2025/03/17/kubernetes-API-server/image-20250317145348516.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317145348516">

<p><em>图：多种认证方式</em></p>
<p>以下是常见的认证机制：</p>
<hr>
<h4 id="3-1-X-509-客户端证书"><a href="#3-1-X-509-客户端证书" class="headerlink" title="3.1 X.509 客户端证书"></a><strong>3.1 X.509 客户端证书</strong></h4><ul>
<li><strong>原理</strong>: 基于 TLS 双向认证。客户端提供证书，API Server 使用配置的 CA (<code>--client-ca-file</code>) 验证该证书。证书的 <code>Common Name (CN)</code> 字段作为用户名，<code>Organization (O)</code> 字段作为用户组。</li>
<li><strong>配置</strong>:<ul>
<li>生成 CA 及客户端证书 (如前文所示)。</li>
<li>启动 API Server 时指定 <code>--client-ca-file</code>。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 集群组件（如 kubelet, kube-proxy）、管理员用户。</li>
</ul>
<hr>
<h4 id="3-2-Service-Account-Tokens"><a href="#3-2-Service-Account-Tokens" class="headerlink" title="3.2 Service Account Tokens"></a><strong>3.2 Service Account Tokens</strong></h4><ul>
<li><strong>原理</strong>: Kubernetes 内部机制，主要用于 Pod 访问 API Server。每个 Namespace 都有一个默认的 ServiceAccount，也可以创建自定义的。Token (JWT 格式) 以 Secret 形式存储，并自动挂载到 Pod 的 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>。API Server 使用 <code>--service-account-key-file</code> 指定的公钥验证 Token 签名。</li>
<li><strong>优点</strong>: Kubernetes 原生集成，自动管理。</li>
<li><strong>适用场景</strong>: Pod 内应用访问 API Server。</li>
</ul>
<hr>
<h4 id="3-3-OpenID-Connect-OIDC-Tokens"><a href="#3-3-OpenID-Connect-OIDC-Tokens" class="headerlink" title="3.3 OpenID Connect (OIDC) Tokens"></a><strong>3.3 OpenID Connect (OIDC) Tokens</strong></h4><ul>
<li><strong>原理</strong>: 集成外部身份提供商 (IdP)，如 Keycloak, Google, Dex 等。用户通过 IdP 获取 ID Token (JWT)，并在请求头 <code>Authorization: Bearer &lt;token&gt;</code> 中提供给 API Server。API Server 使用 IdP 的公钥验证 Token，并从中提取用户信息（用户名、组等）。</li>
<li><strong>配置</strong>: 需要配置 <code>--oidc-issuer-url</code>, <code>--oidc-client-id</code>, <code>--oidc-username-claim</code>, <code>--oidc-groups-claim</code> 等参数。</li>
<li><strong>适用场景</strong>: 集成企业 SSO 系统，为人类用户提供认证。</li>
</ul>
<hr>
<h4 id="3-4-Webhook-Token-认证"><a href="#3-4-Webhook-Token-认证" class="headerlink" title="3.4 Webhook Token 认证"></a><strong>3.4 Webhook Token 认证</strong></h4><ul>
<li><strong>原理</strong>: 将 Token 发送给一个外部 Webhook 服务进行验证。API Server 向配置的 Webhook 端点发送 <code>TokenReview</code> 对象，Webhook 服务返回包含用户信息的 <code>TokenReviewStatus</code>。</li>
<li><strong>配置</strong>:<ul>
<li>创建 Webhook 配置文件 (如前文所示)。</li>
<li>启动 API Server 时指定 <code>--authentication-token-webhook-config-file</code>。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 实现自定义或复杂的认证逻辑，集成现有认证系统。</li>
</ul>
<h5 id="3-4-1-基于-Webhook-的认证服务集成示例"><a href="#3-4-1-基于-Webhook-的认证服务集成示例" class="headerlink" title="3.4.1 基于 Webhook 的认证服务集成示例"></a><strong>3.4.1 基于 Webhook 的认证服务集成示例</strong></h5><p>构建一个符合 <code>TokenReview</code> API 规范的 Webhook 服务。</p>
<ul>
<li><strong>输入</strong>: <code>TokenReview</code> 对象，包含待验证的 Token。</li>
<li><strong>处理</strong>: 服务根据 Token 查询用户信息（例如，调用 GitHub API 验证 Personal Access Token）。</li>
<li><strong>输出</strong>: <code>TokenReview</code> 对象，<code>status</code> 字段包含认证结果 (<code>authenticated: true/false</code>) 和用户信息 (<code>user: &#123;username, uid, groups&#125;</code>).</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//解码认证请求</span><br>decoder := json.NewDecoder(r.Body)<br><span class="hljs-keyword">var</span> tr authentication.TokenReview<br>err := decoder.Decode(&amp;tr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 转发认证请求至认证服务器(以github为例)</span><br>ts := oauth2.StaticTokenSource(<br>	&amp;oauth2.Token&#123;AccessToken: tr.Spec.Token&#125;,<br>)<br>tc := oauth2.NewClient(oauth2.NoContext, ts)<br>client := github.NewClient(tc)<br>user, _, err := client.Users.Get(context.Background(), <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br>	<span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 认证结果返回给APIServer</span><br>w.WriteHeader(http.StatusOK)<br>trs := authentication.TokenReviewStatus&#123;<br>	Authenticated: <span class="hljs-literal">true</span>,<br>	User: authentication.UserInfo&#123;<br>		Username: *user.Login,<br>		UID:      *user.Login,<br>	&#125;,<br>&#125;<br>json.NewEncoder(w).Encode(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>	<span class="hljs-string">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span>,<br>	<span class="hljs-string">&quot;kind&quot;</span>:       <span class="hljs-string">&quot;TokenReview&quot;</span>,<br>	<span class="hljs-string">&quot;status&quot;</span>:     trs,<br>&#125;)<br></code></pre></td></tr></table></figure>

<h5 id="3-4-2-Keystone-认证集成陷阱"><a href="#3-4-2-Keystone-认证集成陷阱" class="headerlink" title="3.4.2 Keystone 认证集成陷阱"></a><strong>3.4.2 Keystone 认证集成陷阱</strong></h5><ul>
<li><strong>问题</strong>: 使用某些版本的 gophercloud 库与 Keystone 集成时，当 Keystone 返回 Token 过期错误，gophercloud 可能会无限重试，导致 API Server 持续向 Keystone 发送请求，最终压垮 Keystone。</li>
<li><strong>解决方案</strong>:<ul>
<li><strong>熔断</strong>: 在 API Server 的 Keystone 认证插件或 Webhook 服务中实现熔断逻辑，当错误率超过阈值时暂时停止向 Keystone 发送请求。</li>
<li><strong>限流</strong>: 对发往 Keystone 的请求进行限流。</li>
<li><strong>更新库</strong>: 使用修复了此问题的 gophercloud 版本。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-5-引导-Token-Bootstrap-Token"><a href="#3-5-引导-Token-Bootstrap-Token" class="headerlink" title="3.5 引导 Token (Bootstrap Token)"></a><strong>3.5 引导 Token (Bootstrap Token)</strong></h4><ul>
<li><strong>原理</strong>: 用于 <code>kubeadm join</code> 过程，让新节点安全地加入集群。Token 以 Secret 形式存储在 <code>kube-system</code> 命名空间，有 TTL，由 <code>kube-controller-manager</code> 的 <code>tokencleaner</code> 控制器自动清理。</li>
<li><strong>适用场景</strong>: 集群节点引导。</li>
</ul>
<hr>
<h4 id="3-6-静态-Token-文件-静态密码文件"><a href="#3-6-静态-Token-文件-静态密码文件" class="headerlink" title="3.6 静态 Token 文件 &amp; 静态密码文件"></a><strong>3.6 静态 Token 文件 &amp; 静态密码文件</strong></h4><ul>
<li><strong>原理</strong>: 将预定义的 Token 或用户名密码存储在 CSV 文件中 (<code>--token-auth-file</code>, <code>--basic-auth-file</code>)。API Server 加载文件内容进行匹配。</li>
<li><strong>缺点</strong>: 安全性差（明文存储、无过期），管理不便。不推荐用于生产环境。</li>
</ul>
<hr>
<h4 id="3-7-匿名请求"><a href="#3-7-匿名请求" class="headerlink" title="3.7 匿名请求"></a><strong>3.7 匿名请求</strong></h4><ul>
<li><strong>原理</strong>: 如果所有配置的认证器都无法识别请求者身份，且 API Server 启用了匿名认证 (<code>--anonymous-auth=true</code>，默认启用)，则请求被视为匿名用户 (<code>system:anonymous</code>)，属于 <code>system:unauthenticated</code> 组。</li>
<li><strong>注意</strong>: 需要配合授权策略（如 RBAC）限制匿名用户的权限。生产环境通常建议禁用 (<code>--anonymous-auth=false</code>) 或严格限制其权限。</li>
</ul>
<h2 id="4-授权-Authorization-你能做什么？"><a href="#4-授权-Authorization-你能做什么？" class="headerlink" title="4. 授权 (Authorization) - 你能做什么？"></a>4. 授权 (Authorization) - 你能做什么？</h2><p>认证之后，授权环节决定用户是否有权限对目标资源执行请求的操作（如 GET, POST, DELETE）。API Server 支持多种授权模式，通过 <code>--authorization-mode</code> 参数指定，可以指定多个模式，按顺序检查，只要有一个模式授权通过即可。</p>
<img src="/2025/03/17/kubernetes-API-server/image-20250317141918159.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317141918159">

<p><em>图：授权流程</em></p>
<p>常见的授权模式：</p>
<ul>
<li><strong>Node</strong>: 特殊模式，用于授权 Kubelet 发出的 API 请求。它根据 Kubelet 自身注册的 Node 对象，限制其只能访问与自身节点相关的资源（如 Pods, Secrets, ConfigMaps 等）。</li>
<li><strong>RBAC (Role-Based Access Control)</strong>: <strong>推荐使用</strong>。基于角色的访问控制，通过 Role&#x2F;ClusterRole 定义权限，通过 RoleBinding&#x2F;ClusterRoleBinding 将角色绑定到用户、组或 ServiceAccount。</li>
<li><strong>Webhook</strong>: 将授权决策委托给外部 Webhook 服务。API Server 发送 <code>SubjectAccessReview</code> 对象，Webhook 服务返回授权结果。</li>
<li><strong>ABAC (Attribute-Based Access Control)</strong>: 基于属性的访问控制，通过策略文件定义规则。配置复杂，管理困难，已不推荐。</li>
<li><strong>AlwaysAllow &#x2F; AlwaysDeny</strong>: 测试模式，允许或拒绝所有请求。</li>
</ul>
<h3 id="4-1-RBAC-详解"><a href="#4-1-RBAC-详解" class="headerlink" title="4.1 RBAC 详解"></a>4.1 RBAC 详解</h3><p>RBAC 是 Kubernetes 中最常用且推荐的授权机制。</p>
<ul>
<li><p><strong>核心概念</strong>:</p>
<ul>
<li><strong>Subject (主体)</strong>: User, Group, ServiceAccount。</li>
<li><strong>Role (角色)</strong>: 定义在一组 <strong>Namespace 范围</strong> 内的权限（允许对哪些资源执行哪些操作）。</li>
<li><strong>ClusterRole (集群角色)</strong>: 定义 <strong>集群范围</strong> 的权限（适用于所有 Namespace 的资源或集群级别的资源，如 Node, Namespace）。</li>
<li><strong>RoleBinding (角色绑定)</strong>: 将 Role 绑定到一个或多个 Subject，使其在 <strong>特定 Namespace</strong> 内拥有该 Role 定义的权限。</li>
<li><strong>ClusterRoleBinding (集群角色绑定)</strong>: 将 ClusterRole 绑定到一个或多个 Subject，使其在 <strong>整个集群</strong> 拥有该 ClusterRole 定义的权限。</li>
</ul>
</li>
<li><p><strong>示例：为用户组授权读取 Secrets</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ClusterRole 定义读取 Secret 的权限</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-reader</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>] <span class="hljs-comment"># &quot;&quot; 表示 core API group</span><br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;secrets&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>]<br><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># ClusterRoleBinding 将 &#x27;secret-reader&#x27; 角色绑定到 &#x27;manager&#x27; 组</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">read-secrets-global</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">manager</span> <span class="hljs-comment"># 组名区分大小写</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-reader</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-规划系统角色与权限"><a href="#4-2-规划系统角色与权限" class="headerlink" title="4.2 规划系统角色与权限"></a>4.2 规划系统角色与权限</h3><p>设计 RBAC 策略时，应遵循最小权限原则。常见角色划分：</p>
<ul>
<li><strong>Cluster Admin</strong>: 拥有集群所有权限 (绑定到 <code>cluster-admin</code> ClusterRole)。</li>
<li><strong>Namespace Admin</strong>: 拥有特定 Namespace 内所有资源的完全控制权。</li>
<li><strong>Developer</strong>: 在特定 Namespace 内创建、更新、删除工作负载（Deployments, Pods 等）的权限，可能有限制地访问 Secrets, ConfigMaps。</li>
<li><strong>Viewer</strong>: 对特定 Namespace 或整个集群有只读权限。</li>
<li><strong>CI&#x2F;CD System (ServiceAccount)</strong>: 部署应用所需的权限。</li>
</ul>
<h3 id="4-3-实现自定义授权逻辑-Namespace-Owner-示例"><a href="#4-3-实现自定义授权逻辑-Namespace-Owner-示例" class="headerlink" title="4.3 实现自定义授权逻辑 (Namespace Owner 示例)"></a>4.3 实现自定义授权逻辑 (Namespace Owner 示例)</h3><p>有时需要更动态的授权逻辑，例如让 Namespace 的创建者自动拥有该 Namespace 的管理权限。</p>
<ol>
<li><strong>创建基础角色</strong>: 定义一个 <code>namespace-admin</code> Role (或 ClusterRole，如果权限需要在所有 Namespace 中一致)。</li>
<li><strong>准入控制器 (Mutating Webhook)</strong>: 创建一个 Mutating Admission Webhook。当创建 Namespace 的请求 (<code>CREATE Namespace</code>) 到达时，该 Webhook 自动将请求用户的身份信息（用户名或组）添加到 Namespace 的 Annotation 中，例如 <code>owner: user-a</code>。</li>
<li><strong>RBAC 控制器 (自定义 Controller)</strong>: 创建一个自定义控制器，监听 Namespace 的创建和更新事件。当检测到新的 Namespace 或 <code>owner</code> Annotation 变化时，该控制器：<ul>
<li>读取 <code>owner</code> Annotation 获取用户信息。</li>
<li>在对应的 Namespace 中创建或更新一个 RoleBinding，将步骤 1 中定义的 <code>namespace-admin</code> Role 绑定到该用户。</li>
</ul>
</li>
</ol>
<h3 id="4-4-授权最佳实践与陷阱"><a href="#4-4-授权最佳实践与陷阱" class="headerlink" title="4.4 授权最佳实践与陷阱"></a>4.4 授权最佳实践与陷阱</h3><ul>
<li><strong>最小权限原则</strong>: 只授予必要的权限。</li>
<li><strong>使用 Role 和 RoleBinding</strong> 优先于 ClusterRole 和 ClusterRoleBinding，以限制权限范围。</li>
<li><strong>定期审计</strong>: 定期检查 RoleBinding 和 ClusterRoleBinding，移除不再需要的权限。</li>
<li><strong>管理 ServiceAccount 权限</strong>: 不要给 ServiceAccount 过高的权限，特别是 <code>default</code> ServiceAccount。</li>
<li><strong>避免使用 <code>default</code> Namespace</strong>: 为不同应用或团队创建独立的 Namespace。</li>
<li><strong>源代码管理 RBAC 配置</strong>: 将 RBAC YAML 文件纳入版本控制。</li>
<li><strong>注意权限传递</strong>: 用户 A 可以创建 RoleBinding 将自己拥有的权限授予用户 B。</li>
<li><strong>避免大量 Role&#x2F;Binding</strong>: 过多的 RBAC 对象会影响鉴权性能。</li>
<li><strong>绕过鉴权 (不推荐)</strong>: SSH 到 Master 节点通过 insecure port (如果启用) 访问 apiserver 可以绕过认证和授权，仅用于紧急情况。</li>
</ul>
<h2 id="5-准入控制-Admission-Control-规则检查与修改"><a href="#5-准入控制-Admission-Control-规则检查与修改" class="headerlink" title="5. 准入控制 (Admission Control) - 规则检查与修改"></a>5. 准入控制 (Admission Control) - 规则检查与修改</h2><p>准入控制是请求处理流程的最后一道关卡，发生在请求通过认证和授权之后、对象持久化到 etcd 之前。它用于执行更复杂的验证逻辑、强制实施策略或在对象创建&#x2F;更新时自动进行修改。</p>
<p>准入控制器只对 <code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CONNECT</code> 操作生效，对 <code>GET</code>, <code>LIST</code>, <code>WATCH</code> 无效。</p>
<p>API Server 通过 <code>--enable-admission-plugins</code> 参数启用一系列内置的准入控制器，并通过 <code>--disable-admission-plugins</code> 禁用某些默认启用的插件。执行顺序很重要。</p>
<p>常见的内置准入控制器：</p>
<ul>
<li><strong>NamespaceLifecycle</strong>: 防止在正在被删除的 Namespace 中创建新对象，防止删除包含活跃资源的 <code>kube-system</code>, <code>kube-public</code>, <code>kube-node-lease</code> Namespace。</li>
<li><strong>LimitRanger</strong>: 读取 Namespace 下的 LimitRange 对象，为 Pod 设置默认的资源请求 (Request) 和限制 (Limit)，并校验 Pod 的资源设置不超过 LimitRange 的限制。</li>
<li><strong>ServiceAccount</strong>: 为 Pod 自动挂载 ServiceAccount Token，如果 Pod 没有指定 ServiceAccount，则使用 <code>default</code> ServiceAccount。</li>
<li><strong>ResourceQuota</strong>: 读取 Namespace 下的 ResourceQuota 对象，确保创建或更新资源不会超出 Namespace 的配额限制（如 CPU, Memory, 对象数量等）。</li>
<li><strong>PodSecurityPolicy (Deprecated in 1.21, Removed in 1.25)</strong> &#x2F; <strong>PodSecurity (Stable in 1.25+)</strong>: 强制实施 Pod 安全标准（如禁止特权容器、限制 HostPath 挂载等）。PodSecurity 通过 Namespace Label 控制策略级别 (privileged, baseline, restricted)。</li>
<li><strong>MutatingAdmissionWebhook</strong>: 调用外部 Webhook 服务来修改对象。</li>
<li><strong>ValidatingAdmissionWebhook</strong>: 调用外部 Webhook 服务来验证对象。</li>
<li><strong>NodeRestriction</strong>: 限制 Kubelet 只能修改其自身注册的 Node 对象，以及只能获取&#x2F;修改运行在自身节点上的 Pod 对象。</li>
</ul>
<h3 id="5-1-自定义准入控制-Webhooks"><a href="#5-1-自定义准入控制-Webhooks" class="headerlink" title="5.1 自定义准入控制 (Webhooks)"></a>5.1 自定义准入控制 (Webhooks)</h3><p>可以通过创建 <code>MutatingWebhookConfiguration</code> 和 <code>ValidatingWebhookConfiguration</code> 对象来注册自定义的准入逻辑。</p>
<ul>
<li><strong>Mutating Webhook</strong>: 在内置的修改逻辑之后、对象模式校验之前执行。可以修改请求中的对象。常用于自动注入 Sidecar 容器、设置默认标签等。</li>
<li><strong>Validating Webhook</strong>: 在对象模式校验之后、持久化之前执行。只能验证对象，不能修改。常用于强制实施自定义策略、检查资源规范等。</li>
</ul>
<p><strong>Webhook 配置示例</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">admissionregistration.k8s.io/v1</span> <span class="hljs-comment"># v1beta1 已弃用</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">MutatingWebhookConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-mutating-webhook</span><br><span class="hljs-attr">webhooks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-webhook.example.com</span><br>  <span class="hljs-attr">clientConfig:</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-comment"># 可以是 Service 或 URL</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">my-admission-webhook-service</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-admission-system</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mutate&quot;</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>    <span class="hljs-attr">caBundle:</span> <span class="hljs-comment"># CA 证书，用于验证 Webhook Server 的 TLS 证书</span><br>      <span class="hljs-string">&quot;LS0t...&quot;</span> <br>  <span class="hljs-attr">rules:</span> <span class="hljs-comment"># 定义哪些操作和资源会触发此 Webhook</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">operations:</span> [ <span class="hljs-string">&quot;CREATE&quot;</span>, <span class="hljs-string">&quot;UPDATE&quot;</span> ]<br>    <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;apps&quot;</span>]<br>    <span class="hljs-attr">apiVersions:</span> [<span class="hljs-string">&quot;v1&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;deployments&quot;</span>]<br>  <span class="hljs-attr">failurePolicy:</span> <span class="hljs-string">Fail</span> <span class="hljs-comment"># 如果 Webhook 调用失败，是拒绝请求 (Fail) 还是忽略 (Ignore)</span><br>  <span class="hljs-attr">sideEffects:</span> <span class="hljs-string">None</span> <span class="hljs-comment"># 指明 Webhook 是否有副作用（如调用其他 API）</span><br>  <span class="hljs-attr">admissionReviewVersions:</span> [<span class="hljs-string">&quot;v1&quot;</span>] <span class="hljs-comment"># 支持的 AdmissionReview API 版本</span><br></code></pre></td></tr></table></figure>
<ul>
<li>Webhook 服务需要实现一个 HTTPS 端点，接收 <code>AdmissionReview</code> 请求，并返回包含决策 (<code>allowed: true/false</code>, <code>patch</code> (for mutating), <code>status</code> (for validating)) 的 <code>AdmissionReview</code> 响应。</li>
</ul>
<h3 id="5-2-配额管理-ResourceQuota"><a href="#5-2-配额管理-ResourceQuota" class="headerlink" title="5.2 配额管理 (ResourceQuota)"></a>5.2 配额管理 (ResourceQuota)</h3><ul>
<li><strong>目的</strong>: 防止单个 Namespace 或用户耗尽集群资源。</li>
<li><strong>实现</strong>:<ol>
<li>在 API Server 中启用 <code>ResourceQuota</code> 准入控制器 (<code>--enable-admission-plugins=...,ResourceQuota,...</code>)。</li>
<li>在需要限制的 Namespace 中创建 <code>ResourceQuota</code> 对象，定义资源限制（计算资源、存储资源、对象数量）。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ResourceQuota</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">compute-quota</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">my-namespace</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hard:</span><br>    <span class="hljs-attr">requests.cpu:</span> <span class="hljs-string">&quot;4&quot;</span> <br>    <span class="hljs-attr">requests.memory:</span> <span class="hljs-string">16Gi</span><br>    <span class="hljs-attr">limits.cpu:</span> <span class="hljs-string">&quot;8&quot;</span><br>    <span class="hljs-attr">limits.memory:</span> <span class="hljs-string">32Gi</span><br>    <span class="hljs-attr">pods:</span> <span class="hljs-string">&quot;10&quot;</span><br>    <span class="hljs-attr">secrets:</span> <span class="hljs-string">&quot;20&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><strong>可选</strong>: 创建一个控制器或 Webhook，在 Namespace 创建时自动为其创建默认的 ResourceQuota 对象（可以从 ConfigMap 读取模板）。</li>
</ol>
</li>
</ul>
<h2 id="6-限流-Rate-Limiting-与-API-优先级和公平性-APF"><a href="#6-限流-Rate-Limiting-与-API-优先级和公平性-APF" class="headerlink" title="6. 限流 (Rate Limiting) 与 API 优先级和公平性 (APF)"></a>6. 限流 (Rate Limiting) 与 API 优先级和公平性 (APF)</h2><p>为了保护 API Server 不被过量请求压垮，需要进行限流。</p>
<h3 id="6-1-传统限流-Max-in-flight"><a href="#6-1-传统限流-Max-in-flight" class="headerlink" title="6.1 传统限流 (Max-in-flight)"></a>6.1 传统限流 (Max-in-flight)</h3><p>早期 Kubernetes 版本主要通过两个参数进行全局限流：</p>
<ul>
<li><code>--max-requests-inflight</code>: 同时处理的最大非变更性请求数 (GET, LIST, WATCH)。默认 400。</li>
<li><code>--max-mutating-requests-inflight</code>: 同时处理的最大变更性请求数 (POST, PUT, DELETE, PATCH)。默认 200。</li>
</ul>
<p><strong>局限性</strong>:</p>
<ul>
<li><strong>粒度粗</strong>: 无法区分请求来源或重要性。</li>
<li><strong>不公平</strong>: 一个行为异常的客户端可能耗尽所有并发额度，影响其他正常客户端。</li>
<li><strong>无优先级</strong>: 关键系统组件（如控制器）的请求可能被普通用户请求阻塞。</li>
</ul>
<h3 id="6-2-API-优先级和公平性-API-Priority-and-Fairness-APF"><a href="#6-2-API-优先级和公平性-API-Priority-and-Fairness-APF" class="headerlink" title="6.2 API 优先级和公平性 (API Priority and Fairness - APF)"></a>6.2 API 优先级和公平性 (API Priority and Fairness - APF)</h3><p>APF (GA in 1.20) 引入了更精细化的限流机制，旨在解决传统限流的不足。</p>
<img src="/2025/03/17/kubernetes-API-server/image-20250317001019487.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001019487">

<p><em>图：APF 架构示意图</em></p>
<p><strong>核心概念</strong>:</p>
<ul>
<li><strong>PriorityLevelConfiguration (PLC)</strong>: 定义一个优先级级别。每个 PLC 拥有独立的并发份额 (<code>assuredConcurrencyShares</code>) 和排队机制。可以配置多个 PLC，代表不同的重要程度。<ul>
<li><code>type: Limited</code>: 受限流控制。<ul>
<li><code>assuredConcurrencyShares</code>: 保证的并发执行单元数。API Server 总并发数按比例分配给各 PLC。</li>
<li><code>limitResponse</code>: 当并发达到限制时的行为。<ul>
<li><code>type: Queue</code>: 请求进入队列等待。<ul>
<li><code>queues</code>: 队列数量。</li>
<li><code>queueLengthLimit</code>: 每个队列的最大长度。</li>
<li><code>handSize</code>: 用于 Shuffle Sharding 的参数。</li>
</ul>
</li>
<li><code>type: Reject</code>: 直接拒绝请求 (HTTP 429)。</li>
</ul>
</li>
</ul>
</li>
<li><code>type: Exempt</code>: 不受限流控制。</li>
</ul>
</li>
<li><strong>FlowSchema (FS)</strong>: 定义规则，将传入的请求分类 (match) 到某个 <code>PriorityLevelConfiguration</code>。匹配规则可以基于用户、组、ServiceAccount、请求的 Verb (GET, POST)、资源类型 (pods, deployments) 等。<ul>
<li><code>matchingPrecedence</code>: 多个 FlowSchema 可能匹配同一个请求，优先级高的先生效。</li>
<li><code>distinguisherMethod</code>: 如何在同一个 FlowSchema 内进一步区分请求流 (Flow)。<ul>
<li><code>type: ByUser</code>: 按请求用户区分。</li>
<li><code>type: ByNamespace</code>: 按请求资源的 Namespace 区分。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Request (请求)</strong>: 每个到达的 API 请求。</li>
<li><strong>Flow (流)</strong>: 根据 FlowSchema 的 <code>distinguisherMethod</code> 划分的一组请求，例如来自同一个用户的所有请求，或针对同一个 Namespace 的所有请求。</li>
<li><strong>Queue (队列)</strong>: 每个 <code>Limited</code> 类型的 PLC 内部包含多个队列。</li>
<li><strong>Shuffle Sharding</strong>: 一种将 Flow 分配到 Queue 的算法。它确保高流量的 Flow 不会完全阻塞低流量的 Flow。每个 Flow 会被哈希到 <code>handSize</code> 个可能的队列中，然后选择当前最不繁忙的一个队列加入。</li>
<li><strong>Fair Queuing</strong>: 从队列中选择下一个要执行的请求的算法。确保同一个 PLC 内的不同 Flow 能够公平地获得执行机会，防止某个 Flow 饿死其他 Flow。</li>
</ul>
<p><strong>默认配置</strong>: Kubernetes 自带了一些默认的 PLC 和 FS，用于区分系统组件、领导者选举、高优先级工作负载、普通工作负载和默认流量。</p>
<ul>
<li><strong>PLC 示例 (<code>global-default</code>)</strong>:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span> <span class="hljs-comment"># 或 v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityLevelConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">global-default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">Limited</span><br>  <span class="hljs-attr">limited:</span><br>    <span class="hljs-attr">assuredConcurrencyShares:</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 保证的并发份额</span><br>    <span class="hljs-attr">limitResponse:</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Queue</span> <span class="hljs-comment"># 超出并发时排队</span><br>      <span class="hljs-attr">queuing:</span><br>        <span class="hljs-attr">queues:</span> <span class="hljs-number">128</span> <span class="hljs-comment"># 队列数量</span><br>        <span class="hljs-attr">queueLengthLimit:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个队列长度</span><br>        <span class="hljs-attr">handSize:</span> <span class="hljs-number">6</span> <span class="hljs-comment"># Shuffle Sharding 参数</span><br></code></pre></td></tr></table></figure></li>
<li><strong>FS 示例 (<code>kube-scheduler</code>)</strong>:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span> <span class="hljs-comment"># 或 v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">FlowSchema</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-scheduler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">priorityLevelConfiguration:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">workload-high</span> <span class="hljs-comment"># 关联到高优先级 PLC</span><br>  <span class="hljs-attr">matchingPrecedence:</span> <span class="hljs-number">800</span> <span class="hljs-comment"># 匹配优先级</span><br>  <span class="hljs-attr">distinguisherMethod:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">ByUser</span> <span class="hljs-comment"># 按用户区分流</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">subjects:</span> <span class="hljs-comment"># 匹配来自 kube-scheduler 用户的请求</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>      <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-scheduler</span><br>    <span class="hljs-attr">resourceRules:</span> <span class="hljs-comment"># 匹配所有资源和操作</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;*&quot;</span>]<br>      <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;*&quot;</span>]<br>      <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;*&quot;</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>调试 APF</strong>: 可以通过 API Server 的 <code>/debug/api_priority_and_fairness/</code> 端点查看当前的 PLC 状态、队列信息和请求统计。</p>
<h2 id="7-高可用-API-Server"><a href="#7-高可用-API-Server" class="headerlink" title="7. 高可用 API Server"></a>7. 高可用 API Server</h2><p>由于 API Server 是控制平面的核心，其高可用性至关重要。</p>
<ul>
<li><strong>无状态设计</strong>: API Server 本身是无状态的 REST 服务，状态存储在 etcd 中。这使得横向扩展（运行多个实例）变得容易。</li>
<li><strong>多副本部署</strong>: 运行至少 3 个 API Server 实例，分布在不同的物理节点或可用区。</li>
<li><strong>负载均衡</strong>: 在多个 API Server 实例前放置一个负载均衡器（如 Nginx, HAProxy, 或云厂商提供的 LB 服务）。<ul>
<li>所有客户端（包括集群内部组件如 Kubelet, Controller Manager, Scheduler）都应配置为访问负载均衡器的 VIP 或 DNS 名称。</li>
<li><strong>证书</strong>: API Server 的 TLS 证书需要包含负载均衡器的 VIP 和 DNS 名称，以及各个 API Server 实例的 IP 和主机名。</li>
</ul>
</li>
<li><strong>etcd 集群</strong>: API Server 依赖高可用的 etcd 集群来存储状态。确保 etcd 集群也是高可用的（通常 3 或 5 个成员）。</li>
</ul>
<p><strong>启动参数示例 (部分)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver \<br>  --advertise-address=&lt;THIS_INSTANCE_IP&gt; \ <span class="hljs-comment"># 当前实例通告给集群其他成员的 IP</span><br>  --allow-privileged=<span class="hljs-literal">true</span> \<br>  --authorization-mode=Node,RBAC \ <span class="hljs-comment"># 启用 Node 和 RBAC 授权</span><br>  --client-ca-file=/etc/kubernetes/pki/ca.crt \<br>  --enable-admission-plugins=NodeRestriction,NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,... \ <span class="hljs-comment"># 启用准入插件</span><br>  --etcd-servers=https://etcd-0:2379,https://etcd-1:2379,https://etcd-2:2379 \ <span class="hljs-comment"># etcd 集群地址</span><br>  --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt \<br>  --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt \<br>  --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key \<br>  --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt \<br>  --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key \<br>  --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \<br>  --secure-port=6443 \ <span class="hljs-comment"># HTTPS 端口</span><br>  --service-account-key-file=/etc/kubernetes/pki/sa.pub \<br>  --service-account-signing-key-file=/etc/kubernetes/pki/sa.key \<br>  --service-account-issuer=https://kubernetes.default.svc.cluster.local \ <span class="hljs-comment"># Service Account Issuer</span><br>  --service-cluster-ip-range=10.96.0.0/12 \ <span class="hljs-comment"># Service Cluster IP 范围</span><br>  --tls-cert-file=/etc/kubernetes/pki/apiserver.crt \ <span class="hljs-comment"># API Server TLS 证书</span><br>  --tls-private-key-file=/etc/kubernetes/pki/apiserver.key \<br>  --apiserver-count=3 \ <span class="hljs-comment"># API Server 实例数量 (用于选举等)</span><br>  --endpoint-reconciler-type=lease \ <span class="hljs-comment"># 端点控制器类型</span><br>  --enable-priority-and-fairness=<span class="hljs-literal">true</span> <span class="hljs-comment"># 启用 APF</span><br>  <span class="hljs-comment"># ... 其他 OIDC, Webhook 等认证/授权/准入配置 ...</span><br></code></pre></td></tr></table></figure>

<p><strong>其他最佳实践</strong>:</p>
<ul>
<li>为 API Server Pod 配置足够的 CPU 和 Memory 资源请求和限制。</li>
<li>监控 API Server 的请求延迟、错误率、资源使用情况。</li>
<li>客户端（尤其是控制器）应使用长连接 (Watch) 而不是频繁轮询 (List)。</li>
<li>内部客户端（如 Controller Manager, Scheduler）优先通过 Service Cluster IP 访问 API Server，减少对外部负载均衡器的依赖。</li>
</ul>
<h2 id="8-构建多租户-Kubernetes-集群"><a href="#8-构建多租户-Kubernetes-集群" class="headerlink" title="8. 构建多租户 Kubernetes 集群"></a>8. 构建多租户 Kubernetes 集群</h2><p>多租户是指在单个 Kubernetes 集群中支持多个独立的租户（用户或团队），同时保证它们之间的隔离和安全性。API Server 的访问控制机制是实现多租户的基础。</p>
<p><strong>核心目标</strong>:</p>
<ol>
<li><strong>授信 (Authentication &amp; Authorization)</strong>:<ul>
<li><strong>认证</strong>: 对接企业身份系统 (如 AD, LDAP, OIDC Provider)，确保只有授权用户能登录。可使用 OIDC 或 Webhook 认证。</li>
<li><strong>授权</strong>: 使用 RBAC 精确控制每个租户在其指定 Namespace 内的权限。避免使用 ClusterRoleBinding 授予租户用户集群级别的权限。</li>
</ul>
</li>
<li><strong>隔离</strong>:<ul>
<li><strong>命名空间 (Namespace)</strong>: 最基本的隔离单元。每个租户分配一个或多个专属 Namespace。RBAC 规则主要基于 Namespace 进行限制。</li>
<li><strong>网络策略 (NetworkPolicy)</strong>: 控制不同 Namespace 之间以及 Pod 之间的网络流量，实现网络隔离。</li>
<li><strong>资源配额 (ResourceQuota)</strong>: 限制每个 Namespace 的资源使用量，防止租户间资源争抢。</li>
<li><strong>节点隔离 (Node Selectors&#x2F;Affinity&#x2F;Taints&#x2F;Tolerations)</strong>: 可以将特定节点分配给特定租户使用（硬隔离），但这会降低资源利用率。</li>
<li><strong>运行时隔离 (RuntimeClass, gVisor, Kata Containers)</strong>: 使用沙箱容器技术增强 Pod 间的内核级隔离。</li>
<li><strong>可见性隔离</strong>: 通过 RBAC 限制用户只能看到其有权限访问的 Namespace 中的资源。</li>
</ul>
</li>
<li><strong>资源管理 (Quota Management)</strong>:<ul>
<li>使用 ResourceQuota 限制计算资源、存储资源和 API 对象数量。</li>
<li>使用 LimitRanger 设置默认资源请求和限制。</li>
</ul>
</li>
</ol>
<p><strong>实现要点</strong>:</p>
<ul>
<li><strong>租户 onboarding</strong>: 需要自动化流程来创建 Namespace、设置 RBAC (RoleBindings)、配置 ResourceQuota 和 NetworkPolicy。</li>
<li><strong>自定义控制器&#x2F;Operator</strong>: 可以开发 Operator 来管理租户生命周期和相关资源的配置。</li>
<li><strong>监控与审计</strong>: 对各租户的资源使用和 API 访问进行监控和审计。</li>
</ul>
<h2 id="9-API-Server-对象实现原理"><a href="#9-API-Server-对象实现原理" class="headerlink" title="9. API Server 对象实现原理"></a>9. API Server 对象实现原理</h2><p>Kubernetes API 基于 “资源 (Resource)” 的概念构建。理解 API 对象的内部表示和处理方式有助于进行扩展开发（如 CRD）。</p>
<h3 id="9-1-GKV-模型-Group-Kind-Version"><a href="#9-1-GKV-模型-Group-Kind-Version" class="headerlink" title="9.1 GKV 模型 (Group, Kind, Version)"></a>9.1 GKV 模型 (Group, Kind, Version)</h3><p>Kubernetes API 使用 GKV 来唯一标识一个 API 对象类型。</p>
<ul>
<li><strong>Group (组)</strong>: 相关 API 功能的集合。例如 <code>apps</code>, <code>batch</code>, <code>rbac.authorization.k8s.io</code>。核心 API (如 Pod, Service, Namespace) 属于空字符串 <code>&quot;&quot;</code> 组 (core group)。Group 使得 API 可以独立演进和扩展。</li>
<li><strong>Version (版本)</strong>: 代表 API 的成熟度和稳定性。例如 <code>v1</code>, <code>v1beta1</code>, <code>v2alpha1</code>。版本允许 API 随时间演进，同时保持向后兼容性。<ul>
<li><strong>External Version</strong>: 暴露给客户端使用的版本 (如 <code>apps/v1</code>)。</li>
<li><strong>Internal Version</strong>: API Server 内部处理和存储时使用的统一版本。所有外部版本在内部都会转换成内部版本进行处理。</li>
</ul>
</li>
<li><strong>Kind (类型)</strong>: 具体的资源类型。例如 <code>Deployment</code>, <code>Pod</code>, <code>RoleBinding</code>。Kind 在同一个 GroupVersion 内必须是唯一的。</li>
</ul>
<img src="/2025/03/17/kubernetes-API-server/image-20250317001025889.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001025889">

<p><em>图：GKV 示例</em></p>
<h3 id="9-2-定义-API-Group-和类型-Go-代码示例"><a href="#9-2-定义-API-Group-和类型-Go-代码示例" class="headerlink" title="9.2 定义 API Group 和类型 (Go 代码示例)"></a>9.2 定义 API Group 和类型 (Go 代码示例)</h3><p>在 Kubernetes 代码库中 (或自定义 API Server&#x2F;CRD 控制器中)，通常这样定义 GKV 和对象类型：</p>
<ol>
<li><p><strong>注册 Group 和 Version (<code>pkg/apis/&#123;group&#125;/register.go</code>)</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> core <span class="hljs-comment">// 假设是 core group</span><br><br><span class="hljs-keyword">import</span> (<br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span><br>)<br><br><span class="hljs-comment">// GroupName 是 API Group 的名称，core group 为空字符串</span><br><span class="hljs-keyword">const</span> GroupName = <span class="hljs-string">&quot;&quot;</span> <br><br><span class="hljs-comment">// SchemeGroupVersion 是此包定义的 Group 和内部 Version</span><br><span class="hljs-keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: runtime.APIVersionInternal&#125;<br><br><span class="hljs-comment">// SchemeBuilder 用于向 Scheme 注册类型</span><br><span class="hljs-keyword">var</span> (<br>    SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)<br>    AddToScheme   = SchemeBuilder.AddToScheme<br>)<br><br><span class="hljs-comment">// addKnownTypes 将此 GroupVersion 下的类型注册到 Scheme</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addKnownTypes</span><span class="hljs-params">(scheme *runtime.Scheme)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 注册 Pod 和 PodList 类型到内部版本</span><br>    scheme.AddKnownTypes(SchemeGroupVersion,<br>        &amp;Pod&#123;&#125;,<br>        &amp;PodList&#123;&#125;,<br>        <span class="hljs-comment">// ... 其他 core 类型 ...</span><br>    )<br>    <br>    <span class="hljs-comment">// 注册外部版本 (例如 v1)</span><br>    metav1.AddToGroupVersion(scheme, schema.GroupVersion&#123;Group: GroupName, Version: <span class="hljs-string">&quot;v1&quot;</span>&#125;) <br>    <span class="hljs-comment">// 需要一个 v1 包来定义 v1.Pod, v1.PodList 并实现转换逻辑</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>定义对象类型 (<code>pkg/apis/&#123;group&#125;/&#123;version&#125;/types.go</code>)</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> v1 <span class="hljs-comment">// 假设是 v1 版本</span><br><br><span class="hljs-keyword">import</span> (<br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>)<br><br><span class="hljs-comment">// +genclient // Tag: 生成 client 代码</span><br><span class="hljs-comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object // Tag: 生成 DeepCopy 方法</span><br><br><span class="hljs-comment">// Pod 是 v1 版本的 Pod 对象定义</span><br><span class="hljs-keyword">type</span> Pod <span class="hljs-keyword">struct</span> &#123;<br>    metav1.TypeMeta   <span class="hljs-string">`json:&quot;,inline&quot;`</span> <span class="hljs-comment">// 包含 Kind 和 APIVersion</span><br>    metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot;`</span> <span class="hljs-comment">// 包含 Name, Namespace, Labels, Annotations 等元数据</span><br>    <br>    Spec   PodSpec   <span class="hljs-string">`json:&quot;spec,omitempty&quot;`</span>   <span class="hljs-comment">// Pod 的期望状态</span><br>    Status PodStatus <span class="hljs-string">`json:&quot;status,omitempty&quot;`</span> <span class="hljs-comment">// Pod 的实际状态</span><br>&#125;<br><br><span class="hljs-comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span><br><br><span class="hljs-comment">// PodList 是 Pod 对象的集合</span><br><span class="hljs-keyword">type</span> PodList <span class="hljs-keyword">struct</span> &#123;<br>    metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>    metav1.ListMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot;`</span> <span class="hljs-comment">// 包含 resourceVersion 等列表元数据</span><br>    <br>    Items []Pod <span class="hljs-string">`json:&quot;items&quot;`</span> <span class="hljs-comment">// Pod 列表</span><br>&#125;<br><br><span class="hljs-comment">// --- PodSpec 和 PodStatus 的定义 ---</span><br><span class="hljs-keyword">type</span> PodSpec <span class="hljs-keyword">struct</span> &#123;<br>    Containers []Container <span class="hljs-string">`json:&quot;containers&quot;`</span><br>    <span class="hljs-comment">// ... 其他字段 ...</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PodStatus <span class="hljs-keyword">struct</span> &#123;<br>    Phase PodPhase <span class="hljs-string">`json:&quot;phase,omitempty&quot;`</span><br>    <span class="hljs-comment">// ... 其他字段 ...</span><br>&#125;<br><br><span class="hljs-comment">// ... Container, PodPhase 等类型的定义 ...</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-3-代码生成-Tags"><a href="#9-3-代码生成-Tags" class="headerlink" title="9.3 代码生成 Tags"></a>9.3 代码生成 Tags</h3><p>Kubernetes 大量使用代码生成来自动创建客户端、Informer、Lister、DeepCopy 方法等。通过在 Go 代码中添加特定格式的注释 (Tags) 来指导代码生成器。</p>
<ul>
<li><strong>Global Tags</strong>: 通常在包的 <code>doc.go</code> 文件中定义，作用于整个包。<ul>
<li><code>// +k8s:deepcopy-gen=package</code>: 为包中所有需要深拷贝的类型生成 <code>DeepCopy()</code> 方法。</li>
<li><code>// +groupName=example.com</code>: 指定 API Group 名称。</li>
</ul>
</li>
<li><strong>Local Tags</strong>: 定义在具体类型或字段上方。<ul>
<li><code>// +genclient</code>: 为该类型生成对应的 ClientSet 代码。</li>
<li><code>// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>: 明确指示该类型需要实现 <code>runtime.Object</code> 接口的 <code>DeepCopyObject()</code> 方法。</li>
<li><code>// +optional</code>: 标记字段为可选。</li>
</ul>
</li>
</ul>
<h3 id="9-4-实现存储接口-etcd-Storage"><a href="#9-4-实现存储接口-etcd-Storage" class="headerlink" title="9.4 实现存储接口 (etcd Storage)"></a>9.4 实现存储接口 (etcd Storage)</h3><p>API Server 需要将对象持久化到 etcd。每个 API 资源都需要一个实现了 <code>registry.Store</code> 接口的存储后端。Kubernetes 提供了通用的存储实现 <code>genericregistry.Store</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/pod/storage/storage.go (示例简化)</span><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/apiserver/pkg/registry/generic&quot;</span><br>	genericregistry <span class="hljs-string">&quot;k8s.io/apiserver/pkg/registry/generic/registry&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/kubernetes/pkg/apis/core&quot;</span> <span class="hljs-comment">// 内部 API 类型</span><br>	<span class="hljs-string">&quot;k8s.io/kubernetes/pkg/printers&quot;</span><br>	printerstorage <span class="hljs-string">&quot;k8s.io/kubernetes/pkg/printers/storage&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/kubernetes/pkg/registry/core/pod&quot;</span> <span class="hljs-comment">// Pod 的 Strategy</span><br>)<br><br><span class="hljs-comment">// NewREST 创建 Pod 资源的 REST storage</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewREST</span><span class="hljs-params">(optsGetter generic.RESTOptionsGetter)</span></span> (*REST, *StatusREST, *LogREST, *ExecREST, *AttachREST, *PortForwardREST, *BindingREST, *EvictionREST, *ProxyREST) &#123;<br>	store := &amp;genericregistry.Store&#123;<br>		<span class="hljs-comment">// 指定如何创建新的空对象和列表对象</span><br>		NewFunc:                  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;core.Pod&#123;&#125; &#125;,<br>		NewListFunc:              <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;core.PodList&#123;&#125; &#125;,<br>		<span class="hljs-comment">// 资源名称 (用于 URL 路径)</span><br>		PredicateFunc:            pod.MatchPod, <span class="hljs-comment">// 用于 List/Watch 的字段选择器</span><br>		DefaultQualifiedResource: core.Resource(<span class="hljs-string">&quot;pods&quot;</span>), <span class="hljs-comment">// GVR 中的 Resource</span><br><br>		<span class="hljs-comment">// 定义 Create, Update, Delete 操作的业务逻辑和验证</span><br>		CreateStrategy: pod.Strategy, <br>		UpdateStrategy: pod.Strategy,<br>		DeleteStrategy: pod.Strategy,<br><br>		<span class="hljs-comment">// 定义如何将对象转换为表格输出 (kubectl get)</span><br>		TableConvertor: printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printers.AddHandlers)&#125;,<br>	&#125;<br>	options := &amp;generic.StoreOptions&#123;<br>		RESTOptions: optsGetter, <span class="hljs-comment">// 包含 etcd 连接信息等</span><br>		AttrFunc:    pod.GetAttrs, <span class="hljs-comment">// 用于字段选择器</span><br>	&#125;<br>	<span class="hljs-comment">// 初始化 store (连接 etcd 等)</span><br>	<span class="hljs-keyword">if</span> err := store.CompleteWithOptions(options); err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// Handle error appropriately</span><br>	&#125;<br><br>	<span class="hljs-comment">// ... 创建 Status, Log, Exec 等子资源的 REST storage ...</span><br>	statusStore := *store <span class="hljs-comment">// Status 通常共享大部分 Store 配置</span><br>	statusStore.UpdateStrategy = pod.StatusStrategy <span class="hljs-comment">// Status 更新有特殊的 Strategy</span><br><br>	<span class="hljs-comment">// ... 返回主资源和子资源的 REST 对象 ...</span><br>	<span class="hljs-keyword">return</span> &amp;REST&#123;store&#125;, &amp;StatusREST&#123;store: &amp;statusStore&#125;, ...<br>&#125;<br><br><span class="hljs-comment">// REST 实现了 k8s.io/apiserver/pkg/registry/rest.StandardStorage 接口</span><br><span class="hljs-keyword">type</span> REST <span class="hljs-keyword">struct</span> &#123;<br>	*genericregistry.Store<br>&#125;<br><br><span class="hljs-comment">// StatusREST 实现了处理 /status 子资源的接口</span><br><span class="hljs-keyword">type</span> StatusREST <span class="hljs-keyword">struct</span> &#123;<br>	store *genericregistry.Store<br>&#125;<br><span class="hljs-comment">// Implement methods like Get, Update for StatusREST</span><br></code></pre></td></tr></table></figure>

<h3 id="9-5-定义业务逻辑-Strategy"><a href="#9-5-定义业务逻辑-Strategy" class="headerlink" title="9.5 定义业务逻辑 (Strategy)"></a>9.5 定义业务逻辑 (Strategy)</h3><p><code>Strategy</code> 对象封装了特定资源类型在 Create, Update, Delete 操作时的业务逻辑和验证规则。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/pod/strategy.go (示例简化)</span><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;context&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/validation/field&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/kubernetes/pkg/apis/core&quot;</span><br>	<span class="hljs-string">&quot;k8s.io/kubernetes/pkg/apis/core/validation&quot;</span><br>)<br><br><span class="hljs-comment">// podStrategy 实现 rest.RESTCreateStrategy, rest.RESTUpdateStrategy, rest.RESTDeleteStrategy</span><br><span class="hljs-keyword">type</span> podStrategy <span class="hljs-keyword">struct</span> &#123;<br>	runtime.ObjectTyper <span class="hljs-comment">// 用于获取 GVK</span><br>	names.NameGenerator <span class="hljs-comment">// 用于生成名称 (如果需要)</span><br>&#125;<br><br><span class="hljs-comment">// Strategy 是 Pod 的标准策略实例</span><br><span class="hljs-keyword">var</span> Strategy = podStrategy&#123;core.Scheme, names.SimpleNameGenerator&#125;<br><br><span class="hljs-comment">// NamespaceScoped 返回 true 因为 Pod 是 Namespace 范围的资源</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> NamespaceScoped() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> &#125;<br><br><span class="hljs-comment">// PrepareForCreate 在对象创建持久化前调用，可以设置默认值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> PrepareForCreate(ctx context.Context, obj runtime.Object) &#123;<br>	pod := obj.(*core.Pod)<br>	<span class="hljs-comment">// 设置默认的 RestartPolicy, DNSPolicy 等</span><br>	<span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Validate 在对象创建持久化前调用，执行验证逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> Validate(ctx context.Context, obj runtime.Object) field.ErrorList &#123;<br>	pod := obj.(*core.Pod)<br>	<span class="hljs-comment">// 调用 validation 包进行复杂的校验</span><br>	<span class="hljs-keyword">return</span> validation.ValidatePod(pod) <br>&#125;<br><br><span class="hljs-comment">// Canonicalize 标准化对象 (通常不需要)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> Canonicalize(obj runtime.Object) &#123;&#125;<br><br><span class="hljs-comment">// AllowCreateOnUpdate 返回 false，不允许通过 Update 操作创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> AllowCreateOnUpdate() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br><br><span class="hljs-comment">// PrepareForUpdate 在对象更新持久化前调用，可以修改新对象或基于旧对象设置字段</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> PrepareForUpdate(ctx context.Context, obj, old runtime.Object) &#123;<br>	newPod := obj.(*core.Pod)<br>	oldPod := old.(*core.Pod)<br>	<span class="hljs-comment">// 不允许修改某些字段，例如 Pod 的 NodeName (通常由调度器设置)</span><br>	newPod.Spec.NodeName = oldPod.Spec.NodeName <br>	<span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ValidateUpdate 在对象更新持久化前调用，验证更新操作是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> ValidateUpdate(ctx context.Context, obj, old runtime.Object) field.ErrorList &#123;<br>	newPod := obj.(*core.Pod)<br>	oldPod := old.(*core.Pod)<br>	<span class="hljs-comment">// 调用专门的 Status 更新验证逻辑</span><br>	<span class="hljs-keyword">return</span> validation.ValidatePodStatusUpdate(newPod, oldPod)<br>&#125;<br><br><span class="hljs-comment">// AllowUnconditionalUpdate 返回 false，不允许无条件的更新 (需要 resourceVersion 匹配)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStrategy)</span></span> AllowUnconditionalUpdate() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> &#125;<br><br><span class="hljs-comment">// ... 实现 Delete 相关方法 ...</span><br></code></pre></td></tr></table></figure>

<h3 id="9-6-子资源-Subresource"><a href="#9-6-子资源-Subresource" class="headerlink" title="9.6 子资源 (Subresource)"></a>9.6 子资源 (Subresource)</h3><p>子资源是附属在主资源下的特定部分，拥有独立的 API 端点和操作逻辑。例如 Pod 的 <code>/status</code>, <code>/log</code>, <code>/exec</code>。</p>
<ul>
<li><strong>实现</strong>: 通常为子资源定义一个独立的 <code>Strategy</code> (如 <code>podStatusStrategy</code>) 和一个独立的 <code>REST</code> 存储对象 (如 <code>StatusREST</code>)。</li>
<li><strong>Status 子资源</strong>: 特别常见，用于更新对象的状态字段。其 <code>PrepareForUpdate</code> 逻辑通常会阻止对 <code>Spec</code> 字段的修改，只允许更新 <code>Status</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/pod/strategy.go (Status Strategy 示例)</span><br><span class="hljs-keyword">var</span> StatusStrategy = podStatusStrategy&#123;Strategy&#125; <span class="hljs-comment">// 继承基础 Strategy</span><br><br><span class="hljs-keyword">type</span> podStatusStrategy <span class="hljs-keyword">struct</span> &#123;<br>	podStrategy<br>&#125;<br><br><span class="hljs-comment">// PrepareForUpdate for status ensures that updates only modify status</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStatusStrategy)</span></span> PrepareForUpdate(ctx context.Context, obj, old runtime.Object) &#123;<br>	newPod := obj.(*core.Pod)<br>	oldPod := old.(*core.Pod)<br>	<span class="hljs-comment">// 关键：强制新对象的 Spec 与旧对象一致，只允许 Status 变化</span><br>	newPod.Spec = oldPod.Spec <br>	<span class="hljs-comment">// 清除 DeletionTimestamp，因为 status 更新不应触发删除</span><br>	newPod.DeletionTimestamp = <span class="hljs-literal">nil</span> <br>	<span class="hljs-comment">// 防止 status 更新意外修改 OwnerReferences (旧 Kubelet 可能存在 bug)</span><br>	newPod.OwnerReferences = oldPod.OwnerReferences<br>&#125;<br><br><span class="hljs-comment">// ValidateUpdate for status ensures that updates only modify status</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStatusStrategy)</span></span> ValidateUpdate(ctx context.Context, obj, old runtime.Object) field.ErrorList &#123;<br>	newPod := obj.(*core.Pod)<br>	oldPod := old.(*core.Pod)<br>	<span class="hljs-comment">// 调用专门的 Status 更新验证逻辑</span><br>	<span class="hljs-keyword">return</span> validation.ValidatePodStatusUpdate(newPod, oldPod)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-7-注册-APIGroup-到-API-Server"><a href="#9-7-注册-APIGroup-到-API-Server" class="headerlink" title="9.7 注册 APIGroup 到 API Server"></a>9.7 注册 APIGroup 到 API Server</h3><p>定义好类型、存储和策略后，需要将它们注册到 API Server 的 HTTP Handler 中。</p>
<ol>
<li><strong>创建 Storage Map</strong>: 为每个 API Version 创建一个映射，将资源名称 (如 “pods”) 映射到其 REST Storage 对象。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/master/master.go (示例简化)</span><br>restStorageMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]rest.Storage&#123;<br>    <span class="hljs-string">&quot;pods&quot;</span>:             podStorage.Pod, <span class="hljs-comment">// Pod 主资源</span><br>    <span class="hljs-string">&quot;pods/attach&quot;</span>:      podStorage.Attach,<br>    <span class="hljs-string">&quot;pods/status&quot;</span>:      podStorage.Status,<br>    <span class="hljs-string">&quot;pods/log&quot;</span>:         podStorage.Log,<br>    <span class="hljs-string">&quot;pods/exec&quot;</span>:        podStorage.Exec,<br>    <span class="hljs-string">&quot;pods/portforward&quot;</span>: podStorage.PortForward,<br>    <span class="hljs-string">&quot;pods/proxy&quot;</span>:       podStorage.Proxy,<br>    <span class="hljs-string">&quot;pods/binding&quot;</span>:     podStorage.Binding,<br>    <span class="hljs-string">&quot;bindings&quot;</span>:         podStorage.Binding, <span class="hljs-comment">// Binding 也可以作为顶级资源访问</span><br>    <span class="hljs-string">&quot;pods/eviction&quot;</span>:    podStorage.Eviction,<br>    <span class="hljs-comment">// ... 其他 core v1 资源 ...</span><br>    <span class="hljs-string">&quot;services&quot;</span>:         serviceRest.Service,<br>    <span class="hljs-string">&quot;services/status&quot;</span>:  serviceRest.Status,<br>    <span class="hljs-string">&quot;services/proxy&quot;</span>:   serviceRest.Proxy,<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>创建 APIGroupInfo</strong>: 包含 GroupVersion 信息、Scheme、参数编解码器以及 VersionedResourcesStorageMap。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/master/master.go (示例简化)</span><br>apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(core.GroupName, Scheme, ParameterCodec, Codecs)<br><span class="hljs-comment">// 将 v1 版本的 Storage Map 关联到 APIGroupInfo</span><br>apiGroupInfo.VersionedResourcesStorageMap[<span class="hljs-string">&quot;v1&quot;</span>] = restStorageMap <br></code></pre></td></tr></table></figure></li>
<li><strong>安装 APIGroup</strong>: 调用 <code>InstallLegacyAPIGroup</code> (用于 core group) 或 <code>InstallAPIGroup</code> (用于命名 group) 将 Handler 挂载到 API Server。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/master/master.go (示例简化)</span><br><span class="hljs-comment">// m 是 *Master 对象，包含 GenericAPIServer</span><br><span class="hljs-keyword">if</span> err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != <span class="hljs-literal">nil</span> &#123;<br>    klog.Fatalf(<span class="hljs-string">&quot;Error in registering group versions: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-8-代码生成工具"><a href="#9-8-代码生成工具" class="headerlink" title="9.8 代码生成工具"></a>9.8 代码生成工具</h3><p>Kubernetes 社区维护了一套用于生成客户端、Informer、Lister、DeepCopy 方法等的代码生成工具： <code>k8s.io/code-generator</code>。</p>
<ul>
<li><strong><code>deepcopy-gen</code></strong>: 生成 <code>DeepCopy()</code> 和 <code>DeepCopyObject()</code> 方法。</li>
<li><strong><code>client-gen</code></strong>: 生成类型化的客户端 (ClientSet)。</li>
<li><strong><code>informer-gen</code></strong>: 生成 Informer，用于高效地监听资源变化。</li>
<li><strong><code>lister-gen</code></strong>: 生成 Lister，用于从 Informer 缓存中读取资源。</li>
<li><strong><code>conversion-gen</code></strong>: 生成不同 API 版本之间的转换函数。</li>
</ul>
<p>通常使用 <code>hack/update-codegen.sh</code> 脚本来调用这些生成器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 示例：生成 DeepCopy 代码</span><br><span class="hljs-variable">$&#123;GOPATH&#125;</span>/bin/deepcopy-gen --input-dirs k8s.io/kubernetes/pkg/apis/core/v1 \<br>-O zz_generated.deepcopy \<br>--bounding-dirs k8s.io/kubernetes/pkg/apis/core \<br>--go-header-file <span class="hljs-variable">$&#123;SCRIPT_ROOT&#125;</span>/hack/boilerplate.go.txt <br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kubernetes API Server 是集群的中枢神经系统，理解其访问控制流程（认证、授权、准入控制）、限流机制（特别是 APF）、高可用部署方式以及 API 对象的内部实现原理，对于深入掌握 Kubernetes、进行集群管理、故障排查和二次开发都至关重要。希望本文的梳理能帮助你构建更清晰的知识体系。</p>
<p>若想深入了解 apiserver 源码，可以参考：<a target="_blank" rel="noopener" href="https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d">https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/k8s/" class="print-no-link">#k8s</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解 Kubernetes API Server：核心机制与实践</div>
      <div>https://mfzzf.github.io/2025/03/17/kubernetes-API-server/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mzzf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/03/18/kubernetes-scheduler/" title="kubernetes_scheduler">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">kubernetes_scheduler</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" title="Kubernetes 架构深度解析：从 Borg 到云原生">
                        <span class="hidden-mobile">Kubernetes 架构深度解析：从 Borg 到云原生</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
