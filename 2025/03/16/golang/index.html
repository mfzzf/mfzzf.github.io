

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mzzf">
  <meta name="keywords" content="">
  
    <meta name="description" content="Golang 基本使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 语言基础与实践">
<meta property="og:url" content="https://mfzzf.github.io/2025/03/16/golang/index.html">
<meta property="og:site_name" content="Mzzf&#39;s Blog">
<meta property="og:description" content="Golang 基本使用。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-16T15:08:33.000Z">
<meta property="article:modified_time" content="2025-03-16T15:50:39.023Z">
<meta property="article:author" content="Mzzf">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Go 语言基础与实践 - Mzzf&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mfzzf.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mzzf&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Go 语言基础与实践"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-16 23:08" pubdate>
          2025年3月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          57 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Go 语言基础与实践</h1>
            
            
              <div class="markdown-body">
                
                <p>Golang 基本使用。</p>
<span id="more"></span>

<h3 id="一、统一思想：12-因素应用宣言"><a href="#一、统一思想：12-因素应用宣言" class="headerlink" title="一、统一思想：12 因素应用宣言"></a>一、统一思想：12 因素应用宣言</h3><p>在深入学习 Go 语言之前，我们先来了解一下构建云原生应用的指导原则——12 因素应用宣言（The Twelve-Factor App）。这套方法论由 Heroku 平台的开发者总结，旨在帮助开发者构建可扩展、可维护、易部署的云原生应用。</p>
<ol>
<li><p><strong>基准代码 (Codebase)</strong>：一份基准代码，多份部署。使用版本控制系统（如 Git）管理代码，确保不同环境（开发、测试、生产）使用同一份代码的不同版本。</p>
</li>
<li><p><strong>依赖 (Dependencies)</strong>：显式声明依赖关系。使用依赖管理工具（如 Go Modules）管理项目依赖，确保依赖的明确性和可重复性。</p>
</li>
<li><p><strong>配置 (Config)</strong>：在环境中存储配置。将配置信息（如数据库连接、API 密钥）存储在环境变量中，而不是硬编码在代码中，提高应用的可移植性和安全性。</p>
</li>
<li><p><strong>后端服务 (Backing Services)</strong>：把后端服务当作附加资源。将数据库、消息队列、缓存等后端服务视为可插拔的资源，通过 URL 或配置信息进行连接，方便应用的迁移和扩展。</p>
</li>
<li><p><strong>构建，发布，运行 (Build, Release, Run)</strong>：严格分离构建和运行。将应用构建、发布和运行三个阶段分离，确保每个阶段的独立性和可重复性。</p>
</li>
<li><p><strong>进程 (Processes)</strong>：以一个或多个无状态进程运行应用。将应用设计为无状态进程，方便水平扩展和故障恢复。</p>
</li>
<li><p><strong>端口绑定 (Port Binding)</strong>：通过端口绑定提供服务。应用通过绑定端口对外提供服务，不依赖于特定的 Web 服务器或容器。</p>
</li>
<li><p><strong>并发 (Concurrency)</strong>：通过进程模型进行扩展。利用进程或线程模型实现应用的并发，提高应用的吞吐量和响应速度。</p>
</li>
<li><p><strong>易处理 (Disposability)</strong>：快速启动和优雅终止可最大化健壮性。应用应能够快速启动和优雅终止，方便部署、重启和故障恢复。</p>
</li>
<li><p><strong>开发环境与线上环境等价 (Dev&#x2F;Prod Parity)</strong>：尽可能地保持开发、预发布、线上环境相同。使用相同的操作系统、依赖和配置，减少环境差异导致的问题。</p>
</li>
<li><p><strong>日志 (Logs)</strong>：把日志当作事件流。将应用的日志输出到标准输出（stdout），由外部系统（如日志收集器）进行处理和分析。</p>
</li>
<li><p><strong>管理进程 (Admin Processes)</strong>：后台管理任务当作一次性进程运行。将后台管理任务（如数据库迁移、数据备份）作为一次性进程运行，与应用的主进程分离。</p>
</li>
</ol>
<p><strong>面试知识点：</strong></p>
<ul>
<li>什么是 12 因素应用宣言？它的核心原则是什么？</li>
<li>为什么要在环境中存储配置？这样做有什么好处？</li>
<li>如何理解应用的无状态性？无状态应用有什么优势？</li>
</ul>
<h3 id="二、Go-语言的诞生与设计哲学"><a href="#二、Go-语言的诞生与设计哲学" class="headerlink" title="二、Go 语言的诞生与设计哲学"></a>二、Go 语言的诞生与设计哲学</h3><h4 id="1-为什么需要-Go-语言？"><a href="#1-为什么需要-Go-语言？" class="headerlink" title="1. 为什么需要 Go 语言？"></a>1. 为什么需要 Go 语言？</h4><p>在 Go 语言出现之前，开发者面临着一些挑战：</p>
<ul>
<li><strong>硬件发展与软件瓶颈</strong>：硬件性能不断提升，但软件开发效率却没有同步提升。</li>
<li><strong>现有语言的不足</strong>：<ul>
<li>C&#x2F;C++ 等原生语言缺乏好的依赖管理，编译速度慢。</li>
<li>Java&#x2F;C# 等语言过于庞大，启动速度慢，内存占用高。</li>
<li>现有语言对并发编程的支持不够友好，难以充分利用多核处理器。</li>
</ul>
</li>
</ul>
<p>Go 语言的出现，正是为了解决这些问题。</p>
<h4 id="2-Go-语言的设计哲学"><a href="#2-Go-语言的设计哲学" class="headerlink" title="2. Go 语言的设计哲学"></a>2. Go 语言的设计哲学</h4><p>Go 语言的设计哲学可以用以下几个关键词概括：</p>
<ul>
<li><strong>Less is exponentially more</strong>（少即是多）：Go 语言追求简洁，避免过度设计，减少不必要的复杂性。</li>
<li><strong>Do Less, Enable More</strong>（做更少，成更多）：Go 语言提供了一套精简但强大的工具集，让开发者能够更高效地完成工作。</li>
<li><strong>面向工程</strong>：Go 语言的设计目标是解决实际工程问题，而不是追求学术上的完美。</li>
<li><strong>正交性</strong>：Go 语言的特性之间相互独立，组合起来却能发挥强大的威力。</li>
</ul>
<h4 id="3-Go-语言的主要特性"><a href="#3-Go-语言的主要特性" class="headerlink" title="3. Go 语言的主要特性"></a>3. Go 语言的主要特性</h4><ul>
<li><strong>编译型语言</strong>：Go 语言是一种编译型语言，可以将代码编译成机器码，执行效率高。</li>
<li><strong>静态类型</strong>：Go 语言是一种静态类型语言，在编译时进行类型检查，可以减少运行时错误。</li>
<li><strong>垃圾回收</strong>：Go 语言内置垃圾回收机制，开发者无需手动管理内存，降低了开发难度。</li>
<li><strong>并发编程</strong>：Go 语言通过 goroutine 和 channel 提供了强大的并发编程支持，可以轻松编写高并发程序。</li>
<li><strong>简洁的语法</strong>：Go 语言的语法简洁明了，易于学习和使用。</li>
<li><strong>丰富的标准库</strong>：Go 语言提供了丰富的标准库，涵盖了网络编程、系统编程、数据处理等多个领域。</li>
</ul>
<h4 id="4-Go-语言不支持的特性"><a href="#4-Go-语言不支持的特性" class="headerlink" title="4. Go 语言不支持的特性"></a>4. Go 语言不支持的特性</h4><p>为了保持语言的简洁性和一致性，Go 语言有意不支持一些常见的特性：</p>
<ul>
<li><strong>函数重载和操作符重载</strong>：避免代码的歧义和复杂性。</li>
<li><strong>隐式类型转换</strong>：减少潜在的错误和不确定性。</li>
<li><strong>继承</strong>：Go 语言使用组合来实现代码复用，而不是继承。</li>
<li><strong>异常处理</strong>：Go 语言使用显式的错误处理机制（error），而不是异常。</li>
<li><strong>断言</strong>：Go 语言鼓励开发者编写更健壮的代码，而不是依赖断言来捕获错误。</li>
<li><strong>静态变量</strong>：Go 语言不支持静态变量，避免全局状态带来的问题。</li>
</ul>
<p><strong>面试知识点：</strong></p>
<ul>
<li>Go 语言的设计目标是什么？它解决了哪些问题？</li>
<li>Go 语言有哪些主要的特性？这些特性有什么优势？</li>
<li>为什么 Go 语言不支持某些常见的特性（如继承、异常）？</li>
</ul>
<h3 id="三、Go-语言环境搭建与基础"><a href="#三、Go-语言环境搭建与基础" class="headerlink" title="三、Go 语言环境搭建与基础"></a>三、Go 语言环境搭建与基础</h3><h4 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1. 下载与安装"></a>1. 下载与安装</h4><ul>
<li>访问 Go 语言官网（<a target="_blank" rel="noopener" href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a>）下载对应平台的安装包。</li>
<li>按照官方文档的指引进行安装。</li>
</ul>
<h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h4><ul>
<li><strong>GOROOT</strong>：Go 语言的安装目录。</li>
<li><strong>GOPATH</strong>：Go 语言的工作目录，用于存放项目代码、依赖包和可执行文件。<ul>
<li><code>src</code>：存放项目源代码。</li>
<li><code>pkg</code>：存放编译后的包文件。</li>
<li><code>bin</code>：存放可执行文件。</li>
</ul>
</li>
<li><strong>GOOS</strong>：目标操作系统（如 linux、windows、darwin）。</li>
<li><strong>GOARCH</strong>：目标处理器架构（如 amd64、arm64）。</li>
<li><strong>GOPROXY</strong>：Go 模块代理，用于加速依赖包的下载。国内用户建议设置为 <code>https://goproxy.cn</code>。</li>
</ul>
<h4 id="3-IDE-设置"><a href="#3-IDE-设置" class="headerlink" title="3. IDE 设置"></a>3. IDE 设置</h4><ul>
<li>推荐使用 VS Code，并安装 Go 插件。</li>
<li>其他可选的 IDE 包括：<ul>
<li>Goland（JetBrains 出品，收费）</li>
<li>Vim、Sublime Text 等（需要配置相关插件）</li>
</ul>
</li>
</ul>
<h4 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h4><ul>
<li><code>go build</code>：编译 Go 程序。<ul>
<li><code>-o</code>：指定输出文件名。</li>
<li><code>GOOS</code> 和 <code>GOARCH</code> 环境变量可以用于交叉编译。</li>
</ul>
</li>
<li><code>go run</code>：编译并运行 Go 程序。</li>
<li><code>go test</code>：运行测试。<ul>
<li><code>./...</code>：运行当前目录及子目录下的所有测试。</li>
<li><code>-v</code>：显示详细的测试输出。</li>
</ul>
</li>
<li><code>go vet</code>：静态代码检查，发现潜在的错误。</li>
<li><code>go fmt</code>：格式化 Go 代码。</li>
<li><code>go get</code>：下载并安装依赖包。</li>
<li><code>go mod</code>：Go 模块管理工具。</li>
<li><code>go doc</code>：查看文档。</li>
<li><code>go env</code>：查看 Go 环境变量。</li>
</ul>
<h4 id="5-代码版本控制"><a href="#5-代码版本控制" class="headerlink" title="5. 代码版本控制"></a>5. 代码版本控制</h4><ul>
<li>推荐使用 Git 进行代码版本控制。</li>
<li>将代码托管到 GitHub、GitLab 等平台。</li>
</ul>
<h4 id="6-Golang-Playground"><a href="#6-Golang-Playground" class="headerlink" title="6. Golang Playground"></a>6. Golang Playground</h4><ul>
<li>官方 Playground：<a target="_blank" rel="noopener" href="https://play.golang.org/">https://play.golang.org/</a></li>
<li>国内可访问的 Playground：<a target="_blank" rel="noopener" href="https://goplay.tools/">https://goplay.tools/</a></li>
</ul>
<p><strong>面试知识点：</strong></p>
<ul>
<li><code>go build</code> 和 <code>go run</code> 有什么区别？</li>
<li><code>go vet</code> 可以检查出哪些类型的错误？</li>
<li>如何使用 Go Modules 管理项目依赖？</li>
<li>如何进行交叉编译？</li>
</ul>
<h3 id="四、Go-语言控制结构"><a href="#四、Go-语言控制结构" class="headerlink" title="四、Go 语言控制结构"></a>四、Go 语言控制结构</h3><h4 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition1 &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2 &#123;<br>    <span class="hljs-comment">// do something else</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// catch-all or default</span><br>&#125;<br><br><span class="hljs-comment">// 简短语句</span><br><span class="hljs-keyword">if</span> v := x - <span class="hljs-number">100</span>; v &lt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-switch-语句"><a href="#2-switch-语句" class="headerlink" title="2. switch 语句"></a>2. switch 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br><span class="hljs-keyword">case</span> val1:<br>    <span class="hljs-comment">// 空分支</span><br><span class="hljs-keyword">case</span> val2:<br>    <span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">// 执行 case3 中的代码</span><br><span class="hljs-keyword">case</span> val3:<br>    f()<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计数器循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>    sum += sum<br>&#125;<br><br><span class="hljs-comment">// 无限循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// for-range 循环</span><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> myArray &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>面试知识点：</strong></p>
<ul>
<li>Go 语言中如何实现类似于 while 循环的功能？</li>
<li>for-range 循环遍历不同类型的数据时，有哪些需要注意的地方？</li>
</ul>
<h3 id="五、Go-语言常用数据结构"><a href="#五、Go-语言常用数据结构" class="headerlink" title="五、Go 语言常用数据结构"></a>五、Go 语言常用数据结构</h3><h4 id="1-变量与常量"><a href="#1-变量与常量" class="headerlink" title="1. 变量与常量"></a>1. 变量与常量</h4><ul>
<li><strong>常量</strong>：使用 <code>const</code> 关键字定义。</li>
<li><strong>变量</strong>：使用 <code>var</code> 关键字定义。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Go&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="2-变量定义与初始化"><a href="#2-变量定义与初始化" class="headerlink" title="2. 变量定义与初始化"></a>2. 变量定义与初始化</h4><ul>
<li><strong>变量声明</strong>：<code>var identifier type</code></li>
<li><strong>变量初始化</strong>：<code>var i, j int = 1, 2</code></li>
<li><strong>短变量声明</strong>：<code>c, python, java := true, false, &quot;no!&quot;</code> （只能在函数内部使用）</li>
</ul>
<h4 id="3-类型转换与推导"><a href="#3-类型转换与推导" class="headerlink" title="3. 类型转换与推导"></a>3. 类型转换与推导</h4><ul>
<li><strong>类型转换</strong>：<code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</li>
<li><strong>类型推导</strong>：在声明变量时不指定类型，Go 编译器会根据右值的类型自动推导。</li>
</ul>
<h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h4><ul>
<li><strong>定义</strong>：<code>var identifier [len]type</code></li>
<li><strong>特点</strong>：相同类型、长度固定、连续内存。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myArray := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-切片-slice"><a href="#5-切片-slice" class="headerlink" title="5. 切片 (slice)"></a>5. 切片 (slice)</h4><ul>
<li><strong>定义</strong>：<code>var identifier []type</code></li>
<li><strong>特点</strong>：对数组的引用、动态长度、连续内存。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>append</code>：追加元素。</li>
<li><code>make</code>：创建切片。</li>
<li>切片操作：<code>myArray[1:3]</code></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>mySlice = <span class="hljs-built_in">append</span>(mySlice, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<h4 id="6-make-和-new"><a href="#6-make-和-new" class="headerlink" title="6. make 和 new"></a>6. make 和 new</h4><ul>
<li><strong>new</strong>：返回指针地址。</li>
<li><strong>make</strong>：返回第一个元素，可预设内存空间。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice1 := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// 返回 *[]int</span><br>mySlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 返回 []int，长度为 0</span><br>mySlice3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 返回 []int，长度为 10，容量为 20</span><br></code></pre></td></tr></table></figure>

<h4 id="7-Map"><a href="#7-Map" class="headerlink" title="7. Map"></a>7. Map</h4><ul>
<li><strong>声明</strong>：<code>var map1 map[keytype]valuetype</code></li>
<li><strong>特点</strong>：键值对、无序。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>make</code>：创建 Map。</li>
<li><code>delete</code>：删除键值对。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="8-访问-Map-元素"><a href="#8-访问-Map-元素" class="headerlink" title="8. 访问 Map 元素"></a>8. 访问 Map 元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按 Key 取值</span><br>value, exists := myMap[<span class="hljs-string">&quot;a&quot;</span>]<br><span class="hljs-keyword">if</span> exists &#123;<br>    <span class="hljs-built_in">println</span>(value)<br>&#125;<br><br><span class="hljs-comment">// 遍历 Map</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-built_in">println</span>(k, v)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-结构体和指针"><a href="#9-结构体和指针" class="headerlink" title="9. 结构体和指针"></a>9. 结构体和指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMyType</span><span class="hljs-params">(t *MyType)</span></span> &#123;<br>	<span class="hljs-built_in">println</span>(t.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	t := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>	printMyType(&amp;t) <span class="hljs-comment">// 传入指针</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>通过 <code>type … struct</code> 关键字自定义结构体</li>
<li>Go 语言支持指针，但不支持指针运算</li>
<li>指针变量的值为内存地址</li>
<li>未赋值的指针为 <code>nil</code></li>
</ul>
<h4 id="10-结构体标签"><a href="#10-结构体标签" class="headerlink" title="10. 结构体标签"></a>10. 结构体标签</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>	Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	mt := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>	myType := reflect.TypeOf(mt)<br>	name := myType.Field(<span class="hljs-number">0</span>)<br>	tag := name.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br>	<span class="hljs-built_in">println</span>(tag)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li>
<li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag</li>
<li><code>NodeName string  json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li>
</ul>
<h4 id="11-类型别名"><a href="#11-类型别名" class="headerlink" title="11. 类型别名"></a>11. 类型别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Service Type string describes ingress methods for a service</span><br><span class="hljs-keyword">type</span> ServiceType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span><br>	<span class="hljs-comment">// cluster, via the ClusterIP.</span><br>	ServiceTypeClusterIP ServiceType = <span class="hljs-string">&quot;ClusterIP&quot;</span><br><br>	<span class="hljs-comment">// ServiceTypeNodePort means a service will be exposed on one port of</span><br>	<span class="hljs-comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span><br>	ServiceTypeNodePort ServiceType = <span class="hljs-string">&quot;NodePort&quot;</span><br><br>	<span class="hljs-comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span><br>	<span class="hljs-comment">// external load balancer (if the cloud provider supports it), in addition</span><br>	<span class="hljs-comment">// to &#x27;NodePort&#x27; type.</span><br>	ServiceTypeLoadBalancer ServiceType = <span class="hljs-string">&quot;LoadBalancer&quot;</span><br><br>	<span class="hljs-comment">// ServiceTypeExternalName means a service consists of only a reference to</span><br>	<span class="hljs-comment">// an external name that kubedns or equivalent will return as a CNAME</span><br>	<span class="hljs-comment">// record, with no exposing or proxying of any pods involved.</span><br>	ServiceTypeExternalName ServiceType = <span class="hljs-string">&quot;ExternalName&quot;</span><br>)<br></code></pre></td></tr></table></figure>

<p><strong>面试知识点：</strong></p>
<ul>
<li>数组和切片有什么区别？</li>
<li><code>make</code> 和 <code>new</code> 有什么区别？</li>
<li>如何判断一个 Map 中是否存在某个键？</li>
<li>结构体标签有什么作用？</li>
</ul>
<h3 id="课后练习-1-1"><a href="#课后练习-1-1" class="headerlink" title="课后练习 1.1"></a>课后练习 1.1</h3><ul>
<li>安装 Go</li>
<li>安装 IDE 并安装 Go 语言插件</li>
<li>编写一个小程序</li>
</ul>
<p>给定一个字符串数组<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;stupid&quot;,&quot;and&quot;,&quot;weak&quot;]</code><br>用 <code>for</code> 循环遍历该数组并修改为<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;smart&quot;,&quot;and&quot;,&quot;strong&quot;]</code></p>
<p><strong>答案：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;am&quot;</span>, <span class="hljs-string">&quot;stupid&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;weak&quot;</span>&#125;<br>	replacements := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>		<span class="hljs-string">&quot;stupid&quot;</span>: <span class="hljs-string">&quot;smart&quot;</span>,<br>		<span class="hljs-string">&quot;weak&quot;</span>:   <span class="hljs-string">&quot;strong&quot;</span>,<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> words &#123;<br>		<span class="hljs-keyword">if</span> replacement, ok := replacements[word]; ok &#123;<br>			words[i] = replacement<br>		&#125;<br>	&#125;<br><br>	fmt.Println(words) <span class="hljs-comment">// 输出 [&quot;I&quot;, &quot;am&quot;, &quot;smart&quot;, &quot;and&quot;, &quot;strong&quot;]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="六、Go-语言函数"><a href="#六、Go-语言函数" class="headerlink" title="六、Go 语言函数"></a>六、Go 语言函数</h3><h4 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main 函数"></a>1. main 函数</h4><ul>
<li>每个 Go 程序都应该有一个 <code>main</code> 包。</li>
<li><code>main</code> 包里的 <code>main</code> 函数是程序的入口。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-参数解析"><a href="#2-参数解析" class="headerlink" title="2. 参数解析"></a>2. 参数解析</h4><ul>
<li><code>main</code> 函数没有参数，不同于其他语言的<code>[]string args</code>。</li>
<li>可以使用 <code>os.Args</code> 获取命令行参数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	args := os.Args<br>	fmt.Println(<span class="hljs-string">&quot;Arguments:&quot;</span>, args)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>可以使用 <code>flag</code> 包解析命令行参数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;flag&quot;</span><br>	<span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	name := flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;specify the name you want to say hi&quot;</span>)<br>	flag.Parse()<br>	fmt.Println(<span class="hljs-string">&quot;Hello,&quot;</span>, *name)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-init-函数"><a href="#3-init-函数" class="headerlink" title="3. init 函数"></a>3. init 函数</h4><ul>
<li><code>init</code> 函数会在包初始化时自动执行。</li>
<li>谨慎使用 <code>init</code> 函数，避免循环依赖和不可重复运行的问题。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> myVariable = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>	myVariable = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul>
<li><strong>多值返回</strong>：函数可以返回多个值。</li>
<li><strong>命名返回值</strong>：可以给返回值命名，并在函数体中直接使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(sum <span class="hljs-type">int</span>)</span></span> (x, y <span class="hljs-type">int</span>) &#123;<br>    x = sum * <span class="hljs-number">4</span> / <span class="hljs-number">9</span><br>    y = sum - x<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 裸返回，返回已命名的 x 和 y</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-调用者忽略部分返回值"><a href="#5-调用者忽略部分返回值" class="headerlink" title="5. 调用者忽略部分返回值"></a>5. 调用者忽略部分返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result, _ = strconv.Atoi(origStr) <span class="hljs-comment">// 忽略错误返回值</span><br></code></pre></td></tr></table></figure>

<h4 id="6-传递变长参数"><a href="#6-传递变长参数" class="headerlink" title="6. 传递变长参数"></a>6. 传递变长参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []Type, elems ...Type)</span></span> []Type <span class="hljs-comment">// 接收任意多个 Type 类型的参数</span><br></code></pre></td></tr></table></figure>

<h4 id="7-内置函数"><a href="#7-内置函数" class="headerlink" title="7. 内置函数"></a>7. 内置函数</h4><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>close</code></td>
<td align="left">管道关闭</td>
</tr>
<tr>
<td align="left"><code>len</code>, <code>cap</code></td>
<td align="left">返回数组、切片、Map 的长度或容量</td>
</tr>
<tr>
<td align="left"><code>new</code>, <code>make</code></td>
<td align="left">内存分配</td>
</tr>
<tr>
<td align="left"><code>copy</code>, <code>append</code></td>
<td align="left">操作切片</td>
</tr>
<tr>
<td align="left"><code>panic</code>, <code>recover</code></td>
<td align="left">错误处理</td>
</tr>
<tr>
<td align="left"><code>print</code>, <code>println</code></td>
<td align="left">打印</td>
</tr>
<tr>
<td align="left"><code>complex</code>, <code>real</code>, <code>imag</code></td>
<td align="left">操作复数</td>
</tr>
</tbody></table>
<h4 id="8-回调函数-Callback"><a href="#8-回调函数-Callback" class="headerlink" title="8. 回调函数 (Callback)"></a>8. 回调函数 (Callback)</h4><ul>
<li>将函数作为参数传递给其他函数，并在其他函数内部调用执行。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doOperation</span><span class="hljs-params">(y <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>) &#123;<br>    f(y, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increase</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;increase result is:&quot;</span>, a+b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    doOperation(<span class="hljs-number">1</span>, increase)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9. 闭包"></a>9. 闭包</h4><ul>
<li>匿名函数，可以访问其外部作用域的变量。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        sum += x<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pos, neg := adder(), adder()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<br>            pos(i),<br>            neg(<span class="hljs-number">-2</span>*i),<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="10-方法"><a href="#10-方法" class="headerlink" title="10. 方法"></a>10. 方法</h4><ul>
<li>作用在接收者上的函数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="11-传值还是传指针"><a href="#11-传值还是传指针" class="headerlink" title="11. 传值还是传指针"></a>11. 传值还是传指针</h4><ul>
<li>Go 语言只有一种规则-传值</li>
<li>函数内修改参数的值不会影响函数外原始变量的值</li>
<li>可以传递指针参数将变量地址传递给调用函数，Go 语言会<br>复制该指针作为函数内的地址，但指向同一地址</li>
<li>思考：当我们写代码的时候，函数的参数传递应该用<code>struct</code><br>还是<code>pointer</code>？<ul>
<li>如果需要修改参数的值，或者参数较大，传递指针更高效。</li>
<li>如果不需要修改参数的值，且参数较小，传递值更安全。</li>
</ul>
</li>
</ul>
<h4 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h4><ul>
<li>接口定义一组方法集合。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>    Abs() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(-f)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a Abser<br>    f := MyFloat(-math.Sqrt2)<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>    a = f  <span class="hljs-comment">// MyFloat 实现了 Abser</span><br>    a = &amp;v <span class="hljs-comment">// *Vertex 实现了 Abser</span><br><br>    <span class="hljs-comment">// a = v // 错误：Vertex 没有实现 Abser（Abs 方法的接收者是 *Vertex）</span><br><br>    fmt.Println(a.Abs())<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="13-注意事项"><a href="#13-注意事项" class="headerlink" title="13. 注意事项"></a>13. 注意事项</h4><ul>
<li><code>Interface</code> 是可能为 <code>nil</code> 的，所以针对 <code>interface</code> 的使用一定要预先判空，否则会引起程序 <code>crash(nil panic)</code></li>
<li><code>Struct</code> 初始化意味着空间分配，对 <code>struct</code> 的引用不会出现空指针</li>
</ul>
<h4 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14. 反射机制"></a>14. 反射机制</h4><ul>
<li><code>reflect.TypeOf()</code> 返回被检查对象的类型</li>
<li><code>reflect.ValueOf()</code> 返回被检查对象的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br>t := reflect.TypeOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, t)<br>v := reflect.ValueOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, v)<br></code></pre></td></tr></table></figure>

<h4 id="15-基于-struct-的反射"><a href="#15-基于-struct-的反射" class="headerlink" title="15. 基于 struct 的反射"></a>15. 基于 struct 的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// struct</span><br>myStruct := T&#123;A: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>v1 := reflect.ValueOf(myStruct)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumField(); i++ &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumMethod(); i++ &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))<br>&#125;<br><br><span class="hljs-comment">// 需要注意receive是struct还是指针</span><br>result := v1.Method(<span class="hljs-number">0</span>).Call(<span class="hljs-literal">nil</span>)<br>fmt.Println(<span class="hljs-string">&quot;result:&quot;</span>, result)<br></code></pre></td></tr></table></figure>

<h4 id="16-Go-语言中的面向对象编程"><a href="#16-Go-语言中的面向对象编程" class="headerlink" title="16. Go 语言中的面向对象编程"></a>16. Go 语言中的面向对象编程</h4><ul>
<li>可见性控制<ul>
<li><code>public</code>-常量、变量、类型、接口、结构、函数等的名称大写</li>
<li><code>private</code> -非大写就只能在包内使用</li>
</ul>
</li>
<li>继承<ul>
<li>通过组合实现，内嵌一个或多个<code>struct</code></li>
</ul>
</li>
<li>多态<ul>
<li>通过接口实现，通过接口定义方法集，编写多套实现</li>
</ul>
</li>
</ul>
<h4 id="17-Json-编解码"><a href="#17-Json-编解码" class="headerlink" title="17. Json 编解码"></a>17. Json 编解码</h4><ul>
<li><code>Unmarshal</code>: 从 <code>string</code> 转换至 <code>struct</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unmarshal2Struct</span><span class="hljs-params">(humanStr <span class="hljs-type">string</span>)</span></span> Human &#123;<br>	h := Human&#123;&#125;<br>	err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;h)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">println</span>(err)<br>	&#125;<br>	<span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Marshal</code>: 从 <code>struct</code> 转换至 <code>string</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">marshal2JsonString</span><span class="hljs-params">(h Human)</span></span> <span class="hljs-type">string</span> &#123;<br>	h.Age = <span class="hljs-number">30</span><br>	updatedBytes, err := json.Marshal(&amp;h)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-built_in">println</span>(err)<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(updatedBytes)<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>json</code> 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 类型保存任意对象</li>
<li>可通过如下逻辑解析任意 <code>json</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> obj <span class="hljs-keyword">interface</span>&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;obj)<br>objMap, ok := obj.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> objMap &#123;<br>	<span class="hljs-keyword">switch</span> value := v.(<span class="hljs-keyword">type</span>) &#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>		fmt.Printf(<span class="hljs-string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)<br>	<span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:<br>		fmt.Printf(<span class="hljs-string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)<br>	<span class="hljs-keyword">default</span>:<br>		fmt.Printf(<span class="hljs-string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>面试知识点：</strong></p>
<ul>
<li>Go 语言中如何实现函数的重载？</li>
<li>什么是闭包？闭包有什么作用？</li>
<li>Go 语言中的方法和普通函数有什么区别？</li>
<li>Go 语言中如何实现接口？接口和抽象类有什么区别？</li>
<li>什么是反射？反射有什么作用？</li>
<li>如何使用 <code>encoding/json</code> 包进行 JSON 编解码？</li>
</ul>
<h3 id="六、常用语法"><a href="#六、常用语法" class="headerlink" title="六、常用语法"></a>六、常用语法</h3><h4 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1. 错误处理"></a>1. 错误处理</h4><p>Go 语言无内置 <code>exceptio</code> 机制，只提供 <code>error</code> 接口供定义错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>	Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可通过 <code>errors.New</code> 或 <code>fmt.Errorf</code> 创建新的 <code>error</code></li>
<li><code>var errNotFound error = errors.New(&quot;NotFound&quot;)</code></li>
<li>通常应用程序对 <code>error</code> 的处理大部分是判断 <code>error</code> 是否为 <code>nil</code><br>如需将 <code>error</code> 归类，通常交给应用程序自定义，比如 <code>kubernetes</code> 自定义了与 <code>apiserver</code> 交互的不同类型错误</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StatusError <span class="hljs-keyword">struct</span> &#123;<br>	ErrStatus metav1.Status<br>&#125;<br><br><span class="hljs-keyword">var</span> _ <span class="hljs-type">error</span> = &amp;StatusError&#123;&#125;<br><br><span class="hljs-comment">// Error implements the Error interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StatusError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> e.ErrStatus.Message<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-defer"><a href="#2-defer" class="headerlink" title="2. defer"></a>2. defer</h4><ul>
<li>函数返回之前执行某个语句或函数</li>
<li>等同于Java 和C# 的finally</li>
<li>常见的 <code>defer</code> 使用场景：记得关闭你打开的资源<ul>
<li><code>defer file.Close()</code></li>
<li><code>defer mu.Unlock()</code></li>
<li><code>defer println(&quot;&quot;)</code></li>
</ul>
</li>
</ul>
<h4 id="3-Panic-和-recover"><a href="#3-Panic-和-recover" class="headerlink" title="3. Panic 和 recover"></a>3. Panic 和 recover</h4><ul>
<li><code>panic</code>: 可在系统出现不可恢复错误时主动调用 <code>panic</code>, <code>panic</code> 会使当前线程直接 <code>crash</code></li>
<li><code>defer</code>: 保证执行并把控制权交还给接收到 <code>panic</code> 的函数调用者</li>
<li><code>recover</code>: 函数从 <code>panic</code> 或 错误场景中恢复</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;defer func is called&quot;</span>)<br>	<span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>		fmt.Println(err)<br>	&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;a panic is triggered&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七. 多线程"></a>七. 多线程</h3><h4 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h4><ul>
<li>并发（concurrency）<ul>
<li>两个或多个事件在同一时间间隔发生</li>
</ul>
</li>
<li>并行（parallellism）<ul>
<li>两个或者多个事件在同一时刻发生</li>
</ul>
</li>
</ul>
<h4 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h4><ul>
<li>进程：<ul>
<li>分配系统资源（CPU 时间、内存等）基本单位</li>
<li>有独立的内存空间，切换开销大</li>
</ul>
</li>
<li>线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位<ul>
<li>同一进程中的多线程共享内存空间，线程切换代价小</li>
<li>多线程通信方便</li>
<li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li>
</ul>
</li>
<li>协程<ul>
<li>Go语言中的轻量级线程实现</li>
<li>Golang 在<code>runtime</code>、系统调用等多方面对<code>goroutine</code> 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前<code>goroutine</code> 的<code>CPU (P)</code> 转让出去，让其他<code>goroutine</code> 能被调度<br>并执行，也就是<code>Golang</code> 从语言层面支持了协程</li>
</ul>
</li>
</ul>
<h4 id="3-Communicating-Sequential-Process"><a href="#3-Communicating-Sequential-Process" class="headerlink" title="3. Communicating Sequential Process"></a>3. Communicating Sequential Process</h4><ul>
<li>CSP<ul>
<li>描述两个独立的并发实体通过共享的通讯<code>channel</code>进行通信的并发模型。</li>
</ul>
</li>
<li>Go 协程 <code>goroutine</code><ul>
<li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度。</li>
<li>是一种绿色线程，微线程，它与<code>Coroutine</code>协程也有区别，能够在发现堵塞后启动新的微线程。</li>
</ul>
</li>
<li>通道 <code>channel</code><ul>
<li>类似<code>Unix</code>的<code>Pipe</code>，用于协程之间通讯和同步。</li>
<li>协程之间虽然解耦，但是它们和<code>Channel</code>有着耦合。</li>
</ul>
</li>
</ul>
<h4 id="4-线程和协程的差异"><a href="#4-线程和协程的差异" class="headerlink" title="4. 线程和协程的差异"></a>4. 线程和协程的差异</h4><ul>
<li>每个 <code>goroutine</code> (协程) 默认占用内存远比 <code>Java</code> 、<code>C</code> 的线程少<ul>
<li><code>goroutine</code>：<code>2KB</code></li>
<li>线程：<code>8MB</code></li>
</ul>
</li>
<li>线程&#x2F;<code>goroutine</code> 切换开销方面，<code>goroutine</code> 远比线程小<ul>
<li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、<code>PC</code>、<code>SP</code>…等寄存器的刷新</li>
<li><code>goroutine</code>：只有三个寄存器的值修改-<code>PC</code> &#x2F; <code>SP</code> &#x2F; <code>DX</code>.</li>
</ul>
</li>
<li>GOMAXPROCS<ul>
<li>控制并行线程数量</li>
</ul>
</li>
</ul>
<h4 id="5-协程示例"><a href="#5-协程示例" class="headerlink" title="5. 协程示例"></a>5. 协程示例</h4><ul>
<li>启动新协程：<code>go functionName()</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>	<span class="hljs-keyword">go</span> fmt.Println(i)<br>&#125;<br>time.Sleep(time.Second)<br></code></pre></td></tr></table></figure>

<h4 id="6-channel-多线程通信"><a href="#6-channel-多线程通信" class="headerlink" title="6. channel - 多线程通信"></a>6. channel - 多线程通信</h4><ul>
<li><code>Channel</code> 是多个协程之间通讯的管道</li>
<li>一端发送数据，一端接收数据</li>
<li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li>
<li>协调协程的执行顺序</li>
<li>声明方式<ul>
<li><code>var identifier chan datatype</code></li>
</ul>
</li>
<li>操作符<code>&lt;-</code></li>
<li>示例</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	fmt.Println(<span class="hljs-string">&quot;hello from goroutine&quot;</span>)<br>	ch &lt;- <span class="hljs-number">0</span> <span class="hljs-comment">//数据写入Channel</span><br>&#125;()<br>i := &lt;-ch <span class="hljs-comment">//从Channel中取数据并赋值</span><br></code></pre></td></tr></table></figure>
<h4 id="7-通道缓冲"><a href="#7-通道缓冲" class="headerlink" title="7. 通道缓冲"></a>7. 通道缓冲</h4><ul>
<li>基于 <code>Channel</code> 的通信是同步的</li>
<li>当缓冲区满时，数据的发送是阻塞的</li>
<li>通过 <code>make</code> 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li>
<li>下面两个定义的区别？<ul>
<li><code>ch:= make(chan int)</code></li>
<li><code>ch:= make(chan int,1)</code></li>
</ul>
</li>
</ul>
<h4 id="8-遍历通道缓冲区"><a href="#8-遍历通道缓冲区" class="headerlink" title="8. 遍历通道缓冲区"></a>8. 遍历通道缓冲区</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		rand.Seed(time.Now().UnixNano())<br>		n := rand.Intn(<span class="hljs-number">10</span>) <span class="hljs-comment">// n will be between 0 and 10</span><br>		fmt.Println(<span class="hljs-string">&quot;putting: &quot;</span>, n)<br>		ch &lt;- n<br>	&#125;<br>	<span class="hljs-built_in">close</span>(ch)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;hello from main&quot;</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>	fmt.Println(<span class="hljs-string">&quot;receiving: &quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="9-单向通道"><a href="#9-单向通道" class="headerlink" title="9. 单向通道"></a>9. 单向通道</h4><ul>
<li>只发送通道<ul>
<li><code>var sendOnly chan&lt;- int</code></li>
</ul>
</li>
<li>只接收通道<ul>
<li><code>var readOnly &lt;-chan int</code></li>
</ul>
</li>
<li><code>Istio webhook controller</code><ul>
<li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li>
</ul>
</li>
<li>如何用: 双向通道转换</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> prod(c)<br><span class="hljs-keyword">go</span> consume(c)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prod</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> &#123;<br>		ch &lt;- <span class="hljs-number">1</span><br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> &#123;<br>		&lt;-ch<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="10-关闭通道"><a href="#10-关闭通道" class="headerlink" title="10. 关闭通道"></a>10. 关闭通道</h4><ul>
<li>通道无需每次关闭</li>
<li>关闭的作用是告诉接收者该通道再无新数据发送</li>
<li>只有发送方需要关闭通道</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br><span class="hljs-keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;<br>	fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="11-select"><a href="#11-select" class="headerlink" title="11. select"></a>11. select</h4><ul>
<li>当多个协程同时运行时，可通过 <code>select</code> 轮询多个通道</li>
<li>如果所有通道都阻塞则等待，如定义了 <code>default</code> 则执行 <code>default</code></li>
<li>如多个通道就绪则随机选择</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-ch1:<br>	...<br><span class="hljs-keyword">case</span> v := &lt;-ch2:<br>	...<br><span class="hljs-keyword">default</span>:<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="12-定时器-Timer"><a href="#12-定时器-Timer" class="headerlink" title="12. 定时器 Timer"></a>12. 定时器 Timer</h4><ul>
<li><code>time.Ticker</code> 以指定的时间间隔重复的向通道 <code>C</code> 发送时间值</li>
<li>使用场景<ul>
<li>为协程设定超时时间</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">timer := time.NewTimer(time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// check normal channel</span><br><span class="hljs-keyword">case</span> &lt;-ch:<br>	fmt.Println(<span class="hljs-string">&quot;received from ch&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br>	fmt.Println(<span class="hljs-string">&quot;timeout waiting from channel ch&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="13-上下文-Context"><a href="#13-上下文-Context" class="headerlink" title="13. 上下文 Context"></a>13. 上下文 Context</h4><ul>
<li>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</li>
<li><code>Context</code> 是设置截止日期、同步信号，传递请求相关值的结构体</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>	Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>	Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>	Err() <span class="hljs-type">error</span><br>	Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>用法<ul>
<li><code>context.Background</code></li>
<li><code>context.TODO</code></li>
<li><code>context.WithDeadline</code></li>
<li><code>context.WithValue</code></li>
<li><code>context.WithCancel</code></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如何停止一个子协程</span><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-done:<br>            fmt.Println(<span class="hljs-string">&quot;done channel is triggerred, exit child go routine&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(done)<br><br><span class="hljs-comment">// 基于 Context 停止子协程</span><br><span class="hljs-comment">// Context 是 Go 语言对 go routine 和 timer 的封装</span><br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">go</span> process(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br>&lt;-ctx.Done()<br>fmt.Println(<span class="hljs-string">&quot;main:&quot;</span>, ctx.Err())<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ctx context.Context, duration time.Duration)</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(duration):<br>        fmt.Println(<span class="hljs-string">&quot;process successfully&quot;</span>)<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        fmt.Println(<span class="hljs-string">&quot;process cancelled&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>通过 <code>context</code> 包, 可以取消 <code>goroutine</code> 的执行, 或者给 <code>goroutine</code> 设置 Deadline, 超时后 <code>goroutine</code> 会退出。</li>
</ul>
<p><strong>面试知识点:</strong></p>
<ul>
<li>Go 语言中如何实现并发编程？</li>
<li><code>goroutine</code> 和线程有什么区别？</li>
<li><code>channel</code> 的作用是什么？如何使用 <code>channel</code> 进行协程间通信？</li>
<li>如何实现一个有缓冲的 <code>channel</code>？</li>
<li>如何使用 <code>select</code> 语句处理多个 <code>channel</code>？</li>
<li>如何使用 <code>context</code> 包取消 <code>goroutine</code> 的执行？</li>
</ul>
<h3 id="课后练习-1-2"><a href="#课后练习-1-2" class="headerlink" title="课后练习 1.2"></a>课后练习 1.2</h3><ul>
<li>基于 <code>Channel</code> 编写一个简单的单线程生产者消费者模型<ul>
<li>队列：<br>队列长度 10，队列元素类型为 <code>int</code></li>
<li>生产者：<br>每 1 秒往队列中放入一个类型为 <code>int</code> 的元素，队列满时生产者可以阻塞</li>
<li>消费者：<br>每一秒从队列中获取一个元素并打印，队列为空时消费者阻塞</li>
</ul>
</li>
</ul>
<p><strong>答案：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>	i := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> &#123;<br>		time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>		ch &lt;- i<br>		fmt.Println(<span class="hljs-string">&quot;Produced:&quot;</span>, i)<br>		i++<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">for</span> &#123;<br>		time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>		i := &lt;-ch<br>		fmt.Println(<span class="hljs-string">&quot;Consumed:&quot;</span>, i)<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 缓冲大小为 10 的 channel</span><br><br>	<span class="hljs-keyword">go</span> producer(ch)<br>	<span class="hljs-keyword">go</span> consumer(ch)<br><br>	<span class="hljs-keyword">select</span> &#123;&#125; <span class="hljs-comment">// 阻塞主 goroutine，防止程序退出</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="八、Go-Modules"><a href="#八、Go-Modules" class="headerlink" title="八、Go Modules"></a>八、Go Modules</h3><h4 id="1-为什么需要-Go-Modules"><a href="#1-为什么需要-Go-Modules" class="headerlink" title="1. 为什么需要 Go Modules"></a>1. 为什么需要 Go Modules</h4><p>在 Go 1.11 版本之前，Go 语言的依赖管理一直是一个痛点。<code>GOPATH</code> 模式存在以下问题：</p>
<ul>
<li><strong>项目必须放在 <code>$GOPATH/src</code> 目录下</strong>：限制了项目存放的位置，不够灵活。</li>
<li><strong>没有版本控制</strong>：无法指定项目依赖的特定版本，容易出现版本冲突。</li>
<li><strong>无法处理 vendor 依赖</strong>：无法将依赖包复制到项目内部，不利于项目的独立性和可移植性。</li>
</ul>
<p>Go Modules 的出现，解决了这些问题，成为了 Go 语言官方推荐的依赖管理方式。</p>
<h4 id="2-Go-Modules-的主要特性"><a href="#2-Go-Modules-的主要特性" class="headerlink" title="2. Go Modules 的主要特性"></a>2. Go Modules 的主要特性</h4><ul>
<li><strong>项目可以放在任何位置</strong>：不再受限于 <code>$GOPATH/src</code> 目录。</li>
<li><strong>版本控制</strong>：可以指定项目依赖的特定版本，解决了版本冲突问题。</li>
<li><strong>vendor 支持</strong>：可以将依赖包复制到项目内部的 <code>vendor</code> 目录，提高了项目的独立性和可移植性。</li>
<li><strong>模块代理</strong>：可以通过设置 <code>GOPROXY</code> 环境变量，使用模块代理加速依赖包的下载。</li>
</ul>
<h4 id="3-Go-Modules-的基本使用"><a href="#3-Go-Modules-的基本使用" class="headerlink" title="3. Go Modules 的基本使用"></a>3. Go Modules 的基本使用</h4><ul>
<li><strong>初始化模块</strong>：在项目根目录下执行 <code>go mod init &lt;module_name&gt;</code>，创建 <code>go.mod</code> 文件。</li>
<li><strong>添加依赖</strong>：执行 <code>go get &lt;package_name&gt;@&lt;version&gt;</code>，会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li>
<li><strong>构建项目</strong>：执行 <code>go build</code>，会自动下载并构建依赖。</li>
<li><strong>运行项目</strong>：执行 <code>go run</code>，会自动下载、构建并运行项目。</li>
<li><strong>整理依赖</strong>：执行 <code>go mod tidy</code>，会移除未使用的依赖，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li>
<li><strong>vendor 依赖</strong>：执行 <code>go mod vendor</code>，会将依赖包复制到项目内部的 <code>vendor</code> 目录。</li>
</ul>
<p><strong>面试知识点：</strong></p>
<ul>
<li>Go Modules 解决了 <code>GOPATH</code> 模式的哪些问题？</li>
<li><code>go.mod</code> 和 <code>go.sum</code> 文件有什么作用？</li>
<li>如何使用 Go Modules 添加、更新和删除依赖？</li>
<li>如何使用 vendor 依赖？</li>
</ul>
<h3 id="九、Go-语言与云原生"><a href="#九、Go-语言与云原生" class="headerlink" title="九、Go 语言与云原生"></a>九、Go 语言与云原生</h3><p>Go 语言的特性使其非常适合云原生应用开发：</p>
<ul>
<li><strong>高效的编译和执行速度</strong>：Go 语言的编译速度快，生成的二进制文件小，启动速度快，非常适合云原生环境下的快速部署和弹性伸缩。</li>
<li><strong>强大的并发编程支持</strong>：Go 语言的 goroutine 和 channel 机制，可以轻松编写高并发程序，充分利用多核处理器，提高应用的吞吐量和响应速度。</li>
<li><strong>简洁的语法和丰富的标准库</strong>：Go 语言的语法简洁易学，标准库功能丰富，可以减少开发者的工作量，提高开发效率。</li>
<li><strong>跨平台编译</strong>：Go 语言支持交叉编译，可以方便地为不同的操作系统和处理器架构构建应用。</li>
<li><strong>容器友好</strong>：Go 语言生成的二进制文件不依赖于外部库，非常适合打包成 Docker 镜像，方便部署和管理。</li>
</ul>
<p>Go 语言已经成为云原生领域的主流语言，许多知名的云原生项目都是用 Go 语言开发的，例如：</p>
<ul>
<li><strong>Docker</strong>：容器引擎。</li>
<li><strong>Kubernetes</strong>：容器编排平台。</li>
<li><strong>Istio</strong>：服务网格。</li>
<li><strong>Etcd</strong>：分布式键值存储。</li>
<li><strong>Prometheus</strong>：监控系统。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Go 语言基础与实践</div>
      <div>https://mfzzf.github.io/2025/03/16/golang/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mzzf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/03/16/golang%E8%BF%9B%E9%98%B6/" title="Go 语言进阶">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Go 语言进阶</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/16/docker/" title="Docker核心技术">
                        <span class="hidden-mobile">Docker核心技术</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
