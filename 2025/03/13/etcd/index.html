

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Mzzf">
  <meta name="keywords" content="">
  
    <meta name="description" content="深入理解 etcd：Kubernetes 的分布式基石">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 etcd：Kubernetes 的分布式基石">
<meta property="og:url" content="https://mfzzf.github.io/2025/03/13/etcd/index.html">
<meta property="og:site_name" content="Mzzf&#39;s Blog">
<meta property="og:description" content="深入理解 etcd：Kubernetes 的分布式基石">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250315134912712.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317000021831.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317000027311.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317000031277.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317000035671.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317001558102.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317001627420.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317001741454.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317001746455.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317001643290.png">
<meta property="og:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250317001853663.png">
<meta property="article:published_time" content="2025-03-13T15:50:52.000Z">
<meta property="article:modified_time" content="2025-04-27T09:37:15.359Z">
<meta property="article:author" content="Mzzf">
<meta property="article:tag" content="k8s">
<meta property="article:tag" content="etcd">
<meta property="article:tag" content="distributed systems">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mfzzf.github.io/2025/03/13/etcd/image-20250315134912712.png">
  
  
  
  <title>深入理解 etcd：Kubernetes 的分布式基石 - Mzzf&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mfzzf.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mzzf&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="深入理解 etcd：Kubernetes 的分布式基石"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-13 23:50" pubdate>
          2025年3月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          48 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">深入理解 etcd：Kubernetes 的分布式基石</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="深入理解-etcd：Kubernetes-的分布式基石"><a href="#深入理解-etcd：Kubernetes-的分布式基石" class="headerlink" title="深入理解 etcd：Kubernetes 的分布式基石"></a>深入理解 etcd：Kubernetes 的分布式基石</h1><span id="more"></span>

<img src="/2025/03/13/etcd/image-20250315134912712.png" srcset="/img/loading.gif" lazyload class="" title="image-20250315134912712">

<p><strong>引言</strong></p>
<p>在 Kubernetes（K8s）集群中，etcd 扮演着独一无二且至关重要的角色——它是集群状态的唯一真实来源（Single Source of Truth）。所有关于集群配置、期望状态、实际状态的数据都存储在 etcd 中。理解 etcd 的工作原理、特性和最佳实践，对于管理和维护一个稳定、高效的 Kubernetes 集群至关重要。本文将深入探讨 etcd 的核心概念、Raft 一致性协议、存储机制、Watch 机制、高可用部署、在 Kubernetes 中的具体应用、性能优化及故障排查。</p>
<h2 id="1-什么是-etcd？"><a href="#1-什么是-etcd？" class="headerlink" title="1. 什么是 etcd？"></a>1. 什么是 etcd？</h2><p>etcd 是一个由 CoreOS（现隶属于 Red Hat）开发的开源、分布式、强一致性的键值存储系统。它专为分布式系统设计，用于可靠地存储关键数据。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li><strong>简单接口：</strong> 提供基于 gRPC 的 API（v3）以及兼容 HTTP+JSON 的网关，易于集成和使用（如 <code>etcdctl</code>）。</li>
<li><strong>键值存储：</strong> 数据以键值对形式存储，支持按 Key 或 Key 前缀范围查询。</li>
<li><strong>监听机制 (Watch)：</strong> 客户端可以监听（Watch）指定的 Key 或 Key 前缀范围，当数据发生变化时获得实时通知。这是 Kubernetes 控制器模型的基础。</li>
<li><strong>基于 Raft 的一致性：</strong> 使用 Raft 协议保证集群中多个节点数据的一致性和高可用性。即使部分节点故障，集群仍能正常工作（需要超过半数节点存活）。</li>
<li><strong>安全性：</strong> 支持 TLS 客户端证书认证，确保通信安全。</li>
<li><strong>事务支持：</strong> 支持原子性的 Compare-and-Swap (CAS) 和 Compare-and-Delete (CAD) 操作，可用于实现分布式锁、领导者选举等。</li>
<li><strong>多版本并发控制 (MVCC)：</strong> 每个 Key 的修改都会创建一个新版本（Revision），支持查询历史版本数据。</li>
</ul>
<h2 id="2-etcd-的核心功能与应用场景"><a href="#2-etcd-的核心功能与应用场景" class="headerlink" title="2. etcd 的核心功能与应用场景"></a>2. etcd 的核心功能与应用场景</h2><p>etcd 的核心功能使其在分布式系统中应用广泛：</p>
<ul>
<li><strong>服务发现与注册：</strong> 服务实例启动时将其信息（如 IP、端口）注册到 etcd 的特定 Key 下，并设置 TTL（租约）。服务消费者监听这些 Key 来发现可用的服务实例。实例通过续约 TTL 来表明其存活状态。</li>
<li><strong>配置共享：</strong> 将应用的配置信息存储在 etcd 中，应用实例启动时读取配置，并监听配置 Key 的变化以实现动态更新。</li>
<li><strong>分布式协调：</strong><ul>
<li><strong>分布式锁：</strong> 利用 Lease（租约）和原子操作（如事务）实现分布式锁，确保同一时间只有一个进程能访问共享资源。</li>
<li><strong>领导者选举：</strong> 多个实例竞争写入一个特定的 Key（通常带有 Lease），成功写入者成为 Leader。</li>
</ul>
</li>
<li><strong>Kubernetes 集群状态存储：</strong> 这是 etcd 最重要的应用场景。存储所有 Kubernetes 对象（Pods, Services, Deployments 等）的定义和状态。API Server 是唯一直接与 etcd 交互的 K8s 组件。</li>
</ul>
<p><strong>服务注册与发现示例（Mermaid 流程图）：</strong></p>
<img src="/2025/03/13/etcd/image-20250317000021831.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317000021831">

<pre class="mermaid">graph LR
    subgraph 服务注册
        A[服务提供者] -- 注册服务信息 (Key: /services/my-app/instance-1, Value: ip:port, Lease: ttl=10s) --> E[etcd]
        A -- 定期续约 Lease --> E
    end

    subgraph 服务发现
        C[服务消费者] -- Watch /services/my-app/ 前缀 --> E
        E -- 返回当前实例列表 --> C
        E -- 当实例增/删/过期时通知 --> C
    end

    subgraph 服务调用
        C -- 根据获取的列表 --> G[服务提供者实例]
    end</pre>

<p><strong>配置共享示例（Mermaid 流程图）：</strong></p>
<img src="/2025/03/13/etcd/image-20250317000027311.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317000027311">

<pre class="mermaid">graph LR
    subgraph 配置发布
        A[管理员/CI/CD] -- 更新配置 (Key: /config/app/db_url, Value: new_url) --> E[etcd]
    end

    subgraph 配置订阅与应用
        C[应用实例] -- Watch /config/app/db_url --> E
        E -- 配置变更通知 --> C
        C -- 应用新配置 --> C
    end</pre>

<h2 id="3-深入理解-Raft-一致性协议"><a href="#3-深入理解-Raft-一致性协议" class="headerlink" title="3. 深入理解 Raft 一致性协议"></a>3. 深入理解 Raft 一致性协议</h2><p>Raft 是一种旨在比 Paxos 更易于理解和实现的分布式一致性算法。etcd 使用 Raft 来确保集群数据的一致性和容错性。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>角色：</strong><ul>
<li><strong>Leader（领导者）：</strong> 集群中同一时间只有一个 Leader。负责处理所有客户端写请求，并将日志条目复制给 Follower。定期向 Follower 发送心跳以维持领导地位。</li>
<li><strong>Follower（跟随者）：</strong> 被动接收 Leader 的日志条目和心跳。如果超时未收到 Leader 心跳，会转变为 Candidate并发起选举。响应 Candidate 的投票请求。</li>
<li><strong>Candidate（候选者）：</strong> 在选举期间的角色。向其他节点请求投票，如果获得超过半数节点的投票，则成为新的 Leader。</li>
<li><strong>Learner（学习者）：</strong> v3.4 新增角色。只接收 Leader 的日志复制，不参与选举投票，也不计入 Quorum（法定人数）。用于在不影响集群写性能和可用性的情况下扩展集群或替换节点。</li>
</ul>
</li>
<li><strong>Term（任期）：</strong> 一个单调递增的数字，表示一个 Leader 的任期。每次选举成功都会进入一个新的 Term。Term 用于检测过期的 Leader 或 Candidate。</li>
<li><strong>Log Replication（日志复制）：</strong> Leader 将客户端请求（命令）封装成日志条目，追加到自己的日志中，然后并行地发送给所有 Follower。当 Leader 收到超过半数 Follower 的成功响应后，该日志条目被视为<strong>已提交 (Committed)</strong>。Leader 会通知 Follower 提交相应的日志条目。只有已提交的日志条目才能被应用到状态机（即 KV 存储）。</li>
<li><strong>Safety（安全性）：</strong> Raft 通过以下机制保证安全性：<ul>
<li><strong>Election Safety:</strong> 每个 Term 最多只有一个 Leader 被选举出来。</li>
<li><strong>Leader Append-Only:</strong> Leader 只能追加日志，不能覆盖或删除。</li>
<li><strong>Log Matching:</strong> 如果两个日志在某个索引位置具有相同的 Term，那么它们在该索引之前的所有日志条目都相同。</li>
<li><strong>Leader Completeness:</strong> 如果一个日志条目在某个 Term 被提交，那么它将出现在所有更高 Term 的 Leader 的日志中。</li>
<li><strong>State Machine Safety:</strong> 如果一个节点已经将某个索引的日志条目应用到其状态机，那么其他节点不能在该索引应用不同的日志条目。</li>
</ul>
</li>
<li><strong>Leader Election（领导者选举）：</strong><ol>
<li>Follower 在 <code>election timeout</code>（通常是随机化的，如 150-300ms）内未收到 Leader 心跳，则增加当前 Term，转变为 Candidate。</li>
<li>Candidate 投票给自己，并向其他节点发送 <code>RequestVote</code> RPC。</li>
<li>其他节点收到 <code>RequestVote</code> 后，如果在当前 Term 尚未投票，并且 Candidate 的日志至少和自己一样新（比较最后日志条目的 Term 和 Index），则投票给该 Candidate。</li>
<li>Candidate 若收到超过半数节点的投票，则成为 Leader。</li>
<li>若选举超时仍未选出 Leader（可能发生选票分裂），则 Candidate 增加 Term，开始新一轮选举。</li>
<li>Leader 选举成功后，立即向所有 Follower 发送心跳，确立领导地位。</li>
</ol>
</li>
</ul>
<p><strong>Raft 协议流程（Mermaid 流程图）：</strong></p>
<img src="/2025/03/13/etcd/image-20250317000031277.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317000031277">

<pre class="mermaid">graph TD
    Client[客户端] -- 写请求 --> Leader
    Leader -- 1. 追加日志条目 (uncommitted) --> Log_Leader[Leader 本地日志]
    Log_Leader -- 2. 并行发送 AppendEntries RPC --> Follower1 & Follower2
    Follower1 -- 3. 接收并追加日志 (uncommitted) --> Log_F1[Follower1 日志]
    Follower2 -- 3. 接收并追加日志 (uncommitted) --> Log_F2[Follower2 日志]
    Log_F1 -- 4. 发送成功 ACK --> Leader
    Log_F2 -- 4. 发送成功 ACK --> Leader
    Leader -- 5. 收到多数 ACK (包括自己) --> MarkCommitted{将日志标记为 Committed}
    MarkCommitted -- 6. 应用到状态机 --> StateMachine_L[Leader 状态机 (KV Store)]
    MarkCommitted -- 7. 响应客户端 --> Client
    Leader -- 8. 下次心跳/AppendEntries 通知 Follower --> Follower1 & Follower2
    Follower1 -- 9. 收到提交通知 --> Apply_F1{Follower1 应用日志到状态机}
    Follower2 -- 9. 收到提交通知 --> Apply_F2{Follower2 应用日志到状态机}
    Apply_F1 --> StateMachine_F1[Follower1 状态机]
    Apply_F2 --> StateMachine_F2[Follower2 状态机]</pre>

<p><strong>WAL 日志 (Write-Ahead Log)：</strong></p>
<p>etcd 将 Raft 日志持久化到磁盘上的 WAL 文件中。在将变更应用到内存状态（KV 存储）之前，必须先确保对应的 Raft 日志条目已成功写入 WAL。这保证了即使节点崩溃重启，也能通过回放 WAL 日志来恢复到崩溃前的状态，确保数据不丢失。WAL 文件是顺序写入的，通常性能较好。</p>
<p>WAL 日志条目主要包含：</p>
<ul>
<li><strong>Type:</strong> 日志类型（如普通条目、配置变更条目）。</li>
<li><strong>Term:</strong> 该条目所属的 Leader 任期。</li>
<li><strong>Index:</strong> 该条目的日志索引，单调递增。</li>
<li><strong>Data:</strong> 实际的客户端请求数据（序列化格式）。</li>
</ul>
<h2 id="4-etcd-的存储核心：MVCC-与-BoltDB"><a href="#4-etcd-的存储核心：MVCC-与-BoltDB" class="headerlink" title="4. etcd 的存储核心：MVCC 与 BoltDB"></a>4. etcd 的存储核心：MVCC 与 BoltDB</h2><p>etcd v3 采用了多版本并发控制（MVCC）模型，并使用 BoltDB 作为其底层的持久化存储引擎。</p>
<p><strong>MVCC (Multi-Version Concurrency Control):</strong></p>
<ul>
<li><strong>Revision（版本号）：</strong> etcd 不直接修改 Key 的 Value，而是每次修改（Put、Delete）都创建一个新的 Key-Value 版本。每个版本都有一个全局唯一的、单调递增的 Revision 号。<ul>
<li><strong>Revision 构成:</strong> 一个 Revision 由两部分组成：<code>main revision</code> 和 <code>sub revision</code>。<ul>
<li><code>main revision</code>: 每次 etcd 事务（可能包含多个操作）提交时递增 1。</li>
<li><code>sub revision</code>: 在同一个事务内，每次操作（如 Put）递增 1。</li>
</ul>
</li>
<li><strong>作用:</strong> MVCC 使得读操作可以访问某个特定 Revision 的数据快照，而不会被并发的写操作阻塞。同时，它也是实现 Watch 机制和历史数据查询的基础。</li>
</ul>
</li>
<li><strong>Tombstone（墓碑标记）：</strong> 删除操作并不会立即移除数据，而是创建一个带有特殊标记（Tombstone）的新版本。被标记的数据在后续的 Compaction（压缩）过程中才会被物理删除。</li>
</ul>
<p><strong>BoltDB:</strong></p>
<ul>
<li>是一个嵌入式的、事务性的、基于 B+ Tree 的键值存储库。</li>
<li>etcd 使用 BoltDB 来持久化存储 KV 数据和 Raft 日志（WAL 独立存储）。</li>
<li>在 BoltDB 中，etcd 存储的主要内容是一个 B+ Tree，其 <strong>Key 是 Revision</strong>，<strong>Value 是 etcd 自身的 Key-Value 数据</strong>（序列化后的结构）。<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// BoltDB 中的简化结构</span><br>Bucket <span class="hljs-string">&quot;key&quot;</span>:<br>  K<span class="hljs-function"><span class="hljs-title">ey</span> (Revision) -&gt;</span> Value (LeaseID, etcd_Key, etcd_Value, CreateRevision, ModRevision, Version, Tombstone_flag)<br></code></pre></td></tr></table></figure></li>
<li>这种结构使得通过 Revision 查询特定版本的数据非常高效。</li>
</ul>
<p><strong>内存索引 (TreeIndex):</strong></p>
<ul>
<li>为了加速 Key 的查询（用户关心的是 Key，而不是 Revision），etcd 在内存中维护了一个基于 B-Tree 的索引（<code>treeIndex</code>）。</li>
<li>这个索引 <strong>Key 是用户指定的 etcd Key</strong>，<strong>Value 指向 BoltDB 中该 Key 的最新 Revision</strong> 或历史 Revision 信息。</li>
<li>当查询某个 Key 时，先通过 <code>treeIndex</code> 找到对应的 Revision，再通过 Revision 去 BoltDB 中获取实际的 Value。</li>
</ul>
<p><strong>存储流程示意图：</strong></p>
<img src="/2025/03/13/etcd/image-20250317000035671.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317000035671">

<pre class="mermaid">graph LR
    subgraph "etcd Server (Leader)"
        A[gRPC/HTTP Request] --> B{API Layer}
        B -- Write Request --> C[Raft Module]
        C -- 1. Propose --> C
        C -- 2. Write WAL --> WAL[(WAL File)]
        C -- 3. Replicate to Followers & Wait Quorum --> C
        C -- 4. Commit Log Entry --> C
        C -- 5. Apply Committed Entry --> D[MVCC Storage]
        D -- Update --> E[treeIndex (In-Memory B-Tree: Key -> Revision)]
        D -- Write Revision -> Data --> F[BoltDB (Persistent B+ Tree: Revision -> Data)]
        B -- Read Request --> D
        D -- Query --> E
        E -- Get Revision(s) --> D
        D -- Get Data by Revision --> F
        F -- Return Data --> D
        D -- Return Result --> B
        B -- Response --> A
    end</pre>

<p><strong>Compaction (压缩) 与 Defragmentation (碎片整理):</strong></p>
<ul>
<li><strong>Compaction:</strong> 由于 MVCC 会不断创建新版本，旧版本数据会累积。Compaction 用于清理指定 Revision 之前的历史版本（包括 Tombstone 标记的版本），回收 BoltDB 中的空间。可以通过 <code>etcdctl compact</code> 手动触发，或配置自动压缩策略。<strong>注意：Compaction 只标记空间可重用，不缩小文件大小。</strong></li>
<li><strong>Defragmentation:</strong> Compaction 后，BoltDB 文件内部可能存在很多碎片（已被回收但未释放给操作系统的空间）。Defragmentation 会重建 BoltDB 文件，将有效数据紧凑地排列，并将空闲空间返还给操作系统，从而<strong>缩小文件大小</strong>。这是一个 I&#x2F;O 密集型操作，建议在低峰期执行 (<code>etcdctl defrag</code>)。</li>
</ul>
<h2 id="5-etcd-的-Watch-机制详解"><a href="#5-etcd-的-Watch-机制详解" class="headerlink" title="5. etcd 的 Watch 机制详解"></a>5. etcd 的 Watch 机制详解</h2><p>Watch 机制是 etcd 的核心功能之一，允许客户端高效地追踪 Key 或 Key 范围的变化。Kubernetes 的控制器严重依赖此机制来响应集群状态的变化。</p>
<ul>
<li><strong>基于 Revision 的事件流:</strong> Watch 不是轮询。客户端发起 Watch 请求时，可以指定一个起始 Revision。etcd 会从该 Revision 开始，将后续发生的所有变更事件（Put, Delete）按顺序推送给客户端。</li>
<li><strong>Watch Stream:</strong> 每个 Watch 连接建立一个持久的 gRPC 流。etcd Server 会持续将匹配该 Watch 请求的事件发送到这个流上。</li>
<li><strong>Watcher Group:</strong> etcd 内部为每个被监听的 Key 或 Key 范围维护 Watcher 集合。当一个 Key 被修改（产生新的 Revision）时，MVCC 模块会通知相关的 Watcher Group。</li>
<li><strong>Synced vs Unsynced Watchers:</strong><ul>
<li><strong>Synced Group:</strong> 包含那些已经追赶上当前最新 Revision 的 Watcher。当新的变更发生时，事件会直接发送给这些 Watcher。</li>
<li><strong>Unsynced Group:</strong> 包含那些因为网络延迟或其他原因落后于当前最新 Revision 的 Watcher。etcd 会有一个后台任务（<code>syncWatchersLoop</code>）负责从 BoltDB 读取历史事件，发送给这些落后的 Watcher，直到它们追上进度，然后将其移入 Synced Group。</li>
<li><strong>性能考量:</strong> 如果有大量 Watcher 长期处于 Unsynced 状态，会增加 etcd 的 CPU 和 I&#x2F;O 负担，因为需要不断读取旧数据。</li>
</ul>
</li>
</ul>
<img src="/2025/03/13/etcd/image-20250317001558102.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001558102">

<ul>
<li><strong>慢 Watcher 处理:</strong> 如果某个 Watcher 消费事件的速度过慢，etcd 的发送缓冲区可能会被占满，进而影响其他 Watcher 甚至整个 etcd 的性能。etcd 会有机制检测并可能断开过慢的 Watcher 连接。</li>
</ul>
<h2 id="6-etcd-的高可用部署方案"><a href="#6-etcd-的高可用部署方案" class="headerlink" title="6. etcd 的高可用部署方案"></a>6. etcd 的高可用部署方案</h2><p>etcd 的高可用性依赖于 Raft 协议和集群部署。</p>
<ul>
<li><strong>集群规模:</strong> 推荐部署奇数个节点（通常 3 或 5 个）。<ul>
<li>3 节点集群：可容忍 1 个节点故障。</li>
<li>5 节点集群：可容忍 2 个节点故障。</li>
<li>更多节点会增加 Raft 协议的网络通信开销和延迟，不一定带来更好的写性能。读性能可以通过增加 Learner 节点来扩展。</li>
</ul>
</li>
<li><strong>部署拓扑:</strong><ul>
<li><strong>静态发现:</strong> 启动时通过 <code>--initial-cluster</code> 参数指定所有成员的地址。</li>
<li><strong>DNS 发现:</strong> 通过预配置的 DNS SRV 记录来发现集群成员。</li>
<li><strong>etcd 发现服务:</strong> 利用另一个 etcd 集群或公共发现服务 (<code>discovery.etcd.io</code>) 来引导新成员加入。</li>
</ul>
</li>
<li><strong>故障转移:</strong> 当 Leader 节点故障或网络隔离时，剩余的节点（如果构成多数派）会自动发起选举，选出新的 Leader，集群继续提供服务。故障节点的恢复通常需要人工介入或自动化脚本。</li>
<li><strong>数据备份与恢复:</strong><ul>
<li><strong>快照 (Snapshot):</strong> 定期使用 <code>etcdctl snapshot save</code> 创建集群状态的快照。快照包含了某个时间点的完整 KV 数据。</li>
<li><strong>恢复:</strong> 可以从快照恢复整个集群。恢复过程需要停止所有 etcd 实例，使用 <code>etcdctl snapshot restore</code> 在新数据目录中恢复数据，然后使用新的集群配置重新启动所有节点。<strong>恢复是有损操作，会丢失快照点之后的数据。</strong></li>
</ul>
</li>
<li><strong>自动化运维工具:</strong><ul>
<li><strong>etcd Operator (已归档):</strong> 早期用于在 Kubernetes 上管理 etcd 集群的 Operator。</li>
<li><strong>Helm Charts (如 Bitnami):</strong> 提供标准化的部署模板，简化在 Kubernetes 上部署高可用 etcd 集群（通常使用 StatefulSet）。</li>
</ul>
</li>
</ul>
<p><strong>使用 Bitnami Helm chart 安装 etcd 高可用集群（示例）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加 Bitnami Helm 仓库</span><br>helm repo add bitnami https://charts.bitnami.com/bitnami<br><br><span class="hljs-comment"># 安装 etcd (默认会创建 3 副本的 StatefulSet)</span><br>helm install my-etcd bitnami/etcd --<span class="hljs-built_in">set</span> replicaCount=3<br></code></pre></td></tr></table></figure>

<img src="/2025/03/13/etcd/image-20250317001627420.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001627420">

<h2 id="7-etcd-在-Kubernetes-中的核心作用"><a href="#7-etcd-在-Kubernetes-中的核心作用" class="headerlink" title="7. etcd 在 Kubernetes 中的核心作用"></a>7. etcd 在 Kubernetes 中的核心作用</h2><p>etcd 是 Kubernetes 控制平面的大脑，存储了整个集群的状态。</p>
<ul>
<li><strong>API Server 的唯一后端:</strong> Kubernetes API Server 是唯一直接与 etcd 通信的组件。所有其他组件（kubelet, controller-manager, scheduler）都通过 API Server 间接读写集群状态。</li>
<li><strong>存储对象:</strong> 所有 Kubernetes 资源对象（Pods, Services, ConfigMaps, Secrets, Custom Resources 等）的 YAML&#x2F;JSON 定义都以 Key-Value 的形式存储在 etcd 中。Key 通常遵循 <code>/registry/&lt;resource_type&gt;/&lt;namespace&gt;/&lt;resource_name&gt;</code> 的路径格式。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 示例 Key 路径</span><br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/default/my</span>-nginx-pod<br><span class="hljs-regexp">/registry/</span>services<span class="hljs-regexp">/kube-system/</span>kube-dns<br><span class="hljs-regexp">/registry/</span>configmaps<span class="hljs-regexp">/my-namespace/my</span>-config<br></code></pre></td></tr></table></figure></li>
<li><strong>Watch 与控制器模型:</strong> Kubernetes 的控制器（如 Deployment Controller, ReplicaSet Controller）通过 API Server Watch 相关的资源类型。当 etcd 中有资源变更时，API Server 会收到 Watch 事件，并将其转发给相应的控制器。控制器根据这些事件来调整集群状态，使其趋向于期望状态（例如，创建&#x2F;删除 Pod）。</li>
<li><strong>Resource Version (RV):</strong> Kubernetes API 中的 <code>resourceVersion</code> 字段直接映射到 etcd 中该资源的 ModRevision。客户端（如 kubectl, 控制器）在发起 Watch 请求时会带上已知的最新 RV，API Server 会基于此 RV 从 etcd 获取后续的变更事件。这确保了事件的有序性和不丢失。</li>
<li><strong>API Server 与 etcd 的连接:</strong> API Server 启动时通过 <code>--etcd-servers</code> 参数指定 etcd 集群的地址列表。通过 <code>--etcd-cafile</code>, <code>--etcd-certfile</code>, <code>--etcd-keyfile</code> 配置 TLS 连接。</li>
<li><strong>健康检查:</strong> API Server 会定期对 etcd 集群进行健康检查（现在是真实的 API 调用，而非简单的 Ping），以确保后端存储可用。</li>
</ul>
<p><strong>Kubernetes 集群中 etcd 的部署拓扑:</strong></p>
<ol>
<li><strong>堆叠式 (Stacked) &#x2F; 托管式 (Hosted):</strong> etcd 成员与 Kubernetes 控制平面组件（API Server, Scheduler, Controller Manager）运行在相同的节点上。<ul>
<li><strong>优点:</strong> 部署简单，所需节点较少。控制平面和 etcd 之间的通信是本地的，延迟低。</li>
<li><strong>缺点:</strong> 控制平面节点故障可能同时影响 API Server 和 etcd 成员，降低了容错性。资源竞争可能更激烈。</li>
</ul>
<img src="/2025/03/13/etcd/image-20250317001741454.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001741454"></li>
<li><strong>外部式 (External):</strong> etcd 集群运行在独立的专用节点上，与 Kubernetes 控制平面节点分离。<ul>
<li><strong>优点:</strong> 提高了容错性，控制平面故障不直接影响 etcd，反之亦然。资源隔离更好。可以独立扩展 etcd 集群。</li>
<li><strong>缺点:</strong> 需要更多的主机。控制平面与 etcd 之间的通信需要跨网络，可能引入更高延迟。管理更复杂。</li>
</ul>
<img src="/2025/03/13/etcd/image-20250317001746455.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001746455"></li>
</ol>
<img src="/2025/03/13/etcd/image-20250317001643290.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001643290">

<h2 id="8-etcd-最佳实践与性能优化"><a href="#8-etcd-最佳实践与性能优化" class="headerlink" title="8. etcd 最佳实践与性能优化"></a>8. etcd 最佳实践与性能优化</h2><p>维护一个健康的 etcd 集群对 Kubernetes 的稳定至关重要。</p>
<ol>
<li><strong>硬件要求:</strong><ul>
<li><strong>CPU:</strong> 2-4 核起步，根据集群规模调整。</li>
<li><strong>内存:</strong> 8GB 起步，建议 16GB 或更高。etcd 会缓存数据和索引在内存中。监控 <code>etcd_mvcc_db_total_size_in_bytes</code> 和 <code>process_resident_memory_bytes</code>。</li>
<li><strong>磁盘:</strong> <strong>必须使用低延迟的 SSD</strong>（最好是 NVMe）。磁盘 I&#x2F;O 性能是 etcd 最关键的瓶颈。将 WAL 文件和数据文件放在不同的物理磁盘上可以进一步提升性能 (<code>--wal-dir</code>)。监控磁盘 I&#x2F;O 延迟 (<code>etcd_disk_wal_fsync_duration_seconds</code>, <code>etcd_disk_backend_commit_duration_seconds</code>)，应保持在 10ms 以下。</li>
<li><strong>网络:</strong> 低延迟、高带宽的网络。节点间 RTT (Round Trip Time) 应尽可能低。监控 <code>etcd_network_peer_round_trip_time_seconds</code>。</li>
</ul>
</li>
<li><strong>集群配置:</strong><ul>
<li><strong>规模:</strong> 3 或 5 节点。避免偶数节点。</li>
<li><strong>地域:</strong> 部署在同一数据中心或可用区内，避免跨地域部署导致的高延迟。</li>
<li><strong>时间同步:</strong> 所有节点必须保持精确的时间同步（使用 NTP）。时间偏差可能导致 Raft 协议异常和 TLS 证书验证失败。</li>
</ul>
</li>
<li><strong>参数调优:</strong><ul>
<li><strong>心跳间隔 (<code>--heartbeat-interval</code>):</strong> Leader 发送心跳的频率。默认为 100ms。</li>
<li><strong>选举超时 (<code>--election-timeout</code>):</strong> Follower 等待 Leader 心跳的超时时间。默认为 1000ms。通常应设置为心跳间隔的 5-10 倍。<strong>这两个值需要根据实际网络延迟调整。</strong> 网络延迟高时应适当增加。</li>
<li><strong>快照频率 (<code>--snapshot-count</code>):</strong> 每隔多少次事务提交后创建一次快照。默认为 100,000。频繁快照会增加 I&#x2F;O 负担，但能更快地回收 WAL 日志空间。</li>
</ul>
</li>
<li><strong>存储维护:</strong><ul>
<li><strong>配额 (<code>--quota-backend-bytes</code>):</strong> 设置 etcd 数据库大小的上限（默认为 2GB，建议调大至 8GB 或更高），防止无限增长耗尽磁盘。</li>
<li><strong>自动压缩 (<code>--auto-compaction-retention</code>):</strong> 配置自动压缩策略，保留指定时间段的历史版本（如 <code>--auto-compaction-mode=revision --auto-compaction-retention=1000</code> 保留最近 1000 个版本，或 <code>--auto-compaction-mode=periodic --auto-compaction-retention=1h</code> 每小时压缩一次，保留 1 小时数据）。</li>
<li><strong>定期碎片整理 (<code>etcdctl defrag</code>):</strong> 在低峰期定期执行，回收磁盘空间。<strong>注意：Defrag 是阻塞操作，需要逐个节点执行。</strong></li>
</ul>
</li>
<li><strong>安全性:</strong><ul>
<li><strong>启用 TLS:</strong> 对 Peer（成员间）和 Client（API Server 到 etcd）通信启用双向 TLS 认证 (<code>--peer-client-cert-auth=true</code>, <code>--client-cert-auth=true</code>)。</li>
<li><strong>RBAC (未来可能):</strong> 关注 etcd 未来可能引入的更细粒度的访问控制。</li>
<li><strong>数据加密 (可选):</strong> etcd 支持静态数据加密 (<code>--experimental-encryption-key</code>)，但会带来性能开销。</li>
</ul>
</li>
<li><strong>监控:</strong><ul>
<li><strong>关键指标:</strong><ul>
<li><code>etcd_server_has_leader</code>: 是否有 Leader (0 或 1)。</li>
<li><code>etcd_server_leader_changes_seen_total</code>: Leader 切换次数。频繁切换表明不稳定。</li>
<li><code>etcd_mvcc_db_total_size_in_bytes</code>: 数据库文件大小。</li>
<li><code>etcd_network_peer_round_trip_time_seconds</code>: Peer 间网络延迟。</li>
<li><code>etcd_disk_wal_fsync_duration_seconds</code>: WAL fsync 延迟。</li>
<li><code>etcd_disk_backend_commit_duration_seconds</code>: 后端存储提交延迟。</li>
<li><code>etcd_server_proposals_failed_total</code>: 提案失败次数。</li>
<li><code>grpc_server_handled_total</code> (按 <code>grpc_method</code> 区分): 各 API 调用频率。</li>
<li><code>etcd_debugging_mvcc_keys_total</code>: 总 Key 数量。</li>
<li><code>etcd_debugging_mvcc_pending_events_total</code>: 待处理的 Watch 事件数。</li>
</ul>
</li>
<li><strong>日志:</strong> 关注 etcd 日志中的 WARN 和 ERROR 信息。</li>
</ul>
</li>
<li><strong>事件分离 (大规模集群):</strong> 对于非常大的 Kubernetes 集群，可以将 K8s 事件（Events）存储在单独的 etcd 集群中 (<code>--etcd-servers-overrides=/events#&lt;event-etcd-urls&gt;</code>)，减轻主 etcd 集群的压力。</li>
</ol>
<img src="/2025/03/13/etcd/image-20250317001853663.png" srcset="/img/loading.gif" lazyload class="" title="image-20250317001853663">

<h2 id="9-etcd-常见问题与故障排查"><a href="#9-etcd-常见问题与故障排查" class="headerlink" title="9. etcd 常见问题与故障排查"></a>9. etcd 常见问题与故障排查</h2><ol>
<li><strong>频繁的 Leader 选举:</strong><ul>
<li><strong>症状:</strong> <code>etcd_server_leader_changes_seen_total</code> 指标快速增加，日志中出现选举相关信息。</li>
<li><strong>原因:</strong> 网络延迟高或不稳定、节点负载过高（CPU&#x2F;内存&#x2F;磁盘 I&#x2F;O）、心跳或选举超时设置不合理、时间不同步。</li>
<li><strong>排查:</strong><ul>
<li>检查节点间网络连通性和延迟 (<code>ping</code>, <code>traceroute</code>, <code>etcd_network_peer_round_trip_time_seconds</code>)。</li>
<li>检查节点资源使用情况 (<code>top</code>, <code>iostat</code>, <code>vmstat</code>)。</li>
<li>检查 etcd 日志，查找超时或慢请求信息。</li>
<li>验证 NTP 服务是否正常工作。</li>
<li>检查并调整 <code>--heartbeat-interval</code> 和 <code>--election-timeout</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>集群分裂 (Split Brain):</strong><ul>
<li><strong>症状:</strong> 集群中出现多个 Leader（理论上 Raft 能避免，但可能由配置错误或严重网络分区导致）。</li>
<li><strong>原因:</strong> 错误的 <code>--initial-cluster</code> 配置、网络分区导致多数派无法形成。</li>
<li><strong>排查:</strong><ul>
<li>使用 <code>etcdctl endpoint status --cluster -w table</code> 检查每个成员视角下的集群状态和 Leader。</li>
<li>检查网络防火墙和路由配置。</li>
<li>确保 <code>--initial-cluster-state</code> 配置正确（新建集群为 <code>new</code>，加入现有集群为 <code>existing</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>etcd 请求慢或超时:</strong><ul>
<li><strong>症状:</strong> API Server 延迟高，<code>kubectl</code> 操作缓慢或失败，日志中出现 “context deadline exceeded”。</li>
<li><strong>原因:</strong> 磁盘 I&#x2F;O 瓶颈、网络延迟、etcd 节点 CPU&#x2F;内存不足、大量并发请求、数据库过大需要 Compaction&#x2F;Defrag。</li>
<li><strong>排查:</strong><ul>
<li>检查磁盘 I&#x2F;O 延迟指标 (<code>etcd_disk_wal_fsync_duration_seconds</code>, <code>etcd_disk_backend_commit_duration_seconds</code>)。</li>
<li>检查节点资源使用。</li>
<li>检查网络延迟。</li>
<li>查看 <code>grpc_server_handled_total</code> 确定是否有异常高频的请求。</li>
<li>检查数据库大小 (<code>etcd_mvcc_db_total_size_in_bytes</code>) 和是否达到配额。考虑执行 Compaction 和 Defrag。</li>
</ul>
</li>
</ul>
</li>
<li><strong>磁盘空间不足:</strong><ul>
<li><strong>症状:</strong> etcd 无法写入，日志报错 “database space exceeded”。</li>
<li><strong>原因:</strong> 未配置或达到存储配额 (<code>--quota-backend-bytes</code>)、未进行 Compaction 导致历史版本过多、WAL 文件累积（快照失败或频率过低）。</li>
<li><strong>排查:</strong><ul>
<li>检查配额设置和当前数据库大小。</li>
<li>执行 <code>etcdctl compact</code> 和 <code>etcdctl defrag</code>。</li>
<li>检查自动压缩配置。</li>
<li>检查快照是否成功创建，调整 <code>--snapshot-count</code>。</li>
<li>检查是否有异常大量的写操作。</li>
</ul>
</li>
</ul>
</li>
<li><strong>成员节点 Down 或 Unhealthy:</strong><ul>
<li><strong>症状:</strong> <code>etcdctl endpoint health</code> 显示部分节点 unhealthy。</li>
<li><strong>原因:</strong> 节点宕机、网络不通、etcd 进程崩溃、磁盘故障。</li>
<li><strong>排查:</strong><ul>
<li>检查节点状态和网络连通性。</li>
<li>查看故障节点的 etcd 服务日志 (<code>journalctl -u etcd</code> 或容器日志)。</li>
<li>检查磁盘健康状态。</li>
<li>如果节点无法恢复，需要从集群中移除 (<code>etcdctl member remove</code>)，并可能需要替换新节点 (<code>etcdctl member add</code>)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>结论</strong></p>
<p>etcd 作为 Kubernetes 的核心存储，其稳定性、性能和可靠性直接决定了整个集群的健康状况。深入理解 etcd 的内部机制、部署策略、优化方法和故障排查技巧，是每一位 Kubernetes 管理员和运维工程师的必备技能。通过合理的配置、持续的监控和及时的维护，可以确保 etcd 稳定高效地支撑 Kubernetes 集群运行。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/k8s/" class="print-no-link">#k8s</a>
      
        <a href="/tags/etcd/" class="print-no-link">#etcd</a>
      
        <a href="/tags/distributed-systems/" class="print-no-link">#distributed systems</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>深入理解 etcd：Kubernetes 的分布式基石</div>
      <div>https://mfzzf.github.io/2025/03/13/etcd/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Mzzf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/03/14/%E5%89%91%E6%8C%87offer/" title="剑指offer">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">剑指offer</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/" title="Linux Cgroup 详解：从 v1 到 v2 的演进与实践">
                        <span class="hidden-mobile">Linux Cgroup 详解：从 v1 到 v2 的演进与实践</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
