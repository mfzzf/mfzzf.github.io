<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kubernetes_API_server</title>
    <link href="/2025/03/17/kubernetes-API-server/"/>
    <url>/2025/03/17/kubernetes-API-server/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-Kubernetes-API-Server：访问控制、限流与对象实现"><a href="#深入理解-Kubernetes-API-Server：访问控制、限流与对象实现" class="headerlink" title="深入理解 Kubernetes API Server：访问控制、限流与对象实现"></a>深入理解 Kubernetes API Server：访问控制、限流与对象实现</h1><p>kube-apiserver 是 Kubernetes 集群的”大脑”，负责处理所有请求，是集群管理的核心组件。本文将深入探讨 kube-apiserver 的访问控制机制（认证、鉴权、准入控制）、限流策略以及 APIServer 对象的实现原理。</p><span id="more"></span><h2 id="1-API-Server-的核心功能"><a href="#1-API-Server-的核心功能" class="headerlink" title="1. API Server 的核心功能"></a>1. API Server 的核心功能</h2><p>kube-apiserver 主要提供以下功能：</p><ul><li><strong>集群管理的 REST API 接口</strong>：提供认证授权、数据校验、集群状态变更等功能。</li><li><strong>模块间数据交互枢纽</strong>：其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001413236.png" class="" title="image-20250317001413236"><h2 id="2-访问控制"><a href="#2-访问控制" class="headerlink" title="2. 访问控制"></a>2. 访问控制</h2><img src="/2025/03/17/kubernetes-API-server/image-20250317001401046.png" class="" title="image-20250317001401046"><p>客户端（例如 <code>kubectl</code>、自定义控制器或其他 K8s 组件）发出的 API 请求首先到达 <code>kube-apiserver</code>。这些请求经过一系列处理步骤，最终被处理并存储到 <code>etcd</code> 中（或从 <code>etcd</code> 中检索）。</p><img src="/2025/03/17/kubernetes-API-server/image-20250317141928036.png" class="" title="image-20250317141928036"><ul><li><p><strong>Panic Recovery</strong>: 捕获并处理任何 panic，防止整个 apiserver 崩溃。</p></li><li><p><strong>Request Timeout</strong>: 设置请求的超时时间，防止请求无限期挂起。</p></li><li><p><strong>Authentication</strong>: 验证请求者的身份。K8s 支持多种认证机制，如 X.509 证书、Service Account Tokens、Bearer Tokens 等。</p></li><li><p><strong>Audit</strong>: 记录请求的审计日志，用于安全审计和故障排除。</p></li><li><p><strong>Impersonation</strong>: 允许一个用户或服务账户以另一个用户或服务账户的身份执行操作。</p></li><li><p><strong>Max-in-flight</strong>: 限制并发处理的请求数量，防止服务器过载。</p></li><li><p><strong>Authorization</strong>: 确定经过身份验证的用户是否有权限执行请求的操作。K8s 支持多种授权机制，如 RBAC (Role-Based Access Control)、ABAC (Attribute-Based Access Control) 等。</p></li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317141918159.png" class="" title="image-20250317141918159"><h3 id="2-1-认证（Authentication）"><a href="#2-1-认证（Authentication）" class="headerlink" title="2.1 认证（Authentication）"></a>2.1 认证（Authentication）</h3><p>在 Kubernetes 中，认证是指对请求的发送者（用户或服务）进行身份识别，以确保只有合法的实体可以访问 Kubernetes API Server。以下是 Kubernetes 支持的多种认证机制的详细说明：</p><hr><h4 id="1-X-509-证书"><a href="#1-X-509-证书" class="headerlink" title="1. X.509 证书"></a><strong>1. X.509 证书</strong></h4><p><strong>概念</strong>：<br>X.509 是一种基于公钥基础设施 (PKI) 的证书标准，通常用于安全通信。Kubernetes 支持通过客户端证书进行身份验证。</p><p><strong>工作原理</strong>：</p><ol><li>用户使用私钥和证书向 API Server 发起 HTTPS 请求。</li><li>API Server 使用信任的 CA 证书对客户端证书进行验证。</li><li>若验证通过，则认证成功。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>生成 CA 和用户证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 CA 私钥和证书</span><br>openssl genrsa -out ca.key 2048<br>openssl req -x509 -new -nodes -key ca.key -subj <span class="hljs-string">&quot;/CN=kube-ca&quot;</span> -days 10000 -out ca.crt<br><br><span class="hljs-comment"># 生成用户私钥和 CSR</span><br>openssl genrsa -out user.key 2048<br>openssl req -new -key user.key -subj <span class="hljs-string">&quot;/CN=my-user/O=my-group&quot;</span> -out user.csr<br><br><span class="hljs-comment"># 使用 CA 签发用户证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> user.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out user.crt -days 10000 -extensions v3_ext<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --client-ca-file=/path/to/ca.crt<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong>：</p><ul><li>用户名（CN）由证书中的 <code>Common Name</code> 字段指定。</li><li>组（Group）由证书中的 <code>Organization</code> 字段指定。</li></ul><hr><h4 id="2-静态-Token-文件"><a href="#2-静态-Token-文件" class="headerlink" title="2. 静态 Token 文件"></a><strong>2. 静态 Token 文件</strong></h4><p><strong>概念</strong>：<br>静态 Token 是预定义的令牌，用于认证用户。它适合小型测试集群，但不推荐生产环境中使用。</p><p><strong>工作原理</strong>：</p><ol><li>用户请求中携带 <code>Authorization: Bearer &lt;token&gt;</code>。</li><li>API Server 从配置的 Token 文件中查找匹配的 Token。</li><li>若匹配成功，则认证通过。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>创建 Token 文件（CSV 格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csv">token1234,my-user,uid1234,&quot;group1,group2&quot;<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --token-auth-file=/path/to/tokens.csv<br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：简单易用，易于共享。</li><li><strong>缺点</strong>：缺乏安全性（Token 没有过期机制）。</li></ul><hr><h4 id="3-引导-Token-Bootstrap-Token"><a href="#3-引导-Token-Bootstrap-Token" class="headerlink" title="3. 引导 Token (Bootstrap Token)"></a><strong>3. 引导 Token (Bootstrap Token)</strong></h4><p><strong>概念</strong>：<br>引导 Token 是一种动态令牌，主要用于集群引导阶段（例如 <code>kubeadm join</code>）。Token 生命周期由 <code>kube-controller-manager</code> 管理。</p><p><strong>工作原理</strong>：</p><ol><li>Token 以 Kubernetes Secret 的形式存储于 <code>kube-system</code> 命名空间。</li><li>当客户端请求使用 Token 时，API Server 查询对应的 Secret 以验证其合法性。</li><li><code>TokenCleaner</code> 控制器会自动清理过期的 Token。</li></ol><p><strong>常见命令</strong>：</p><ul><li><p>查看引导 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm token list<br></code></pre></td></tr></table></figure></li><li><p>创建引导 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm token create<br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：动态管理，支持自动过期。</li><li><strong>缺点</strong>：只适合用于集群引导。</li></ul><hr><h4 id="4-静态密码文件"><a href="#4-静态密码文件" class="headerlink" title="4. 静态密码文件"></a><strong>4. 静态密码文件</strong></h4><p><strong>概念</strong>：<br>通过用户名和密码进行认证。这种方式简单但不安全，因此不推荐在生产环境中使用。</p><p><strong>配置方式</strong>：</p><ul><li><p>创建密码文件（CSV 格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csv">password1234,my-user,uid1234,&quot;group1,group2&quot;<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --basic-auth-file=/path/to/passwords.csv<br></code></pre></td></tr></table></figure></li></ul><p><strong>缺点</strong>：</p><ul><li>用户名和密码以明文方式存储。</li><li>缺乏强制密码保护机制。</li></ul><hr><h4 id="5-Service-Account-Token"><a href="#5-Service-Account-Token" class="headerlink" title="5. Service Account Token"></a><strong>5. Service Account Token</strong></h4><p><strong>概念</strong>：<br>Service Account 是 Kubernetes 原生的认证机制，主要为 Pod 提供身份认证。</p><p><strong>工作原理</strong>：</p><ol><li>每个 Pod 都可以绑定一个 Service Account。</li><li>默认情况下，Service Account 的 Token 会自动挂载到 Pod 的文件系统路径 <code>/run/secrets/kubernetes.io/serviceaccount</code>。</li><li>Pod 使用 Token 与 API Server 通信。</li></ol><p><strong>优点</strong>：</p><ul><li>安全性高，自动管理。</li><li>适合 Pod 内部访问 API Server。</li></ul><hr><h4 id="6-OpenID-Connect-OIDC"><a href="#6-OpenID-Connect-OIDC" class="headerlink" title="6. OpenID Connect (OIDC)"></a><strong>6. OpenID Connect (OIDC)</strong></h4><p><strong>概念</strong>：<br>OIDC 是基于 OAuth 2.0 的身份认证协议，用于对接外部身份认证服务（例如 Google, Keycloak）。</p><p><strong>工作原理</strong>：</p><ol><li>用户向 OIDC 提供商请求 Token。</li><li>用户携带 Token 向 API Server 发起请求。</li><li>API Server 验证 Token 的签名及有效性。</li><li>验证成功后，返回认证成功。</li></ol><p><strong>配置方式</strong>：</p><ul><li>配置 API Server：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver \<br>  --oidc-issuer-url=https://issuer.example.com \<br>  --oidc-client-id=kubernetes \<br>  --oidc-username-claim=email \<br>  --oidc-groups-claim=<span class="hljs-built_in">groups</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>集成第三方身份认证系统。</li><li>支持复杂身份和组管理。</li></ul><hr><h4 id="7-Webhook-Token-认证"><a href="#7-Webhook-Token-认证" class="headerlink" title="7. Webhook Token 认证"></a><strong>7. Webhook Token 认证</strong></h4><p><strong>概念</strong>：<br>通过 Webhook 调用外部服务来验证 Token 的合法性。</p><p><strong>工作原理</strong>：</p><ol><li>用户携带 Token 向 API Server 发起请求。</li><li>API Server 将 Token 转发到配置的 Webhook 服务。</li><li>Webhook 服务返回认证结果。</li><li>API Server 根据认证结果决定是否通过。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>配置 Webhook：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># webhook-config.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://auth.example.com/authenticate</span><br><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-context</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">example-context</span><br></code></pre></td></tr></table></figure></li><li><p>启用 Webhook：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --authentication-token-webhook-config-file=/path/to/webhook-config.yaml<br></code></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>灵活性高，可以集成复杂的认证逻辑。</li></ul><hr><h4 id="8-匿名请求"><a href="#8-匿名请求" class="headerlink" title="8. 匿名请求"></a><strong>8. 匿名请求</strong></h4><p><strong>概念</strong>：<br>当未提供身份凭据时，API Server 将请求识别为匿名请求。匿名请求默认启用，但可以禁用。</p><p><strong>配置方式</strong>：</p><ul><li>禁用匿名请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --anonymous-auth=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：允许调试和测试。</li><li><strong>缺点</strong>：不适合生产环境，可能引发安全问题。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317145348516.png" class="" title="image-20250317145348516"><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="2-1-1-基于-Webhook-的认证服务集成"><a href="#2-1-1-基于-Webhook-的认证服务集成" class="headerlink" title="2.1.1 基于 Webhook 的认证服务集成"></a>2.1.1 基于 Webhook 的认证服务集成</h4><p>可以构建符合 Kubernetes 规范的自定义认证服务。以下是构建认证服务的要点：</p><ul><li><strong>规范</strong>：<ul><li>URL：<code>https://authn.example.com/authenticate</code></li><li>Method：<code>POST</code></li><li>Input：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TokenReview&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;spec&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(BEARERTOKEN)&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>Output：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TokenReview&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;authenticated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;janedoe@example.com&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;42&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;groups&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;developers&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;qa&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>以下为go代码示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//解码认证请求</span><br>decoder := json.NewDecoder(r.Body)<br><span class="hljs-keyword">var</span> tr authentication.TokenReview<br>err := decoder.Decode(&amp;tr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 转发认证请求至认证服务器(以github为例)</span><br>ts := oauth2.StaticTokenSource(<br>&amp;oauth2.Token&#123;AccessToken: tr.Spec.Token&#125;,<br>)<br>tc := oauth2.NewClient(oauth2.NoContext, ts)<br>client := github.NewClient(tc)<br>user, _, err := client.Users.Get(context.Background(), <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 认证结果返回给APIServer</span><br>w.WriteHeader(http.StatusOK)<br>trs := authentication.TokenReviewStatus&#123;<br>Authenticated: <span class="hljs-literal">true</span>,<br>User: authentication.UserInfo&#123;<br>Username: *user.Login,<br>UID:      *user.Login,<br>&#125;,<br>&#125;<br>json.NewEncoder(w).Encode(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span>,<br><span class="hljs-string">&quot;kind&quot;</span>:       <span class="hljs-string">&quot;TokenReview&quot;</span>,<br><span class="hljs-string">&quot;status&quot;</span>:     trs,<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-1-2-keystone认证的陷阱"><a href="#2-1-2-keystone认证的陷阱" class="headerlink" title="2.1.2 keystone认证的陷阱"></a>2.1.2 keystone认证的陷阱</h4><p>Keystone 是很多企业的核心认证服务。Kubernetes 中使用 Keystone 作为认证插件可能会导致 Keystone 故障且无法恢复。<br>原因：gophercloud 针对过期 token 会一直 retry,导致服务无法恢复</p><p><strong>解决方案:</strong></p><ul><li>熔断</li><li>限流</li></ul><h3 id="2-2-授权"><a href="#2-2-授权" class="headerlink" title="2.2 授权"></a>2.2 授权</h3><p>授权阶段负责确定已认证的用户是否有权限执行请求的操作。Kubernetes 支持以下授权模式：</p><ul><li><strong>ABAC (Attribute-Based Access Control)</strong>：基于属性的访问控制，配置复杂，不推荐。</li><li><strong>RBAC (Role-Based Access Control)</strong>：基于角色的访问控制，推荐使用。</li><li><strong>Webhook</strong>：将授权决策委托给外部 Webhook 服务。</li><li><strong>Node</strong>：一种特殊用途的授权模式，用于授予 kubelet 访问特定资源的权限。</li></ul><h4 id="2-2-1-RBAC"><a href="#2-2-1-RBAC" class="headerlink" title="2.2.1 RBAC"></a>2.2.1 RBAC</h4><p>RBAC 的核心概念：</p><ul><li><strong>Role（角色）</strong>：定义了一组权限规则。</li><li><strong>ClusterRole（集群角色）</strong>：与 Role 类似，但作用于整个集群。</li><li><strong>RoleBinding（角色绑定）</strong>：将 Role 或 ClusterRole 与用户、组或 ServiceAccount 绑定。</li><li><strong>ClusterRoleBinding（集群角色绑定）</strong>：将 ClusterRole 与用户、组或 ServiceAccount 绑定。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001000991.png" class="" title="image-20250317001000991"><ul><li><strong>针对群组授权</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">read-secrets-global</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">manager</span> <span class="hljs-comment"># &#x27;name&#x27; 是区分大小写的</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-reader</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-规划系统角色"><a href="#2-2-2-规划系统角色" class="headerlink" title="2.2.2 规划系统角色"></a>2.2.2 规划系统角色</h4><p>在规划 Kubernetes 集群的权限时，需要考虑以下角色：</p><ul><li><strong>管理员</strong>：拥有集群的最高权限。</li><li><strong>普通用户</strong>：拥有其创建的命名空间内资源的操作权限，对其他命名空间可能有只读权限。</li><li><strong>SystemAccount</strong>：用于 Kubernetes 组件或自定义应用与 API Server 通信。</li></ul><h4 id="2-2-3-实现自定义授权逻辑的方案"><a href="#2-2-3-实现自定义授权逻辑的方案" class="headerlink" title="2.2.3 实现自定义授权逻辑的方案"></a>2.2.3 实现自定义授权逻辑的方案</h4><ol><li>在集群创建时，创建自定义的 Role，例如 <code>namespace-creator</code>，定义用户可操作的对象和读写权限。</li><li>创建自定义的 Namespace 准入控制器，在 Namespace 创建请求被处理时，获取当前用户信息并将其添加到 Namespace 的 Annotation 中。</li><li>创建 RBAC 控制器，监视 Namespace 的创建事件，获取 Namespace 创建者信息，并在当前 Namespace 中创建 RoleBinding 对象，将 <code>namespace-creator</code> 角色与用户绑定。</li></ol><h4 id="2-2-4-权限相关的最佳实践"><a href="#2-2-4-权限相关的最佳实践" class="headerlink" title="2.2.4 权限相关的最佳实践"></a>2.2.4 权限相关的最佳实践</h4><ul><li>ClusterRole 是非命名空间绑定的，针对整个集群生效。</li><li>通常需要创建一个管理员角色，并且绑定给开发运营团队成员。</li><li>ThirdPartyResource 和 CustomResourceDefinition 是全局资源，普通用户创建<br>ThirdPartyResource 以后，需要管理员授予相应权限后才能真正操作该对象。</li><li>针对所有的角色管理，建议创建 spec，用源代码驱动。</li><li>权限是可以传递的，用户 A 可以将其对某对象的某操作，抽取成一个权限，并赋给用户 B。</li><li>防止海量的角色和角色绑定对象，因为大量的对象会导致鉴权效率低，同时给 apiserver 增加负担。</li><li>ServiceAccount 也需要授权的。</li><li>Tips：SSH 到 master 节点通过 insecure port 访问 apiserver 可绕过鉴权，当需要做管理操作又没有权限时可以使用（不推荐）</li></ul><p><strong>授权相关的坑：</strong><br>研发人员忘记在生产环境更新 rolebinding 导致权限不足</p><h3 id="2-3-准入控制"><a href="#2-3-准入控制" class="headerlink" title="2.3 准入控制"></a>2.3 准入控制</h3><p>准入控制在授权之后对请求进行进一步的验证或修改。与认证和授权不同，准入控制可以处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等操作有效。</p><p>Kubernetes 内置了许多准入控制插件，例如：</p><ul><li><strong>AlwaysPullImages</strong>：强制拉取最新镜像。</li><li><strong>DenyEscalatingExec</strong>：禁止特权容器的 exec 和 attach 操作。</li><li><strong>ServiceAccount</strong>：自动创建默认 ServiceAccount。</li><li><strong>ResourceQuota</strong>：限制 Pod 的资源请求。</li><li><strong>LimitRanger</strong>：为 Pod 设置默认资源请求和限制。</li><li><strong>NamespaceLifecycle</strong>：确保处于 termination 状态的命名空间不再接收新的对象创建请求。</li><li><strong>PodSecurityPolicy</strong>：实施 Pod 安全策略。</li><li><strong>NodeRestriction</strong>：限制 kubelet 仅可访问 node、endpoint、pod、service 以及 secret、<br> configmap、PV 和 PVC 等相关的资源</li></ul><h4 id="2-3-1-准入控制插件的开发"><a href="#2-3-1-准入控制插件的开发" class="headerlink" title="2.3.1 准入控制插件的开发"></a>2.3.1 准入控制插件的开发</h4><p>除了默认的准入控制插件，Kubernetes 还支持自定义准入控制插件：</p><ul><li><strong>MutatingWebhookConfiguration</strong>：修改准入对象。</li><li><strong>ValidatingWebhookConfiguration</strong>：校验准入对象，但不修改。<br>准入控制例子：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span><br><span class="hljs-string">admissionregistration.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">MutatingWebhookConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ns-mutating.webhook.k8s.io</span><br><span class="hljs-attr">webhooks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">clientConfig:</span><br>    <span class="hljs-attr">caBundle:</span> &#123;&#123;<span class="hljs-string">.serverca_base64</span>&#125;&#125;<br>    <span class="hljs-attr">url:</span><br><span class="hljs-string">https://admission.local.tess.io/apis/admission.k8s.io/v1alpha1/ns-mutating</span><br>  <span class="hljs-attr">failurePolicy:</span> <span class="hljs-string">Fail</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ns-mutating.webhook.k8s.io</span><br>  <span class="hljs-attr">namespaceSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>     <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">apiVersions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">operations:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CREATE</span><br>    <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>    <span class="hljs-attr">sideEffects:</span> <span class="hljs-string">Unknown</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-配额管理"><a href="#2-3-2-配额管理" class="headerlink" title="2.3.2 配额管理"></a>2.3.2 配额管理</h4><p><strong>原因：</strong><br>资源有限，如何限定某个用户有多少资源？<br><strong>方案：</strong></p><ul><li>预定义每个Namespace的ResourceQuota，并把spec保存为configmap</li><li>创建ResourceQuota Controller</li><li>apiserver中开启ResourceQuota的admission plugin</li></ul><h2 id="3-限流"><a href="#3-限流" class="headerlink" title="3. 限流"></a>3. 限流</h2><p>限流是保护 API Server 免受过多请求影响的重要机制。</p><h3 id="3-1-传统限流算法"><a href="#3-1-传统限流算法" class="headerlink" title="3.1 传统限流算法"></a>3.1 传统限流算法</h3><ul><li><strong>计数器固定窗口算法</strong>：在固定时间窗口内对请求计数，超过阈值则拒绝。</li><li><strong>计数器滑动窗口算法</strong>：将固定窗口划分为多个小窗口，分别计数，窗口滑动时更新计数。</li><li><strong>漏斗算法</strong>：请求进入漏斗，以恒定速率流出，漏斗满时溢出。</li><li><strong>令牌桶算法</strong>：以恒定速率向令牌桶中放入令牌，请求消耗令牌，桶空时拒绝。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001009246.png" class="" title="image-20250317001009246"><pre class="mermaid">graph LR    subgraph "计数器固定窗口"        A[请求] --> B{计数器 < 阈值?}        B -- 是 --> C[处理请求]        B -- 否 --> D[拒绝请求]    end    subgraph "计数器滑动窗口"        E[请求] --> F[小窗口1]        F --> G[小窗口2]        G --> H[...]        H --> I[小窗口N]        I --> J{总数 < 阈值?}        J -- 是 --> K[处理请求]        J -- 否 --> L[拒绝请求]    end    subgraph "漏斗算法"        M[请求] --> N(漏斗)        N -- 恒定速率 --> O[处理请求]        N -- 溢出 --> P[拒绝请求]    end    subgraph "令牌桶算法"        Q[请求] --> R{有令牌?}        R -- 是 --> S[消耗令牌]        S --> T[处理请求]        R -- 否 --> U[拒绝请求]    end</pre><h3 id="3-2-APIServer-中的限流"><a href="#3-2-APIServer-中的限流" class="headerlink" title="3.2 APIServer 中的限流"></a>3.2 APIServer 中的限流</h3><p>kube-apiserver 通过以下参数进行限流：</p><ul><li><code>--max-requests-inflight</code>：最大非 mutating 请求数。</li><li><code>--max-mutating-requests-inflight</code>：最大 mutating 请求数。</li><li>代码： <code>staging/src/k8s.io/apiserver/pkg/server/filters/maxinflight.go:WithMaxInFlightLimit()</code></li></ul><p>默认值：</p><table><thead><tr><th>节点数</th><th>max-requests-inflight</th><th>max-mutating-requests-inflight</th></tr></thead><tbody><tr><td>1000-3000</td><td>400&#x2F;1500</td><td>200&#x2F;500</td></tr><tr><td>&gt;3000</td><td>3000</td><td>1000</td></tr></tbody></table><h3 id="3-3-传统限流方法的局限性"><a href="#3-3-传统限流方法的局限性" class="headerlink" title="3.3 传统限流方法的局限性"></a>3.3 传统限流方法的局限性</h3><ul><li><strong>粒度粗</strong>：无法针对不同用户、场景进行精细化限流。</li><li><strong>单队列</strong>：所有请求共享限流资源，可能导致单个用户的行为影响整个系统。</li><li><strong>不公平</strong>：正常用户的请求可能被排在队尾，无法及时处理。</li><li><strong>无优先级</strong>：重要请求可能被限流，导致系统故障难以恢复。</li></ul><h3 id="3-4-API-Priority-and-Fairness-APF"><a href="#3-4-API-Priority-and-Fairness-APF" class="headerlink" title="3.4 API Priority and Fairness (APF)"></a>3.4 API Priority and Fairness (APF)</h3><p>APF 是 Kubernetes 1.18 引入的新特性，提供更细粒度的请求分类和隔离，以及有限的排队机制，避免短暂突发流量导致请求被拒绝。</p><h4 id="3-4-1-APF-的核心概念"><a href="#3-4-1-APF-的核心概念" class="headerlink" title="3.4.1 APF 的核心概念"></a>3.4.1 APF 的核心概念</h4><ul><li><strong>多等级 (Priority Level)</strong>：不同优先级的请求拥有独立的并发资源。</li><li><strong>多队列 (Multiple Queues)</strong>：每个优先级内部使用多个队列，通过公平排队算法避免单个 Flow 饿死其他 Flow。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001019487.png" class="" title="image-20250317001019487"><pre class="mermaid">graph LR    A[请求] --> B(FlowSchema)    B --> C{匹配?}    C -- 是 --> D[Priority Level]    D --> E(Queue Set)    E --> F[Queue 1]    E --> G[Queue 2]    E --> H[...]    E --> I[Queue N]    F --> J[处理请求]    G --> J    H --> J    I --> J    C -- 否 --> B(下一个 FlowSchema)</pre><h4 id="3-4-2-关键概念"><a href="#3-4-2-关键概念" class="headerlink" title="3.4.2 关键概念"></a>3.4.2 关键概念</h4><ul><li><strong>FlowSchema</strong>：将请求分类到不同的 Flow。</li><li><strong>PriorityLevelConfiguration</strong>：定义每个优先级的并发限制和排队参数。</li><li><strong>Distinguisher</strong>：在 FlowSchema 内部进一步区分请求（例如，按用户或命名空间）。</li><li><strong>Shuffle Sharding</strong>：将请求分配到队列的算法，隔离低强度和高强度流量。</li><li><strong>Fair Queuing</strong>：从队列中选择请求的算法，确保同一优先级内不同 Flow 的公平性。</li></ul><h4 id="3-4-3-豁免请求"><a href="#3-4-3-豁免请求" class="headerlink" title="3.4.3 豁免请求"></a>3.4.3 豁免请求</h4><p>某些特别重要的请求（例如，<code>system:masters</code> 组的请求）不受 APF 限制。</p><h4 id="3-4-4-默认配置"><a href="#3-4-4-默认配置" class="headerlink" title="3.4.4 默认配置"></a>3.4.4 默认配置</h4><p>Kubernetes 提供了以下默认配置：</p><ul><li><code>system</code>：用于 <code>system:nodes</code> 组的请求。</li><li><code>leader-election</code>：用于内置控制器的领导者选举请求。</li><li><code>workload-high</code>：用于内置控制器的请求。</li><li><code>workload-low</code>：用于来自任何服务帐户的请求。</li><li><code>global-default</code>：处理所有其他流量。</li><li><code>exempt</code>：完全不受流控限制。</li><li><code>catch-all</code>：确保每个请求都被分类。</li></ul><h4 id="3-4-5-PriorityLevelConfiguration"><a href="#3-4-5-PriorityLevelConfiguration" class="headerlink" title="3.4.5 PriorityLevelConfiguration"></a>3.4.5 PriorityLevelConfiguration</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityLevelConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">global-default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">limited:</span><br>    <span class="hljs-attr">assuredConcurrencyShares:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">limitResponse:</span><br>      <span class="hljs-attr">queuing:</span><br>        <span class="hljs-attr">handSize:</span> <span class="hljs-number">6</span><br>        <span class="hljs-attr">queueLengthLimit:</span> <span class="hljs-number">50</span><br>        <span class="hljs-attr">queues:</span> <span class="hljs-number">128</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Queue</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">Limited</span><br></code></pre></td></tr></table></figure><h4 id="3-4-6-FlowSchema"><a href="#3-4-6-FlowSchema" class="headerlink" title="3.4.6 FlowSchema"></a>3.4.6 FlowSchema</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">FlowSchema</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-scheduler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">distinguisherMethod:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">ByNamespace</span><br>  <span class="hljs-attr">matchingPrecedence:</span> <span class="hljs-number">800</span><br>  <span class="hljs-attr">priorityLevelConfiguration:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">workload-high</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">resourceRules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>      <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">subjects:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>      <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-scheduler</span><br></code></pre></td></tr></table></figure><h4 id="3-4-7-调试"><a href="#3-4-7-调试" class="headerlink" title="3.4.7 调试"></a>3.4.7 调试</h4><p>可以使用以下命令调试 APF：</p><ul><li><code>/debug/api_priority_and_fairness/dump_priority_levels</code></li><li><code>/debug/api_priority_and_fairness/dump_queues</code></li><li><code>/debug/api_priority_and_fairness/dump_requests</code></li></ul><h2 id="4-高可用-APIServer"><a href="#4-高可用-APIServer" class="headerlink" title="4. 高可用 APIServer"></a>4. 高可用 APIServer</h2><h3 id="4-1-启动-apiserver-示例"><a href="#4-1-启动-apiserver-示例" class="headerlink" title="4.1 启动 apiserver 示例"></a>4.1 启动 apiserver 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --feature-gates=AllAlpha=<span class="hljs-literal">true</span> --runtime-config=api/all=<span class="hljs-literal">true</span> \<br>--requestheader-allowed-names=front-proxy-client \<br>--client-ca-file=/etc/kubernetes/pki/ca.crt \<br>--allow-privileged=<span class="hljs-literal">true</span> \<br>--experimental-bootstrap-token-auth=<span class="hljs-literal">true</span> \<br>--storage-backend=etcd3 \<br>--requestheader-username-headers=X-Remote-User \<br>--requestheader-extra-headers-prefix=X-Remote-Extra- \<br>--service-account-key-file=/etc/kubernetes/pki/sa.pub \<br>--tls-cert-file=/etc/kubernetes/pki/apiserver.crt \<br>--tls-private-key-file=/etc/kubernetes/pki/apiserver.key \<br>--kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt \<br>--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt \<br>--enabled-hooks=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota \<br>--requestheader-group-headers=X-Remote-Group \<br>--kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key \<br>--secure-port=6443 \<br>--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \<br>--service-cluster-ip-range=10.96.0.0/12 \<br>--advertise-address=192.168.0.20 --etcd-servers=http://127.0.0.1:2379<br></code></pre></td></tr></table></figure><h3 id="4-2-构建高可用的多副本-apiserver"><a href="#4-2-构建高可用的多副本-apiserver" class="headerlink" title="4.2 构建高可用的多副本 apiserver"></a>4.2 构建高可用的多副本 apiserver</h3><p>apiserver是无状态的Rest Server,无状态所以方便Scale Up／down,在多个apiserver实例之上，配置负载均衡,证书可能需要加上Loadbalancer VIP重新生成</p><h3 id="4-3-其他最佳实践"><a href="#4-3-其他最佳实践" class="headerlink" title="4.3 其他最佳实践"></a>4.3 其他最佳实践</h3><ul><li><strong>预留充足的 CPU、内存资源</strong>。</li><li><strong>善用速率限制（RateLimit）</strong>。</li><li><strong>设置合适的缓存大小</strong>。</li><li><strong>客户端尽量使用长连接</strong>。</li><li><strong>访问 APIServer</strong>:<ul><li>外部客户：通过 LoadBalancer 访问。</li><li>内部客户端：优先访问 Cluster IP。</li></ul></li></ul><h2 id="5-搭建多租户的-Kubernetes-集群"><a href="#5-搭建多租户的-Kubernetes-集群" class="headerlink" title="5. 搭建多租户的 Kubernetes 集群"></a>5. 搭建多租户的 Kubernetes 集群</h2><h3 id="5-1-目标"><a href="#5-1-目标" class="headerlink" title="5.1 目标"></a>5.1 目标</h3><ul><li><strong>授信</strong>：认证和授权，确保只有可信用户才能访问集群，并防止用户越权操作。</li><li><strong>隔离</strong>：可见性隔离、资源隔离、应用访问隔离，确保不同租户之间的隔离性。</li><li><strong>资源管理</strong>：Quota 管理，控制每个租户的资源使用量。</li></ul><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><ul><li><strong>认证</strong>：与企业现有认证系统集成（例如，使用 Webhook 认证插件与 Microsoft Active Directory 集成）。</li><li><strong>授权</strong>：使用 RBAC 进行细粒度的权限控制。</li><li><strong>可见性隔离</strong>：通过命名空间对不同租户可见的资源进行隔离</li><li><strong>资源隔离</strong>：通过专有设备给特定租户使用</li><li><strong>应用访问隔离</strong>： 通过设置，只允许特定租户访问某些应用</li><li><strong>Quota 管理</strong>：通过 ResourceQuota 控制每个命名空间的资源使用。</li></ul><h2 id="6-APIServer-对象的实现"><a href="#6-APIServer-对象的实现" class="headerlink" title="6. APIServer 对象的实现"></a>6. APIServer 对象的实现</h2><h3 id="6-1-GKV-Group-Kind-Version"><a href="#6-1-GKV-Group-Kind-Version" class="headerlink" title="6.1  GKV (Group, Kind, Version)"></a>6.1  GKV (Group, Kind, Version)</h3><ul><li><strong>Group</strong>：API 资源的分组。</li><li><strong>Kind</strong>：API 资源的类型。</li><li><strong>Version</strong>：API 资源的版本（Internal version 和 External version）。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001025889.png" class="" title="image-20250317001025889"><pre class="mermaid">graph LR    A[API Resource] --> B(Group)    A --> C(Kind)    A --> D(Version)    D --> E(Internal)    D --> F(External)</pre><h3 id="6-2-定义-Group"><a href="#6-2-定义-Group" class="headerlink" title="6.2  定义 Group"></a>6.2  定义 Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apis/core/register.go</span><br><span class="hljs-keyword">package</span> core<br><span class="hljs-keyword">const</span> GroupName = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// core group 的 GroupName 为空</span><br><span class="hljs-keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: runtime.APIVersionInternal&#125;<br><br><span class="hljs-keyword">var</span> (<br>SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)<br>AddToScheme   = SchemeBuilder.AddToScheme<br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addKnownTypes</span><span class="hljs-params">(scheme *runtime.Scheme)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := scheme.AddIgnoredConversionType(&amp;metav1.TypeMeta&#123;&#125;, &amp;metav1.TypeMeta&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>scheme.AddKnownTypes(SchemeGroupVersion,<br>&amp;Pod&#123;&#125;,<br>&amp;PodList&#123;&#125;,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-定义对象类型"><a href="#6-3-定义对象类型" class="headerlink" title="6.3 定义对象类型"></a>6.3 定义对象类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// types.go</span><br><span class="hljs-keyword">type</span> Pod <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br>Spec PodSpec <span class="hljs-string">`json:&quot;spec,omitempty&quot; protobuf:&quot;bytes,2,opt,name=spec&quot;`</span><br>Status PodStatus <span class="hljs-string">`json:&quot;status,omitempty&quot; protobuf:&quot;bytes,3,opt,name=status&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PodList <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ListMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br>Items []Pod <span class="hljs-string">`json:&quot;items&quot; protobuf:&quot;bytes,2,rep,name=items&quot;`</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-4-代码生成-Tags"><a href="#6-4-代码生成-Tags" class="headerlink" title="6.4 代码生成 Tags"></a>6.4 代码生成 Tags</h3><ul><li><strong>Global Tags</strong>：定义在 <code>doc.go</code> 中，例如 <code>// +k8s:deepcopy-gen=package</code>。</li><li><strong>Local Tags</strong>：定义在 <code>types.go</code> 中的每个对象里，例如 <code>// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>。</li></ul><h3 id="6-5-实现-etcd-storage"><a href="#6-5-实现-etcd-storage" class="headerlink" title="6.5  实现 etcd storage"></a>6.5  实现 etcd storage</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/configmap/storage/storage.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewREST</span><span class="hljs-params">(optsGetter generic.RESTOptionsGetter)</span></span> *REST &#123;<br>store := &amp;genericregistry.Store&#123;<br>NewFunc:                  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;api.ConfigMap&#123;&#125; &#125;,<br>NewListFunc:              <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;api.ConfigMapList&#123;&#125; &#125;,<br>DefaultQualifiedResource: api.Resource(<span class="hljs-string">&quot;configmaps&quot;</span>),<br>CreateStrategy:           configmap.Strategy,<br>UpdateStrategy:           configmap.Strategy,<br>DeleteStrategy:           configmap.Strategy,<br>TableConvertor:           printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,<br>&#125;<br>options := &amp;generic.StoreOptions&#123;RESTOptions: optsGetter&#125;<br><span class="hljs-keyword">if</span> err := store.CompleteWithOptions(options); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Propagate error up</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;REST&#123;store&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-6-创建和更新对象时的业务逻辑-Strategy"><a href="#6-6-创建和更新对象时的业务逻辑-Strategy" class="headerlink" title="6.6  创建和更新对象时的业务逻辑-Strategy"></a>6.6  创建和更新对象时的业务逻辑-Strategy</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/configmap/strategy.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> PrepareForCreate(ctx context.Context, obj runtime.Object) &#123;<br>_ = obj.(*api.ConfigMap)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> Validate(ctx context.Context, obj runtime.Object) field.ErrorList &#123;<br>cfg := obj.(*api.ConfigMap)<br><span class="hljs-keyword">return</span> validation.ValidateConfigMap(cfg)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> PrepareForUpdate(ctx context.Context, newObj, oldObj runtime.Object) &#123;<br>_ = oldObj.(*api.ConfigMap)<br>_ = newObj.(*api.ConfigMap)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-7-subresource"><a href="#6-7-subresource" class="headerlink" title="6.7 subresource"></a>6.7 subresource</h3><p>内嵌在kubernetes对象中，有独立的操作逻辑的属性集合，如podstatus</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">statusStore.UpdateStrategy = pod.StatusStrategy<br><span class="hljs-keyword">var</span> StatusStrategy = podStatusStrategy&#123;Strategy&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStatusStrategy)</span></span> PrepareForUpdate(ctx context.Context, obj, old runtime.Object)<br>&#123;<br>newPod := obj.(*api.Pod)<br>oldPod := old.(*api.Pod)<br>newPod.Spec = oldPod.Spec<br>newPod.DeletionTimestamp = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// don&#x27;t allow the pods/status endpoint to touch owner references since old kubelets corrupt them in a way</span><br><span class="hljs-comment">// that breaks garbage collection</span><br>newPod.OwnerReferences = oldPod.OwnerReferences<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-8-注册-APIGroup"><a href="#6-8-注册-APIGroup" class="headerlink" title="6.8 注册 APIGroup"></a>6.8 注册 APIGroup</h3><ol><li>定义 Storage：<code>configMapStorage := configmapstore.NewREST(restOptionsGetter)</code>。</li><li>定义对象的 StorageMap：<code>apiGroupInfo.VersionedResourcesStorageMap[&quot;v1&quot;] = restStorageMap</code>。</li><li>将对象注册至 APIServer（挂载 handler）：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err :=<br>m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix,<br>&amp;apiGroupInfo); err != <span class="hljs-literal">nil</span> &#123;<br>    klog.Fatalf(<span class="hljs-string">&quot;Error in registering group versions: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-9-代码生成"><a href="#6-9-代码生成" class="headerlink" title="6.9 代码生成"></a>6.9 代码生成</h3><p>Kubernetes 使用以下代码生成器：</p><ul><li><code>deepcopy-gen</code>：为对象生成 DeepCopy 方法。</li><li><code>client-gen</code>：创建 Clientset。</li><li><code>informer-gen</code>：创建 Informer 框架。</li><li><code>lister-gen</code>：创建 Lister 框架。</li><li><code>conversion-gen</code>：创建版本转换方法。</li></ul><p>代码生成器位于：<a href="https://github.com/kubernetes/code-generator">https://github.com/kubernetes/code-generator</a></p><p><code>hack/update-codegen.sh</code> 脚本用于生成代码。<br>命令示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;GOPATH&#125;</span>/bin/deepcopy-gen --input-dirs &#123;versioned-package-pach&#125; \<br>-O zz_generated.deepcopy \<br>--bounding-dirs &#123;output-package-path&#125; \<br>--go-header-file <span class="hljs-variable">$&#123;SCRIPT_ROOT&#125;</span>/hack/boilerplate.go.txt<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入探讨了 Kubernetes API Server 的内部机制，包括访问控制、限流策略和 APIServer 对象的实现。理解这些概念对于构建和管理 Kubernetes 集群至关重要。希望这篇博客能帮助你更好地理解 Kubernetes API Server 的工作原理。<br>apiserver 代码走读可以参考：<a href="https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d">https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes架构原则与对象设计</title>
    <link href="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>这篇文章解析了 Kubernetes 的对象设计。</p><span id="more"></span><h3 id="1-云计算的演变：从虚拟机到容器"><a href="#1-云计算的演变：从虚拟机到容器" class="headerlink" title="1. 云计算的演变：从虚拟机到容器"></a>1. 云计算的演变：从虚拟机到容器</h3><p>云计算，简单来说，就是把计算资源（比如CPU、内存、存储、网络）放到“云”上，大家按需使用，不用自己买服务器、搭机房。</p><p>云计算平台大致经历了两个阶段：</p><ul><li><p><strong>第一阶段：虚拟化平台 (以 OpenStack 为代表)</strong></p><ul><li>想象一下，你有一台大电脑，通过虚拟化技术，把它“切”成很多小电脑（虚拟机），每个小电脑可以独立运行不同的应用。</li><li><strong>优点：</strong> 资源利用率提高了，不用每部署一个应用就买一台服务器。</li><li><strong>缺点：</strong> 虚拟机的创建和业务代码的部署是分开的，每次部署应用都要先创建虚拟机，再安装各种依赖，比较麻烦。而且，虚拟机的底层环境（操作系统、各种库）可能不一样，维护起来比较头疼。</li></ul></li><li><p><strong>第二阶段：基于进程的作业调度平台 (以谷歌 Borg 为代表)</strong></p><ul><li>Borg 是谷歌内部使用的容器集群管理系统，它直接管理进程，而不是虚拟机。</li><li><strong>优点：</strong> 资源利用率更高，应用部署更快，故障恢复也更快。</li><li><strong>缺点：</strong> Borg 的设计比较复杂，有一些不太合理的地方，比如：<ul><li>对象之间的依赖关系太强，不够灵活。</li><li>所有容器共享 IP，容易导致端口冲突。</li><li>给超级用户添加了太多复杂逻辑，系统变得臃肿。</li></ul></li></ul></li></ul><h3 id="2-谷歌-Borg：Kubernetes-的灵感之源"><a href="#2-谷歌-Borg：Kubernetes-的灵感之源" class="headerlink" title="2. 谷歌 Borg：Kubernetes 的灵感之源"></a>2. 谷歌 Borg：Kubernetes 的灵感之源</h3><p>Borg 在谷歌内部发挥了巨大作用，支撑了 Gmail、Google Docs、Web Search 等众多核心业务。</p><h4 id="2-1-Borg-的核心特性"><a href="#2-1-Borg-的核心特性" class="headerlink" title="2.1 Borg 的核心特性"></a>2.1 Borg 的核心特性</h4><ul><li><strong>高资源利用率：</strong> 通过共享服务器，在进程级别进行隔离，充分利用硬件资源。</li><li><strong>高可用性：</strong> 应用故障时，可以快速恢复，保证服务不中断。</li><li><strong>灵活的调度：</strong> 可以根据不同的应用需求，灵活地分配资源。</li><li><strong>方便易用：</strong> 提供了完善的工具，方便用户部署、管理应用。</li></ul><h4 id="2-2-Borg-的基本概念"><a href="#2-2-Borg-的基本概念" class="headerlink" title="2.2 Borg 的基本概念"></a>2.2 Borg 的基本概念</h4><ul><li><strong>Workload（工作负载）：</strong> 分为两种：<ul><li><strong>prod：</strong> 在线任务，比如网站、邮件服务等，对延迟敏感，需要长期运行。</li><li><strong>non-prod：</strong> 离线任务，比如数据分析、批量计算等，可以容忍一定的延迟。</li></ul></li><li><strong>Cell（单元）：</strong> 一个 Cell 包含一个 Borg 集群管理系统，用户不需要关心应用具体跑在哪台机器上，Borg 会自动分配资源、处理故障。</li><li><strong>Job 和 Task：</strong><ul><li><strong>Job：</strong> 用户提交的应用部署请求，包含一个或多个相同的 Task。</li><li><strong>Task：</strong> 运行相同应用程序的副本，Task 的数量就是应用的副本数。</li></ul></li><li><strong>Naming（命名）：</strong> Borg 通过 BNS（Borg Name Service）实现服务发现。例如：<code>50.jfoo.ubar.cc.borg.google.com</code> 表示在名为 <code>cc</code> 的 Cell 中，由用户 <code>uBar</code> 部署的名为 <code>jFoo</code> 的 Job 下的第 50 个 Task。</li></ul><h4 id="2-3-Borg-的架构"><a href="#2-3-Borg-的架构" class="headerlink" title="2.3 Borg 的架构"></a>2.3 Borg 的架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235410146.png" class="" title="image-20250316235410146"><pre class="mermaid">graph LR    subgraph Borg        A[客户端] --> B(Borgmaster)        B --> C{Scheduler}        B --> D[Borglet]        D --> E[应用程序进程]    end</pre><ul><li><strong>Borgmaster：</strong><ul><li>处理客户端请求（创建 Job、查询 Job 等）。</li><li>维护系统组件和服务状态。</li><li>与 Borglet 通信。</li></ul></li><li><strong>Scheduler：</strong><ul><li>负责调度 Task 到合适的机器上。</li><li>采用多种优化策略，提高调度效率。</li></ul></li><li><strong>Borglet：</strong><ul><li>部署在每台服务器上的 Agent。</li><li>接收 Borgmaster 的指令，管理 Task。</li></ul></li></ul><h4 id="2-4-Borg-的高可用性"><a href="#2-4-Borg-的高可用性" class="headerlink" title="2.4 Borg 的高可用性"></a>2.4 Borg 的高可用性</h4><ul><li><strong>应用高可用：</strong><ul><li>多副本部署，跨故障域（不同机器、机架、电源等）。</li><li>控制节点故障时的任务调度速率，避免网络分区误判。</li><li>记录详细信息，方便故障排查。</li><li><strong>关键原则：</strong> 即使 Borgmaster 或 Borglet 挂掉，也不能杀掉正在运行的服务。</li></ul></li><li><strong>Borg 系统自身高可用：</strong><ul><li>Borgmaster 多副本设计。</li><li>使用简单工具部署 Borg，避免过多外部依赖。</li><li>每个 Cell 的 Borg 独立部署，避免相互影响。</li></ul></li></ul><h4 id="2-5-Borg-的资源利用率"><a href="#2-5-Borg-的资源利用率" class="headerlink" title="2.5 Borg 的资源利用率"></a>2.5 Borg 的资源利用率</h4><ul><li><strong>混部：</strong> 在线任务（prod）和离线任务（non-prod）混合部署，充分利用资源。<ul><li>空闲时，离线任务可以使用更多资源。</li><li>繁忙时，在线任务优先执行。</li></ul></li><li><strong>效果：</strong><ul><li>98% 的服务器实现了混部。</li><li>90% 的服务器运行了超过 25 个 Task 和 4500 个线程。</li><li>相比独立部署，混合部署可以节省 20%-30% 的服务器。</li></ul></li></ul><h4 id="2-6-Borg-的调度原理"><a href="#2-6-Borg-的调度原理" class="headerlink" title="2.6 Borg 的调度原理"></a>2.6 Borg 的调度原理</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235416843.png" class="" title="image-20250316235416843"><pre class="mermaid">graph LR    A[machine] --> B(task)    B --> C[实际使用资源]    B --> D[保留资源]    B --> E[回收资源]    B --> F[限制资源]</pre><ul><li><strong>资源回收：</strong> 在 task 启动一段时间后，进行资源回收，将保留资源设置为实际使用资源加上一定的安全余量，并定期重新计算。</li></ul><h4 id="2-7-Borg-的隔离性"><a href="#2-7-Borg-的隔离性" class="headerlink" title="2.7 Borg 的隔离性"></a>2.7 Borg 的隔离性</h4><ul><li><strong>安全性隔离：</strong> 早期采用 Chroot jail，后期基于 Namespace。</li><li><strong>性能隔离：</strong> 采用基于 Cgroup 的容器技术。<ul><li>在线任务优先级高，离线任务优先级低。</li><li>通过抢占式调度，优先保障在线任务性能。</li><li>资源分为可压榨（如 CPU）和不可压榨（如内存）两种。</li></ul></li></ul><h3 id="3-Kubernetes：Borg-的开源版本"><a href="#3-Kubernetes：Borg-的开源版本" class="headerlink" title="3. Kubernetes：Borg 的开源版本"></a>3. Kubernetes：Borg 的开源版本</h3><p>Kubernetes（K8s）是谷歌开源的容器集群管理系统，是 Borg 的开源版本。</p><h4 id="3-1-K8s-的主要功能"><a href="#3-1-K8s-的主要功能" class="headerlink" title="3.1 K8s 的主要功能"></a>3.1 K8s 的主要功能</h4><ul><li>基于容器的应用部署、维护和滚动升级。</li><li>负载均衡和服务发现。</li><li>跨机器和跨地区的集群调度。</li><li>自动伸缩。</li><li>无状态服务和有状态服务。</li><li>插件机制保证扩展性。</li></ul><h4 id="3-2-命令式-vs-声明式"><a href="#3-2-命令式-vs-声明式" class="headerlink" title="3.2 命令式 vs 声明式"></a>3.2 命令式 vs 声明式</h4><ul><li><strong>命令式系统：</strong> 关注“如何做”，需要明确告诉系统每一步做什么。</li><li><strong>声明式系统：</strong> 关注“做什么”，只需要告诉系统你想要什么，系统会自动完成。</li></ul><p>Kubernetes 是一个声明式系统，具有以下特点：</p><ul><li><strong>声明式规范：</strong><ul><li>直接声明：直接告诉系统你的需求。</li><li>间接声明：把需求放在特定地方，系统会自动处理。</li></ul></li><li><strong>幂等性：</strong> 状态固定，每次操作返回相同结果。</li><li><strong>面向对象：</strong> 把一切抽象成对象。</li></ul><h4 id="3-3-Kubernetes-的核心对象"><a href="#3-3-Kubernetes-的核心对象" class="headerlink" title="3.3 Kubernetes 的核心对象"></a>3.3 Kubernetes 的核心对象</h4><ul><li><strong>Node：</strong> 计算节点的抽象。</li><li><strong>Namespace：</strong> 资源隔离的基本单位。</li><li><strong>Pod：</strong> 应用实例的抽象，包含镜像地址、资源需求等，是 K8s 最核心的对象。</li><li><strong>Service：</strong> 将应用发布成服务，本质上是负载均衡和域名服务的声明。</li></ul><h4 id="3-4-Kubernetes-的架构"><a href="#3-4-Kubernetes-的架构" class="headerlink" title="3.4 Kubernetes 的架构"></a>3.4 Kubernetes 的架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/kubernetes-cluster-architecture-2265122.svg" class="" title="image-20250316235421656"><ul><li><strong>Master Node（主节点）：</strong><ul><li><strong>API Server：</strong> 暴露 Kubernetes API，是集群的入口。</li><li><strong>Cluster Data Store (etcd)：</strong> 存储集群所有数据。</li><li><strong>Controller Manager：</strong> 运行各种控制器，确保集群状态与期望状态一致。</li><li><strong>Scheduler：</strong> 负责将 Pod 调度到合适的节点。</li></ul></li><li><strong>Worker Node（工作节点）：</strong><ul><li><strong>Kubelet：</strong> 管理 Pod 的生命周期，向 Master 节点汇报状态。</li><li><strong>Kube-proxy：</strong> 负责网络，维护网络规则，执行连接转发。</li><li><strong>Container Runtime：</strong> 负责运行容器（如 Docker）。</li></ul></li></ul><h4 id="3-5-Kubernetes-的其他组件"><a href="#3-5-Kubernetes-的其他组件" class="headerlink" title="3.5 Kubernetes 的其他组件"></a>3.5 Kubernetes 的其他组件</h4><ul><li><strong>etcd：</strong> 分布式 key-value 存储，用于服务发现、共享配置和一致性保障。</li><li><strong>APIServer：</strong> 提供集群管理的 REST API 接口，包括认证、授权、准入控制等。</li><li><strong>Controller Manager：</strong> 确保集群的真实状态与用户定义的期望状态一致。</li><li><strong>Scheduler：</strong> 监控未调度的 Pod，选择最佳节点进行调度。</li><li><strong>Kubelet：</strong> 从不同源获取 Pod 清单，并按需求启停 Pod。</li><li><strong>Kube-Proxy：</strong> 监控集群中用户发布的服务，并完成负载均衡配置。</li></ul><h4 id="3-6-Kubernetes-的常用-Add-ons"><a href="#3-6-Kubernetes-的常用-Add-ons" class="headerlink" title="3.6 Kubernetes 的常用 Add-ons"></a>3.6 Kubernetes 的常用 Add-ons</h4><ul><li><strong>kube-dns：</strong> 提供 DNS 服务。</li><li><strong>Ingress Controller：</strong> 提供外网入口。</li><li><strong>Metrics Server：</strong> 提供资源监控。</li><li><strong>Dashboard：</strong> 提供 GUI。</li><li><strong>Fluentd-Elasticsearch：</strong> 提供日志采集、存储与查询。</li></ul><h4 id="3-7-kubectl：Kubernetes-的命令行工具"><a href="#3-7-kubectl：Kubernetes-的命令行工具" class="headerlink" title="3.7 kubectl：Kubernetes 的命令行工具"></a>3.7 kubectl：Kubernetes 的命令行工具</h4><ul><li><strong>kubectl：</strong> 允许用户以命令行的方式与 Kubernetes 交互。</li><li><strong>kubeconfig：</strong> 配置文件，包含 apiserver 地址、用户信息等。</li><li><strong>常用命令：</strong><ul><li><code>kubectl get po -oyaml -w</code>：查看对象，输出 yaml 格式，并 watch 变化。</li><li><code>kubectl describe po &lt;pod_name&gt;</code>：展示资源的详细信息和相关 Event。</li><li><code>kubectl exec -it &lt;pod_name&gt; bash</code>：进入运行的容器。</li><li><code>kubectl logs &lt;pod_name&gt;</code>：查看 pod 的标准输出。</li></ul></li></ul><h3 id="4-深入理解-Kubernetes"><a href="#4-深入理解-Kubernetes" class="headerlink" title="4. 深入理解 Kubernetes"></a>4. 深入理解 Kubernetes</h3><h4 id="4-1-云计算的传统分类"><a href="#4-1-云计算的传统分类" class="headerlink" title="4.1 云计算的传统分类"></a>4.1 云计算的传统分类</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235428142.png" class="" title="image-20250316235428142"><ul><li><strong>IaaS (Infrastructure as a Service)：</strong> 提供基础设施，如虚拟机、存储、网络。</li><li><strong>PaaS (Platform as a Service)：</strong> 提供平台，如操作系统、运行时环境、数据库。</li><li><strong>SaaS (Software as a Service)：</strong> 提供软件，如邮件服务、CRM 系统。</li></ul><h4 id="4-2-Kubernetes-生态系统"><a href="#4-2-Kubernetes-生态系统" class="headerlink" title="4.2 Kubernetes 生态系统"></a>4.2 Kubernetes 生态系统</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235435441.png" class="" title="image-20250316235435441"><h4 id="4-3-Kubernetes-设计理念"><a href="#4-3-Kubernetes-设计理念" class="headerlink" title="4.3 Kubernetes 设计理念"></a>4.3 Kubernetes 设计理念</h4><ul><li><strong>可扩展性：</strong> 基于 CRD 的扩展，插件化的生态系统。</li><li><strong>高可用：</strong> 基于 replicaset、statefulset 的应用高可用，Kubernetes 组件本身高可用。</li><li><strong>可移植性：</strong> 多种 host OS 选择，多种基础架构的选择，多云和混合云。</li><li><strong>安全：</strong> 基于 TLS 提供服务，Serviceaccount 和 user，基于 Namespace 的隔离，secret，Taints，psp，networkpolicy。</li></ul><h4 id="4-4-Kubernetes-分层架构"><a href="#4-4-Kubernetes-分层架构" class="headerlink" title="4.4 Kubernetes 分层架构"></a>4.4 Kubernetes 分层架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235445064.png" class="" title="image-20250316235445064"><ul><li><strong>核心层：</strong> 提供 API 构建高层应用，提供插件式应用执行环境。</li><li><strong>应用层：</strong> 部署和路由。</li><li><strong>管理层：</strong> 系统度量、自动化、策略管理。</li><li><strong>接口层：</strong> kubectl 命令行工具、客户端 SDK 以及集群联邦。</li><li><strong>生态系统：</strong><ul><li>Kubernetes 外部：日志、监控、配置管理、CI&#x2F;CD 等。</li><li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider 等。</li></ul></li></ul><h4 id="4-5-API-设计原则"><a href="#4-5-API-设计原则" class="headerlink" title="4.5 API 设计原则"></a>4.5 API 设计原则</h4><ul><li>所有 API 都应是声明式的。</li><li>API 对象是彼此互补而且可组合的。</li><li>高层 API 以操作意图为基础设计。</li><li>低层 API 根据高层 API 的控制需要设计。</li><li>尽量避免简单封装。</li><li>API 操作复杂度与对象数量成正比。</li><li>API 对象状态不能依赖于网络连接状态。</li><li>尽量避免让操作机制依赖于全局状态。</li></ul><h4 id="4-6-Kubernetes-对象的组合"><a href="#4-6-Kubernetes-对象的组合" class="headerlink" title="4.6 Kubernetes 对象的组合"></a>4.6 Kubernetes 对象的组合</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235450125.png" class="" title="image-20250316235450125"><pre class="mermaid">graph LR    A[Deployment] --> B(滚动升级策略)    A --> C(副本数)    A --> D[PodTemplate]    D --> E[Replicaset]    E --> F(版本信息)    E --> G(副本数)    E --> H[PodTemplate]    H --> I[Node]    H --> J[Pod]    H --> K[Service]    H --> L[Ingress]    I --> M(计算资源)    I --> N(健康状况)    J --> O(镜像地址)    J --> P(资源需求)    K --> Q(服务协议)    K --> R(服务端口)    L --> S(域名)    L --> T(访问 URL)    L --> U(目标服务)</pre><h4 id="4-7-架构设计原则"><a href="#4-7-架构设计原则" class="headerlink" title="4.7 架构设计原则"></a>4.7 架构设计原则</h4><ul><li>只有 APIServer 可以直接访问 etcd 存储。</li><li>单节点故障不应该影响集群的状态。</li><li>所有组件应该在内存中保持所需要的状态。</li><li>优先使用事件监听而不是轮询。</li></ul><h4 id="4-8-引导（Bootstrapping）原则"><a href="#4-8-引导（Bootstrapping）原则" class="headerlink" title="4.8 引导（Bootstrapping）原则"></a>4.8 引导（Bootstrapping）原则</h4><ul><li>Self-hosting 是目标。</li><li>减少依赖。</li><li>通过分层的原则管理依赖。</li><li>循环依赖问题的原则：<ul><li>接受其他方式的数据输入。</li><li>状态应该是可恢复或可重新发现的。</li><li>支持简单的启动临时实例来创建稳态运行所需要的状态。</li><li>自动重启异常退出的服务。</li></ul></li></ul><h4 id="4-9-核心技术概念和-API-对象"><a href="#4-9-核心技术概念和-API-对象" class="headerlink" title="4.9 核心技术概念和 API 对象"></a>4.9 核心技术概念和 API 对象</h4><ul><li><strong>API 对象：</strong> Kubernetes 集群中的管理操作单元。</li><li><strong>四大类属性：</strong><ul><li><strong>TypeMeta：</strong> 对象的类型定义（GKV 模型）。<ul><li>Group：对象的分组。</li><li>Kind：对象的基本类型。</li><li>Version：对象的版本。</li></ul></li><li><strong>MetaData：</strong> 对象的元数据。<ul><li>Namespace：对象的命名空间。</li><li>Name：对象的名称。</li><li>Label：对象的标签，用于识别和选择对象。</li><li>Annotation：对象的注解，用于记录附加信息。</li><li>Finalizer：资源锁，用于控制对象的删除。</li><li>ResourceVersion：乐观锁，用于并发访问对象。</li></ul></li><li><strong>Spec：</strong> 用户的期望状态。</li><li><strong>Status：</strong> 对象的实际状态。</li></ul></li></ul><h4 id="4-10-常用-Kubernetes-对象及其分组"><a href="#4-10-常用-Kubernetes-对象及其分组" class="headerlink" title="4.10 常用 Kubernetes 对象及其分组"></a>4.10 常用 Kubernetes 对象及其分组</h4><ul><li><strong>Node：</strong> Pod 运行的主机。</li><li><strong>Namespace：</strong> 资源和对象的抽象集合。</li><li><strong>Pod：</strong> 一组紧密关联的容器集合，共享 PID、IPC、Network 和 UTS namespace。<ul><li><strong>环境变量：</strong> 设置容器的环境变量。</li><li><strong>存储卷：</strong> 将外挂存储挂载到 Pod 内部。</li><li><strong>Pod 网络：</strong> 多个容器共享网络 Namespace。</li><li><strong>资源限制：</strong> 限制每个容器的 CPU 和内存使用。</li><li><strong>健康检查：</strong> 探测应用是否健康和就绪。</li></ul></li><li><strong>ConfigMap：</strong> 保存非机密性的数据到键值对中。</li><li><strong>Secret：</strong> 保存和传递密码、密钥、认证凭证等敏感信息。</li><li><strong>User Account &amp; Service Account：</strong><ul><li>User Account：为人提供账户标识。</li><li>Service Account：为计算机进程和 Pod 提供账户标识。</li></ul></li><li><strong>Service：</strong> 应用服务的抽象，通过 labels 提供负载均衡和服务发现。</li><li><strong>Replica Set：</strong> 定义 Pod 的副本数，保证指定数量的 Pod 正常运行。</li><li><strong>Deployment：</strong> 表示用户对 Kubernetes 集群的一次更新操作。</li><li><strong>StatefulSet：</strong> 用于管理有状态应用，每个 Pod 挂载自己独立的存储。</li><li><strong>Job：</strong> 控制批处理型任务。</li><li><strong>DaemonSet：</strong> 保证每个节点上都有一个 Pod 运行。</li><li><strong>PersistentVolume (PV) &amp; PersistentVolumeClaim (PVC)：</strong><ul><li>PV：集群中的一块存储卷。</li><li>PVC：用户对存储的请求。</li></ul></li><li><strong>CustomResourceDefinition (CRD)：</strong> 允许用户自定义对象。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言进阶</title>
    <link href="/2025/03/16/golang%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/03/16/golang%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>这篇博客将深入探讨 Go 语言的一些核心概念，包括并发编程中的线程加锁和调度、内存管理机制，以及依赖管理。这些概念是构建高性能、可扩展的 Go 应用程序的基础。</p><span id="more"></span><h3 id="1-线程加锁"><a href="#1-线程加锁" class="headerlink" title="1. 线程加锁"></a>1. 线程加锁</h3><p>在并发编程中，多个 goroutine（Go 语言的轻量级线程）可能会同时访问和修改共享资源。为了防止数据竞争和不一致，我们需要使用锁机制来协调对共享资源的访问。</p><p><strong>Go 语言的锁机制</strong></p><p>Go 语言不仅提供了基于 CSP（Communicating Sequential Processes）的通道（channel）通信模型，还支持基于共享内存的多线程数据访问。<code>sync</code> 包提供了多种锁原语，以满足不同的并发场景需求：</p><ul><li><strong><code>sync.Mutex</code>（互斥锁）</strong>:<ul><li>最基本的锁类型，用于保护临界区，确保同一时间只有一个 goroutine 可以访问共享资源。</li><li>使用 <code>Lock()</code> 方法加锁，<code>Unlock()</code> 方法解锁。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    counter <span class="hljs-type">int</span><br>    mutex   sync.Mutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock() <span class="hljs-comment">// 加锁</span><br>    counter++<br>    mutex.Unlock() <span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.RWMutex</code>（读写锁）</strong>:<ul><li>适用于读多写少的场景。</li><li>允许多个 goroutine 同时读取共享资源，但在写入时会阻塞所有其他 goroutine（包括读取和写入）。</li><li>使用 <code>RLock()</code> 和 <code>RUnlock()</code> 方法进行读锁定，<code>Lock()</code> 和 <code>Unlock()</code> 方法进行写锁定。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    data    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    rwMutex sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readData</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    rwMutex.RLock() <span class="hljs-comment">// 读锁定</span><br>    <span class="hljs-keyword">defer</span> rwMutex.RUnlock()<br>    <span class="hljs-keyword">return</span> data[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeData</span><span class="hljs-params">(key, value <span class="hljs-type">string</span>)</span></span> &#123;<br>    rwMutex.Lock() <span class="hljs-comment">// 写锁定</span><br>    <span class="hljs-keyword">defer</span> rwMutex.Unlock()<br>    data[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.WaitGroup</code></strong>:<ul><li>用于等待一组 goroutine 完成。</li><li><code>Add(n)</code> 方法增加等待的 goroutine 数量，<code>Done()</code> 方法表示一个 goroutine 完成，<code>Wait()</code> 方法阻塞直到所有 goroutine 完成。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 表示当前 goroutine 完成</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d starting\n&quot;</span>, id)<br>    <span class="hljs-comment">// 执行任务...</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d done\n&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 增加等待的 goroutine 数量</span><br>        <span class="hljs-keyword">go</span> worker(i, &amp;wg)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 阻塞，直到所有 goroutine 完成</span><br>    fmt.Println(<span class="hljs-string">&quot;All workers done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.Once</code></strong>:<ul><li>确保某个函数只执行一次，常用于单例模式的初始化。</li><li><code>Do(f)</code> 方法接收一个函数 <code>f</code> 作为参数，并保证 <code>f</code> 只会被调用一次。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    once     sync.Once<br>    instance *MySingleton<br>)<br><br><span class="hljs-keyword">type</span> MySingleton <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *MySingleton &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 保证只执行一次</span><br>        instance = &amp;MySingleton&#123;&#125;<br>        <span class="hljs-comment">// 初始化 instance...</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.Cond</code>（条件变量）</strong>:<ul><li>用于协调多个 goroutine 在满足特定条件时等待或被唤醒。</li><li><code>Wait()</code> 方法阻塞当前 goroutine，直到其他 goroutine 调用 <code>Signal()</code> 或 <code>Broadcast()</code> 方法唤醒。</li><li><code>Signal()</code> 方法唤醒一个等待的 goroutine，<code>Broadcast()</code> 方法唤醒所有等待的 goroutine。</li><li>通常与互斥锁一起使用，以保护条件。</li><li>下面是 Kubernetes 中使用的 <code>sync.Cond</code> 示例：</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>cond sync.Cond<br><span class="hljs-comment">// ... 其他字段</span><br>&#125;<br><br><span class="hljs-comment">// Add marks item as needing processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span></span> Add(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>q.cond.L.Lock()<br><span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><span class="hljs-comment">// ... 添加 item 到队列的逻辑 ...</span><br>q.cond.Signal() <span class="hljs-comment">// 唤醒一个等待的 goroutine</span><br>&#125;<br><br><span class="hljs-comment">// Get blocks until it can return an item to be processed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span></span> Get() (item <span class="hljs-keyword">interface</span>&#123;&#125;, shutdown <span class="hljs-type">bool</span>) &#123;<br>q.cond.L.Lock()<br><span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.queue) == <span class="hljs-number">0</span> &amp;&amp; !q.shuttingDown &#123;<br>q.cond.Wait() <span class="hljs-comment">// 等待条件满足（队列中有元素）</span><br>&#125;<br><span class="hljs-comment">// ... 从队列中取出 item 的逻辑 ...</span><br><span class="hljs-keyword">return</span> item, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码示例：Kubernetes 中的锁应用</strong></p><ul><li><strong><code>sharedInformerFactory</code> 中的 <code>sync.Mutex</code></strong>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// Start initializes all requested informers.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    f.lock.Lock() <span class="hljs-comment">// 加锁</span><br>    <span class="hljs-keyword">defer</span> f.lock.Unlock() <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br>        <span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<br>            <span class="hljs-keyword">go</span> informer.Run(stopCh)<br>            f.startedInformers[informerType] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了 Kubernetes 的 <code>sharedInformerFactory</code> 如何使用互斥锁来保护 <code>informers</code> 和 <code>startedInformers</code> 字段，确保在启动 informer 时不会发生并发冲突。</p><ul><li><strong><code>PodClient</code> 中的 <code>sync.WaitGroup</code></strong>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// CreateBatch create a batch of pods. All pods are created before</span><br><span class="hljs-comment">// waiting.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;<br>    ps := <span class="hljs-built_in">make</span>([]*v1.Pod, <span class="hljs-built_in">len</span>(pods))<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 增加等待的 goroutine 数量</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, pod *v1.Pod)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 表示当前 goroutine 完成</span><br>            <span class="hljs-keyword">defer</span> GinkgoRecover()<br>            ps[i] = c.CreateSync(pod)<br>        &#125;(i, pod)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 阻塞，直到所有 goroutine 完成</span><br>    <span class="hljs-keyword">return</span> ps<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了 Kubernetes 的 <code>PodClient</code> 如何使用 <code>sync.WaitGroup</code> 来并发创建多个 Pod，并在所有 Pod 创建完成后返回结果。</p><h3 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a>2. 线程调度</h3><p>在操作系统层面，线程是调度的基本单位。理解线程调度对于理解 Go 语言的 goroutine 调度至关重要。</p><p><strong>进程与线程</strong></p><ul><li><strong>进程</strong>: 资源分配的基本单位。每个进程都有独立的内存空间、文件句柄、信号处理等。</li><li><strong>线程</strong>: 调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源（如内存空间），但有各自的栈和寄存器。</li></ul><p>在 Linux 中，无论是进程还是线程，都由 <code>task_struct</code> 结构体表示。从内核的角度来看，进程和线程没有本质区别。Glibc 提供的 <code>pthread</code> 库实现了 NPTL（Native POSIX Threading Library），为用户空间提供了线程支持。</p><p><strong>Linux 进程的内存模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235836393.png" class="" title="image-20250316235836393"><pre class="mermaid">graph LR    subgraph 虚拟地址空间        A[内核空间] --> B(参数环境变量)        B --> C[栈 Stack]        C --> D[未分配内存]        D --> E[堆 Heap]        E --> F[未初始化数据 BSS]        F --> G[已初始化数据 Data]        G --> H[程序代码 Text]    end      subgraph 物理内存        I[物理内存]    end    subgraph 磁盘        J[磁盘_虚拟内存]    end      H --> PGD    PGD --> PUD    PUD --> PMD    PMD --> PT    PT --> I    I -- 换出/换入 --> J      A -.->|用户空间不可见| I    style D fill:#f9f,stroke:#333,stroke-width:2px</pre><ul><li><strong>内核空间</strong>: 存放内核代码和数据，用户程序不能直接访问。</li><li><strong>栈 (Stack)</strong>: 存储局部变量、函数参数、返回值等。栈的大小是有限的，由操作系统或编译器决定。</li><li><strong>堆 (Heap)</strong>: 动态分配的内存区域，用于存储程序运行时创建的对象。</li><li><strong>BSS 段</strong>: 存储未初始化的全局变量和静态变量。</li><li><strong>数据段 (Data)</strong>: 存储已初始化的全局变量和静态变量。</li><li><strong>代码段 (Text)</strong>: 存储程序的机器指令。</li></ul><p><strong>CPU 对内存的访问</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235840260.png" class="" title="image-20250316235840260"><pre class="mermaid">graph LR    A[CPU] --> B(MMU)    B --> C{TLB}    C -- 命中 --> F[总线]    C -- 未命中 --> D[页表 PGD/PUD/PMD/PT]    D --> F    F --> E[物理内存]</pre><ol><li>CPU 发出虚拟地址。</li><li>MMU（Memory Management Unit）首先在 TLB（Translation Lookaside Buffer）中查找虚拟地址对应的物理地址。</li><li>如果 TLB 命中，则直接从 TLB 中获取物理地址。</li><li>如果 TLB 未命中，则 MMU 需要查询页表（PGD、PUD、PMD、PT）来获取物理地址，并将映射关系缓存到 TLB 中。</li><li>CPU 使用物理地址访问内存。</li></ol><p><strong>进程切换开销</strong></p><p>进程切换的开销主要包括：</p><ul><li><strong>直接开销</strong>:<ul><li>切换页表全局目录（PGD）。</li><li>切换内核态堆栈。</li><li>切换硬件上下文（寄存器等）。</li><li>刷新 TLB。</li><li>执行系统调度器的代码。</li></ul></li><li><strong>间接开销</strong>:<ul><li>CPU 缓存失效，导致访问内存的次数增加。</li></ul></li></ul><p><strong>线程切换开销</strong></p><p>线程切换比进程切换开销小，因为同一进程内的线程共享虚拟地址空间，不需要切换页表。但线程切换仍然需要内核参与，进行上下文切换。</p><p><strong>用户线程 vs. 内核线程</strong></p><ul><li><strong>用户线程</strong>: 在用户空间创建和管理，无需内核支持。创建和销毁速度快，但不能利用多核 CPU。</li><li><strong>内核线程</strong>: 由内核创建和管理，可以利用多核 CPU，但创建和销毁开销较大。</li></ul><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235844279.png" class="" title="image-20250316235844279"><pre class="mermaid">graph LR    subgraph 用户态        A[Process] --> B[User Thread]        A --> C[User Thread]        D[Process] --> E[User Thread]        D --> F[User Thread]        G[Process] --> H[User Thread]        G --> I[User Thread]    end    subgraph 内核态        B --> J[Kernel Thread]        C --> J        E --> K[Kernel Thread]        F --> K        H --> L[Kernel Thread]        I --> L    end    J --> M[CPU]    K --> M    L --> M</pre><p><strong>Goroutine</strong></p><p>Go 语言通过 GMP 模型实现了用户态线程（goroutine）：</p><ul><li><strong>G (Goroutine)</strong>: 代表一个 goroutine，拥有自己的栈空间、定时器等。初始栈大小为 2KB，可按需增长。</li><li><strong>M (Machine)</strong>: 代表内核线程，负责执行 goroutine。M 会保存 goroutine 的栈信息，以便在调度时恢复执行。</li><li><strong>P (Processor)</strong>: 代表逻辑处理器，负责调度 goroutine。P 维护一个本地 goroutine 队列，M 从 P 获取 goroutine 并执行。P 还负责部分内存管理。</li></ul><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235849700.png" class="" title="image-20250316235849700"><pre class="mermaid">graph LR    subgraph 全局资源        A(GRQ - 全局可运行G队列)        B(sudog - 阻塞队列)        C(gFree - 全局自由G列表)        D(pidle - 全局空闲P列表)    end    subgraph P的本地资源        E(LRQ - 本地可运行G队列)        F(gFree - 本地自由G列表)    end    A -- G --> E    B -- G --> M    C -- G --> C      D -- P --> D      E -- G --> M    F -- G --> F    M --> P    P --> CPU    G1(G - Grunnable) -- 状态 --> G2(G - Grunning)    G2 -- 状态 --> G3(G - Gwaiting)    G2 -- 状态 --> G4(G - Gsyscall)    G3 -- 状态 --> G1    G4 -- 状态 --> G1    G2 -- 状态 --> G5(G - Gdead)    G5 -- 状态 --> F    P1(P - Pidle) -- 状态 --> P2(P - Prunning)    P2 -- 状态 --> P3(P - Psyscall)    P3 -- 状态 --> P1</pre><p><strong>Goroutine 的创建过程</strong></p><ol><li>获取或创建新的 Goroutine 结构体：<ul><li>尝试从 P 的 <code>gFree</code> 列表中获取空闲的 Goroutine。</li><li>如果 <code>gFree</code> 列表为空，则通过 <code>runtime.malg</code> 创建一个新的 Goroutine 结构体。</li></ul></li><li>将函数参数复制到 Goroutine 的栈上。</li><li>更新 Goroutine 的调度信息，将其状态设置为 <code>_Grunnable</code>。</li><li>将 Goroutine 存储到全局变量 <code>allgs</code> 中。</li><li>将 Goroutine 放入运行队列：<ul><li>优先放入 P 的 <code>runnext</code> 字段，作为下一个要执行的 Goroutine。</li><li>如果 P 的本地运行队列已满，则将一部分 Goroutine 和待加入的 Goroutine 放入全局运行队列。</li></ul></li></ol><p><strong>调度器行为</strong></p><ol><li><strong>公平性</strong>: 如果全局运行队列中有待执行的 Goroutine，调度器会以一定概率从全局队列中选择 Goroutine 执行。</li><li><strong>本地队列</strong>: 调度器优先从 P 的本地运行队列中选择 Goroutine 执行。</li><li><strong>阻塞查找</strong>: 如果本地队列和全局队列都为空，调度器会通过 <code>runtime.findrunnable</code> 函数阻塞地查找可运行的 Goroutine：<ul><li>从本地队列、全局队列、网络轮询器中查找。</li><li>尝试从其他 P 的本地队列中窃取 Goroutine。</li></ul></li></ol><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><p>内存管理是程序设计中的关键问题。手动管理内存容易出错，而自动管理内存（垃圾回收）可能会影响性能。Go 语言采用了自动垃圾回收机制，并对内存管理进行了优化。</p><p><strong>堆内存管理</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235855215.png" class="" title="image-20250316235855215"><pre class="mermaid">graph LR    A{Mutator} --> B{Allocator}    B --> C{Heap}    C --> D{Object Header}    C --> E{Collector}    B --> E    style C fill:#ccf,stroke:#333,stroke-width:2px</pre><ul><li><strong>Mutator</strong>: 用户程序，通过 Allocator 申请内存。</li><li><strong>Allocator</strong>: 内存分配器，负责从堆中分配内存块。</li><li><strong>Heap</strong>: 堆，一块连续的内存区域，用于动态分配。</li><li><strong>Object Header</strong>: 对象头，存储对象的元数据（大小、是否被使用、下一个对象的地址等）。</li><li><strong>Collector</strong>: 垃圾回收器，负责回收不再使用的内存。</li></ul><p><strong>TCMalloc</strong></p><p>Go 语言的内存分配器借鉴了 TCMalloc（Thread-Caching Malloc）的思想。</p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235905932.png" class="" title="image-20250316235905932"><pre class="mermaid">graph LR    subgraph        A["Virtual Memory"]    end    subgraph "PageHeap"        B["PageHeap"] --> C["Span list 1 (1 page)"]        B --> D["Span list 2 (2 pages)"]        B --> E["... (3-127 pages)"]        B --> F["Span list 128 (128 pages = 1MB)"]        B --> G["Large span set (Large and medium object)"]    end      subgraph "CentralCache"      H["CentralCache"] --> I["Size class 0"]      H --> J["Size class 1"]      H --> K["..."]      H --> L["Size class n"]      I --> C      J --> D      L --> F    end    subgraph "ThreadCache"        M["ThreadCache 1"] --> N["Size class 0"]        M --> O["Size class 1"]        M --> P["..."]        M --> Q["Size class n"]        N --> FreeObject["(Free Object)"]    end      subgraph "ThreadCache"      R["ThreadCache 2"]    end    subgraph "ThreadCache"        S["ThreadCache n"]    end      M --> H    R --> H    S --> H    T["Application"] --> M    T --> R    T --> S</pre><ul><li><strong>page</strong>: 内存页，8KB 大小的内存块。Go 语言与操作系统之间的内存申请和释放都以 page 为单位。</li><li><strong>span</strong>: 内存块，由一个或多个连续的 page 组成。</li><li><strong>sizeclass</strong>: 空间规格，每个 span 都有一个 sizeclass，表示 span 中的 page 应该如何使用。</li><li><strong>object</strong>: 对象，用于存储变量数据的内存空间。一个 span 在初始化时会被分割成多个等大小的 object。</li></ul><p><strong>对象大小</strong></p><ul><li><strong>小对象</strong>: 0 ~ 256KB</li><li><strong>中对象</strong>: 256KB ~ 1MB</li><li><strong>大对象</strong>: &gt; 1MB</li></ul><p><strong>分配流程</strong></p><ul><li><strong>小对象</strong>: ThreadCache -&gt; CentralCache -&gt; HeapPage。通常情况下，ThreadCache 足够满足小对象的分配需求，无需访问 CentralCache 和 HeapPage。</li><li><strong>中对象</strong>: 直接从 PageHeap 中选择合适大小的 span。</li><li><strong>大对象</strong>: 从 large span set 中选择合适数量的 page 组成 span。</li></ul><p><strong>Go 语言内存分配</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235913087.png" class="" title="image-20250316235913087"><pre class="mermaid">graph LR    subgraph 虚拟内存        A[Virtual Memory]    end      subgraph arenas        B[arenas] --> C[heapArena]        B --> D[heapArena]        B --> E[...]        C --> F[span class 133]        C --> G[span class 134]        D --> H[span class 134]    end    subgraph mheap        I[mheap] --> J[free]        I --> K[scav]        I --> L[mcentral]        I --> B        L --> M[span class 0]        L --> N[span class 1]        L --> O[...]        M --> P[Span]        P --> Q[Pages]    end      subgraph mcache        R[mcache of P1] --> S[span class 0]        R --> T[span class 1]        R --> U[...]        S --> V[Free Object]    end    subgraph mcache        W[mcache of P2]    end    subgraph mcache        X[mcache of P3]    end      R --> L    W --> L    X --> L      Y[Application] --> R    Y --> W    Y --> X    Y --> LargeObject[(Large and medium object)]    Y --> TinyObject[(Tiny object)]    LargeObject --> B</pre><ul><li><strong><code>mcache</code></strong>: 小对象的内存分配直接从 <code>mcache</code> 获取。<code>mcache</code> 包含多个 size class（1 到 66），每个 class 有两个 span。span 大小为 8KB，根据 size class 的大小进行切分。</li><li><strong><code>mcentral</code></strong>: 当 <code>mcache</code> 中的 span 没有剩余空间时，会向 <code>mcentral</code> 申请一个 span。<code>mcentral</code> 如果没有符合条件的 span，则会向 <code>mheap</code> 申请。</li><li><strong><code>mheap</code></strong>: 当 <code>mheap</code> 没有足够的内存时，会向操作系统申请内存。<code>mheap</code> 将 span 组织成树结构，并分配到 <code>heapArena</code> 进行管理。<code>heapArena</code> 包含地址映射和 span 是否包含指针等位图信息。</li></ul><p><strong>内存回收</strong></p><p>常见的垃圾回收算法包括：</p><ul><li><strong>引用计数</strong>: 为每个对象维护一个引用计数，当引用计数为 0 时回收对象。<ul><li>优点：对象可以很快被回收。</li><li>缺点：无法处理循环引用，维护引用计数有开销。</li></ul></li><li><strong>标记-清除</strong>: 从根对象开始遍历所有可达对象，标记为“被引用”，未被标记的对象被回收。<ul><li>优点：可以处理循环引用。</li><li>缺点：需要 STW（Stop The World），暂停程序运行。</li></ul></li><li><strong>分代收集</strong>: 根据对象的生命周期将内存划分为不同的代，对不同代采用不同的回收频率。<ul><li>优点：提高回收效率。</li><li>缺点：实现复杂。</li></ul></li></ul><p>Go 语言采用<strong>标记-清除</strong>算法，并进行了优化。</p><p><strong><code>mspan</code></strong></p><ul><li><strong><code>allocBits</code></strong>: 记录了每块内存的分配情况。</li><li><strong><code>gcmarkBits</code></strong>: 记录了每块内存的引用情况。在标记阶段，有对象引用的内存块被标记为 1，没有的标记为 0。</li></ul><p>标记结束后，<code>allocBits</code> 指向 <code>gcmarkBits</code>，被标记的内存块保留，未标记的被回收。</p><p><strong>GC 工作流程</strong></p><p>Go 语言的 GC 大部分过程与用户代码并发执行。</p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235919958.png" class="" title="image-20250316235919958"><pre class="mermaid">graph LR    A[关闭 GC] --> B{栈扫描}    B -- 开启写屏障 --> C["STW (开启写屏障等准备工作)"]    C --> D["标记 (从全局空间和 goroutine 栈扫描变量)"]    D -- "三色标记，直到没有灰色对象" --> E["标记结束 (STW, 重新扫描 root 区域新变量)"]    E --> F["清除 (关闭 STW 和写屏障，清除白色对象)"]    F --> A</pre><ol><li><strong>Mark</strong>:<ul><li><strong>Mark Prepare</strong>: 初始化 GC 任务，开启写屏障（write barrier）和辅助 GC（mutator assist），统计 root 对象的数量。这个阶段需要 STW。</li><li><strong>GC Drains</strong>: 扫描所有 root 对象（全局指针和 goroutine 栈上的指针），将它们加入标记队列（灰色队列），并循环处理灰色队列中的对象，直到队列为空。这个阶段并发执行。</li><li><strong>Mark Termination</strong>: 完成标记工作，重新扫描全局指针和栈。由于 Mark 阶段与用户程序并发执行，可能会有新的对象分配和指针赋值，写屏障会记录这些变化，re-scan 阶段会再次检查。这个阶段需要 STW。</li></ul></li><li><strong>Sweep</strong>: 根据标记结果回收所有白色对象。这个阶段并发执行。</li><li><strong>Sweep Termination</strong>: 清扫未被清扫的 span。只有上一轮 GC 的清扫工作完成后，才能开始新一轮 GC。</li></ol><p><strong>三色标记</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235925383.png" class="" title="image-20250316235925383"><pre class="mermaid">graph LR    A["a"] --> B["b"]    A["a"] --> C["c"]    B["b"] --> D["d"]    subgraph "初始状态"        A1["a (白色)"] --> B1["b (白色)"]        A1["a (白色)"] --> C1["c (白色)"]        B1["b (白色)"] --> D1["d (白色)"]    end    subgraph "第一次遍历"        A2["a (灰色)"] --> B2["b (白色)"]        A2["a (灰色)"] --> C2["c (白色)"]        B2["b (白色)"] --> D2["d (白色)"]    end    subgraph "第二次遍历"        A3["a (黑色)"] --> B3["b (灰色)"]        A3["a (黑色)"] --> C3["c (灰色)"]        B3["b (灰色)"] --> D3["d (白色)"]    end    subgraph "第三次遍历"        A4["a (黑色)"] --> B4["b (黑色)"]        A4["a (黑色)"] --> C4["c (灰色)"]        B4["b (黑色)"] --> D4["d (白色)"]    end      subgraph "第四次遍历"        A5["a (黑色)"] --> B5["b (黑色)"]        A5["a (黑色)"] --> C5["c (黑色)"]        B5["b (黑色)"] --> D5["d (灰色)"]    end        subgraph "第五次遍历"        A6["a (黑色)"] --> B6["b (黑色)"]        A6["a (黑色)"] --> C6["c (黑色)"]        B6["b (黑色)"] --> D6["d (黑色)"]    end</pre><ol><li>GC 开始时，所有对象都被认为是白色（垃圾）。</li><li>从 root 对象开始遍历，可达对象被标记为灰色。</li><li>遍历所有灰色对象，将它们引用的对象标记为灰色，自身标记为黑色。</li><li>重复第 3 步，直到没有灰色对象，只剩下黑色和白色对象。白色对象即为垃圾。</li><li>对于黑色对象，如果在标记期间发生了写操作，写屏障会在赋值前将新对象标记为灰色。</li><li>标记过程中新分配的对象会被直接标记为黑色。</li></ol><p><strong>垃圾回收触发机制</strong></p><ul><li><strong>内存分配量达到阈值</strong>:<ul><li>每次内存分配时都会检查当前内存分配量是否达到阈值。</li><li>阈值 &#x3D; 上次 GC 内存分配量 * 内存增长率。</li><li>内存增长率由环境变量 <code>GOGC</code> 控制，默认为 100（即内存扩大一倍时触发 GC）。</li></ul></li><li><strong>定期触发</strong>: 默认情况下，每 2 分钟触发一次 GC。</li><li><strong>手动触发</strong>: 使用 <code>runtime.GC()</code> 函数手动触发 GC。</li></ul><h3 id="4-包引用与依赖管理"><a href="#4-包引用与依赖管理" class="headerlink" title="4. 包引用与依赖管理"></a>4. 包引用与依赖管理</h3><p>Go 语言的依赖管理经历了从 GOPATH 到 vendor，再到 Go Modules 的演变过程。</p><p><strong>GOPATH</strong></p><ul><li>通过环境变量 <code>GOPATH</code> 设置 Go 语言类库的目录。</li><li>问题：<ul><li>不同项目可能依赖同一库的不同版本。</li><li>代码被克隆后需要设置 <code>GOPATH</code> 才能编译。</li></ul></li></ul><p><strong>vendor</strong></p><ul><li>Go 1.6 版本引入了 <code>vendor</code> 目录。</li><li>每个项目创建一个 <code>vendor</code> 目录，并将依赖复制到该目录。</li><li>Go 语言项目会自动将 <code>vendor</code> 目录作为依赖路径。</li><li>优点：<ul><li>每个项目的 <code>vendor</code> 目录独立，可以灵活选择版本。</li><li><code>vendor</code> 目录与源代码一起提交，其他人克隆后可以直接编译。</li><li>编译期间无需下载依赖。</li></ul></li></ul><p><strong>vendor 管理工具</strong></p><ul><li>Godeps, Glide</li><li>Go 官方的依赖管理工具 Gopkg</li><li>Go Modules (gomod)</li></ul><p><strong>Go Modules (gomod)</strong></p><ul><li>通过 <code>go mod</code> 命令开启：<code>export GO111MODULE=on/off/auto</code></li><li>更灵活易用，基本统一了 Go 语言的依赖管理。</li></ul><p><strong>Go Modules 的目的</strong></p><ul><li>版本管理</li><li>防止篡改</li></ul><p><strong>Go Modules 使用</strong></p><ol><li>创建项目。</li><li>初始化 Go 模块：<code>go mod init</code></li><li>下载依赖包：<code>go mod download</code>（依赖包下载到 <code>$GOPATH/pkg</code>，如果没有设置 <code>GOPATH</code>，则下载到项目根目录下的 <code>pkg</code> 目录）。</li><li>在代码中使用依赖包，例如 <code>github.com/emicklei/go-restful</code>。</li><li>添加缺少的依赖并清理：<code>go mod tidy</code></li><li>将依赖复制到 <code>vendor</code> 目录：<code>go mod vendor</code></li></ol><p><strong><code>go.mod</code> 文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">module k8s.io/apiserver<br><br>go 1.13<br><br>require (<br>github.com/evanphx/json-patch v4.9.0+incompatible<br>github.com/go-openapi/jsonreference v0.19.3 // indirect<br>github.com/go-openapi/spec v0.19.3<br>github.com/gogo/protobuf v1.3.2<br>github.com/google/go-cmp v0.3.0<br>github.com/google/gofuzz v1.1.0<br>k8s.io/apimachinery v0.0.0-20210518100737-44f1264f7b6b<br>)<br><br>replace (<br>golang.org/x/crypto =&gt; golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975<br>golang.org/x/text =&gt; golang.org/x/text v0.3.2<br>k8s.io/api =&gt; k8s.io/api v0.0.0-20210518101910-53468e23a787<br>k8s.io/apimachinery =&gt; k8s.io/apimachinery v0.0.0-20210518100737-44f1264f7b6b<br>k8s.io/client-go =&gt; k8s.io/client-go v0.0.0-20210518104342-fa3acefe68f3<br>k8s.io/component-base =&gt; k8s.io/component-base v0.0.0-20210518111421-67c12a31a26a<br>)<br></code></pre></td></tr></table></figure><ul><li><code>module</code>: 定义模块的导入路径。</li><li><code>go</code>: 指定 Go 语言版本。</li><li><code>require</code>: 指定依赖包及其版本。</li><li><code>replace</code>: 替换依赖包。</li></ul><p><strong><code>GOPROXY</code> 和 <code>GOPRIVATE</code></strong></p><ul><li><strong><code>GOPROXY</code></strong>: 设置 Go 依赖的代理。<ul><li><code>export GOPROXY=https://goproxy.cn</code></li><li>设置 <code>GOPROXY</code> 后，默认所有依赖都会通过代理拉取，并进行 checksum 校验。</li></ul></li><li><strong><code>GOPRIVATE</code></strong>: 声明私有代码仓库，避免通过 <code>GOPROXY</code> 拉取。<ul><li><code>GOPRIVATE=*.corp.example.com</code></li><li><code>GONOPROXY=myrepo.corp.example.com</code></li><li><code>GOPROXY=proxy.example.com</code></li></ul></li></ul><h3 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5. Makefile"></a>5. Makefile</h3><p>Go 语言项目通常使用 Makefile 来组织编译过程。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ROOT=github.com/cncamp/golang<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: root</span><br><span class="hljs-section">root:</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: release</span><br><span class="hljs-section">release:</span><br>@echo <span class="hljs-string">&quot;building httpserver binary&quot;</span><br>@mkdir -p bin/amd64<br>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/amd64 .<br></code></pre></td></tr></table></figure><ul><li><code>.PHONY</code>: 声明伪目标。</li><li><code>release</code>: 定义构建目标，设置环境变量 <code>CGO_ENABLED</code>、<code>GOOS</code> 和 <code>GOARCH</code>，然后使用 <code>go build</code> 编译程序。</li></ul><h3 id="6-编写-HTTP-Server"><a href="#6-编写-HTTP-Server" class="headerlink" title="6. 编写 HTTP Server"></a>6. 编写 HTTP Server</h3><p><strong>理解 <code>net/http</code> 包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">healthz</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>io.WriteString(w, <span class="hljs-string">&quot;ok\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/healthz&quot;</span>, healthz) <span class="hljs-comment">// 注册处理函数</span><br>err := http.ListenAndServe(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 监听端口，使用默认的 DefaultServeMux</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>http.HandleFunc</code>: 注册处理函数，将 URL 路径与处理函数关联起来。</li><li><code>http.ListenAndServe</code>: 启动 HTTP 服务器，监听指定端口。第二个参数为 <code>nil</code> 时，使用默认的 <code>DefaultServeMux</code>。</li><li><code>healthz</code>: 处理函数，接收 <code>http.ResponseWriter</code> 和 <code>http.Request</code> 作为参数。</li></ul><p><strong>阻塞 IO 模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235937032.png" class="" title="image-20250316235937032"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    Note over 应用进程,系统内核: 进程阻塞于 recvfrom 调用    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据    Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>非阻塞 IO 模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235942132.png" class="" title="image-20250316235942132"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    系统内核-->>应用进程: 返回错误    Note over 应用进程: 进程重复调用 recvfrom    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    系统内核-->>应用进程: 返回错误    Note over 应用进程: ...    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据     Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>IO 多路复用</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235948370.png" class="" title="image-20250316235948370"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: select/poll (系统调用)    Note over 系统内核: 数据报文尚未就绪    Note over 应用进程,系统内核: 进程阻塞于 select/poll 调用，等待有可读的 socket    系统内核-->>应用进程: 返回可读    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据    Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>异步 IO</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235953003.png" class="" title="image-20250316235953003"><pre><code class="language-mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程-&gt;&gt;系统内核: 异步 IO 读 (系统调用)    Note over 系统内核: 数据报文尚未就绪  </code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言基础与实践</title>
    <link href="/2025/03/16/golang/"/>
    <url>/2025/03/16/golang/</url>
    
    <content type="html"><![CDATA[<p>Golang 基本使用。</p><span id="more"></span><h3 id="一、统一思想：12-因素应用宣言"><a href="#一、统一思想：12-因素应用宣言" class="headerlink" title="一、统一思想：12 因素应用宣言"></a>一、统一思想：12 因素应用宣言</h3><p>在深入学习 Go 语言之前，我们先来了解一下构建云原生应用的指导原则——12 因素应用宣言（The Twelve-Factor App）。这套方法论由 Heroku 平台的开发者总结，旨在帮助开发者构建可扩展、可维护、易部署的云原生应用。</p><ol><li><p><strong>基准代码 (Codebase)</strong>：一份基准代码，多份部署。使用版本控制系统（如 Git）管理代码，确保不同环境（开发、测试、生产）使用同一份代码的不同版本。</p></li><li><p><strong>依赖 (Dependencies)</strong>：显式声明依赖关系。使用依赖管理工具（如 Go Modules）管理项目依赖，确保依赖的明确性和可重复性。</p></li><li><p><strong>配置 (Config)</strong>：在环境中存储配置。将配置信息（如数据库连接、API 密钥）存储在环境变量中，而不是硬编码在代码中，提高应用的可移植性和安全性。</p></li><li><p><strong>后端服务 (Backing Services)</strong>：把后端服务当作附加资源。将数据库、消息队列、缓存等后端服务视为可插拔的资源，通过 URL 或配置信息进行连接，方便应用的迁移和扩展。</p></li><li><p><strong>构建，发布，运行 (Build, Release, Run)</strong>：严格分离构建和运行。将应用构建、发布和运行三个阶段分离，确保每个阶段的独立性和可重复性。</p></li><li><p><strong>进程 (Processes)</strong>：以一个或多个无状态进程运行应用。将应用设计为无状态进程，方便水平扩展和故障恢复。</p></li><li><p><strong>端口绑定 (Port Binding)</strong>：通过端口绑定提供服务。应用通过绑定端口对外提供服务，不依赖于特定的 Web 服务器或容器。</p></li><li><p><strong>并发 (Concurrency)</strong>：通过进程模型进行扩展。利用进程或线程模型实现应用的并发，提高应用的吞吐量和响应速度。</p></li><li><p><strong>易处理 (Disposability)</strong>：快速启动和优雅终止可最大化健壮性。应用应能够快速启动和优雅终止，方便部署、重启和故障恢复。</p></li><li><p><strong>开发环境与线上环境等价 (Dev&#x2F;Prod Parity)</strong>：尽可能地保持开发、预发布、线上环境相同。使用相同的操作系统、依赖和配置，减少环境差异导致的问题。</p></li><li><p><strong>日志 (Logs)</strong>：把日志当作事件流。将应用的日志输出到标准输出（stdout），由外部系统（如日志收集器）进行处理和分析。</p></li><li><p><strong>管理进程 (Admin Processes)</strong>：后台管理任务当作一次性进程运行。将后台管理任务（如数据库迁移、数据备份）作为一次性进程运行，与应用的主进程分离。</p></li></ol><p><strong>面试知识点：</strong></p><ul><li>什么是 12 因素应用宣言？它的核心原则是什么？</li><li>为什么要在环境中存储配置？这样做有什么好处？</li><li>如何理解应用的无状态性？无状态应用有什么优势？</li></ul><h3 id="二、Go-语言的诞生与设计哲学"><a href="#二、Go-语言的诞生与设计哲学" class="headerlink" title="二、Go 语言的诞生与设计哲学"></a>二、Go 语言的诞生与设计哲学</h3><h4 id="1-为什么需要-Go-语言？"><a href="#1-为什么需要-Go-语言？" class="headerlink" title="1. 为什么需要 Go 语言？"></a>1. 为什么需要 Go 语言？</h4><p>在 Go 语言出现之前，开发者面临着一些挑战：</p><ul><li><strong>硬件发展与软件瓶颈</strong>：硬件性能不断提升，但软件开发效率却没有同步提升。</li><li><strong>现有语言的不足</strong>：<ul><li>C&#x2F;C++ 等原生语言缺乏好的依赖管理，编译速度慢。</li><li>Java&#x2F;C# 等语言过于庞大，启动速度慢，内存占用高。</li><li>现有语言对并发编程的支持不够友好，难以充分利用多核处理器。</li></ul></li></ul><p>Go 语言的出现，正是为了解决这些问题。</p><h4 id="2-Go-语言的设计哲学"><a href="#2-Go-语言的设计哲学" class="headerlink" title="2. Go 语言的设计哲学"></a>2. Go 语言的设计哲学</h4><p>Go 语言的设计哲学可以用以下几个关键词概括：</p><ul><li><strong>Less is exponentially more</strong>（少即是多）：Go 语言追求简洁，避免过度设计，减少不必要的复杂性。</li><li><strong>Do Less, Enable More</strong>（做更少，成更多）：Go 语言提供了一套精简但强大的工具集，让开发者能够更高效地完成工作。</li><li><strong>面向工程</strong>：Go 语言的设计目标是解决实际工程问题，而不是追求学术上的完美。</li><li><strong>正交性</strong>：Go 语言的特性之间相互独立，组合起来却能发挥强大的威力。</li></ul><h4 id="3-Go-语言的主要特性"><a href="#3-Go-语言的主要特性" class="headerlink" title="3. Go 语言的主要特性"></a>3. Go 语言的主要特性</h4><ul><li><strong>编译型语言</strong>：Go 语言是一种编译型语言，可以将代码编译成机器码，执行效率高。</li><li><strong>静态类型</strong>：Go 语言是一种静态类型语言，在编译时进行类型检查，可以减少运行时错误。</li><li><strong>垃圾回收</strong>：Go 语言内置垃圾回收机制，开发者无需手动管理内存，降低了开发难度。</li><li><strong>并发编程</strong>：Go 语言通过 goroutine 和 channel 提供了强大的并发编程支持，可以轻松编写高并发程序。</li><li><strong>简洁的语法</strong>：Go 语言的语法简洁明了，易于学习和使用。</li><li><strong>丰富的标准库</strong>：Go 语言提供了丰富的标准库，涵盖了网络编程、系统编程、数据处理等多个领域。</li></ul><h4 id="4-Go-语言不支持的特性"><a href="#4-Go-语言不支持的特性" class="headerlink" title="4. Go 语言不支持的特性"></a>4. Go 语言不支持的特性</h4><p>为了保持语言的简洁性和一致性，Go 语言有意不支持一些常见的特性：</p><ul><li><strong>函数重载和操作符重载</strong>：避免代码的歧义和复杂性。</li><li><strong>隐式类型转换</strong>：减少潜在的错误和不确定性。</li><li><strong>继承</strong>：Go 语言使用组合来实现代码复用，而不是继承。</li><li><strong>异常处理</strong>：Go 语言使用显式的错误处理机制（error），而不是异常。</li><li><strong>断言</strong>：Go 语言鼓励开发者编写更健壮的代码，而不是依赖断言来捕获错误。</li><li><strong>静态变量</strong>：Go 语言不支持静态变量，避免全局状态带来的问题。</li></ul><p><strong>面试知识点：</strong></p><ul><li>Go 语言的设计目标是什么？它解决了哪些问题？</li><li>Go 语言有哪些主要的特性？这些特性有什么优势？</li><li>为什么 Go 语言不支持某些常见的特性（如继承、异常）？</li></ul><h3 id="三、Go-语言环境搭建与基础"><a href="#三、Go-语言环境搭建与基础" class="headerlink" title="三、Go 语言环境搭建与基础"></a>三、Go 语言环境搭建与基础</h3><h4 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1. 下载与安装"></a>1. 下载与安装</h4><ul><li>访问 Go 语言官网（<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a>）下载对应平台的安装包。</li><li>按照官方文档的指引进行安装。</li></ul><h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h4><ul><li><strong>GOROOT</strong>：Go 语言的安装目录。</li><li><strong>GOPATH</strong>：Go 语言的工作目录，用于存放项目代码、依赖包和可执行文件。<ul><li><code>src</code>：存放项目源代码。</li><li><code>pkg</code>：存放编译后的包文件。</li><li><code>bin</code>：存放可执行文件。</li></ul></li><li><strong>GOOS</strong>：目标操作系统（如 linux、windows、darwin）。</li><li><strong>GOARCH</strong>：目标处理器架构（如 amd64、arm64）。</li><li><strong>GOPROXY</strong>：Go 模块代理，用于加速依赖包的下载。国内用户建议设置为 <code>https://goproxy.cn</code>。</li></ul><h4 id="3-IDE-设置"><a href="#3-IDE-设置" class="headerlink" title="3. IDE 设置"></a>3. IDE 设置</h4><ul><li>推荐使用 VS Code，并安装 Go 插件。</li><li>其他可选的 IDE 包括：<ul><li>Goland（JetBrains 出品，收费）</li><li>Vim、Sublime Text 等（需要配置相关插件）</li></ul></li></ul><h4 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h4><ul><li><code>go build</code>：编译 Go 程序。<ul><li><code>-o</code>：指定输出文件名。</li><li><code>GOOS</code> 和 <code>GOARCH</code> 环境变量可以用于交叉编译。</li></ul></li><li><code>go run</code>：编译并运行 Go 程序。</li><li><code>go test</code>：运行测试。<ul><li><code>./...</code>：运行当前目录及子目录下的所有测试。</li><li><code>-v</code>：显示详细的测试输出。</li></ul></li><li><code>go vet</code>：静态代码检查，发现潜在的错误。</li><li><code>go fmt</code>：格式化 Go 代码。</li><li><code>go get</code>：下载并安装依赖包。</li><li><code>go mod</code>：Go 模块管理工具。</li><li><code>go doc</code>：查看文档。</li><li><code>go env</code>：查看 Go 环境变量。</li></ul><h4 id="5-代码版本控制"><a href="#5-代码版本控制" class="headerlink" title="5. 代码版本控制"></a>5. 代码版本控制</h4><ul><li>推荐使用 Git 进行代码版本控制。</li><li>将代码托管到 GitHub、GitLab 等平台。</li></ul><h4 id="6-Golang-Playground"><a href="#6-Golang-Playground" class="headerlink" title="6. Golang Playground"></a>6. Golang Playground</h4><ul><li>官方 Playground：<a href="https://play.golang.org/">https://play.golang.org/</a></li><li>国内可访问的 Playground：<a href="https://goplay.tools/">https://goplay.tools/</a></li></ul><p><strong>面试知识点：</strong></p><ul><li><code>go build</code> 和 <code>go run</code> 有什么区别？</li><li><code>go vet</code> 可以检查出哪些类型的错误？</li><li>如何使用 Go Modules 管理项目依赖？</li><li>如何进行交叉编译？</li></ul><h3 id="四、Go-语言控制结构"><a href="#四、Go-语言控制结构" class="headerlink" title="四、Go 语言控制结构"></a>四、Go 语言控制结构</h3><h4 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition1 &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2 &#123;<br>    <span class="hljs-comment">// do something else</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// catch-all or default</span><br>&#125;<br><br><span class="hljs-comment">// 简短语句</span><br><span class="hljs-keyword">if</span> v := x - <span class="hljs-number">100</span>; v &lt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-switch-语句"><a href="#2-switch-语句" class="headerlink" title="2. switch 语句"></a>2. switch 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br><span class="hljs-keyword">case</span> val1:<br>    <span class="hljs-comment">// 空分支</span><br><span class="hljs-keyword">case</span> val2:<br>    <span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">// 执行 case3 中的代码</span><br><span class="hljs-keyword">case</span> val3:<br>    f()<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计数器循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>    sum += sum<br>&#125;<br><br><span class="hljs-comment">// 无限循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// for-range 循环</span><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> myArray &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>Go 语言中如何实现类似于 while 循环的功能？</li><li>for-range 循环遍历不同类型的数据时，有哪些需要注意的地方？</li></ul><h3 id="五、Go-语言常用数据结构"><a href="#五、Go-语言常用数据结构" class="headerlink" title="五、Go 语言常用数据结构"></a>五、Go 语言常用数据结构</h3><h4 id="1-变量与常量"><a href="#1-变量与常量" class="headerlink" title="1. 变量与常量"></a>1. 变量与常量</h4><ul><li><strong>常量</strong>：使用 <code>const</code> 关键字定义。</li><li><strong>变量</strong>：使用 <code>var</code> 关键字定义。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Go&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-变量定义与初始化"><a href="#2-变量定义与初始化" class="headerlink" title="2. 变量定义与初始化"></a>2. 变量定义与初始化</h4><ul><li><strong>变量声明</strong>：<code>var identifier type</code></li><li><strong>变量初始化</strong>：<code>var i, j int = 1, 2</code></li><li><strong>短变量声明</strong>：<code>c, python, java := true, false, &quot;no!&quot;</code> （只能在函数内部使用）</li></ul><h4 id="3-类型转换与推导"><a href="#3-类型转换与推导" class="headerlink" title="3. 类型转换与推导"></a>3. 类型转换与推导</h4><ul><li><strong>类型转换</strong>：<code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</li><li><strong>类型推导</strong>：在声明变量时不指定类型，Go 编译器会根据右值的类型自动推导。</li></ul><h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h4><ul><li><strong>定义</strong>：<code>var identifier [len]type</code></li><li><strong>特点</strong>：相同类型、长度固定、连续内存。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myArray := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-切片-slice"><a href="#5-切片-slice" class="headerlink" title="5. 切片 (slice)"></a>5. 切片 (slice)</h4><ul><li><strong>定义</strong>：<code>var identifier []type</code></li><li><strong>特点</strong>：对数组的引用、动态长度、连续内存。</li><li><strong>常用方法</strong>：<ul><li><code>append</code>：追加元素。</li><li><code>make</code>：创建切片。</li><li>切片操作：<code>myArray[1:3]</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>mySlice = <span class="hljs-built_in">append</span>(mySlice, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="6-make-和-new"><a href="#6-make-和-new" class="headerlink" title="6. make 和 new"></a>6. make 和 new</h4><ul><li><strong>new</strong>：返回指针地址。</li><li><strong>make</strong>：返回第一个元素，可预设内存空间。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice1 := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// 返回 *[]int</span><br>mySlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 返回 []int，长度为 0</span><br>mySlice3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 返回 []int，长度为 10，容量为 20</span><br></code></pre></td></tr></table></figure><h4 id="7-Map"><a href="#7-Map" class="headerlink" title="7. Map"></a>7. Map</h4><ul><li><strong>声明</strong>：<code>var map1 map[keytype]valuetype</code></li><li><strong>特点</strong>：键值对、无序。</li><li><strong>常用方法</strong>：<ul><li><code>make</code>：创建 Map。</li><li><code>delete</code>：删除键值对。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="8-访问-Map-元素"><a href="#8-访问-Map-元素" class="headerlink" title="8. 访问 Map 元素"></a>8. 访问 Map 元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按 Key 取值</span><br>value, exists := myMap[<span class="hljs-string">&quot;a&quot;</span>]<br><span class="hljs-keyword">if</span> exists &#123;<br>    <span class="hljs-built_in">println</span>(value)<br>&#125;<br><br><span class="hljs-comment">// 遍历 Map</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-built_in">println</span>(k, v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-结构体和指针"><a href="#9-结构体和指针" class="headerlink" title="9. 结构体和指针"></a>9. 结构体和指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMyType</span><span class="hljs-params">(t *MyType)</span></span> &#123;<br><span class="hljs-built_in">println</span>(t.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>printMyType(&amp;t) <span class="hljs-comment">// 传入指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>type … struct</code> 关键字自定义结构体</li><li>Go 语言支持指针，但不支持指针运算</li><li>指针变量的值为内存地址</li><li>未赋值的指针为 <code>nil</code></li></ul><h4 id="10-结构体标签"><a href="#10-结构体标签" class="headerlink" title="10. 结构体标签"></a>10. 结构体标签</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mt := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>myType := reflect.TypeOf(mt)<br>name := myType.Field(<span class="hljs-number">0</span>)<br>tag := name.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br><span class="hljs-built_in">println</span>(tag)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li><li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag</li><li><code>NodeName string  json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li></ul><h4 id="11-类型别名"><a href="#11-类型别名" class="headerlink" title="11. 类型别名"></a>11. 类型别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Service Type string describes ingress methods for a service</span><br><span class="hljs-keyword">type</span> ServiceType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span><br><span class="hljs-comment">// cluster, via the ClusterIP.</span><br>ServiceTypeClusterIP ServiceType = <span class="hljs-string">&quot;ClusterIP&quot;</span><br><br><span class="hljs-comment">// ServiceTypeNodePort means a service will be exposed on one port of</span><br><span class="hljs-comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span><br>ServiceTypeNodePort ServiceType = <span class="hljs-string">&quot;NodePort&quot;</span><br><br><span class="hljs-comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span><br><span class="hljs-comment">// external load balancer (if the cloud provider supports it), in addition</span><br><span class="hljs-comment">// to &#x27;NodePort&#x27; type.</span><br>ServiceTypeLoadBalancer ServiceType = <span class="hljs-string">&quot;LoadBalancer&quot;</span><br><br><span class="hljs-comment">// ServiceTypeExternalName means a service consists of only a reference to</span><br><span class="hljs-comment">// an external name that kubedns or equivalent will return as a CNAME</span><br><span class="hljs-comment">// record, with no exposing or proxying of any pods involved.</span><br>ServiceTypeExternalName ServiceType = <span class="hljs-string">&quot;ExternalName&quot;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>数组和切片有什么区别？</li><li><code>make</code> 和 <code>new</code> 有什么区别？</li><li>如何判断一个 Map 中是否存在某个键？</li><li>结构体标签有什么作用？</li></ul><h3 id="课后练习-1-1"><a href="#课后练习-1-1" class="headerlink" title="课后练习 1.1"></a>课后练习 1.1</h3><ul><li>安装 Go</li><li>安装 IDE 并安装 Go 语言插件</li><li>编写一个小程序</li></ul><p>给定一个字符串数组<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;stupid&quot;,&quot;and&quot;,&quot;weak&quot;]</code><br>用 <code>for</code> 循环遍历该数组并修改为<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;smart&quot;,&quot;and&quot;,&quot;strong&quot;]</code></p><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;am&quot;</span>, <span class="hljs-string">&quot;stupid&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;weak&quot;</span>&#125;<br>replacements := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;stupid&quot;</span>: <span class="hljs-string">&quot;smart&quot;</span>,<br><span class="hljs-string">&quot;weak&quot;</span>:   <span class="hljs-string">&quot;strong&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> words &#123;<br><span class="hljs-keyword">if</span> replacement, ok := replacements[word]; ok &#123;<br>words[i] = replacement<br>&#125;<br>&#125;<br><br>fmt.Println(words) <span class="hljs-comment">// 输出 [&quot;I&quot;, &quot;am&quot;, &quot;smart&quot;, &quot;and&quot;, &quot;strong&quot;]</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六、Go-语言函数"><a href="#六、Go-语言函数" class="headerlink" title="六、Go 语言函数"></a>六、Go 语言函数</h3><h4 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main 函数"></a>1. main 函数</h4><ul><li>每个 Go 程序都应该有一个 <code>main</code> 包。</li><li><code>main</code> 包里的 <code>main</code> 函数是程序的入口。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-参数解析"><a href="#2-参数解析" class="headerlink" title="2. 参数解析"></a>2. 参数解析</h4><ul><li><code>main</code> 函数没有参数，不同于其他语言的<code>[]string args</code>。</li><li>可以使用 <code>os.Args</code> 获取命令行参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>args := os.Args<br>fmt.Println(<span class="hljs-string">&quot;Arguments:&quot;</span>, args)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>flag</code> 包解析命令行参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name := flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;specify the name you want to say hi&quot;</span>)<br>flag.Parse()<br>fmt.Println(<span class="hljs-string">&quot;Hello,&quot;</span>, *name)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-init-函数"><a href="#3-init-函数" class="headerlink" title="3. init 函数"></a>3. init 函数</h4><ul><li><code>init</code> 函数会在包初始化时自动执行。</li><li>谨慎使用 <code>init</code> 函数，避免循环依赖和不可重复运行的问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> myVariable = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>myVariable = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>多值返回</strong>：函数可以返回多个值。</li><li><strong>命名返回值</strong>：可以给返回值命名，并在函数体中直接使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(sum <span class="hljs-type">int</span>)</span></span> (x, y <span class="hljs-type">int</span>) &#123;<br>    x = sum * <span class="hljs-number">4</span> / <span class="hljs-number">9</span><br>    y = sum - x<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 裸返回，返回已命名的 x 和 y</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-调用者忽略部分返回值"><a href="#5-调用者忽略部分返回值" class="headerlink" title="5. 调用者忽略部分返回值"></a>5. 调用者忽略部分返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result, _ = strconv.Atoi(origStr) <span class="hljs-comment">// 忽略错误返回值</span><br></code></pre></td></tr></table></figure><h4 id="6-传递变长参数"><a href="#6-传递变长参数" class="headerlink" title="6. 传递变长参数"></a>6. 传递变长参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []Type, elems ...Type)</span></span> []Type <span class="hljs-comment">// 接收任意多个 Type 类型的参数</span><br></code></pre></td></tr></table></figure><h4 id="7-内置函数"><a href="#7-内置函数" class="headerlink" title="7. 内置函数"></a>7. 内置函数</h4><table><thead><tr><th align="left">函数名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>close</code></td><td align="left">管道关闭</td></tr><tr><td align="left"><code>len</code>, <code>cap</code></td><td align="left">返回数组、切片、Map 的长度或容量</td></tr><tr><td align="left"><code>new</code>, <code>make</code></td><td align="left">内存分配</td></tr><tr><td align="left"><code>copy</code>, <code>append</code></td><td align="left">操作切片</td></tr><tr><td align="left"><code>panic</code>, <code>recover</code></td><td align="left">错误处理</td></tr><tr><td align="left"><code>print</code>, <code>println</code></td><td align="left">打印</td></tr><tr><td align="left"><code>complex</code>, <code>real</code>, <code>imag</code></td><td align="left">操作复数</td></tr></tbody></table><h4 id="8-回调函数-Callback"><a href="#8-回调函数-Callback" class="headerlink" title="8. 回调函数 (Callback)"></a>8. 回调函数 (Callback)</h4><ul><li>将函数作为参数传递给其他函数，并在其他函数内部调用执行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doOperation</span><span class="hljs-params">(y <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>) &#123;<br>    f(y, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increase</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;increase result is:&quot;</span>, a+b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    doOperation(<span class="hljs-number">1</span>, increase)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9. 闭包"></a>9. 闭包</h4><ul><li>匿名函数，可以访问其外部作用域的变量。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        sum += x<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pos, neg := adder(), adder()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<br>            pos(i),<br>            neg(<span class="hljs-number">-2</span>*i),<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-方法"><a href="#10-方法" class="headerlink" title="10. 方法"></a>10. 方法</h4><ul><li>作用在接收者上的函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-传值还是传指针"><a href="#11-传值还是传指针" class="headerlink" title="11. 传值还是传指针"></a>11. 传值还是传指针</h4><ul><li>Go 语言只有一种规则-传值</li><li>函数内修改参数的值不会影响函数外原始变量的值</li><li>可以传递指针参数将变量地址传递给调用函数，Go 语言会<br>复制该指针作为函数内的地址，但指向同一地址</li><li>思考：当我们写代码的时候，函数的参数传递应该用<code>struct</code><br>还是<code>pointer</code>？<ul><li>如果需要修改参数的值，或者参数较大，传递指针更高效。</li><li>如果不需要修改参数的值，且参数较小，传递值更安全。</li></ul></li></ul><h4 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h4><ul><li>接口定义一组方法集合。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>    Abs() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(-f)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a Abser<br>    f := MyFloat(-math.Sqrt2)<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>    a = f  <span class="hljs-comment">// MyFloat 实现了 Abser</span><br>    a = &amp;v <span class="hljs-comment">// *Vertex 实现了 Abser</span><br><br>    <span class="hljs-comment">// a = v // 错误：Vertex 没有实现 Abser（Abs 方法的接收者是 *Vertex）</span><br><br>    fmt.Println(a.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-注意事项"><a href="#13-注意事项" class="headerlink" title="13. 注意事项"></a>13. 注意事项</h4><ul><li><code>Interface</code> 是可能为 <code>nil</code> 的，所以针对 <code>interface</code> 的使用一定要预先判空，否则会引起程序 <code>crash(nil panic)</code></li><li><code>Struct</code> 初始化意味着空间分配，对 <code>struct</code> 的引用不会出现空指针</li></ul><h4 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14. 反射机制"></a>14. 反射机制</h4><ul><li><code>reflect.TypeOf()</code> 返回被检查对象的类型</li><li><code>reflect.ValueOf()</code> 返回被检查对象的值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br>t := reflect.TypeOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, t)<br>v := reflect.ValueOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, v)<br></code></pre></td></tr></table></figure><h4 id="15-基于-struct-的反射"><a href="#15-基于-struct-的反射" class="headerlink" title="15. 基于 struct 的反射"></a>15. 基于 struct 的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// struct</span><br>myStruct := T&#123;A: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>v1 := reflect.ValueOf(myStruct)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumField(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumMethod(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))<br>&#125;<br><br><span class="hljs-comment">// 需要注意receive是struct还是指针</span><br>result := v1.Method(<span class="hljs-number">0</span>).Call(<span class="hljs-literal">nil</span>)<br>fmt.Println(<span class="hljs-string">&quot;result:&quot;</span>, result)<br></code></pre></td></tr></table></figure><h4 id="16-Go-语言中的面向对象编程"><a href="#16-Go-语言中的面向对象编程" class="headerlink" title="16. Go 语言中的面向对象编程"></a>16. Go 语言中的面向对象编程</h4><ul><li>可见性控制<ul><li><code>public</code>-常量、变量、类型、接口、结构、函数等的名称大写</li><li><code>private</code> -非大写就只能在包内使用</li></ul></li><li>继承<ul><li>通过组合实现，内嵌一个或多个<code>struct</code></li></ul></li><li>多态<ul><li>通过接口实现，通过接口定义方法集，编写多套实现</li></ul></li></ul><h4 id="17-Json-编解码"><a href="#17-Json-编解码" class="headerlink" title="17. Json 编解码"></a>17. Json 编解码</h4><ul><li><code>Unmarshal</code>: 从 <code>string</code> 转换至 <code>struct</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unmarshal2Struct</span><span class="hljs-params">(humanStr <span class="hljs-type">string</span>)</span></span> Human &#123;<br>h := Human&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;h)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">println</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Marshal</code>: 从 <code>struct</code> 转换至 <code>string</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">marshal2JsonString</span><span class="hljs-params">(h Human)</span></span> <span class="hljs-type">string</span> &#123;<br>h.Age = <span class="hljs-number">30</span><br>updatedBytes, err := json.Marshal(&amp;h)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">println</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(updatedBytes)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>json</code> 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 类型保存任意对象</li><li>可通过如下逻辑解析任意 <code>json</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> obj <span class="hljs-keyword">interface</span>&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;obj)<br>objMap, ok := obj.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> objMap &#123;<br><span class="hljs-keyword">switch</span> value := v.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>Go 语言中如何实现函数的重载？</li><li>什么是闭包？闭包有什么作用？</li><li>Go 语言中的方法和普通函数有什么区别？</li><li>Go 语言中如何实现接口？接口和抽象类有什么区别？</li><li>什么是反射？反射有什么作用？</li><li>如何使用 <code>encoding/json</code> 包进行 JSON 编解码？</li></ul><h3 id="六、常用语法"><a href="#六、常用语法" class="headerlink" title="六、常用语法"></a>六、常用语法</h3><h4 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1. 错误处理"></a>1. 错误处理</h4><p>Go 语言无内置 <code>exceptio</code> 机制，只提供 <code>error</code> 接口供定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可通过 <code>errors.New</code> 或 <code>fmt.Errorf</code> 创建新的 <code>error</code></li><li><code>var errNotFound error = errors.New(&quot;NotFound&quot;)</code></li><li>通常应用程序对 <code>error</code> 的处理大部分是判断 <code>error</code> 是否为 <code>nil</code><br>如需将 <code>error</code> 归类，通常交给应用程序自定义，比如 <code>kubernetes</code> 自定义了与 <code>apiserver</code> 交互的不同类型错误</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StatusError <span class="hljs-keyword">struct</span> &#123;<br>ErrStatus metav1.Status<br>&#125;<br><br><span class="hljs-keyword">var</span> _ <span class="hljs-type">error</span> = &amp;StatusError&#123;&#125;<br><br><span class="hljs-comment">// Error implements the Error interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StatusError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.ErrStatus.Message<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-defer"><a href="#2-defer" class="headerlink" title="2. defer"></a>2. defer</h4><ul><li>函数返回之前执行某个语句或函数</li><li>等同于Java 和C# 的finally</li><li>常见的 <code>defer</code> 使用场景：记得关闭你打开的资源<ul><li><code>defer file.Close()</code></li><li><code>defer mu.Unlock()</code></li><li><code>defer println(&quot;&quot;)</code></li></ul></li></ul><h4 id="3-Panic-和-recover"><a href="#3-Panic-和-recover" class="headerlink" title="3. Panic 和 recover"></a>3. Panic 和 recover</h4><ul><li><code>panic</code>: 可在系统出现不可恢复错误时主动调用 <code>panic</code>, <code>panic</code> 会使当前线程直接 <code>crash</code></li><li><code>defer</code>: 保证执行并把控制权交还给接收到 <code>panic</code> 的函数调用者</li><li><code>recover</code>: 函数从 <code>panic</code> 或 错误场景中恢复</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer func is called&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;a panic is triggered&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七. 多线程"></a>七. 多线程</h3><h4 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h4><ul><li>并发（concurrency）<ul><li>两个或多个事件在同一时间间隔发生</li></ul></li><li>并行（parallellism）<ul><li>两个或者多个事件在同一时刻发生</li></ul></li></ul><h4 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h4><ul><li>进程：<ul><li>分配系统资源（CPU 时间、内存等）基本单位</li><li>有独立的内存空间，切换开销大</li></ul></li><li>线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位<ul><li>同一进程中的多线程共享内存空间，线程切换代价小</li><li>多线程通信方便</li><li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li></ul></li><li>协程<ul><li>Go语言中的轻量级线程实现</li><li>Golang 在<code>runtime</code>、系统调用等多方面对<code>goroutine</code> 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前<code>goroutine</code> 的<code>CPU (P)</code> 转让出去，让其他<code>goroutine</code> 能被调度<br>并执行，也就是<code>Golang</code> 从语言层面支持了协程</li></ul></li></ul><h4 id="3-Communicating-Sequential-Process"><a href="#3-Communicating-Sequential-Process" class="headerlink" title="3. Communicating Sequential Process"></a>3. Communicating Sequential Process</h4><ul><li>CSP<ul><li>描述两个独立的并发实体通过共享的通讯<code>channel</code>进行通信的并发模型。</li></ul></li><li>Go 协程 <code>goroutine</code><ul><li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度。</li><li>是一种绿色线程，微线程，它与<code>Coroutine</code>协程也有区别，能够在发现堵塞后启动新的微线程。</li></ul></li><li>通道 <code>channel</code><ul><li>类似<code>Unix</code>的<code>Pipe</code>，用于协程之间通讯和同步。</li><li>协程之间虽然解耦，但是它们和<code>Channel</code>有着耦合。</li></ul></li></ul><h4 id="4-线程和协程的差异"><a href="#4-线程和协程的差异" class="headerlink" title="4. 线程和协程的差异"></a>4. 线程和协程的差异</h4><ul><li>每个 <code>goroutine</code> (协程) 默认占用内存远比 <code>Java</code> 、<code>C</code> 的线程少<ul><li><code>goroutine</code>：<code>2KB</code></li><li>线程：<code>8MB</code></li></ul></li><li>线程&#x2F;<code>goroutine</code> 切换开销方面，<code>goroutine</code> 远比线程小<ul><li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、<code>PC</code>、<code>SP</code>…等寄存器的刷新</li><li><code>goroutine</code>：只有三个寄存器的值修改-<code>PC</code> &#x2F; <code>SP</code> &#x2F; <code>DX</code>.</li></ul></li><li>GOMAXPROCS<ul><li>控制并行线程数量</li></ul></li></ul><h4 id="5-协程示例"><a href="#5-协程示例" class="headerlink" title="5. 协程示例"></a>5. 协程示例</h4><ul><li>启动新协程：<code>go functionName()</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> fmt.Println(i)<br>&#125;<br>time.Sleep(time.Second)<br></code></pre></td></tr></table></figure><h4 id="6-channel-多线程通信"><a href="#6-channel-多线程通信" class="headerlink" title="6. channel - 多线程通信"></a>6. channel - 多线程通信</h4><ul><li><code>Channel</code> 是多个协程之间通讯的管道</li><li>一端发送数据，一端接收数据</li><li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li><li>协调协程的执行顺序</li><li>声明方式<ul><li><code>var identifier chan datatype</code></li></ul></li><li>操作符<code>&lt;-</code></li><li>示例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello from goroutine&quot;</span>)<br>ch &lt;- <span class="hljs-number">0</span> <span class="hljs-comment">//数据写入Channel</span><br>&#125;()<br>i := &lt;-ch <span class="hljs-comment">//从Channel中取数据并赋值</span><br></code></pre></td></tr></table></figure><h4 id="7-通道缓冲"><a href="#7-通道缓冲" class="headerlink" title="7. 通道缓冲"></a>7. 通道缓冲</h4><ul><li>基于 <code>Channel</code> 的通信是同步的</li><li>当缓冲区满时，数据的发送是阻塞的</li><li>通过 <code>make</code> 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li><li>下面两个定义的区别？<ul><li><code>ch:= make(chan int)</code></li><li><code>ch:= make(chan int,1)</code></li></ul></li></ul><h4 id="8-遍历通道缓冲区"><a href="#8-遍历通道缓冲区" class="headerlink" title="8. 遍历通道缓冲区"></a>8. 遍历通道缓冲区</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>rand.Seed(time.Now().UnixNano())<br>n := rand.Intn(<span class="hljs-number">10</span>) <span class="hljs-comment">// n will be between 0 and 10</span><br>fmt.Println(<span class="hljs-string">&quot;putting: &quot;</span>, n)<br>ch &lt;- n<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;hello from main&quot;</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(<span class="hljs-string">&quot;receiving: &quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-单向通道"><a href="#9-单向通道" class="headerlink" title="9. 单向通道"></a>9. 单向通道</h4><ul><li>只发送通道<ul><li><code>var sendOnly chan&lt;- int</code></li></ul></li><li>只接收通道<ul><li><code>var readOnly &lt;-chan int</code></li></ul></li><li><code>Istio webhook controller</code><ul><li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li></ul></li><li>如何用: 双向通道转换</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> prod(c)<br><span class="hljs-keyword">go</span> consume(c)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prod</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>ch &lt;- <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>&lt;-ch<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-关闭通道"><a href="#10-关闭通道" class="headerlink" title="10. 关闭通道"></a>10. 关闭通道</h4><ul><li>通道无需每次关闭</li><li>关闭的作用是告诉接收者该通道再无新数据发送</li><li>只有发送方需要关闭通道</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br><span class="hljs-keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;<br>fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-select"><a href="#11-select" class="headerlink" title="11. select"></a>11. select</h4><ul><li>当多个协程同时运行时，可通过 <code>select</code> 轮询多个通道</li><li>如果所有通道都阻塞则等待，如定义了 <code>default</code> 则执行 <code>default</code></li><li>如多个通道就绪则随机选择</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-ch1:<br>...<br><span class="hljs-keyword">case</span> v := &lt;-ch2:<br>...<br><span class="hljs-keyword">default</span>:<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-定时器-Timer"><a href="#12-定时器-Timer" class="headerlink" title="12. 定时器 Timer"></a>12. 定时器 Timer</h4><ul><li><code>time.Ticker</code> 以指定的时间间隔重复的向通道 <code>C</code> 发送时间值</li><li>使用场景<ul><li>为协程设定超时时间</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">timer := time.NewTimer(time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// check normal channel</span><br><span class="hljs-keyword">case</span> &lt;-ch:<br>fmt.Println(<span class="hljs-string">&quot;received from ch&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br>fmt.Println(<span class="hljs-string">&quot;timeout waiting from channel ch&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-上下文-Context"><a href="#13-上下文-Context" class="headerlink" title="13. 上下文 Context"></a>13. 上下文 Context</h4><ul><li>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</li><li><code>Context</code> 是设置截止日期、同步信号，传递请求相关值的结构体</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用法<ul><li><code>context.Background</code></li><li><code>context.TODO</code></li><li><code>context.WithDeadline</code></li><li><code>context.WithValue</code></li><li><code>context.WithCancel</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如何停止一个子协程</span><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-done:<br>            fmt.Println(<span class="hljs-string">&quot;done channel is triggerred, exit child go routine&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(done)<br><br><span class="hljs-comment">// 基于 Context 停止子协程</span><br><span class="hljs-comment">// Context 是 Go 语言对 go routine 和 timer 的封装</span><br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">go</span> process(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br>&lt;-ctx.Done()<br>fmt.Println(<span class="hljs-string">&quot;main:&quot;</span>, ctx.Err())<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ctx context.Context, duration time.Duration)</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(duration):<br>        fmt.Println(<span class="hljs-string">&quot;process successfully&quot;</span>)<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        fmt.Println(<span class="hljs-string">&quot;process cancelled&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>context</code> 包, 可以取消 <code>goroutine</code> 的执行, 或者给 <code>goroutine</code> 设置 Deadline, 超时后 <code>goroutine</code> 会退出。</li></ul><p><strong>面试知识点:</strong></p><ul><li>Go 语言中如何实现并发编程？</li><li><code>goroutine</code> 和线程有什么区别？</li><li><code>channel</code> 的作用是什么？如何使用 <code>channel</code> 进行协程间通信？</li><li>如何实现一个有缓冲的 <code>channel</code>？</li><li>如何使用 <code>select</code> 语句处理多个 <code>channel</code>？</li><li>如何使用 <code>context</code> 包取消 <code>goroutine</code> 的执行？</li></ul><h3 id="课后练习-1-2"><a href="#课后练习-1-2" class="headerlink" title="课后练习 1.2"></a>课后练习 1.2</h3><ul><li>基于 <code>Channel</code> 编写一个简单的单线程生产者消费者模型<ul><li>队列：<br>队列长度 10，队列元素类型为 <code>int</code></li><li>生产者：<br>每 1 秒往队列中放入一个类型为 <code>int</code> 的元素，队列满时生产者可以阻塞</li><li>消费者：<br>每一秒从队列中获取一个元素并打印，队列为空时消费者阻塞</li></ul></li></ul><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>ch &lt;- i<br>fmt.Println(<span class="hljs-string">&quot;Produced:&quot;</span>, i)<br>i++<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>i := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;Consumed:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 缓冲大小为 10 的 channel</span><br><br><span class="hljs-keyword">go</span> producer(ch)<br><span class="hljs-keyword">go</span> consumer(ch)<br><br><span class="hljs-keyword">select</span> &#123;&#125; <span class="hljs-comment">// 阻塞主 goroutine，防止程序退出</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八、Go-Modules"><a href="#八、Go-Modules" class="headerlink" title="八、Go Modules"></a>八、Go Modules</h3><h4 id="1-为什么需要-Go-Modules"><a href="#1-为什么需要-Go-Modules" class="headerlink" title="1. 为什么需要 Go Modules"></a>1. 为什么需要 Go Modules</h4><p>在 Go 1.11 版本之前，Go 语言的依赖管理一直是一个痛点。<code>GOPATH</code> 模式存在以下问题：</p><ul><li><strong>项目必须放在 <code>$GOPATH/src</code> 目录下</strong>：限制了项目存放的位置，不够灵活。</li><li><strong>没有版本控制</strong>：无法指定项目依赖的特定版本，容易出现版本冲突。</li><li><strong>无法处理 vendor 依赖</strong>：无法将依赖包复制到项目内部，不利于项目的独立性和可移植性。</li></ul><p>Go Modules 的出现，解决了这些问题，成为了 Go 语言官方推荐的依赖管理方式。</p><h4 id="2-Go-Modules-的主要特性"><a href="#2-Go-Modules-的主要特性" class="headerlink" title="2. Go Modules 的主要特性"></a>2. Go Modules 的主要特性</h4><ul><li><strong>项目可以放在任何位置</strong>：不再受限于 <code>$GOPATH/src</code> 目录。</li><li><strong>版本控制</strong>：可以指定项目依赖的特定版本，解决了版本冲突问题。</li><li><strong>vendor 支持</strong>：可以将依赖包复制到项目内部的 <code>vendor</code> 目录，提高了项目的独立性和可移植性。</li><li><strong>模块代理</strong>：可以通过设置 <code>GOPROXY</code> 环境变量，使用模块代理加速依赖包的下载。</li></ul><h4 id="3-Go-Modules-的基本使用"><a href="#3-Go-Modules-的基本使用" class="headerlink" title="3. Go Modules 的基本使用"></a>3. Go Modules 的基本使用</h4><ul><li><strong>初始化模块</strong>：在项目根目录下执行 <code>go mod init &lt;module_name&gt;</code>，创建 <code>go.mod</code> 文件。</li><li><strong>添加依赖</strong>：执行 <code>go get &lt;package_name&gt;@&lt;version&gt;</code>，会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li><li><strong>构建项目</strong>：执行 <code>go build</code>，会自动下载并构建依赖。</li><li><strong>运行项目</strong>：执行 <code>go run</code>，会自动下载、构建并运行项目。</li><li><strong>整理依赖</strong>：执行 <code>go mod tidy</code>，会移除未使用的依赖，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li><li><strong>vendor 依赖</strong>：执行 <code>go mod vendor</code>，会将依赖包复制到项目内部的 <code>vendor</code> 目录。</li></ul><p><strong>面试知识点：</strong></p><ul><li>Go Modules 解决了 <code>GOPATH</code> 模式的哪些问题？</li><li><code>go.mod</code> 和 <code>go.sum</code> 文件有什么作用？</li><li>如何使用 Go Modules 添加、更新和删除依赖？</li><li>如何使用 vendor 依赖？</li></ul><h3 id="九、Go-语言与云原生"><a href="#九、Go-语言与云原生" class="headerlink" title="九、Go 语言与云原生"></a>九、Go 语言与云原生</h3><p>Go 语言的特性使其非常适合云原生应用开发：</p><ul><li><strong>高效的编译和执行速度</strong>：Go 语言的编译速度快，生成的二进制文件小，启动速度快，非常适合云原生环境下的快速部署和弹性伸缩。</li><li><strong>强大的并发编程支持</strong>：Go 语言的 goroutine 和 channel 机制，可以轻松编写高并发程序，充分利用多核处理器，提高应用的吞吐量和响应速度。</li><li><strong>简洁的语法和丰富的标准库</strong>：Go 语言的语法简洁易学，标准库功能丰富，可以减少开发者的工作量，提高开发效率。</li><li><strong>跨平台编译</strong>：Go 语言支持交叉编译，可以方便地为不同的操作系统和处理器架构构建应用。</li><li><strong>容器友好</strong>：Go 语言生成的二进制文件不依赖于外部库，非常适合打包成 Docker 镜像，方便部署和管理。</li></ul><p>Go 语言已经成为云原生领域的主流语言，许多知名的云原生项目都是用 Go 语言开发的，例如：</p><ul><li><strong>Docker</strong>：容器引擎。</li><li><strong>Kubernetes</strong>：容器编排平台。</li><li><strong>Istio</strong>：服务网格。</li><li><strong>Etcd</strong>：分布式键值存储。</li><li><strong>Prometheus</strong>：监控系统。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker核心技术</title>
    <link href="/2025/03/16/docker/"/>
    <url>/2025/03/16/docker/</url>
    
    <content type="html"><![CDATA[<p>Cgroups,Namespace,Union FS</p> <span id="more"></span><h3 id="1-从系统架构谈起：传统分层架构-vs-微服务"><a href="#1-从系统架构谈起：传统分层架构-vs-微服务" class="headerlink" title="1. 从系统架构谈起：传统分层架构 vs 微服务"></a>1. 从系统架构谈起：传统分层架构 vs 微服务</h3><p>在深入 Docker 之前，我们先来聊聊系统架构的演变。</p><h4 id="传统分层架构"><a href="#传统分层架构" class="headerlink" title="传统分层架构"></a>传统分层架构</h4><p>传统的单体应用通常采用分层架构，如下图所示：</p><img src="/2025/03/16/docker/image-20250316235507888.png" class="" title="image-20250316235507888"><pre class="mermaid">graph LR    A[Presentation Layer] --> B(Business Logic Layer)    B --> C(Data Access Layer)    C --> D{Database}</pre><p><strong>优点：</strong></p><ul><li>对于简单的系统，易于部署、测试和横向扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>对于复杂的系统：<ul><li>难以理解整体</li><li>不易快速维护</li><li>启动和部署慢</li><li>变更引起的回归问题多</li><li>难以持续集成和持续部署</li></ul></li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>为了解决传统分层架构的痛点，微服务架构应运而生。它将一个庞大的系统分解成多个独立的小服务，每个服务负责特定的业务功能。</p><img src="/2025/03/16/docker/image-20250316235512635.png" class="" title="image-20250316235512635"><pre class="mermaid">graph LR    subgraph Microservices        A[Service 1] -->|API| B(API Gateway)        C[Service 2] -->|API| B        D[Service 3] -->|API| B    end    B --> E{External Services}</pre><p><strong>优点：</strong></p><ul><li>系统部署更快，更易理解和维护。</li><li>不同服务可由不同团队维护，分工更细。</li><li>可自主选择技术栈。</li><li>易于持续集成和持续部署。</li><li>每个微服务独立扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂性（分布式部署）。</li><li>需要处理分布式系统的复杂问题（如进程间通信、部分失败）。</li><li>分布式事务更复杂（失败回滚）。</li><li>测试和部署监控更复杂。</li></ul><h4 id="微服务改造"><a href="#微服务改造" class="headerlink" title="微服务改造"></a>微服务改造</h4><p>将单体应用拆分成微服务，可以遵循以下原则：</p><ul><li><strong>分离业务逻辑：</strong> 审视并发现可以分离的业务逻辑。</li><li><strong>寻找隔离模块：</strong> 寻找天生隔离的代码模块（可借助静态代码分析工具）。</li><li><strong>考虑性能需求：</strong> 不同并发规模、不同内存需求的模块可分离成不同的微服务。</li></ul><p>一些常用的可微服务化的组件：</p><ul><li>用户和账户管理</li><li>授权和会话管理</li><li>系统配置</li><li>通知和通讯服务</li><li>照片、多媒体、元数据等</li></ul><p><strong>分解原则：</strong> 基于 size, scope and capabilities</p><h4 id="微服务间通讯"><a href="#微服务间通讯" class="headerlink" title="微服务间通讯"></a>微服务间通讯</h4><p>微服务之间通常有两种通讯方式：</p><ol><li><p><strong>点对点：</strong></p><ul><li>多用于系统内部组件间通讯。</li><li>存在大量重复模块（如认证授权）。</li><li>缺少统一规范（如监控、审计）。</li><li>后期维护成本高。</li></ul></li><li><p><strong>API 网关：</strong></p><ul><li>基于一个轻量级的 message gateway。</li><li>新 API 通过注册至 Gateway 实现。</li><li>整合实现 Common function。</li></ul></li></ol><h3 id="2-理解-Docker"><a href="#2-理解-Docker" class="headerlink" title="2. 理解 Docker"></a>2. 理解 Docker</h3><p>Docker 是一种容器化技术，可以将应用程序及其依赖项打包到一个可移植的容器中，从而实现快速部署、一致的运行环境和高效的资源利用。</p><h4 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h4><ul><li>Docker 基于 Linux 内核的 Cgroup、Namespace 以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li><li>Docker 容器独立于宿主机和其他容器。</li><li>Docker 在容器的基础上进行了进一步的封装，简化了容器的创建和维护。</li></ul><h4 id="为什么要用-Docker？"><a href="#为什么要用-Docker？" class="headerlink" title="为什么要用 Docker？"></a>为什么要用 Docker？</h4><ul><li><strong>更高效地利用系统资源：</strong> 容器共享宿主机内核，资源开销更小。</li><li><strong>更快速的启动时间：</strong> 容器启动只需几秒钟，远快于虚拟机。</li><li><strong>一致的运行环境：</strong> 容器打包了应用程序及其依赖项，保证在不同环境中的一致性。</li><li><strong>持续交付和部署：</strong> 容器易于构建、测试和部署，方便实现持续交付。</li><li><strong>更轻松地迁移：</strong> 容器可轻松迁移到不同的平台和环境。</li><li><strong>更轻松地维护和扩展：</strong> 容器易于管理和扩展，可根据需求动态调整资源。</li></ul><h4 id="虚拟机和容器运行态的对比"><a href="#虚拟机和容器运行态的对比" class="headerlink" title="虚拟机和容器运行态的对比"></a>虚拟机和容器运行态的对比</h4><img src="/2025/03/16/docker/image-20250316235519406.png" class="" title="image-20250316235519406"><pre class="mermaid">graph LR    subgraph 虚拟机        A[虚拟机 1] --> B(Hypervisor)        C[虚拟机 2] --> B        D[虚拟机 3] --> B        B --> E(Host OS)        E --> F{Hardware}    end    subgraph 容器        G[容器 1] --> H(Docker Engine)        I[容器 2] --> H        J[容器 3] --> H        H --> K(Host OS)        K --> L{Hardware}    end</pre><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机上千个容器</td><td>一般几十个</td></tr></tbody></table><h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><p>在 Ubuntu 上安装 Docker 的步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 更新 apt 包索引</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 2. 安装依赖包</span><br><span class="hljs-built_in">sudo</span> apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg-agent \<br>    software-properties-common<br><br><span class="hljs-comment"># 3. 添加 Docker 的官方 GPG 密钥</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> apt-key add -<br><br><span class="hljs-comment"># 4. 设置稳定版仓库</span><br><span class="hljs-built_in">sudo</span> add-apt-repository \<br>   <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">   <span class="hljs-subst">$(lsb_release -cs)</span> \</span><br><span class="hljs-string">   stable&quot;</span><br><br><span class="hljs-comment"># 5. 再次更新 apt 包索引</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 6. 安装 Docker Engine</span><br><span class="hljs-built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul><li><strong>启动容器：</strong><ul><li><code>docker run</code>：创建并启动一个新的容器。<ul><li><code>-it</code>：交互式运行。</li><li><code>-d</code>：后台运行。</li><li><code>-p</code>：端口映射。</li><li><code>-v</code>：磁盘挂载。</li></ul></li><li><code>docker start</code>：启动已终止的容器。</li></ul></li><li><strong>停止容器：</strong><ul><li><code>docker stop</code>：停止正在运行的容器。</li></ul></li><li><strong>查看容器进程：</strong><ul><li><code>docker ps</code>：列出正在运行的容器。</li><li><code>docker ps -a</code>：列出所有容器（包括已停止的）。</li></ul></li><li><strong>查看容器细节</strong></li></ul><pre><code class="hljs">* `docker inspect &lt;containerid&gt;`</code></pre><ul><li><strong>进入容器</strong><ul><li><code>docker attach</code></li><li><code>nsenter</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PID=$(docker inspect --format <span class="hljs-string">&quot;&#123;&#123; .State.Pid &#125;&#125;&quot;</span><br>&lt;container&gt;)<br>$ nsenter --target <span class="hljs-variable">$PID</span> --mount --uts --ipc --net --pid<br></code></pre></td></tr></table></figure></li><li><strong>拷贝文件至容器内</strong><ul><li><code>docker cp file1 &lt;containerid&gt;:/file-to-path</code></li></ul></li></ul><h4 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h4><p>让我们通过一个简单的例子来体验 Docker 的魅力。</p><ol><li><p><strong>编写 Dockerfile：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">ENV</span> MY_SERVICE_PORT=<span class="hljs-number">80</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> bin/amd64/httpserver /httpserver</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> /httpserver</span><br></code></pre></td></tr></table></figure><ul><li><code>FROM</code>：指定基础镜像（这里使用 Ubuntu）。</li><li><code>ENV</code>：设置环境变量。</li><li><code>ADD</code>：将本地文件复制到容器中。</li><li><code>ENTRYPOINT</code>：指定容器启动时执行的命令。</li></ul></li><li><p><strong>构建镜像：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t cncamp/httpserver:<span class="hljs-variable">$&#123;tag&#125;</span> .<br>docker push cncamp/httpserver:v1.0<br></code></pre></td></tr></table></figure><ul><li><code>-t</code>：指定镜像的名称和标签。</li><li><code>.</code>：表示 Dockerfile 所在的当前目录。</li></ul></li><li><p><strong>运行容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d cncamp/httpserver:v1.0<br></code></pre></td></tr></table></figure></li></ol><h4 id="容器标准"><a href="#容器标准" class="headerlink" title="容器标准"></a>容器标准</h4><p>为了规范容器技术的发展，业界制定了 OCI（Open Container Initiative）标准。</p><ul><li><strong>OCI 是什么？</strong><ul><li>一个轻量级开放式管理组织。</li><li>主要定义两个规范：<ul><li><strong>Runtime Specification：</strong> 定义如何解压文件系统包并在运行时运行。</li><li><strong>Image Specification：</strong> 定义如何打包镜像、生成清单、文件系统序列化文件和镜像配置。</li></ul></li></ul></li></ul><h4 id="容器主要特性"><a href="#容器主要特性" class="headerlink" title="容器主要特性"></a>容器主要特性</h4><ul><li><strong>安全性：</strong> 容器提供了隔离的运行环境，增强了安全性。</li><li><strong>便携性：</strong> 容器可在不同平台和环境中轻松迁移。</li><li><strong>隔离性：</strong> 容器之间相互隔离，互不影响。</li><li><strong>可配额：</strong> 可对容器的资源使用进行限制。</li></ul><h3 id="3-Docker-核心技术：Namespace、Cgroups、UnionFS"><a href="#3-Docker-核心技术：Namespace、Cgroups、UnionFS" class="headerlink" title="3. Docker 核心技术：Namespace、Cgroups、UnionFS"></a>3. Docker 核心技术：Namespace、Cgroups、UnionFS</h3><p>Docker 的核心技术主要包括 Namespace、Cgroups 和 UnionFS。</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>Namespace 是 Linux 内核提供的一种资源隔离方案。它可以为进程分配不同的 Namespace，保证不同 Namespace 下的资源独立分配，进程彼此隔离。</p><ul><li><p><strong>Linux 内核代码中 Namespace 的实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进程数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-comment">/* namespaces */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> *<span class="hljs-title">nsproxy</span>;</span><br>    ...<br>&#125;<br><br><span class="hljs-comment">// Namespace 数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> &#123;</span><br>    <span class="hljs-type">atomic_t</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uts_namespace</span> *<span class="hljs-title">uts_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ipc_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mnt_namespace</span> *<span class="hljs-title">mnt_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns_for_children</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net_ns</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Linux 对 Namespace 操作方法：</strong></p><ul><li><code>clone</code>：创建新进程时，可通过 <code>flags</code> 参数指定需要新建的 Namespace 类型。</li><li><code>setns</code>：将调用进程加入某个已存在的 Namespace。</li><li><code>unshare</code>：将调用进程移动到新的 Namespace。</li></ul></li><li><p><strong>Namespace 类型：</strong></p><table><thead><tr><th>Namespace 类型</th><th>隔离资源</th><th>Kernel 版本</th></tr></thead><tbody><tr><td>IPC</td><td>System V IPC 和 POSIX 消息队列</td><td>2.6.19</td></tr><tr><td>Network</td><td>网络设备、网络协议栈、网络端口等</td><td>2.6.29</td></tr><tr><td>PID</td><td>进程</td><td>2.6.14</td></tr><tr><td>Mount</td><td>挂载点</td><td>2.4.19</td></tr><tr><td>UTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>User</td><td>用户和用户组</td><td>3.8</td></tr></tbody></table></li><li><p><strong>Namespace 常用操作：</strong></p><ul><li>查看当前系统的 namespace：<code>lsns -t &lt;type&gt;</code></li><li>查看某进程的 namespace：<code>ls -la /proc/&lt;pid&gt;/ns/</code></li><li>进入某 namespace 运行命令：<code>nsenter -t &lt;pid&gt; -n ip addr</code></li></ul></li><li><p><strong>Namespace 练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在新 network namespace 执行 sleep 指令</span><br>unshare -fn <span class="hljs-built_in">sleep</span> 60<br><br><span class="hljs-comment"># 查看进程信息</span><br>ps -ef | grep <span class="hljs-built_in">sleep</span><br><br><span class="hljs-comment"># 查看网络 Namespace</span><br>lsns -t net<br><br><span class="hljs-comment"># 进入该进程所在 Namespace 查看网络配置</span><br>nsenter -t &lt;pid&gt; -n ip a<br></code></pre></td></tr></table></figure></li></ul><h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><p>Cgroups（Control Groups）是 Linux 下用于对一个或一组进程进行资源控制和监控的机制。它可以对 CPU 使用时间、内存、磁盘 I&#x2F;O 等进程所需的资源进行限制。</p><ul><li><p><strong>Linux 内核代码中 Cgroups 的实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CGROUPS</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cgroups</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cg_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Set of subsystem states, one for each subsystem. This array is</span><br><span class="hljs-comment">    * immutable after creation apart from the init_css_set during</span><br><span class="hljs-comment">    * subsystem registration (at boot time).</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">subsys</span>[<span class="hljs-title">CGROUP_SUBSYS_COUNT</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>Cgroups 子系统：</strong></p><table><thead><tr><th>子系统</th><th>作用</th></tr></thead><tbody><tr><td>blkio</td><td>限制每个块设备的输入输出</td></tr><tr><td>cpu</td><td>使用调度程序为 cgroup 任务提供 CPU 的访问</td></tr><tr><td>cpuacct</td><td>产生 cgroup 任务的 CPU 资源报告</td></tr><tr><td>cpuset</td><td>为 cgroup 任务分配单独的 CPU 和内存</td></tr><tr><td>devices</td><td>允许或拒绝 cgroup 任务对设备的访问</td></tr><tr><td>freezer</td><td>暂停和恢复 cgroup 任务</td></tr><tr><td>memory</td><td>设置每个 cgroup 的内存限制以及产生内存资源报告</td></tr><tr><td>net_cls</td><td>标记每个网络包以供 cgroup 方便使用</td></tr><tr><td>ns</td><td>名称空间子系统</td></tr><tr><td>pid</td><td>进程标识子系统</td></tr></tbody></table></li><li><p><strong>CPU 子系统：</strong></p><ul><li><code>cpu.shares</code>：可出让的能获得 CPU 使用时间的相对值。</li><li><code>cpu.cfs_period_us</code>：时间周期长度（微秒）。</li><li><code>cpu.cfs_quota_us</code>：当前 Cgroup 在 <code>cfs_period_us</code> 时间内最多能使用的 CPU 时间数（微秒）。</li><li><code>cpu.stat</code>：Cgroup 内的进程使用的 CPU 时间统计。<ul><li><code>nr_periods</code>：经过 <code>cpu.cfs_period_us</code> 的时间周期数量。</li><li><code>nr_throttled</code>：进程受限次数。</li><li><code>throttled_time</code>：进程被限制使用 CPU 的总用时（纳秒）。</li></ul></li></ul></li><li><p><strong>Linux 调度器：</strong></p><ul><li><strong>Stop 调度器（<code>stop_sched_class</code>）：</strong> 优先级最高，可抢占其他所有进程。</li><li><strong>Deadline 调度器（<code>dl_sched_class</code>）：</strong> 使用红黑树，按绝对截止期限排序进程。</li><li><strong>RT 调度器（<code>rt_sched_class</code>）：</strong> 实时调度器，为每个优先级维护一个队列。</li><li><strong>CFS 调度器（<code>cfs_sched_class</code>）：</strong> 完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念。</li><li><strong>IDLE-Task 调度器（<code>idle_sched_class</code>）：</strong> 空闲调度器，每个 CPU 都有一个 idle 线程。</li></ul></li><li><p><strong>CFS 调度器：</strong></p><ul><li>维护任务提供处理器时间方面的平衡。</li><li>通过虚拟运行时间（vruntime）来实现平衡。</li><li><code>vruntime = 实际运行时间 * 1024 / 进程权重</code></li><li>进程按各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</li></ul><img src="/2025/03/16/docker/image-20250316235528868.png" class="" title="image-20250316235528868"></li></ul><pre class="mermaid">graph LR    subgraph 红黑树    A[vruntime 最小] --> B    B --> C    C --> D    D --> E[vruntime 最大]    end</pre><ul><li><p><strong>CFS 进程调度：</strong></p><ol><li>时钟周期开始时，调用 <code>__schedule()</code> 函数。</li><li><code>__schedule()</code> 调用 <code>pick_next_task()</code> 选择最合适的进程（红黑树最左边的节点）。</li><li>通过 <code>context_switch()</code> 切换到新的地址空间，保证进程运行。</li><li>时钟周期结束时，调用 <code>entity_tick()</code> 函数更新进程负载、状态和 vruntime。</li><li>将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，决定是否触发调度。</li></ol></li><li><p><strong>CPU 子系统练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cgroup cpu 子系统目录中创建目录结构</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu<br><span class="hljs-built_in">mkdir</span> cpudemo<br><span class="hljs-built_in">cd</span> cpudemo<br><br><span class="hljs-comment"># 运行 busyloop</span><br><br><span class="hljs-comment"># 查看 CPU 使用情况</span><br>top<br><br><span class="hljs-comment"># 通过 cgroup 限制 cpu</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu/cpudemo<br><br><span class="hljs-comment"># 把进程添加到 cgroup 进程配置组</span><br><span class="hljs-built_in">echo</span> $(ps -ef | grep busyloop | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>) &gt; cgroup.procs<br><br><span class="hljs-comment"># 设置 cpuquota</span><br><span class="hljs-built_in">echo</span> 10000 &gt; cpu.cfs_quota_us<br><br><span class="hljs-comment"># 再次查看 CPU 使用情况</span><br>top<br></code></pre></td></tr></table></figure></li><li><p><strong>cpuacct 子系统：</strong></p><ul><li><code>cpuacct.usage</code>：Cgroup 及其子 Cgroup 下进程使用 CPU 的时间（纳秒）。</li><li><code>cpuacct.stat</code>：Cgroup 及其子 Cgroup 下进程使用的 CPU 时间（用户态和内核态）。</li></ul></li><li><p><strong>Memory 子系统：</strong></p><ul><li><code>memory.usage_in_bytes</code>：Cgroup 下进程使用的内存。</li><li><code>memory.max_usage_in_bytes</code>：Cgroup 下进程使用内存的最大值。</li><li><code>memory.limit_in_bytes</code>：设置 Cgroup 下进程最多能使用的内存。</li><li><code>memory.soft_limit_in_bytes</code>：软限制，系统内存足够时优先回收超过限额的内存。</li><li><code>memory.oom_control</code>：设置是否在 Cgroup 中使用 OOM Killer。</li></ul></li><li><p><strong>Cgroup driver：</strong></p><ul><li><strong>systemd：</strong> 当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup 管理器。</li><li><strong>cgroupfs：</strong> Docker 默认使用 cgroupfs 作为 cgroup 驱动。<ul><li><strong>存在问题：</strong> 在 systemd 作为 init system 的系统中，可能存在两套 group driver，导致管理混乱。</li><li><strong>建议：</strong> 将 kubelet 的 <code>--cgroup-driver</code> 设置为 <code>systemd</code>。</li></ul></li></ul></li><li><p><strong>课后练习 3.1：Memory 子系统练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cgroup memory 子系统目录中创建目录结构</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory<br><span class="hljs-built_in">mkdir</span> memorydemo<br><span class="hljs-built_in">cd</span> memorydemo<br><br><span class="hljs-comment"># 运行 malloc（在 linux 机器 make build）</span><br><br><span class="hljs-comment"># 查看内存使用情况</span><br>watch <span class="hljs-string">&#x27;ps -aux|grep malloc|grep -v grep&#x27;</span><br><br><span class="hljs-comment"># 通过 cgroup 限制 memory</span><br><span class="hljs-comment"># 把进程添加到 cgroup 进程配置组</span><br><span class="hljs-built_in">echo</span> $(ps -ef | grep malloc | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>) &gt; cgroup.procs<br><br><span class="hljs-comment"># 设置 memory.limit_in_bytes</span><br><span class="hljs-built_in">echo</span> 104960000 &gt; memory.limit_in_bytes<br><br><span class="hljs-comment"># 等待进程被 oom kill</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Union-FS"><a href="#Union-FS" class="headerlink" title="Union FS"></a>Union FS</h4><p>Union FS 是一种将不同目录挂载到同一个虚拟文件系统下的文件系统。</p><ul><li><p><strong>特点：</strong></p><ul><li>支持为每一个成员目录设定 readonly、readwrite 和 whiteout-able 权限。</li><li>文件系统分层，对 readonly 权限的 branch 可以逻辑上进行修改（增量地，不影响 readonly 部分）。</li></ul></li><li><p><strong>用途：</strong></p><ul><li>将多个 disk 挂到同一个目录下。</li><li>将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起。</li></ul><img src="/2025/03/16/docker/image-20250316235535631.png" class="" title="image-20250316235535631"></li></ul><pre class="mermaid">graph LR    subgraph Union FS        A[Read-Only Layer 1] --> C(Merged View)        B[Read-Write Layer 2] --> C    end</pre><h4 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h4><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile-java:</span><br><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y default-jre</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /app.jar</span><br><span class="hljs-keyword">EntryPoint</span><span class="language-bash"> [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;app1.jar&quot;</span>]</span><br><br><span class="hljs-comment"># Dockerfile-elasticsearch:</span><br><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y default-jre</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget elasticseach</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> untar elasticseach</span><br><span class="hljs-keyword">EntryPoint</span><span class="language-bash">: [<span class="hljs-string">&quot;./elasticseach&quot;</span>]</span><br></code></pre></td></tr></table></figure><pre class="mermaid">graph LR    subgraph "myapp:v1.0"        A["BaseImage(ubuntu)"] --> B("install default-jre")        B --> C("copy app1.jar")        C --> D("EntryPoint: [Java, app1.jar]")    end    subgraph "elasticsearch:v7.14"        E["BaseImage(ubuntu)"] --> F("install default-jre")        F --> G("wget elasticseach")        G --> H("untar elasticseach")        H --> I("EntryPoint: [./elasticseach]")    end    subgraph "通用层"    A --> B    E --> F    end</pre><img src="/2025/03/16/docker/image-20250316235712098.png" class="" title="image-20250316235712098"><h4 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h4><p>典型的 Linux 文件系统组成：</p><ul><li><strong>Bootfs（boot file system）：</strong><ul><li>Bootloader：引导加载 kernel。</li><li>Kernel：当 kernel 被加载到内存中后 umount bootfs。</li></ul></li><li><strong>rootfs（root file system）：</strong><ul><li><code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件。</li><li>不同的 linux 发行版，bootfs 基本一致，但 rootfs 会有差别。</li></ul></li></ul><p><strong>Docker 启动：</strong></p><ul><li>Linux：启动后，首先将 rootfs 设置为 readonly，进行一系列检查，然后将其切换为 “readwrite” 供用户使用。</li><li>Docker：初始化时也是将 rootfs 以 readonly 方式加载并检查，然后利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上。</li></ul><img src="/2025/03/16/docker/image-20250316235736584.png" class="" title="image-20250316235736584"><pre class="mermaid">graph LR    subgraph Docker File System        A["Read-Only Layer 1 (Base Image)"] --> C(Container Layer - Read-Write)        B[Read-Only Layer 2] --> C        C --> D{Running Container}    end</pre><p><strong>写操作：</strong></p><ul><li><strong>写时复制（Copy-on-Write）：</strong><ul><li>一个镜像可以被多个容器使用，不需要在内存和磁盘上做多个拷贝。</li><li>需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改。</li><li>不同容器对文件的修改相互独立。</li></ul></li><li><strong>用时分配：</strong><ul><li>按需分配空间，而非提前分配。</li></ul></li></ul><h4 id="容器存储驱动"><a href="#容器存储驱动" class="headerlink" title="容器存储驱动"></a>容器存储驱动</h4><table><thead><tr><th>存储驱动</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>AUFS</td><td>Docker 最早支持的驱动类型，稳定性高</td><td>未进入主线内核，只能在有限场合下使用。实现上具有多层结构，在层比较多的场景下，做写时复制有时会需要比较长的时间</td><td>少 I&#x2F;O 的场景</td></tr><tr><td>OverlayFS</td><td>并入主线内核，可在几乎所有发行版本上使用。实现上只有两层，性能比 AUFS 高</td><td>写时复制机制需要复制整个文件，不能只针对修改部分进行复制，对大文件操作会需要比较长的时间。其中 Overlay 在 Docker 的后续版本中被移除</td><td>少 I&#x2F;O 的场景</td></tr><tr><td>Device Mapper</td><td>并入主线内核，针对块操作，性能比较高。修改文件时只需复制需要修改的块，效率高</td><td>不同容器之间不能共享缓存。在 Docker 的后续版本中会被移除</td><td>I&#x2F;O 密集场景</td></tr><tr><td>BtrFS</td><td>并入主线内核，虽然是文件级操作系统，但是可以对块进行操作。</td><td>需要消耗比较多的内存，稳定性相对比较差</td><td>需要支持 Snapshot 等比较特</td></tr><tr><td>ZFS</td><td>不同的容器之间可以共享缓存，多个容器访问相同的文件能够共享一个单一的 Page Cache。</td><td>在频繁写操作的场景下，会产生比较严重的磁盘碎片。需要消耗比较多的内存，另外稳定性相对比较差</td><td>容器高密度部署的场景</td></tr></tbody></table><p><strong>以 OverlayFS 为例：</strong></p><ul><li>OverlayFS 是一种与 AUFS 类似的联合文件系统，属于文件级的存储驱动。</li><li>包含最初的 Overlay 和更新更稳定的 overlay2。</li><li>Overlay 只有两层：upper 层和 lower 层。<ul><li>Lower 层：镜像层。</li><li>Upper 层：容器可写层。</li></ul></li></ul><p><strong>OverlayFS 文件系统练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> upper lower merged work<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from lower&quot;</span> &gt; lower/in_lower.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from upper&quot;</span> &gt; upper/in_upper.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from lower&quot;</span> &gt; lower/in_both.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from upper&quot;</span> &gt; upper/in_both.txt<br><span class="hljs-built_in">sudo</span> mount -t overlay overlay -o lowerdir=`<span class="hljs-built_in">pwd</span>`/lower,upperdir=`<span class="hljs-built_in">pwd</span>`/upper,workdir=`<span class="hljs-built_in">pwd</span>`/work `<span class="hljs-built_in">pwd</span>`/merged<br><span class="hljs-built_in">cat</span> merged/in_both.txt<br><span class="hljs-built_in">rm</span> merged/in_both.txt<br><span class="hljs-built_in">rm</span> merged/in_lower.txt<br><span class="hljs-built_in">rm</span> merged/in_upper.txt<br></code></pre></td></tr></table></figure><h4 id="OCI-容器标准"><a href="#OCI-容器标准" class="headerlink" title="OCI 容器标准"></a>OCI 容器标准</h4><ul><li><strong>Open Container Initiative：</strong><ul><li>OCI 组织于 2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织。</li><li>OCI 定义了镜像标准（Runtime Specification）、运行时标准（Image Specification）和分发标准（Distribution Specification）。<ul><li>镜像标准：定义应用如何打包。</li><li>运行时标准：定义如何解压应用包并运行。</li><li>分发标准：定义如何分发容器镜像。</li></ul></li></ul></li></ul><h4 id="Docker-引擎架构"><a href="#Docker-引擎架构" class="headerlink" title="Docker 引擎架构"></a>Docker 引擎架构</h4><img src="/2025/03/16/docker/image-20250316235742348.png" class="" title="image-20250316235742348"><pre class="mermaid">graph LR    A[Docker Client] --> B(Docker Daemon)    B --> C{Images}    B --> D{Containers}    B --> E{Networks}    B --> F{Volumes}</pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li><p><strong>Null（<code>--net=None</code>）：</strong></p><ul><li>把容器放入独立的网络空间但不做任何网络配置。</li><li>用户需要通过运行 docker network 命令来完成网络配置。</li></ul></li><li><p><strong>Host：</strong></p><ul><li>使用主机网络名空间，复用主机网络。</li></ul></li><li><p><strong>Container：</strong></p><ul><li>重用其他容器的网络。</li></ul></li><li><p><strong>Bridge（<code>--net=bridge</code>）：</strong></p><ul><li>使用 Linux 网桥和 iptables 提供容器互联。</li><li>Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint。</li></ul><img src="/2025/03/16/docker/image-20250316235751842.png" class="" title="image-20250316235751842"></li></ul><pre class="mermaid">graph LR    subgraph Host        A[Container 1] -->|veth pair| B(docker0 bridge)        C[Container 2] -->|veth pair| B        B --> D{External Network}    end</pre><ul><li><p><strong>Overlay（libnetwork, libkv）：</strong></p><ul><li>通过网络封包实现。</li></ul></li><li><p><strong>Remote (work with remote drivers)</strong></p><ul><li>Underlay<ul><li>使用现有底层网络，为每一个容器配置可路由的网络 IP。</li></ul></li><li>Overlay<ul><li>通过网络封包实现。</li></ul></li></ul></li><li><p><strong>Null 模式</strong></p><ul><li>Null 模式是一个空实现；</li><li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /var/run/netns<br>find -L /var/run/netns -<span class="hljs-built_in">type</span> l -delete<br><span class="hljs-built_in">ln</span> -s /proc/<span class="hljs-variable">$pid</span>/ns/net /var/run/netns/<span class="hljs-variable">$pid</span><br>ip <span class="hljs-built_in">link</span> add A <span class="hljs-built_in">type</span> veth peer name B<br>brctl addif br0 A<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> A up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> B netns <span class="hljs-variable">$pid</span><br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev B name eth0<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip addr add<br><span class="hljs-variable">$SETIP</span>/<span class="hljs-variable">$SETMASK</span> dev eth0<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip route add default via<br><span class="hljs-variable">$GATEWAY</span><br></code></pre></td></tr></table></figure></li><li><p><strong>默认模式– 网桥和 NAT</strong></p></li><li><img src="/2025/03/16/docker/image-20250316235758666.png" class="" title="image-20250316235758666"><pre class="mermaid">    graph LR    subgraph Host A        A[Container 1] -->|eth0 172.17.0.2| B(veth)        B --> C(docker0 172.17.0.1/16)        D[Container 2] -->|eth0 172.17.0.3| E(veth)        E --> C        C -->|NAT| F(eth0 192.168.0.101)    end</pre><ul><li>为主机 eth0 分配 IP 192.168.0.101。</li><li>启动 docker daemon，查看主机 iptables。<ul><li><code>POSTROUTING -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code></li></ul></li><li>在主机启动容器：<ul><li><code>docker run -d --name ssh -p 2333:22 centos-ssh</code></li><li>Docker 会以标准模式配置网络：<ul><li>创建 veth pair。</li><li>将 veth pair 的一端连接到 docker0 网桥。</li><li>veth pair 的另外一端设置为容器名空间的 eth0。</li><li>为容器名空间的 eth0 分配 ip。</li><li>主机上的 Iptables 规则：<code>PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp --dport 2333 -j DNAT --to-destination 172.17.0.2:22</code>。</li></ul></li></ul></li></ul></li><li><p><strong>Underlay</strong></p><img src="/2025/03/16/docker/image-20250316235807168.png" class="" title="image-20250316235807168"><pre class="mermaid">  graph LR    subgraph Host A        A[Container 1] -->|eth0 10.249.67.31| B(veth)        B --> C(mydr0 10.249.67.30)        D[Container 2] -->|eth0 10.249.67.32| E(veth)        E --> C        C -->|eth0| F{External Network}    end</pre><ul><li>采用 Linux 网桥设备（<code>brctl</code>），通过物理网络连通容器。</li><li>创建新的网桥设备 mydr0。</li><li>将主机网卡加入网桥。</li><li>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 mydr0。</li><li>启动容器。</li><li>创建 veth 对，并且把一个 peer 添加到网桥 mydr0。</li><li>配置容器把 veth 的另一个 peer 分配给容器网卡。</li></ul></li><li><p><strong>Docker Libnetwork Overlay</strong></p><ul><li>Docker overlay 网络驱动原生支持多主机网络。</li><li>Libnetwork 是一个内置的基于 VXLAN 的网络驱动。</li></ul></li></ul><h4 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h4><img src="/2025/03/16/docker/image-20250316235814269.png" class="" title="image-20250316235814269"><pre class="mermaid">graph LR    subgraph Host 1        A[VM 1] --> B(VXLAN Tunnel Endpoint)        B -->|VXLAN Encapsulation| C(Underlay Network)    end    subgraph Host 2        C --> D(VXLAN Tunnel Endpoint)        D --> E[VM 2]    end</pre><h4 id="Overlay-network-sample-–-Flannel"><a href="#Overlay-network-sample-–-Flannel" class="headerlink" title="Overlay network sample – Flannel"></a>Overlay network sample – Flannel</h4><img src="/2025/03/16/docker/image-20250316235818388.png" class="" title="image-20250316235818388"><pre class="mermaid">graph LR    subgraph Host 1        A[Pod 1] -->|Bridge| B(Flannel)        B -->|UDP Encapsulation| C(Underlay Network)    end    subgraph Host 2        C --> D(Flannel)        D -->|Bridge| E[Pod 2]    end</pre><ul><li>同一主机内的 Pod 可以使用网桥进行通信。</li><li>不同主机上的 Pod 将通过 flanneld 将其流量封装在 UDP 数据包中。</li></ul><h4 id="Flannel-packet-sample"><a href="#Flannel-packet-sample" class="headerlink" title="Flannel packet sample"></a>Flannel packet sample</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">Outer</span> Ethernet <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Outer</span> IP <span class="hljs-keyword">Header</span>]<br>[UDP <span class="hljs-keyword">Header</span>]<br>[VXLAN <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Inner</span> Ethernet <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Inner</span> IP <span class="hljs-keyword">Header</span>]<br>[Payload]<br></code></pre></td></tr></table></figure><h4 id="创建-docker-镜像"><a href="#创建-docker-镜像" class="headerlink" title="创建 docker 镜像"></a>创建 docker 镜像</h4><ul><li><strong>定义 dockerfile</strong><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-comment"># so apt - get doesn&#x27;t complain</span><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND=noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/^exit 101/exit 0/&#x27;</span> /usr/sbin/policy-rc.d</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> \</span><br><span class="language-bash">apt-get update &amp;&amp; \</span><br><span class="language-bash">apt-get install -y ca-certificates &amp;&amp; \</span><br><span class="language-bash">apt-get install -y curl &amp;&amp; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> ./bin/eic eic</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/eic&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><strong>docker build</strong></li></ul><h3 id="4-Dockerfile-的最佳实践"><a href="#4-Dockerfile-的最佳实践" class="headerlink" title="4. Dockerfile 的最佳实践"></a>4. Dockerfile 的最佳实践</h3><h4 id="回顾-12-Factor-之进程"><a href="#回顾-12-Factor-之进程" class="headerlink" title="回顾 12 Factor 之进程"></a>回顾 12 Factor 之进程</h4><ul><li>运行环境中，应用程序通常是以一个和多个进程运行的。</li><li>12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。</li><li>任何需要持久化的数据都要存储在后端服务内，比如数据库。</li><li>应在构建阶段将源代码编译成待执行应用。</li><li>Session Sticky 是 12-Factor 极力反对的。</li><li>Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</li></ul><p>Docker 遵循以上原则管理和构建应用。</p><h4 id="理解构建上下文（Build-Context）"><a href="#理解构建上下文（Build-Context）" class="headerlink" title="理解构建上下文（Build Context）"></a>理解构建上下文（Build Context）</h4><ul><li>当运行 <code>docker build</code> 命令时，当前工作目录被称为构建上下文。</li><li><code>docker build</code> 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 <code>-f</code> 指定 Dockerfile。<ul><li><code>docker build -f ./Dockerfile</code></li></ul></li><li>当 <code>docker build</code> 运行时，首先会把构建上下文传输给 docker daemon。</li><li>可以通过 <code>.dockerignore</code> 文件从编译上下文排除某些文件。</li></ul><h4 id="镜像构建日志"><a href="#镜像构建日志" class="headerlink" title="镜像构建日志"></a>镜像构建日志</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker build $GOPATH/src/github.com/cncamp/golang/httpserver/<br>Sending build context to Docker daemon <span class="hljs-number">14.57</span>MB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">4</span> : <span class="hljs-type">FROM</span> ubuntu<br><span class="hljs-comment">---&gt; cf0f3ca922e0</span><br>Step <span class="hljs-number">2</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ENV</span> MY_SERVICE_PORT=<span class="hljs-number">80</span><br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; a7d824f74410</span><br>Step <span class="hljs-number">3</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ADD</span> bin/amd64/httpserver /httpserver<br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; 00bb47fce704</span><br>Step <span class="hljs-number">4</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ENTRYPOINT</span> /httpserver<br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; f77ee3366d08</span><br>Successfully built f77ee3366d08<br></code></pre></td></tr></table></figure><h4 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h4><ul><li><p>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p></li><li><p>通常 Docker 简单判断 Dockerfile 中的指令与镜像。</p></li><li><p>针对 <code>ADD</code> 和 <code>COPY</code> 指令，Docker 会比较文件的 checksum。</p></li><li><p>其他指令（如 <code>RUN apt-get -y update</code>），Docker 简单比较指令字串。</p></li><li><p>当某一层 cache 失效，所有后续层级的 cache 均一并失效。</p></li></ul><h4 id="多段构建（Multi-stage-build）"><a href="#多段构建（Multi-stage-build）" class="headerlink" title="多段构建（Multi-stage build）"></a>多段构建（Multi-stage build）</h4><p>多段构建是减少镜像层级、缩小镜像体积的有效方式。它允许您在一个 Dockerfile 中使用多个 <code>FROM</code> 指令，每个 <code>FROM</code> 指令都可以使用不同的基础镜像，并且可以从之前的构建阶段复制文件到当前阶段。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第一阶段：构建阶段</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span>-alpine AS build<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache git</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go get github.com/golang/dep/cmd/dep</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src/project/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> dep ensure -vendor-only</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /go/src/project/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o /bin/project  <span class="hljs-comment"># 只有这个二进制文件是最终需要的</span></span><br><br><span class="hljs-comment"># 第二阶段：运行阶段</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=build /bin/project /bin/project</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/project&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><strong>第一阶段 (build)：</strong><ul><li>使用 <code>golang:1.16-alpine</code> 作为基础镜像。</li><li>安装依赖、复制代码、编译项目。</li><li>最终生成可执行文件 <code>/bin/project</code>。</li></ul></li><li><strong>第二阶段 (无基础镜像)：</strong><ul><li>使用 <code>scratch</code> 作为基础镜像（一个空的镜像）。</li><li>从第一阶段（<code>build</code>）复制 <code>/bin/project</code> 到当前阶段。</li><li>设置 <code>ENTRYPOINT</code> 和 <code>CMD</code>。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>最终镜像只包含运行所需的二进制文件，极大地减小了镜像体积。</li><li>避免了将编译工具、依赖库等不必要的文件包含在最终镜像中。</li></ul><h4 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h4><ul><li><p><strong><code>FROM</code>：</strong> 选择基础镜像，推荐使用 Alpine Linux（体积小）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>LABEL</code>：</strong> 按标签组织项目。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> multi.label1=<span class="hljs-string">&quot;value1&quot;</span> multi.label2=<span class="hljs-string">&quot;value2&quot;</span> other=<span class="hljs-string">&quot;value3&quot;</span></span><br></code></pre></td></tr></table></figure><p>配合 <code>label filter</code> 可过滤镜像查询结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images -f label=multi.label1=<span class="hljs-string">&quot;value1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>RUN</code>：</strong> 执行命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y &lt;package&gt;</span><br></code></pre></td></tr></table></figure><ul><li>最常见的用法是 <code>RUN apt-get update &amp;&amp; apt-get install</code>，这两条命令应该永远用 <code>&amp;&amp;</code> 连接，以避免缓存导致的问题。</li></ul></li><li><p><strong><code>CMD</code>：</strong> 容器镜像中包含应用的运行命令（需要带参数）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>...]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>EXPOSE</code>：</strong> 发布端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br></code></pre></td></tr></table></figure><ul><li>是镜像创建者和使用者的约定。</li><li><code>docker run -P</code> 时，Docker 会自动映射 <code>EXPOSE</code> 的端口到主机大端口。</li></ul></li><li><p><strong><code>ENV</code>：</strong> 设置环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li><li><p><strong><code>ADD</code>：</strong> 从源地址（文件、目录或者 URL）复制文件到目标路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 路径中有空格时使用</span></span><br></code></pre></td></tr></table></figure><ul><li><code>ADD</code> 支持 Go 风格的通配符，如 <code>ADD check* /testdir/</code>。</li><li><code>src</code> 如果是文件，则必须包含在编译上下文中。</li><li><code>src</code> 如果是 URL：<ul><li>如果 <code>dest</code> 结尾没有 <code>/</code>，则 <code>dest</code> 是目标文件名。</li><li>如果 <code>dest</code> 结尾有 <code>/</code>，则 <code>dest</code> 是目标目录名。</li></ul></li><li>如果 <code>src</code> 是一个目录，则所有文件都会被复制至 <code>dest</code>。</li><li>如果 <code>src</code> 是一个本地压缩文件，则在 <code>ADD</code> 的同时完整解压操作。</li><li>如果 <code>dest</code> 不存在，则 <code>ADD</code> 指令会创建目标目录。</li><li>应尽量减少通过 <code>ADD URL</code> 添加 remote 文件，建议使用 <code>curl</code> 或者 <code>wget &amp;&amp; untar</code>。</li></ul></li><li><p><strong><code>COPY</code>：</strong> 从源地址（文件、目录）复制文件到目标路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 路径中有空格时使用</span></span><br></code></pre></td></tr></table></figure><ul><li><code>COPY</code> 的使用与 <code>ADD</code> 类似，但有如下区别：<ul><li><code>COPY</code> 只支持本地文件的复制，不支持 URL。</li><li><code>COPY</code> 不解压文件。</li><li><code>COPY</code> 可以用于多阶段编译场景。</li></ul></li><li><code>COPY</code> 语义上更直白，复制本地文件时，优先使用 <code>COPY</code>。</li></ul></li><li><p><strong><code>ENTRYPOINT</code>：</strong> 定义可以执行的容器镜像入口命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  <span class="hljs-comment"># docker run 参数追加模式</span></span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2              <span class="hljs-comment"># docker run 参数替换模式</span></span><br></code></pre></td></tr></table></figure><ul><li><code>docker run --entrypoint</code> 可替换 Dockerfile 中定义的 <code>ENTRYPOINT</code>。</li><li>最佳实践：用 <code>ENTRYPOINT</code> 定义镜像主命令，并通过 <code>CMD</code> 定义主要参数。<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;s3cmd&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>VOLUME</code>：</strong> 将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>等价于 <code>docker run -v /data</code>，可通过 <code>docker inspect</code> 查看主机的 mount point。</p></li><li><p><strong><code>USER</code>：</strong> 切换运行镜像的用户和用户组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">USER</span> &lt;<span class="hljs-keyword">user</span>&gt;[:&lt;group&gt;]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>WORKDIR</code>：</strong> 等价于 <code>cd</code>，切换工作目录。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br></code></pre></td></tr></table></figure></li><li><p><strong>其他非常用指令：</strong></p><ul><li><code>ARG</code></li><li><code>ONBUILD</code></li><li><code>STOPSIGNAL</code></li><li><code>HEALTHCHECK</code></li><li><code>SHELL</code></li></ul></li></ul><h4 id="Dockerfile-最佳实践总结"><a href="#Dockerfile-最佳实践总结" class="headerlink" title="Dockerfile 最佳实践总结"></a>Dockerfile 最佳实践总结</h4><ul><li><strong>不要安装无效软件包。</strong></li><li><strong>简化镜像中同时运行的进程数：</strong> 理想状况下，每个镜像应该只有一个进程。</li><li><strong>最小化层级数：</strong><ul><li>最新的 Docker 只有 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 创建新层。</li><li>多条 <code>RUN</code> 命令可通过连接符连接成一条指令集。</li><li>通过多段构建减少镜像层数。</li></ul></li><li><strong>把多行参数按字母排序。</strong></li><li><strong>编写 dockerfile 的时候，应该把变更频率低的编译指令优先构建。</strong></li><li><strong>复制文件时，每个文件应独立复制。</strong></li></ul><p><strong>目标：</strong> 易管理、少漏洞、镜像小、层级少、利用缓存。</p><h4 id="多进程的容器镜像"><a href="#多进程的容器镜像" class="headerlink" title="多进程的容器镜像"></a>多进程的容器镜像</h4><ul><li><strong>选择适当的 init 进程：</strong><ul><li>需要捕获 <code>SIGTERM</code> 信号并完成子进程的优雅终止。</li><li>负责清理退出的子进程以避免僵尸进程。</li></ul></li><li><strong>开源项目：</strong> <a href="https://github.com/krallin/tini">https://github.com/krallin/tini</a></li></ul><h3 id="5-Docker-镜像管理"><a href="#5-Docker-镜像管理" class="headerlink" title="5. Docker 镜像管理"></a>5. Docker 镜像管理</h3><ul><li><code>docker save/load</code>：保存和加载镜像。</li><li><code>docker tag</code>：为镜像打标签。</li><li><code>docker push/pull</code>：推送和拉取镜像。</li></ul><h4 id="基于-Docker-镜像的版本管理"><a href="#基于-Docker-镜像的版本管理" class="headerlink" title="基于 Docker 镜像的版本管理"></a>基于 Docker 镜像的版本管理</h4><ul><li><p><strong><code>docker tag</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag &lt;image_id&gt; &lt;repository&gt;/&lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li><code>hub.docker.com</code>：镜像仓库地址（如果不填，默认为 <code>hub.docker.com</code>）。</li><li><code>cncamp</code>：repository。</li><li><code>httpserver</code>：镜像名。</li><li><code>v1.0</code>：tag（常用来记录版本信息）。</li></ul></li><li><p><strong>Docker tag 与 GitHub 的版本管理合力：</strong></p><p>以 Kubernetes 为例：</p><ol><li><strong>开发分支：</strong> <code>git checkout master</code></li><li><strong>Release 分支：</strong> <code>git checkout -b release-1.21</code></li><li><strong>版本发布：</strong><ul><li>以 release branch 为基础构建镜像，并为镜像标记版本信息：<code>docker tag &lt;image_id&gt; k8s.io/kubernetes/apiserver:v1.21</code></li><li>在 GitHub 中保存 release 代码快照：<code>git tag v1.21</code></li></ul></li></ol></li></ul><h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4><ul><li><p><strong>Docker Hub：</strong> <a href="https://hub.docker.com/">https://hub.docker.com/</a></p></li><li><p><strong>创建私有镜像仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -d -p 5000:5000 registry<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-Docker-优势与劣势"><a href="#6-Docker-优势与劣势" class="headerlink" title="6. Docker 优势与劣势"></a>6. Docker 优势与劣势</h3><h4 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h4><ul><li><strong>封装性：</strong><ul><li>应用扩缩容时可以秒速启动。</li><li>资源利用率高。</li><li>方便的 CPU、内存资源调整。</li><li>能实现秒级快速回滚。</li><li>一键启动所有依赖服务。</li><li>镜像一次编译，随处使用。</li><li>测试、生产环境高度一致。</li></ul></li><li><strong>隔离性：</strong><ul><li>应用的运行环境和宿主机环境无关，完全由镜像控制。</li><li>多个应用版本可以并存在机器上。</li></ul></li><li><strong>社区活跃：</strong><ul><li>Docker 命令简单、易用，社区十分活跃，且周边组件丰富。</li></ul></li></ul><h4 id="Docker-劣势"><a href="#Docker-劣势" class="headerlink" title="Docker 劣势"></a>Docker 劣势</h4><ul><li><strong>隔离性不如虚拟机：</strong> 容器共享宿主机内核，隔离性相对较弱。</li><li><strong>安全性：</strong> 如果容器内的应用存在漏洞，可能会影响到宿主机或其他容器。</li><li><strong>网络配置复杂：</strong> 跨主机容器网络配置相对复杂。</li><li><strong>资源限制：</strong> 虽然可以使用 Cgroups 进行资源限制，但配置和管理相对复杂。</li><li><strong>持久化存储：</strong> 容器的持久化存储需要额外的配置和管理。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2025/03/14/%E5%89%91%E6%8C%87offer/"/>
    <url>/2025/03/14/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<p>剑指 offer 算法刷题记录（Golang 版）</p><span id="more"></span><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><strong>从尾到头打印链表</strong></h2><p>描述</p><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>如输入{1,2,3}的链表如下图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F" alt="img"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(head *ListNode)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>stack=<span class="hljs-built_in">append</span>(stack, head.Val)<br>        head = head.Next<br>&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&#123;<br>        res = <span class="hljs-built_in">append</span>(res, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>思路解释：</p><p>从尾到头的顺序，很容易想到栈的结构，后进先出即可。具体步骤如下：</p><ol><li>初始化一个空的栈 <code>stack</code> 和结果数组 <code>res</code>。</li><li>遍历链表，将每个节点的值压入栈中。</li><li>遍历栈，将栈顶元素弹出并添加到结果数组中，直到栈为空。</li><li>返回结果数组 <code>res</code>。</li></ol><p>这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是链表的长度。</p><p>好的，下面是对你提供的链表反转问题的总结：</p><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><p>题目</p><p>给定一个单链表的头节点，反转该链表，并返回反转后的链表的头节点。</p><p><strong>示例：</strong></p><ul><li>输入：<code>&#123;1, 2, 3&#125;</code></li><li>输出：<code>&#123;3, 2, 1&#125;</code></li></ul><p>思路</p><p>链表反转的思路可以用一个非常经典的比喻来理解：<strong>想象你有一堆牌，你需要把它们的顺序颠倒过来。</strong></p><ol><li><p><strong>三个指针：</strong> 我们需要三个指针来完成这个任务：</p><ul><li><code>prev</code>：指向已经反转好的链表的头节点。初始时，它指向 <code>nil</code>，因为最开始还没有反转任何节点。</li><li><code>current</code>：指向当前正在处理的节点。</li><li><code>next</code>：指向 <code>current</code> 节点的下一个节点，用于在断开 <code>current</code> 节点的 <code>Next</code> 指针之前，保存后续节点的引用，防止链表断裂。</li></ul></li><li><p><strong>迭代反转：</strong> 遍历链表，对于每个 <code>current</code> 节点，执行以下操作：</p><ul><li><strong>保存 <code>next</code>：</strong> 首先，用 <code>next</code> 指针保存 <code>current.Next</code>，因为接下来要修改 <code>current.Next</code>。</li><li><strong>反转指针：</strong> 将 <code>current.Next</code> 指向 <code>prev</code>，实现反转。</li><li><strong>移动指针：</strong> 将 <code>prev</code> 移动到 <code>current</code>，<code>current</code> 移动到 <code>next</code>，为处理下一个节点做准备。</li></ul></li><li><p><strong>新的头节点：</strong> 当 <code>current</code> 指针到达链表末尾（<code>nil</code>）时，<code>prev</code> 指针指向的就是反转后链表的头节点。</p></li></ol><p><strong>图解：</strong></p><p>假设链表为 <code>1 -&gt; 2 -&gt; 3 -&gt; nil</code></p><ol><li>初始状态：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> nil<br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ol start="2"><li>第一次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">1</span> -&gt; nil<br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 -&gt; 3 -&gt; nil</code> (1 指向 nil)</p><ol start="3"><li>第二次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 &lt;- 3 -&gt; nil</code> (2 指向 1)</p><ol start="4"><li>第三次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> nil<br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">3</span> -&gt; <span class="hljs-number">2</span><br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> nil<br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 &lt;- 3</code> (3 指向 2)</p><ol start="5"><li>循环结束：<code>current</code> 为 <code>nil</code>，<code>prev</code> 指向新的头节点 <code>3</code>。</li></ol><p>算法代码 (Go)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-comment">// write code here</span><br><span class="hljs-keyword">var</span> prev *ListNode = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">var</span> current *ListNode = head<br><span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &#123;<br>next := current.Next <span class="hljs-comment">// 保存下一个节点</span><br>current.Next = prev  <span class="hljs-comment">// 反转指针</span><br>prev = current       <span class="hljs-comment">// 移动 prev 指针</span><br>current = next       <span class="hljs-comment">// 移动 current 指针</span><br>&#125;<br><span class="hljs-keyword">return</span> prev <span class="hljs-comment">// prev 指向新的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li><strong>适用场景：</strong> 这种反转链表的方法适用于单链表结构。它是一种原地反转算法，只需要常数级别的额外空间（三个指针），因此空间复杂度为 O(1)。时间复杂度为 O(n)，因为需要遍历链表一次。</li><li><strong>算法类型：</strong> 链表操作</li><li><strong>技巧：</strong> 使用多个指针来辅助完成链表结构的修改是非常常见的技巧。一定要理清指针的指向关系，防止链表断裂。</li><li><strong>易错点：</strong> 在反转指针之前，一定要先保存下一个节点的引用，否则链表会断裂。</li><li><strong>变体：</strong> 链表反转有很多变体，例如反转链表的一部分（指定起始和结束位置）。基本思路都是类似的，需要仔细处理指针的指向。</li></ul><p>好的，下面是对你提供的题目和代码的总结：</p><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>题目描述</p><p>输入两个递增的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>数据范围：</strong></p><ul><li>单个链表的长度 <code>n</code> 满足 <code>0 &lt;= n &lt;= 1000</code></li><li>节点值满足 <code>-1000 &lt;= 节点值 &lt;= 1000</code></li></ul><p><strong>要求：</strong></p><ul><li>空间复杂度 O(1)</li><li>时间复杂度 O(n)</li></ul><p>解题思路</p><p>这道题的解题思路非常经典，就是<strong>迭代</strong>比较两个链表的当前节点，将较小的节点添加到新的链表中。  由于输入链表是递增的，所以我们只需要比较两个链表的头节点，将较小的节点作为新链表的头节点，然后递归地处理剩余的链表即可。</p><p>具体步骤如下：</p><ol><li><p><strong>初始化：</strong></p><ul><li>创建一个哑节点（dummy node），作为合并后链表的头节点。哑节点不存储实际数据，只是为了方便操作。</li><li>创建一个指针 <code>current</code>，指向哑节点，用于构建合并后的链表。</li></ul></li><li><p><strong>迭代比较：</strong></p><ul><li>循环比较 <code>pHead1</code> 和 <code>pHead2</code> 指向的节点的值，直到其中一个链表为空。</li><li>如果 <code>pHead1.Val &lt;= pHead2.Val</code>，则将 <code>pHead1</code> 指向的节点添加到 <code>current</code> 的 <code>Next</code> 指针，并将 <code>pHead1</code> 向后移动一位。</li><li>否则，将 <code>pHead2</code> 指向的节点添加到 <code>current</code> 的 <code>Next</code> 指针，并将 <code>pHead2</code> 向后移动一位。</li><li>将 <code>current</code> 指针向后移动一位。</li></ul></li><li><p><strong>处理剩余节点：</strong></p><ul><li>当其中一个链表为空时，将另一个链表剩余的节点直接添加到 <code>current</code> 的 <code>Next</code> 指针。</li></ul></li><li><p><strong>返回结果：</strong></p><ul><li>返回哑节点的 <code>Next</code> 指针，即合并后的链表的头节点。</li></ul></li></ol><p><strong>为什么使用哑节点？</strong></p><p>使用哑节点可以避免对头节点的特殊处理，使代码更加简洁。如果没有哑节点，我们需要判断合并后的链表的头节点是 <code>pHead1</code> 还是 <code>pHead2</code>，这会增加代码的复杂性。</p><p>代码实现 (Go)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param pHead1 ListNode类</span><br><span class="hljs-comment"> * @param pHead2 ListNode类</span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(pHead1 *ListNode, pHead2 *ListNode)</span></span> *ListNode &#123;<br>dummy := &amp;ListNode&#123;&#125; <span class="hljs-comment">// 创建哑节点</span><br>current := dummy     <span class="hljs-comment">// current 指针指向哑节点</span><br><br><span class="hljs-comment">// 循环比较两个链表的节点</span><br><span class="hljs-keyword">for</span> pHead1 != <span class="hljs-literal">nil</span> &amp;&amp; pHead2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pHead1.Val &lt;= pHead2.Val &#123;<br>current.Next = pHead1 <span class="hljs-comment">// 将 pHead1 的节点添加到新链表</span><br>pHead1 = pHead1.Next    <span class="hljs-comment">// pHead1 向后移动</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>current.Next = pHead2 <span class="hljs-comment">// 将 pHead2 的节点添加到新链表</span><br>pHead2 = pHead2.Next    <span class="hljs-comment">// pHead2 向后移动</span><br>&#125;<br>current = current.Next <span class="hljs-comment">// current 向后移动</span><br>&#125;<br><br><span class="hljs-comment">// 处理剩余节点</span><br><span class="hljs-keyword">if</span> pHead1 != <span class="hljs-literal">nil</span> &#123;<br>current.Next = pHead1 <span class="hljs-comment">// 将 pHead1 剩余的节点添加到新链表</span><br>&#125;<br><span class="hljs-keyword">if</span> pHead2 != <span class="hljs-literal">nil</span> &#123;<br>current.Next = pHead2 <span class="hljs-comment">// 将 pHead2 剩余的节点添加到新链表</span><br>&#125;<br><br><span class="hljs-keyword">return</span> dummy.Next <span class="hljs-comment">// 返回新链表的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><strong>时间复杂度：</strong> O(n)，其中 n 是两个链表的总长度。我们需要遍历两个链表的所有节点。</li><li><strong>空间复杂度：</strong> O(1)。我们只使用了常量级的额外空间，例如哑节点和 <code>current</code> 指针。</li></ul><p>适用题目类型</p><p>这种合并排序链表的思路，通常适用于以下类型的题目：</p><ul><li><strong>涉及到两个或多个有序数据结构的合并问题。</strong>  例如，合并 k 个排序链表。</li><li><strong>需要保持合并后的数据结构仍然有序的问题。</strong></li><li><strong>对空间复杂度有要求的题目。</strong>  由于该算法的空间复杂度为 O(1)，因此非常适合对空间复杂度有严格限制的题目。</li></ul><p><strong>举例：</strong></p><ul><li><strong>LeetCode 23. 合并 K 个排序链表</strong></li><li><strong>类似本题的变种，例如要求合并后链表为降序排列。</strong></li></ul><p>好的，我们来一起梳理一下这道寻找链表公共节点的题目。我会用易懂的方式解释思路，并提供带有详细注释的 Golang 代码。</p><h2 id="寻找链表的第一个公共节点"><a href="#寻找链表的第一个公共节点" class="headerlink" title="寻找链表的第一个公共节点"></a>寻找链表的第一个公共节点</h2><p><strong>题目描述：</strong></p><p>给定两个无环的单向链表，找到它们的第一个公共节点。如果不存在公共节点，则返回 <code>nil</code>。</p><p><strong>要求：</strong></p><ul><li>空间复杂度为 O(1)。</li><li>时间复杂度为 O(n)。</li></ul><p>思路解析</p><p>想象一下，你在两条不同的河流上划船。两条河流最终汇入同一条河流，那么汇入点就是它们的第一个公共点。</p><ol><li><strong>长度差：</strong> 首先，我们需要知道两条河流（链表）的长度差。如果一条河流比另一条长，我们需要让较长的河流先划一段时间，直到它们到达同一起跑线。</li><li><strong>同步前进：</strong> 然后，两条河流同时开始划船，每次都前进一步。当两条船在同一个位置时，我们就找到了它们的第一个公共点。</li><li><strong>没有公共点：</strong> 如果两条河流一直没有相遇，那么它们就没有公共点。</li></ol><p><strong>图解：</strong></p><p>假设我们有两个链表：</p><ul><li>链表 A: <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code></li><li>链表 B: <code>      a -&gt; b -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code></li></ul><p>它们的第一个公共节点是 <code>4</code>。</p><p>用 Mermaid 图表示如下：</p><pre class="mermaid">graph LR    A1(1) --> A2(2)    A2 --> A3(3)    A3 --> A4(4)    A4 --> A5(5)    A5 --> A6(6)    A6 --> A7(7)    B1(a) --> B2(b)    B2 --> A4</pre><p><strong>步骤：</strong></p><ol><li>计算链表 A 的长度（lenA &#x3D; 7）。</li><li>计算链表 B 的长度（lenB &#x3D; 2 + 5 &#x3D; 7）。</li><li>计算长度差（diff &#x3D; lenA - lenB &#x3D; 0）。</li><li>因为长度相等，所以不需要移动任何链表的头指针。</li><li>同时遍历链表 A 和链表 B，直到找到相同的节点（即节点 4）。</li></ol><p>Golang 代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param pHead1 ListNode类</span><br><span class="hljs-comment"> * @param pHead2 ListNode类</span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(pHead1 *ListNode, pHead2 *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-comment">// 1. 判空处理：如果任一链表为空，则没有公共节点</span><br><span class="hljs-keyword">if</span> pHead1 == <span class="hljs-literal">nil</span> || pHead2 == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 2. 获取两个链表的长度</span><br>len1 := GetLength(pHead1)<br>len2 := GetLength(pHead2)<br><br><span class="hljs-comment">// 3. 计算长度差，让较长的链表先走几步</span><br>diff := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> len1 &gt; len2 &#123;<br>diff = len1 - len2<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; diff; i++ &#123;<br>pHead1 = pHead1.Next <span class="hljs-comment">// 移动 pHead1 到同一起跑线</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>diff = len2 - len1<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; diff; i++ &#123;<br>pHead2 = pHead2.Next <span class="hljs-comment">// 移动 pHead2 到同一起跑线</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 同时遍历两个链表，查找相同节点</span><br><span class="hljs-keyword">for</span> pHead1 != <span class="hljs-literal">nil</span> &amp;&amp; pHead2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pHead1 == pHead2 &#123; <span class="hljs-comment">// 直接比较指针，如果指针相同则找到公共节点</span><br><span class="hljs-keyword">return</span> pHead1<br>&#125;<br>pHead1 = pHead1.Next <span class="hljs-comment">// 同时移动 pHead1</span><br>pHead2 = pHead2.Next <span class="hljs-comment">// 同时移动 pHead2</span><br>&#125;<br><br><span class="hljs-comment">// 5. 如果没有找到公共节点，则返回 nil</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// GetLength 获取链表的长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">int</span> &#123;<br>length := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>length++        <span class="hljs-comment">// 累加长度</span><br>head = head.Next <span class="hljs-comment">// 移动到下一个节点</span><br>&#125;<br><span class="hljs-keyword">return</span> length<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>判空处理：</strong>  如果任何一个链表为空，那么它们不可能有公共节点，直接返回 <code>nil</code>。</li><li><strong>获取链表长度：</strong>  <code>GetLength</code> 函数用于计算链表的长度。</li><li><strong>调整起始位置：</strong>  计算长度差，并让较长的链表先移动，直到两个链表在同一起跑线上。</li><li><strong>同步遍历：</strong>  同时遍历两个链表，比较节点是否相同。如果找到相同的节点，则返回该节点。</li><li><strong>没有公共节点：</strong>  如果遍历完整个链表都没有找到公共节点，则返回 <code>nil</code>。</li></ol><p>适用场景</p><p>这种方法特别适用于以下场景：</p><ul><li>寻找两个单链表的第一个公共节点。</li><li>要求时间复杂度为 O(n)，空间复杂度为 O(1)。</li><li>链表没有环。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 etcd</title>
    <link href="/2025/03/13/etcd/"/>
    <url>/2025/03/13/etcd/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-etcd：一个分布式键值存储系统"><a href="#深入理解-etcd：一个分布式键值存储系统" class="headerlink" title="深入理解 etcd：一个分布式键值存储系统"></a>深入理解 etcd：一个分布式键值存储系统</h1> <span id="more"></span><img src="/2025/03/13/etcd/image-20250315134912712.png" class="" title="image-20250315134912712"><p>好的，根据您提供的内容，我整理了一篇关于 Kubernetes 控制平面组件 etcd 的技术博客，内容如下：</p><h1 id="深入理解-Kubernetes-基石：etcd-详解"><a href="#深入理解-Kubernetes-基石：etcd-详解" class="headerlink" title="深入理解 Kubernetes 基石：etcd 详解"></a>深入理解 Kubernetes 基石：etcd 详解</h1><p><strong>作者：</strong> 孟凡杰（前 eBay 资深架构师）</p><p><strong>引言</strong></p><p>在 Kubernetes（K8s）集群中，etcd 扮演着至关重要的角色。它是整个集群的“大脑”，负责存储集群状态、配置信息以及进行服务发现。本文将深入探讨 etcd 的核心概念、功能、使用场景、Raft 协议、存储机制、高可用方案以及在 Kubernetes 中的应用，帮助您全面理解这一关键组件。</p><h2 id="什么是-etcd？"><a href="#什么是-etcd？" class="headerlink" title="什么是 etcd？"></a>什么是 etcd？</h2><p>etcd 是由 CoreOS（现已被 Red Hat 收购）开发的一个开源、分布式、高可用的键值存储系统。它基于 Raft 一致性算法，确保数据在多个节点之间保持一致性，即使在部分节点故障的情况下也能正常运行。</p><p>etcd 的主要特点：</p><ul><li><strong>键值对存储：</strong> 数据以键值对的形式存储在分层目录结构中，类似于文件系统。</li><li><strong>变更监测：</strong> 可以监测特定键或目录的变化，并在发生变化时做出反应。</li><li><strong>简单易用：</strong> 提供 HTTP+JSON 的 API，易于使用 curl 等工具进行访问。</li><li><strong>安全可靠：</strong> 支持 SSL 客户端证书认证，使用 Raft 算法保证数据一致性。</li><li><strong>高性能：</strong> 单实例每秒可处理数千次读写操作。</li></ul><h2 id="etcd-的核心功能"><a href="#etcd-的核心功能" class="headerlink" title="etcd 的核心功能"></a>etcd 的核心功能</h2><p>etcd 主要提供以下功能：</p><ol><li><strong>基本的键值存储：</strong> 存储和检索数据。</li><li><strong>监听机制：</strong> 监听键或目录的变化，实现实时通知。</li><li><strong>键的过期及续约：</strong> 用于监控和服务发现，确保服务的可用性。</li><li><strong>原子 Compare And Swap (CAS) 和 Compare And Delete (CAD)：</strong> 用于实现分布式锁和领导者选举。</li></ol><h2 id="etcd-的典型应用场景"><a href="#etcd-的典型应用场景" class="headerlink" title="etcd 的典型应用场景"></a>etcd 的典型应用场景</h2><p>etcd 在分布式系统中有着广泛的应用，常见的场景包括：</p><ol><li><strong>服务注册与发现：</strong> 服务提供者将自己的信息注册到 etcd，服务消费者通过 etcd 发现可用的服务实例。</li><li><strong>消息发布与订阅：</strong> 构建配置共享中心，实现配置的集中管理和动态更新。</li><li><strong>分布式锁：</strong> 利用 CAS 或 CAD 操作实现分布式锁，协调多个进程对共享资源的访问。</li><li><strong>领导者选举：</strong> 在分布式系统中选举出一个领导者，负责协调和管理其他节点。</li><li><strong>键值对存储:</strong> 作为数据库存储集群数据。</li></ol><p><strong>服务注册与发现示例（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000021831.png" class="" title="image-20250317000021831"><pre class="mermaid">graph LR    subgraph 服务注册        A[服务提供者] --> B(向 etcd 注册服务)    end    subgraph 服务发现        C[服务消费者] --> D(从 etcd 查询服务)    end    B --> E[etcd]    D --> E    subgraph 服务绑定        F[服务消费者] --> G[服务提供者]    end</pre><p><strong>消息发布与订阅示例（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000027311.png" class="" title="image-20250317000027311"><pre class="mermaid">graph LR    subgraph 消息发布        A[生产者] --> B(向 etcd 发布消息)    end    subgraph 消息订阅        C[服务消费者] --> D(从 etcd 订阅消息)    end    B --> E[etcd]    D --> E</pre><h2 id="etcd-的安装与使用"><a href="#etcd-的安装与使用" class="headerlink" title="etcd 的安装与使用"></a>etcd 的安装与使用</h2><p>etcd 的安装非常简单，可以从 GitHub Releases 页面下载预编译的二进制文件，解压后即可运行。</p><p><strong>安装步骤（示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ETCD_VER=v3.4.17<br>DOWNLOAD_URL=https://github.com/etcd-io/etcd/releases/download<br><span class="hljs-built_in">rm</span> -f /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br><span class="hljs-built_in">rm</span> -rf /tmp/etcd-download-test &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /tmp/etcd-download-test<br>curl -L <span class="hljs-variable">$&#123;DOWNLOAD_URL&#125;</span>/<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -o /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br>tar xzvf /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1<br><span class="hljs-built_in">rm</span> -f /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p><strong>常用客户端工具：</strong></p><ul><li><strong>etcdctl：</strong> 命令行客户端工具，用于与 etcd 集群交互。</li><li><strong>go-etcd：</strong> Go 语言客户端库。</li><li><strong>jetcd：</strong> Java 客户端库。</li><li><strong>python-etcd：</strong> Python 客户端库。</li></ul><p><strong>基本数据读写操作（etcdctl 示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 写入数据</span><br>etcdctl --endpoints=localhost:12379 put /a b<br><br><span class="hljs-comment"># 读取数据</span><br>etcdctl --endpoints=localhost:12379 get /a<br><br><span class="hljs-comment"># 按 key 的前缀查询数据</span><br>etcdctl --endpoints=localhost:12379 get --prefix /<br><br><span class="hljs-comment"># 只显示键值</span><br>etcdctl --endpoints=localhost:12379 get --prefix / --keys-only --debug<br></code></pre></td></tr></table></figure><h2 id="深入理解-Raft-一致性协议"><a href="#深入理解-Raft-一致性协议" class="headerlink" title="深入理解 Raft 一致性协议"></a>深入理解 Raft 一致性协议</h2><p>etcd 的数据一致性是基于 Raft 协议实现的。Raft 是一种易于理解的分布式一致性算法，它将一致性问题分解为几个子问题：</p><ol><li><strong>领导者选举（Leader Election）：</strong> 初始启动或领导者失效时，集群中的节点会通过投票选举出一个新的领导者。</li><li><strong>日志复制（Log Replication）：</strong> 领导者接收客户端的请求，并将请求作为日志条目复制到其他节点。</li><li><strong>安全性（Safety）：</strong> 确保每个节点都执行相同序列的命令，保证数据的一致性。</li></ol><p><strong>Raft 协议角色：</strong></p><ul><li><strong>Leader（领导者）：</strong> 负责接收客户端请求、日志复制和向 Follower 发送心跳。</li><li><strong>Follower（跟随者）：</strong> 接收 Leader 的日志并复制到本地，参与投票选举 Leader。</li><li><strong>Candidate（候选者）：</strong> 在 Leader 选举过程中，Follower 会转变为 Candidate，发起投票。</li><li><strong>Learner:</strong> 新加入的节点，只接收数据而不参与投票，因此增加<br>learner节点时，集群的quorum不变。</li></ul><p><strong>Raft 协议流程（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000031277.png" class="" title="image-20250317000031277"><pre class="mermaid">graph LR    subgraph 客户端请求        A[客户端] --> B[Leader]    end    subgraph Leader 处理        B --> C[将请求追加到本地日志]        B --> D[通过心跳将日志同步给 Follower]    end    subgraph Follower 处理        D --> E[Follower 接收日志并记录]        E --> F[向 Leader 发送 ACK]    end    subgraph Leader 提交        B -- 收到多数 Follower ACK --> G[将日志设置为已提交]        G --> H[通知客户端]        B -- 下次心跳 --> I[通知 Follower 提交日志]    end</pre><p><strong>Raft 协议失效处理：</strong></p><ol><li><strong>Leader 失效：</strong> Follower 在超时时间内未收到 Leader 心跳，会发起选举。</li><li><strong>Follower 失效：</strong> 重新加入集群后，从 Leader 复制日志。</li><li><strong>多个 Candidate：</strong> 随机等待一段时间后再次发起投票。</li></ol><p><strong>WAL 日志：</strong></p><p>etcd 使用预写式日志（WAL）来记录所有的数据变更。WAL 日志是二进制格式的，包含以下字段：</p><ul><li><strong>type：</strong> 0 表示 Normal，1 表示 ConfChange（配置变更）。</li><li><strong>term：</strong> 主节点任期，每次主节点变更时递增。</li><li><strong>index：</strong> 变更序号，严格有序递增。</li><li><strong>data：</strong> Raft 请求对象的 pb 结构。</li></ul><h2 id="etcd-的存储机制"><a href="#etcd-的存储机制" class="headerlink" title="etcd 的存储机制"></a>etcd 的存储机制</h2><p>etcd v3 的存储分为两部分：</p><ol><li><strong>内存索引（kvindex）：</strong> 基于 Google 开源的 btree 实现，用于加速查询。</li><li><strong>后端存储（backend）：</strong> 目前使用 boltdb，一个单机的支持事务的 KV 存储。</li></ol><p>etcd 在 boltdb 中存储的 key 是 reversion，value 是 etcd 自己的 key-value 组合，实现了多版本机制。</p><p><strong>reversion:</strong> 由两部分组成:</p><ol><li><strong>main rev：</strong> 每次事务进行加一。</li><li><strong>sub rev:</strong> 同一个事务中的每次操作加一。</li></ol><p><strong>存储机制示意图（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000035671.png" class="" title="image-20250317000035671"><pre class="mermaid">graph LR    subgraph etcd v3 存储        A[客户端请求] --> B[Leader]        B --> C["一致性模块 (Raft)"]        C --> D["预检查 (鉴权, 包大小等)"]        C --> E["配额, 限速, 选主, 日志复制"]        E --> F["写 WAL 日志"]        F --> G["写 raftLog (内存)"]        G --> H["收到半数确认, 更新 MatchIndex, Apply"]        H --> I["MVCC 模块"]        I --> J["treeIndex (内存索引)"]        I --> K["BoltDB (后端存储)"]    end</pre><h2 id="etcd-的-Watch-机制"><a href="#etcd-的-Watch-机制" class="headerlink" title="etcd 的 Watch 机制"></a>etcd 的 Watch 机制</h2><p>etcd v3 的 Watch 机制支持监听特定 key 或范围（模拟目录结构）。每个 WatchableStore 包含两种 watcherGroup：</p><ol><li><strong>synced：</strong> watcher 数据已同步完毕，等待新的变更。</li><li><strong>unsynced：</strong> watcher 数据同步落后于当前最新变更，还在追赶。</li></ol><p>etcd 会启动一个后台 goroutine 持续同步 unsynced 的 watcher，然后将其迁移到 synced 组。</p><img src="/2025/03/13/etcd/image-20250317001558102.png" class="" title="image-20250317001558102"><h2 id="etcd-的高可用方案"><a href="#etcd-的高可用方案" class="headerlink" title="etcd 的高可用方案"></a>etcd 的高可用方案</h2><p>为了确保 etcd 集群的高可用性，通常采用以下方案：</p><ol><li><strong>多节点部署：</strong> 部署 3 个或 5 个 etcd 节点，形成集群。</li><li><strong>故障转移：</strong> 当 Leader 节点故障时，其他节点会通过 Raft 协议选举出新的 Leader。</li><li><strong>数据备份：</strong> 定期创建快照，并将快照上传到网络存储设备，以防数据丢失。</li></ol><p><strong>高可用 etcd 解决方案：</strong></p><ul><li><strong>etcd-operator：</strong> CoreOS 开源的基于 Kubernetes CRD 的 etcd 集群配置工具（已归档）。</li></ul><img src="/2025/03/13/etcd/image-20250317001627420.png" class="" title="image-20250317001627420"><ul><li><strong>Etcd statefulset Helm chart：</strong> Bitnami 提供的 Helm chart，用于在 Kubernetes 上部署高可用 etcd 集群。</li></ul><p><strong>使用 Bitnami Helm chart 安装 etcd 高可用集群（示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 helm</span><br><span class="hljs-comment"># 参考 https://github.com/helm/helm/releases</span><br><br><span class="hljs-comment"># 通过 helm 安装 etcd</span><br>helm repo add bitnami https://charts.bitnami.com/bitnami<br>helm install my-release bitnami/etcd<br></code></pre></td></tr></table></figure><h2 id="etcd-在-Kubernetes-中的应用"><a href="#etcd-在-Kubernetes-中的应用" class="headerlink" title="etcd 在 Kubernetes 中的应用"></a>etcd 在 Kubernetes 中的应用</h2><p>etcd 是 Kubernetes 的后端存储，用于存储集群的所有状态信息。</p><ul><li>对于每一个 Kubernetes Object，都有对应的 <code>storage.go</code> 文件负责对象的存储操作（例如 <code>pkg/registry/core/pod/storage/storage.go</code>）。</li><li>API Server 启动脚本中会指定 etcd servers 集群的地址。</li><li>早期 API server 对 etcd 做简单的 Ping check，现在已经改为真实的 etcd api call。</li></ul><p><strong>Kubernetes 对象在 etcd 中的存储路径示例：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-regexp">/registry/</span>namespaces<span class="hljs-operator">/</span>calico<span class="hljs-operator">-</span>apiserver<br><span class="hljs-regexp">/registry/</span>networkpolicies<span class="hljs-regexp">/calico-apiserver/</span>allow<span class="hljs-operator">-</span>apiserver<br><span class="hljs-regexp">/registry/</span><span class="hljs-keyword">operator</span>.tigera.io<span class="hljs-regexp">/tigerastatuses/</span>apiserver<br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/calico-apiserver/</span>calico<span class="hljs-operator">-</span>apiserver<span class="hljs-operator">-</span>77dffffcdf<span class="hljs-operator">-</span>g2tcx<br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/default/</span>toolbox<span class="hljs-operator">-</span>68f79dd5f8<span class="hljs-operator">-</span>4664n<br></code></pre></td></tr></table></figure><p><strong>Kubernetes 集群中 etcd 的部署拓扑：</strong></p><ol><li><p><strong>堆叠式（Stacked）：</strong> 控制平面和 etcd 成员位于同一节点。</p><ul><li>优点：易于建立和管理。</li><li>缺点：存在耦合失败的风险。</li></ul></li><li><p><strong>外部（External）：</strong> 控制平面和 etcd 成员解耦。</p><ul><li>优点：降低耦合失败的风险。</li><li>缺点：需要更多的主机。</li></ul><img src="/2025/03/13/etcd/image-20250317001643290.png" class="" title="image-20250317001643290"></li></ol><img src="/2025/03/13/etcd/image-20250317001741454.png" class="" title="image-20250317001741454"><img src="/2025/03/13/etcd/image-20250317001746455.png" class="" title="image-20250317001746455"><h2 id="最佳实践和优化"><a href="#最佳实践和优化" class="headerlink" title="最佳实践和优化"></a>最佳实践和优化</h2><ol><li><strong>集群规模：</strong> 建议使用 3 或 5 个 etcd 节点，根据集群规模进行调整。</li><li><strong>网络延迟：</strong> 尽量将 etcd 集群部署在同一地域，减少网络延迟。</li><li><strong>磁盘 I&#x2F;O：</strong> 使用 SSD，并将 etcd 数据存放在单独的磁盘。</li><li><strong>日志文件大小：</strong> 定期创建快照，并设置合理的存储配额。</li><li><strong>历史版本压缩：</strong> 自动压缩历史版本，释放存储空间。</li><li><strong>碎片整理：</strong> 定期消除存储碎片。</li><li><strong>数据备份：</strong> 定期创建快照，并上传到网络存储设备。</li></ol><img src="/2025/03/13/etcd/image-20250317001853663.png" class="" title="image-20250317001853663"><ol><li><strong>参数优化：</strong> 根据网络延迟调整心跳周期和选举超时时间。</li><li><strong>安全性：</strong> 启用 peer 和 client 之间的 TLS 加密，并考虑数据加密。</li><li><strong>事件分离：</strong> 对于大规模集群，可以将事件存储在单独的 etcd 集群中。</li></ol><h2 id="etcd-常见问题与解决方案"><a href="#etcd-常见问题与解决方案" class="headerlink" title="etcd 常见问题与解决方案"></a>etcd 常见问题与解决方案</h2><ol><li><strong>频繁的leader election</strong>： 检查网络，查看是否有丢包现象</li><li><strong>etcd 分裂</strong>：检查集群配置。</li><li><strong>etcd 不响应</strong>： 检查磁盘，网络。</li><li><strong>与apiserver之间的链路阻塞</strong>: 检查客户端并发。</li><li><strong>磁盘暴涨</strong>： 检查是否有大量数据写入。</li><li><strong>少数etcd 成员Down</strong>:  检查 down 掉的 etcd 日志。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的Cgroup</title>
    <link href="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/"/>
    <url>/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/</url>
    
    <content type="html"><![CDATA[<p><strong>cgroup（Control Groups）</strong> 是 Linux 内核中的一项重要功能，用于管理和限制系统资源的使用。它允许用户按照需求对 CPU、内存、I&#x2F;O 等资源进行精细化的控制，从而为容器化技术（如 Docker 和 Kubernetes）提供了基础支持。</p><span id="more"></span><p>Linux 的 cgroup 有两个版本：<strong>cgroup v1</strong> 和 <strong>cgroup v2</strong>。随着 Linux 内核的发展，cgroup v2 在功能和设计上对 v1 做了很多改进。本文将详细探讨 cgroup v1 和 v2 的区别，并提供技术细节和实际应用示例。</p><hr><h2 id="什么是-cgroup？"><a href="#什么是-cgroup？" class="headerlink" title="什么是 cgroup？"></a>什么是 cgroup？</h2><p>cgroup 是 Linux 内核的一项功能，用于：</p><ol><li><strong>资源限制</strong>：限制某些进程可以使用的资源量（如 CPU、内存等）。</li><li><strong>资源优先级</strong>：为不同的进程分配不同的资源优先级。</li><li><strong>资源计费</strong>：跟踪进程使用的资源量。</li><li><strong>进程管理</strong>：将一组进程组织为一个组，并对其统一管理。</li></ol><p>它的主要应用场景包括：</p><ul><li>容器技术（如 Docker、Kubernetes）。</li><li>虚拟化技术。</li><li>系统性能调优。</li></ul><hr><h2 id="cgroup-v1-和-v2-的区别"><a href="#cgroup-v1-和-v2-的区别" class="headerlink" title="cgroup v1 和 v2 的区别"></a>cgroup v1 和 v2 的区别</h2><h3 id="1-文件结构对比"><a href="#1-文件结构对比" class="headerlink" title="1.文件结构对比"></a>1.<strong>文件结构对比</strong></h3><h4 id="cgroup-v1-的文件结构"><a href="#cgroup-v1-的文件结构" class="headerlink" title="cgroup v1 的文件结构"></a>cgroup v1 的文件结构</h4><p>在 cgroup v1 中，每种资源（如 CPU、内存、I&#x2F;O）都有独立的子系统，每个子系统都有自己的目录和控制文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/<br>├── cpu/<br>│   ├── cpu.cfs_quota_us<br>│   ├── cpu.cfs_period_us<br>│   ├── tasks<br>│   └── ...<br>├── memory/<br>│   ├── memory.limit_in_bytes<br>│   ├── memory.usage_in_bytes<br>│   ├── tasks<br>│   └── ...<br>└── blkio/<br>    ├── blkio.throttle.read_bps_device<br>    ├── blkio.throttle.write_bps_device<br>    ├── tasks<br>    └── ...<br></code></pre></td></tr></table></figure><ul><li>每个子系统（如 <code>cpu</code>、<code>memory</code>）管理自己的资源。</li><li>配置文件分散在不同的目录中，容易导致配置冲突。</li></ul><h4 id="cgroup-v2-的文件结构"><a href="#cgroup-v2-的文件结构" class="headerlink" title="cgroup v2 的文件结构"></a>cgroup v2 的文件结构</h4><p>在 cgroup v2 中，所有控制器共享一个统一的层次结构和文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/<br>├── cgroup.controllers<br>├── cgroup.procs<br>├── cgroup.subtree_control<br>├── cpu.max<br>├── memory.max<br>├── io.max<br>└── ...<br></code></pre></td></tr></table></figure><ul><li>统一的文件结构，所有资源控制参数（如 CPU、内存、I&#x2F;O）都在同一目录下。</li><li>减少了配置冲突，更加简洁和高效。</li></ul><hr><h3 id="2-资源控制参数对比"><a href="#2-资源控制参数对比" class="headerlink" title="2. 资源控制参数对比"></a>2. <strong>资源控制参数对比</strong></h3><p>以下是 cgroup v1 和 v2 在资源控制方面的主要参数对比：</p><h4 id="CPU-控制参数"><a href="#CPU-控制参数" class="headerlink" title="CPU 控制参数"></a>CPU 控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>设置 CPU 时间配额</td><td><code>cpu.cfs_quota_us</code></td><td><code>cpu.max</code></td></tr><tr><td>设置 CPU 时间周期</td><td><code>cpu.cfs_period_us</code></td><td><code>cpu.max</code></td></tr><tr><td>设置 CPU 权重（优先级）</td><td><code>cpu.shares</code></td><td><code>cpu.weight</code></td></tr></tbody></table><ul><li>在 cgroup v2 中，<code>cpu.max</code> 替代了 <code>cpu.cfs_quota_us</code> 和 <code>cpu.cfs_period_us</code>，格式为 <code>&lt;quota&gt; &lt;period&gt;</code>。</li><li><code>cpu.weight</code> 替代了 <code>cpu.shares</code>，用于设置 CPU 权重。</li></ul><h4 id="内存控制参数"><a href="#内存控制参数" class="headerlink" title="内存控制参数"></a>内存控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>设置内存上限</td><td><code>memory.limit_in_bytes</code></td><td><code>memory.max</code></td></tr><tr><td>设置内存软限制</td><td><code>memory.soft_limit_in_bytes</code></td><td>不支持</td></tr><tr><td>内存使用量</td><td><code>memory.usage_in_bytes</code></td><td><code>memory.current</code></td></tr></tbody></table><ul><li>cgroup v2 简化了内存控制，废弃了一些复杂的参数（如软限制）。</li></ul><h4 id="I-O-控制参数"><a href="#I-O-控制参数" class="headerlink" title="I&#x2F;O 控制参数"></a>I&#x2F;O 控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>限制读写带宽</td><td><code>blkio.throttle.read_bps_device</code></td><td><code>io.max</code></td></tr><tr><td>限制 IOPS</td><td><code>blkio.throttle.write_iops_device</code></td><td><code>io.max</code></td></tr></tbody></table><ul><li>cgroup v2 使用 <code>io.max</code> 统一配置 I&#x2F;O 带宽和 IOPS 限制。</li></ul><hr><h2 id="控制-CPU-使用率示例："><a href="#控制-CPU-使用率示例：" class="headerlink" title="控制 CPU 使用率示例："></a>控制 CPU 使用率示例：</h2><p>运行以下 Go 程序，会吃掉两个 CPU：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">for</span> &#123;<br>                &#125;<br>        &#125;()<br>        <span class="hljs-keyword">for</span> &#123;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">go build -o busyloop</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./busyloop<br></code></pre></td></tr></table></figure><p>此时运行<code>top</code>命令，会显示 200%CPU 占用。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">PID</span> USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                <br><span class="hljs-attribute">426388</span> cadmin    <span class="hljs-number">20</span>   <span class="hljs-number">0</span>  <span class="hljs-number">702356</span>   <span class="hljs-number">1024</span>    <span class="hljs-number">640</span> R <span class="hljs-number">210</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>:<span class="hljs-number">18</span>.<span class="hljs-number">75</span> busyloop  <br></code></pre></td></tr></table></figure><p>他的 PID 号是<code>426388</code>，我们可以<code>mkdir /sys/fs/cgroup/cpudemo</code>，然后将它添加到<code>cpu.procs</code>中。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-keyword">ps</span> -ef|<span class="hljs-keyword">grep</span> busyloop|<span class="hljs-keyword">grep</span> -v <span class="hljs-keyword">grep</span>|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> &gt; cgroup.procs<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;100000 1000000&quot;</span> &gt; cpu.<span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><p>此时限制 100000&#x2F;1000000 就是使用 10% 的 CPU 了。</p><hr><h2 id="如何检查系统使用的是-cgroup-v1-还是-v2？"><a href="#如何检查系统使用的是-cgroup-v1-还是-v2？" class="headerlink" title="如何检查系统使用的是 cgroup v1 还是 v2？"></a>如何检查系统使用的是 cgroup v1 还是 v2？</h2><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount | grep cgroup<br></code></pre></td></tr></table></figure><ul><li>如果输出中包含 <code>cgroup2</code>，说明系统使用的是 cgroup v2。</li><li>如果输出中包含多个子系统（如 <code>cpu</code>、<code>memory</code> 等），说明使用的是 cgroup v1。</li></ul><hr><h2 id="可视化对比"><a href="#可视化对比" class="headerlink" title="可视化对比"></a>可视化对比</h2><p>以下是 cgroup v1 和 v2 的结构对比：</p><img src="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/image-20250315141042299.png" class="" title="image-20250315141042299"><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft协议</title>
    <link href="/2025/03/13/Raft%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/03/13/Raft%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>Raft 协议是一种分布式一致性协议，主要用于实现多个节点之间的一致性，为系统提供强一致性保证。本文描述了 Raft 的四种角色、选举机制、日志复制机制以及 <code>Learner</code> 角色的用途和场景。</p><span id="more"></span><hr><h3 id="Raft-协议的角色"><a href="#Raft-协议的角色" class="headerlink" title="Raft 协议的角色"></a><strong>Raft 协议的角色</strong></h3><p>在 Raft 协议中，一个节点可以处于以下四个角色之一：</p><ol><li><p><strong>Follower</strong>（跟随者）</p><ul><li>默认状态，每个节点在初始阶段或者重新加入集群时都会处于该状态。</li><li>被动接收来自 Leader 的心跳包（heartbeat）或日志更新请求。</li><li>如果一段时间（<code>Election Timeout</code>）内没有接收到 Leader 的心跳包，会转变为 Candidate。</li></ul></li><li><p><strong>Candidate</strong>（候选者）</p><ul><li>当一个 Follower 超过 <code>Election Timeout</code> 没有接收到心跳包时，会变为 Candidate 并发起选举。</li><li>向其他节点广播请求投票（<code>RequestVote</code>）。</li><li>如果获得超过半数的节点投票，即成为 Leader。</li><li>如果选举超时且没有节点获胜，会重新开始下一轮选举。</li></ul></li><li><p><strong>Leader</strong>（领导者）</p><ul><li>集群中的核心角色，处理客户端请求，管理日志复制并维持系统一致性。</li><li>定期向 Follower 发送心跳包，表明自己是当前的 Leader。</li><li>负责接收并提交客户端的写操作（通过日志复制机制实现）。</li></ul></li><li><p><strong>Learner</strong>（学习者）</p><ul><li>一个特殊角色，负责接收日志更新但不参与选举或投票。</li><li>通常用于读取副本（read-only replica），主要目的是增加系统的容错性和可扩展性。</li><li>在一些场景下，Learner 扮演只读节点的角色，例如为了避免对选举过程产生影响，同时满足读扩展需求。</li></ul></li></ol><hr><h3 id="Raft-的-Leader-选举"><a href="#Raft-的-Leader-选举" class="headerlink" title="Raft 的 Leader 选举"></a><strong>Raft 的 Leader 选举</strong></h3><p>起初，所有节点的状态都是 Follower。每个 Follower 都会设置一个随机的 <code>Election Timeout</code>，当这个时间段内没有收到 Leader 的心跳包时，将会发起选举。选举机制如下：</p><ol><li><p><strong>依次选举：</strong></p><ul><li>某个节点首先触发选举状态，变为 Candidate。</li><li>Candidate 向其他节点广播请求投票的消息（<code>RequestVote</code>）。</li><li>其他节点根据候选者的任期（term）和日志完整性决定是否投票给该候选者。</li><li>如果 Candidate 获得集群中过半数节点的选票，则当选 Leader，并开始发送心跳包。</li></ul></li><li><p><strong>冲突处理：</strong></p><ul><li>如果两个或多个节点同时发起选举，且得票数相同，最终导致没有节点获得多数投票，则会进入下一轮选举。</li><li>在进入下一轮选举时，每个节点会重新设置一个随机的 <code>Election Timeout</code>，从而减少下一次选举冲突的概率。</li></ul></li><li><p><strong>Leader 的权威性：</strong><br>当 Leader 当选后，会定期发送心跳包（<code>AppendEntries</code> RPC）。如果其他节点接收到心跳包，则会重置自己的 Election Timeout，确保不会触发新一轮选举。</p></li></ol><hr><h3 id="Raft-的日志复制机制"><a href="#Raft-的日志复制机制" class="headerlink" title="Raft 的日志复制机制"></a><strong>Raft 的日志复制机制</strong></h3><p>当集群中选出了 Leader 后，Leader 开始接收客户端的请求，并通过日志复制机制（Log Replication）确保所有节点状态一致。</p><h4 id="弱一致性："><a href="#弱一致性：" class="headerlink" title="弱一致性："></a><strong>弱一致性：</strong></h4><ol><li>客户端发送请求到 Leader。</li><li>Leader 将操作记录为日志条目，并将其同步到所有 Follower 节点的日志中。</li><li>一旦操作被写入 Leader 的日志，Leader 会直接向客户端返回确认。</li><li>Leader 后续再通知 Follower 提交（Commit）该日志操作。<ul><li>弱一致性具有较低的延迟，但无法保证所有节点都立即同步完成。</li></ul></li></ol><h4 id="强一致性："><a href="#强一致性：" class="headerlink" title="强一致性："></a><strong>强一致性：</strong></h4><ol><li>客户端发送请求到 Leader。</li><li>Leader 将操作记录到自身的日志，然后将该日志条目复制到 Follower 节点。</li><li>Follower 收到日志条目后，会向 Leader 发送确认（ack）信息。</li><li>当 Leader 收到大多数（过半数）节点的确认后，Leader 可以提交（commit）该日志操作，并将结果返回客户端。<ul><li>通过等待大多数节点的确认，确保一致性（即强一致性）。</li></ul></li></ol><p>总结：为了在不同场景下平衡性能和一致性要求，弱一致性和强一致性可以根据系统需求进行选择。</p><hr><h3 id="为什么需要-Learner？有什么应用场景？"><a href="#为什么需要-Learner？有什么应用场景？" class="headerlink" title="为什么需要 Learner？有什么应用场景？"></a><strong>为什么需要 Learner？有什么应用场景？</strong></h3><h4 id="1-什么是-Learner？"><a href="#1-什么是-Learner？" class="headerlink" title="1. 什么是 Learner？"></a><strong>1. 什么是 Learner？</strong></h4><p>Learner 是 Raft 协议中一个特殊的角色：</p><ul><li>Learner 节点被设计为一个只读节点（Read-Only）。</li><li>Learner 不参与选举过程，也不会被要求投票。</li><li>Learner 只接收 Leader 发送的日志复制数据，只用作数据同步，用于扩展系统的读性能或提升容错性。</li></ul><h4 id="2-Learner-的应用场景："><a href="#2-Learner-的应用场景：" class="headerlink" title="2. Learner 的应用场景："></a><strong>2. Learner 的应用场景：</strong></h4><ul><li><p><strong>非核心节点：</strong><br>在一个分布式系统中，为了扩展读取性能，我们可能希望新增更多副本节点。但这些节点不一定需要参与选举和投票。采用 Learner 角色可以减轻选举过程的压力，并不会直接影响一致性协议的核心流程。</p></li><li><p><strong>数据同步：</strong><br>在分布式存储系统中，某些节点因为距离（比如跨地域部署）或硬件性能问题无法及时响应，但仍需要同步集群的最新日志状态。Learner 可以被用作这样的从属节点。</p></li><li><p><strong>新节点加入：</strong><br>通过 Learner 角色将新节点加入到集群中，可以避免直接参与选举和投票所带来的干扰，并且在数据同步完成后，节点可以变为 Follower 正式加入集群。</p></li><li><p><strong>备份和容灾：</strong><br>Learner 节点可以被用于构建灾备集群。其日志内容与主集群一致，在灾难发生时可以切换为 Leader，以实现数据恢复和服务接管。</p></li><li><p><strong>读扩展：</strong><br>通过增加 Learner 节点，可以显著提升系统的读性能，因为这些节点专用于处理只读请求而不会承担写操作（日志复制除外）。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
