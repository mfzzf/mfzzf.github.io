<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kubernetes_CNI</title>
    <link href="/2025/03/25/kubernetes-CNI/"/>
    <url>/2025/03/25/kubernetes-CNI/</url>
    
    <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>CNI 是 Kubernetes 中一个至关重要的组件，它定义了一套标准接口，用于配置和管理容器的网络连接。CNI 将 Kubernetes 与底层网络实现解耦，允许用户选择不同的网络方案，从而提高了 Kubernetes 的灵活性和可扩展性。理解 CNI 的工作原理对于深入理解 Kubernetes 网络至关重要。</p><span id="more"></span><h2 id="Kubernetes-网络模型的核心原则"><a href="#Kubernetes-网络模型的核心原则" class="headerlink" title="Kubernetes 网络模型的核心原则"></a><strong>Kubernetes 网络模型的核心原则</strong></h2><p>Kubernetes 网络模型的设计目标是提供一个扁平的、易于理解和使用的网络环境，让应用程序可以像在传统虚拟机环境中一样运行，而无需关心底层网络的复杂性。为此，Kubernetes 确立了以下三个核心原则：</p><ol><li><p><strong>所有 Pod 能够不通过 NAT 就能相互访问</strong></p><ul><li><p><strong>含义：</strong> 这意味着集群内的任何 Pod 都可以直接使用彼此的 IP 地址进行通信，无需进行网络地址转换（NAT）。这简化了应用程序的开发和调试，因为应用程序可以使用标准的 IP 地址和端口进行通信，而无需担心 NAT 带来的问题。</p></li><li><p>实现方式：</p><p>为了实现这一目标，Kubernetes 需要提供一种机制，使得集群内的所有 Pod 都能被分配到唯一的 IP 地址，并且这些 IP 地址在集群内都是可路由的。这通常通过以下方式实现：</p><ul><li><strong>容器网络接口（CNI）：</strong> Kubernetes 使用 CNI 插件来配置 Pod 的网络。CNI 插件负责为 Pod 分配 IP 地址、配置路由规则和创建必要的网络设备。</li><li><strong>网络插件：</strong> CNI 插件通常会依赖于底层的网络插件来实现具体的网络功能。常见的网络插件包括 Flannel、Calico、Weave Net 等。这些网络插件会使用不同的技术来实现 Pod 之间的网络连通性，例如 VXLAN、IPIP、BGP 等。</li><li><strong>路由配置：</strong> Kubernetes 会自动配置集群内的路由规则，使得所有 Pod 都能通过彼此的 IP 地址进行通信。这通常通过在每个节点上配置路由表来实现。</li></ul></li></ul></li><li><p><strong>所有节点能够不通过 NAT 就能相互访问</strong></p><ul><li><strong>含义：</strong> 这意味着集群内的任何节点都可以直接使用彼此的 IP 地址进行通信，无需进行 NAT。这对于 Kubernetes 的控制平面组件（例如 kube-apiserver、kube-scheduler、kube-controller-manager）之间的通信至关重要。</li><li><strong>实现方式：</strong> 为了实现这一目标，Kubernetes 通常会要求集群内的所有节点都位于同一个网络中，或者通过 VPN 等技术实现节点之间的网络连通性。</li></ul></li><li><p><strong>容器内看见的 IP 地址和外部组件看到的容器 IP 是一样的</strong></p><ul><li><strong>含义：</strong> 这意味着 Pod 内的容器看到的 IP 地址与 Kubernetes 集群内其他组件（例如其他 Pod、Service）看到的 IP 地址是相同的。这消除了应用程序的歧义，简化了网络配置。</li><li><strong>实现方式：</strong> 这主要通过 CNI 插件来实现。CNI 插件会为 Pod 创建一个网络命名空间，并将容器连接到该命名空间。容器在该命名空间中看到的 IP 地址就是 Pod 的 IP 地址。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_CRI</title>
    <link href="/2025/03/22/kubernetes-CRI/"/>
    <url>/2025/03/22/kubernetes-CRI/</url>
    
    <content type="html"><![CDATA[<p>CRI 是 Kubernetes 定义的一组 gRPC 接口。它允许 kubelet（Kubernetes 的节点代理）与容器运行时（例如 Docker, containerd, CRI-O 等）进行通信。</p><span id="more"></span><h1 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CRI 是 Kubernetes 定义的一组 gRPC 接口。它允许 <strong>kubelet</strong>与<strong>容器运行时</strong>（例如 Docker, containerd, CRI-O 等）进行通信。这种接口的设计目的是为了<strong>解耦 Kubernetes 和特定的容器运行时实现</strong>，使得 Kubernetes 可以支持多种容器运行时，而无需修改 Kubernetes 的核心代码。</p><img src="/2025/03/22/kubernetes-CRI/image-20250324125824154.png" class="" title="image-20250324125824154"><h2 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a><strong>容器运行时</strong></h2><p>容器运行时通常被分为两个主要层级：高级运行时（High-level Runtime）和低级运行时（Low-level Runtime）。 这种分层架构有助于解耦容器管理的各个方面，提高了灵活性和可维护性。</p><ol><li><p><strong>高级运行时 (High-level Runtime)</strong></p><ul><li><p><strong>功能</strong>：高级运行时主要负责容器镜像的管理、容器生命周期的管理以及与容器编排系统（如 Kubernetes）的交互。它们提供了一个更友好的接口，简化了容器的创建、启动、停止和删除等操作。</p></li><li><p><strong>代表</strong>：<code>Docker shim</code>、<code>containerd</code>和<code>CRI-O</code></p></li><li><p><strong>流程</strong>：</p><ul><li>接收来自容器编排系统的指令（例如，创建容器）。</li><li>从镜像仓库下载容器镜像。</li><li>将镜像解压成 OCI 运行时文件系统包（filesystem bundle）。</li><li>调用低级运行时来实际创建和运行容器。</li><li>监控容器的生命周期，并向容器编排系统报告状态。</li></ul></li><li><p><strong>例如</strong>，当你使用 <code>docker run</code> 命令时，Docker 守护进程（dockerd）会调用 containerd，然后 containerd 负责拉取镜像、创建容器的元数据，并最终调用 runC 来启动容器。</p></li></ul></li><li><p><strong>低级运行时 (Low-level Runtime)</strong></p><ul><li><p><strong>功能</strong>：低级运行时直接与操作系统内核交互，负责创建和管理容器的隔离环境，包括命名空间（namespaces）、控制组（cgroups）以及文件系统的挂载等。</p></li><li><p><strong>标准</strong>：遵循 OCI（Open Container Initiative）运行时规范（Runtime Specification），该规范定义了如何从 OCI 运行时文件系统包运行容器进程，并定义了容器的配置、运行环境和生命周期。</p></li><li><p><strong>代表</strong>：<code>runC</code>、<code>kata-runtime</code>等。</p></li><li><p><strong>流程</strong>：</p><ul><li>接收来自高级运行时的指令和配置信息。</li><li>使用 Linux 内核的特性（如 namespaces 和 cgroups）来创建容器的隔离环境。</li><li>执行容器内的进程。</li><li>管理容器的资源限制。</li></ul></li><li><p><strong>深入理解 runC</strong>：</p><ul><li><code>runC</code> 是一个轻量级的、可移植的容器运行时工具，它是 Docker 的核心组件之一。它直接调用 Linux 内核的 API 来创建容器。</li><li><code>runC</code> 的主要功能包括：<ul><li><strong>命名空间（Namespaces）</strong>：为容器提供隔离的运行环境，包括 PID、网络、IPC、Mount、UTS 和 User namespaces。</li><li><strong>控制组（Cgroups）</strong>：限制容器可以使用的资源，如 CPU、内存、磁盘 I&#x2F;O 等。</li><li><strong>文件系统隔离</strong>：通过 chroot 或 pivot_root 将容器的文件系统与主机隔离。</li><li><strong>能力（Capabilities）</strong>：控制容器内进程可以执行的特权操作。</li></ul></li></ul></li></ul></li></ol><h2 id="OCI（Open-Container-Initiative）"><a href="#OCI（Open-Container-Initiative）" class="headerlink" title="OCI（Open Container Initiative）"></a><strong>OCI（Open Container Initiative）</strong></h2><p>OCI 是一个开源项目，旨在制定容器格式和运行时的开放标准。OCI 定义了两个主要的规范：</p><ul><li><strong>镜像规范（Image Specification）</strong>：定义了容器镜像的格式。</li><li><strong>运行时规范（Runtime Specification）</strong>：定义了如何运行容器。</li></ul><p>通过遵循 OCI 标准，不同的容器运行时可以互操作，从而避免了厂商锁定。</p><h2 id="开源运行时的比较"><a href="#开源运行时的比较" class="headerlink" title="开源运行时的比较"></a>开源运行时的比较</h2><p><strong>1. 整体架构</strong></p><ul><li><strong>Docker:</strong> 从图中可以看出，Docker 的架构相对复杂，涉及多个组件，包括 dockershim, docker, containerd。这使得 Docker 在 Kubernetes 中的集成略显笨重，维护和调试也相对复杂。</li><li><strong>Containerd:</strong> Containerd 的架构更为简洁，直接通过 <code>cri-containerd</code> 与 Kubernetes 集成，减少了中间环节，提高了效率和稳定性。Containerd 通过 <code>containerd-shim</code> 与底层的 OCI 运行时交互，负责容器的生命周期管理。</li><li><strong>CRI-O:</strong> CRI-O 的设计目标是成为 Kubernetes 的专用容器运行时。它直接实现了 Kubernetes CRI (Container Runtime Interface)，通过 <code>conmon</code> 监控容器进程，并使用 OCI 运行时 (如 runc) 创建和管理容器。</li></ul><p><strong>2. 关键组件</strong></p><ul><li><strong>dockershim:</strong>  dockershim 是 Kubernetes 为了兼容 Docker 而引入的组件，它充当了 Docker 和 Kubernetes 之间的适配器。但 dockershim 的引入增加了维护成本，也限制了 Kubernetes 对其他容器运行时的支持。在 Kubernetes 1.24 版本中，dockershim 已被移除。</li><li><strong>containerd:</strong> Containerd 是一个 CNCF (Cloud Native Computing Foundation) 项目，它提供了一个工业标准的容器运行时。Containerd 专注于容器的生命周期管理、镜像分发和存储等核心功能。</li><li><strong>CRI-O:</strong> CRI-O 是一个轻量级的容器运行时，专门为 Kubernetes 设计。它只关注 Kubernetes 需要的功能，例如镜像拉取、容器创建、启动、停止和删除等。</li><li><strong>OCI Runtime:</strong> OCI (Open Container Initiative) 运行时，如 runc，是真正创建和运行容器的组件。它们负责与操作系统内核交互，完成容器的隔离、资源限制等操作。</li></ul><p><strong>3. 与 Kubernetes 的集成</strong></p><ul><li><strong>Docker:</strong> 通过 dockershim 集成，已被 Kubernetes 废弃。</li><li><strong>Containerd:</strong> 通过 <code>cri-containerd</code> 插件直接集成，是 Kubernetes 推荐的容器运行时。</li><li><strong>CRI-O:</strong> 原生支持 Kubernetes CRI，无需额外的适配层。</li></ul><img src="/2025/03/22/kubernetes-CRI/image-20250325124303637.png" class="" title="image-20250325124303637"><ol start="4"><li><strong>性能比较</strong></li></ol><img src="/2025/03/22/kubernetes-CRI/image-20250325124452967.png" class="" title="image-20250325124452967">]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_kubelet</title>
    <link href="/2025/03/21/kubernetes-kubelet/"/>
    <url>/2025/03/21/kubernetes-kubelet/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h1><p>kubelet 是 Kubernetes 节点（Node）上的核心组件，负责管理节点上的 Pod 和容器生命周期，是 Kubernetes 控制平面（Control Plane）与节点层之间的桥梁。</p><span id="more"></span><hr><img src="/2025/03/21/kubernetes-kubelet/image-20250321224007971.png" class="" title="image-20250321224007971"><hr><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><h3 id="1-Kubelet-API"><a href="#1-Kubelet-API" class="headerlink" title="1. Kubelet API"></a><strong>1. Kubelet API</strong></h3><p>Kubelet 提供了一系列 HTTP API 服务，用于与外部或 Kubernetes 控制平面通信。关键的端口与服务如下：</p><ul><li><strong>:10250 API</strong>：接受 Master 节点发来的指令，管理 Pod 和 Pod 中的容器，每个 Kubelet 在 API Server 上注册自身节点信息，定期向 Master 发送节点使用情况，并通过 cAdvisor 监控节点和容器的资源。</li><li><strong>:10255 只读 API</strong> - 提供一个无需认证的只读接口，通常用于外部系统（如监控系统）获取 Pod 和节点的状态信息。（此端口已逐渐不推荐使用）</li><li><strong>:10248 &#x2F;healthz</strong> - 用于 Kubelet 自身的健康检查。主要提供 <code>/healthz</code> 接口，以供其他组件监控 Kubelet 运行状况。</li></ul><p>这些接口是外界与 Kubelet 交互的重要入口。</p><hr><h3 id="2-核心组件"><a href="#2-核心组件" class="headerlink" title="2. 核心组件"></a><strong>2. 核心组件</strong></h3><h4 id="1-syncLoop"><a href="#1-syncLoop" class="headerlink" title="(1) syncLoop"></a><strong>(1) syncLoop</strong></h4><p><code>syncLoop</code> 是 Kubelet 的核心主循环，负责持续同步节点的状态和调度的 Pod 期望状态。</p><ul><li>通过 Kubernetes API Server <strong>Watch</strong> 机制获取调度到该节点的 Pod 信息（期望状态）。</li><li>对比节点上实际运行的 Pod 状态（实际状态）。</li><li>调用其他模块（如 <code>PodWorker</code>）完成实际状态与期望状态的对齐。</li></ul><h4 id="2-PodWorker"><a href="#2-PodWorker" class="headerlink" title="(2) PodWorker"></a><strong>(2) PodWorker</strong></h4><p><code>PodWorker</code> 是每个 Pod 的具体操作执行模块。它是一个并发协程池，用于处理 Pod 的创建、更新、删除等任务。与 <code>syncLoop</code> 配合，<code>PodWorker</code> 实现了节点状态与调度期望状态的最终一致性。</p><h4 id="3-ProbeManager"><a href="#3-ProbeManager" class="headerlink" title="(3) ProbeManager"></a><strong>(3) ProbeManager</strong></h4><p><code>ProbeManager</code> 负责 Pod 的健康检查。</p><ul><li><strong>Liveness Probe</strong>：判断容器是否健康，不健康时触发重启。</li><li><strong>Readiness Probe</strong>：判断容器是否准备就绪，用于流量负载分发。</li><li><strong>Startup Probe</strong>：当容器启动较慢时，避免被误判为不健康。</li></ul><p>ProbeManager 会根据 Pod 的探针配置，周期性调用相关检查逻辑，确保应用运行状态。</p><h4 id="4-OOMWatcher"><a href="#4-OOMWatcher" class="headerlink" title="(4) OOMWatcher"></a><strong>(4) OOMWatcher</strong></h4><p><code>OOMWatcher</code> 监听容器是否因内存不足（OOM）被系统杀死，并触发回调通知其他模块进行后续处理。</p><h4 id="5-GPUManager"><a href="#5-GPUManager" class="headerlink" title="(5) GPUManager"></a><strong>(5) GPUManager</strong></h4><p><code>GPUManager</code> 专为需要显卡支持的容器（如深度学习模型或 GPU 加速的应用）服务，确保请求 GPU 资源的 Pod 能够成功调度并正常初始化设备。</p><h4 id="6-cAdvisor"><a href="#6-cAdvisor" class="headerlink" title="(6) cAdvisor"></a><strong>(6) cAdvisor</strong></h4><p>cAdvisor 是 Google 开源的资源监控工具，被内置为 Kubelet 的一部分，负责收集节点和容器的资源消耗（CPU、内存、网络、磁盘 IO 等）。这些数据被用于：</p><ul><li>提供给 Kubernetes 控制平面的资源调度。</li><li>在节点上触发资源回收或补救机制。</li></ul><h4 id="7-DiskSpaceManager-Image-GC"><a href="#7-DiskSpaceManager-Image-GC" class="headerlink" title="(7) DiskSpaceManager &amp; Image GC"></a><strong>(7) DiskSpaceManager &amp; Image GC</strong></h4><ul><li><code>DiskSpaceManager</code> 负责监控节点磁盘空间，并协作执行相应的垃圾回收。</li><li><code>Image GC</code> 用于定期回收未使用的镜像资源，避免磁盘因持久化镜像而耗尽。</li></ul><h4 id="8-StatusManager"><a href="#8-StatusManager" class="headerlink" title="(8) StatusManager"></a><strong>(8) StatusManager</strong></h4><p><code>StatusManager</code> 负责汇报节点和 Pod 的状态信息。具体工作包括：</p><ul><li>将本地运行中 Pod 的状态（如 Ready、运行时间、网络状态）上传到 API Server。</li><li>将状态数据同步到 <code>syncLoop</code>，用于进一步决策。</li></ul><h4 id="9-EvictionManager"><a href="#9-EvictionManager" class="headerlink" title="(9) EvictionManager"></a><strong>(9) EvictionManager</strong></h4><p><code>EvictionManager</code> 负责节点资源压力下的 Pod 驱逐。它监控节点整体资源状况，当内存、磁盘、inode 等资源低于预设阈值时，会主动驱逐“非关键”Pod 以释放资源。</p><h4 id="10-VolumeManager"><a href="#10-VolumeManager" class="headerlink" title="(10) VolumeManager"></a><strong>(10) VolumeManager</strong></h4><p><code>VolumeManager</code> 负责处理 Pod 的存储卷挂载和卸载，例如支持 <code>PersistentVolume</code> (PV) 的分配与管理。在 Pod 创建过程中，确保所需存储卷按请求挂载到容器。</p><h4 id="11-CertificateManager"><a href="#11-CertificateManager" class="headerlink" title="(11) CertificateManager"></a><strong>(11) CertificateManager</strong></h4><p><code>CertificateManager</code> 负责管理 Kubelet 所需的证书和密钥文件，用于与 API Server 安全通信的 TLS 握手。</p><hr><h2 id="kubelet-管理-Pod-的流程"><a href="#kubelet-管理-Pod-的流程" class="headerlink" title="kubelet 管理 Pod 的流程"></a>kubelet 管理 Pod 的流程</h2><img src="/2025/03/21/kubernetes-kubelet/image-20250321232354306.png" class="" title="image-20250321232354306"><ol><li><p><strong>Pod 清单的生产与获取</strong>：</p><ul><li><strong>API Server</strong>：Kubelet 从 API Server 获取需要运行的 Pod 信息。</li><li><strong>Manifest 目录</strong>：通过启动参数 <code>--config</code> 指定目录（如 <code>/etc/kubernetes/manifests/</code>），周期性扫描文件获取 Pod 定义（默认间隔 20 秒，可配置）。</li><li><strong>HTTP Server</strong>：通过启动参数 <code>--manifest-url</code> 设置 URL 来周期性拉取 Pod 清单。</li><li><strong>HTTP 接口调用</strong>：通过 kubelet 自身暴露的 HTTP 服务接口，允许动态提交新的 Pod 清单。</li></ul></li><li><p><strong>syncLoop - 消费者流程</strong>：</p><ul><li>Kubelet 的核心事件循环（syncLoop）持续监听 Pod 变更事件（如新建、更新或删除）。</li><li><strong>Worker 处理逻辑</strong>：<ul><li>调用 <code>syncPod</code> 函数处理每个 Pod。</li><li>在 <code>syncPod</code> 中，调用 <code>computePodActions</code> 比对清单中的 Pod（期望状态）和当前节点运行中的实际 Pod（实际状态）。</li><li>根据比对结果，计算需要新增、修改或删除的 Pod，并通过容器运行时接口（CRI：Container Runtime Interface）执行相应的操作。</li></ul></li></ul></li><li><p><strong>容器运行时接口 (CRI)</strong>：</p><ul><li>Kubelet 并不会直接操作容器，而是通过 CRI 进行抽象的容器操作。</li><li>CRI 执行 Pod 和容器的新增、更新、删除操作，屏蔽物理容器运行时（如 Docker、containerd）之间的实现差异。</li></ul></li></ol><hr><h2 id="Pod-生命周期管理-PLEG"><a href="#Pod-生命周期管理-PLEG" class="headerlink" title="Pod 生命周期管理 (PLEG)"></a><strong>Pod 生命周期管理 (PLEG)</strong></h2><p><strong>PLEG (Pod Lifecycle Event Generator)</strong> 是 Kubelet 的一个关键模块，用于监听和维护容器的实际状态。</p><ol><li><p><strong>功能</strong>： </p><ul><li>收集当前节点上所有 Pod 的运行状态，例如容器是否已启动、运行中、退出等。</li><li>定期通过 <strong>relist 操作</strong>，从容器运行时（CRI）中获取实际 Pod 的状态清单。</li><li>将这些状态事件发送到 Kubelet，帮助它同步期望状态与实际状态。</li></ul></li><li><p><strong>状态报告</strong>：</p><ul><li>PLEG 的状态信息会周期性地上传到 Kubernetes 控制平面（API Server），并最终存储到 etcd 中。</li><li>如果 PLEG 中出现问题（如 relist 被阻塞或超时），Kubernetes 控制平面可能会错误地认为节点状态异常（Node Not Ready）。</li></ul></li><li><p><strong>性能限制</strong>：</p><ul><li>Kubernetes 会对每个节点上的 Pod 数量设定上限，原因包括：<ul><li><strong>时间开销</strong>：PLEG 每秒 relist 一次节点上的 Pod，如果 Pod 数过多，会使 relist 操作消耗大量时间。</li><li><strong>节点状态异常</strong>：如 CRI 卡住、无法及时上报状态时，就可能导致控制平面认为节点处于 <code>NotReady</code> 状态。</li></ul></li><li>这种限制保障了分布式系统的稳定性。</li></ul></li></ol><hr><h2 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a><strong>节点管理</strong></h2><p>Kubernetes 中的节点由 Kubelet 注册、监控并周期性汇报状态。以下是节点管理的主要流程：</p><ol><li><p><strong>Kubelet 的节点自注册</strong>：</p><ul><li>通过启动参数 <code>--register-node</code> 决定是否自动向 API Server 注册节点。</li><li>若启用，Kubelet 会在启动时通过与 API Server 通信，注册节点自身的信息（如容量、配置）。</li></ul></li><li><p><strong>手动注册节点</strong>：</p><ul><li>假如未开启节点自注册模式，用户需手动创建节点资源，并将节点的相关信息配置到 API Server。</li><li>同时，需要手动配置 Kubelet 的启动参数，告知其 API Server 的地址。</li></ul></li><li><p><strong>节点状态更新</strong>：</p><ul><li>Kubelet 会定期向控制平面（API Server）发送心跳、节点资源使用情况、节点运行状态等信息。</li><li>API Server 在收到这些信息后，将其写入 etcd，供调度器和控制器使用。</li></ul></li></ol><hr><h2 id="Pod-启动流程"><a href="#Pod-启动流程" class="headerlink" title="Pod 启动流程"></a><strong>Pod 启动流程</strong></h2><img src="/2025/03/21/kubernetes-kubelet/image-20250321234138744.png" class="" title="image-20250321234138744"><h3 id="1-用户提交-Pod-创建请求"><a href="#1-用户提交-Pod-创建请求" class="headerlink" title="1. 用户提交 Pod 创建请求"></a><strong>1. 用户提交 Pod 创建请求</strong></h3><p>用户通过 <code>kubectl</code> 命令或 Kubernetes API 客户端将 Pod 的定义（如 YAML 或 JSON 格式）发送到 API Server。 </p><ol><li><p><strong>流程细节</strong>：</p><ul><li>用户运行命令：<code>kubectl apply -f pod.yaml</code> 或直接调用 REST API。</li><li>API Server 会对收到的 Pod 对象执行一系列验证、权限检查和默认值填充等逻辑：<ul><li><strong>权限校验</strong>：通过 RBAC（Role-Based Access Control）验证用户对资源类型的权限。</li><li><strong>Admission Webhook</strong>：触发一系列 Admission Controllers，用于资源约束、默认值注入或自定义逻辑的执行。</li><li><strong>Schema 验证</strong>：验证 Pod 定义是否符合 Kubernetes 的 API 规范。</li></ul></li></ul></li><li><p><strong>写入 etcd</strong>：</p><ul><li>验证成功后，API Server 将 Pod 信息写入 etcd，与此同时，返回状态 <code>201 CREATED</code> 给用户，表示资源创建成功。</li><li>etcd 是 Kubernetes 的分布式一致性存储组件，所有的集群状态变更最终都会存储在 etcd 中。</li></ul></li></ol><hr><h3 id="2-调度器-Scheduler-分配节点"><a href="#2-调度器-Scheduler-分配节点" class="headerlink" title="2. 调度器 (Scheduler) 分配节点"></a><strong>2. 调度器 (Scheduler) 分配节点</strong></h3><p>调度器负责决定每个 Pod 应该在哪个 Node（工作节点）运行，这是 Kubernetes 中资源调度的重要阶段。</p><h3 id="流程细节："><a href="#流程细节：" class="headerlink" title="流程细节："></a>流程细节：</h3><ol><li><p><strong>Scheduler 监听未绑定的 Pod</strong>：</p><ul><li>调度器通过 Watch 机制监听 API Server，寻找 <code>spec.nodeName</code> 字段为空的 Pod（即尚未绑定到具体节点的 Pod）。</li></ul></li><li><p><strong>调度决策过程</strong>:</p><ul><li>调度器会根据 <strong>调度算法</strong> 对集群中的可用节点进行评估。主要包括：<ul><li><strong>Predicate - 过滤节点</strong>：<ul><li>基本过滤条件（如节点健康状态、资源容量是否足够等）会筛选出一组候选节点。</li><li>网络、存储条件等插件可能也会影响过滤结果。</li></ul></li><li><strong>Priority - 节点评分</strong>：<ul><li>为每个候选节点根据调度优先级打分，例如节点剩余资源多的分数更高，或使 Pod 与本地数据亲和的节点优先。</li><li>最终选择得分最高的一个节点。</li></ul></li></ul></li></ul></li><li><p><strong>绑定节点</strong>：</p><ul><li>调度器决定节点后，会通过调用 API Server 的 <code>Bind</code> 接口，将 Pod 的 <code>spec.nodeName</code> 字段设置为目标节点，建立 Pod 与节点的绑定关系。</li><li>Pod 的最新状态信息会被写入到 etcd 中，由 API Server 同步到其他组件。</li></ul></li></ol><hr><h3 id="3-Kubelet-开始管理-Pod"><a href="#3-Kubelet-开始管理-Pod" class="headerlink" title="3. Kubelet 开始管理 Pod"></a><strong>3. Kubelet 开始管理 Pod</strong></h3><p>调度完成后，Pod 被分配到具体的工作节点，此时 Kubelet（运行在该节点上的组件）开始接管 Pod 的创建和管理。</p><h4 id="Kubelet-的处理流程："><a href="#Kubelet-的处理流程：" class="headerlink" title="Kubelet 的处理流程："></a><strong>Kubelet 的处理流程</strong>：</h4><ol><li><p><strong>监听 API Server</strong>：</p><ul><li>Kubelet 通过 Watch 机制监听 API Server 上的 Pod 定义变更（绑定到本节点的 Pod）。</li><li>Pod 的元数据（如容器镜像名、CPU&#x2F;内存资源需求等）会被获取到本地。</li></ul></li><li><p><strong>创建 Pod 的 sandbox 容器</strong>：</p><ul><li>Kubelet 调用 CRI（Container Runtime Interface）接口，运行一个 Sandbox 容器（如 <code>pause</code> 容器）。具体流程：<ul><li><strong>Pause 容器作用：</strong><ul><li><code>pause</code> 是 Pod 的第一个容器，负责承载网络、PID 和 IPC 等共享的 Linux Namespace。</li><li>它是一个极为轻量级的容器（通常仅几百 KB 且几乎不占用 CPU），为 Pod 提供基础的隔离环境。</li></ul></li><li><strong>网络配置：</strong><ul><li>Sandbox 容器启动后，CNI（Container Network Interface） Plugin 会为 Pod 配置网络（如分配 IP 和设置网络路由）。</li><li>若 Pod 需要挂载存储卷，Kubelet 也会在这个阶段通过 CSI（Container Storage Interface）完成卷的挂载。</li></ul></li></ul></li></ul></li><li><p><strong>构建 Pod 的运行环境</strong>：</p><ul><li>Sandbox 容器运行成功后，容器运行时（如 containerd 或 Docker）会等待 Kubelet 的进一步指令来准备用户定义的应用容器。</li></ul></li><li><p><strong>容器生命周期管理</strong>：</p><ul><li>Kubelet 根据 Pod 定义中描述的容器逐一执行以下操作：<ul><li><strong>PullImage</strong>：拉取容器镜像（若镜像已存在，则跳过）。</li><li><strong>CreateContainer</strong>：创建容器。</li><li><strong>StartContainer</strong>：启动容器。</li></ul></li><li>当所有容器都创建并正常启动后，Pod 进入 “Running” 状态。</li></ul></li></ol><hr><h3 id="4-状态反馈与同步"><a href="#4-状态反馈与同步" class="headerlink" title="4. 状态反馈与同步"></a><strong>4. 状态反馈与同步</strong></h3><ol><li><p><strong>状态更新</strong>：</p><ul><li>Kubelet 会周期性地获取 Pod 的实际运行状态（通过 CRI 和 PLEG）：<ul><li>检查容器是否正常运行；</li><li>如果存在失败，则可能记录事件（Event）并尝试重启容器。</li></ul></li><li>这些状态信息会被汇报到 API Server，API Server 将其写入 etcd。</li></ul></li><li><p><strong>状态查询结果</strong>：</p><ul><li>用户通过 <code>kubectl get pod &lt;pod-name&gt; -o wide</code> 或其他方式查询 Pod 状态时，会从 etcd 中读取最新状态。</li><li>当所有容器成功运行，且健康检查通过时，Pod 会被标记为 <strong>Ready</strong>。</li></ul></li></ol><img src="/2025/03/21/kubernetes-kubelet/image-20250322110715382.png" class="" title="image-20250322110715382">]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang并发编程</title>
    <link href="/2025/03/18/golang-concurrency/"/>
    <url>/2025/03/18/golang-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="GO并发编程（Concurrency）"><a href="#GO并发编程（Concurrency）" class="headerlink" title="GO并发编程（Concurrency）"></a>GO并发编程（Concurrency）</h1><h4 id="通过通信共享内存（Share-by-communicating）"><a href="#通过通信共享内存（Share-by-communicating）" class="headerlink" title="通过通信共享内存（Share by communicating）"></a>通过通信共享内存（Share by communicating）</h4><p>并发编程是一个广泛的话题，这里只讨论一些与 Go 语言相关的重点。</p><p>在许多环境中，并发编程的难点在于如何正确访问共享变量。Go 语言鼓励一种不同的方法：</p><p><strong>通过通道（channel）传递共享值，而不是让多个执行线程主动共享内存。</strong></p><p>在任何给定时间，只有一个 goroutine 可以访问该值。通过设计，数据竞争不会发生。为了鼓励这种思维方式，我们将其简化为一个口号：</p><p><strong>不要通过共享内存来通信；相反，通过通信来共享内存。</strong></p><p>这种方法有时可能被过度使用。例如，引用计数可能最好通过在一个整数变量周围加锁来实现。但作为一种高级方法，使用通道来控制访问可以更容易编写清晰、正确的程序。</p><p>这种模型的一个思考方式是考虑一个在单个 CPU 上运行的典型单线程程序。它不需要同步原语。</p><p>现在运行另一个这样的实例；它也不需要同步。现在让这两个实例进行通信；如果通信本身就是同步器，那么仍然不需要其他同步。例如，Unix 管道完美地符合这种模型。尽管 Go 的并发方法源自 Hoare 的通信顺序进程（CSP），但它也可以被视为 Unix 管道的一种类型安全的泛化。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>它们被称为 goroutines，因为现有的术语（线程、协程、进程等）传达了不准确的含义。Goroutine 有一个简单的模型：它是一个与同一地址空间中的其他 goroutine 并发执行的函数。它是轻量级的，成本几乎只比分配栈空间多一点。而且栈一开始很小，所以它们很便宜，并且根据需要分配（和释放）堆存储来增长。</p><p>Goroutines 被多路复用到多个操作系统线程上，因此如果一个 goroutine 阻塞（例如等待 I&#x2F;O），其他 goroutine 可以继续运行。它们的设计隐藏了许多线程创建和管理的复杂性。</p><p>在函数或方法调用前加上 <code>go</code> 关键字，可以在一个新的 goroutine 中运行该调用。当调用完成时，goroutine 会静默退出。（效果类似于 Unix shell 的 <code>&amp;</code> 符号，用于在后台运行命令。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> list.Sort()  <span class="hljs-comment">// 并发运行 list.Sort；不等待它完成。</span><br></code></pre></td></tr></table></figure><p>在 goroutine 调用中，函数字面量（匿名函数）非常方便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Announce</span><span class="hljs-params">(message <span class="hljs-type">string</span>, delay time.Duration)</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(delay)<br>        fmt.Println(message)<br>    &#125;()  <span class="hljs-comment">// 注意括号 - 必须调用函数。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，函数字面量是闭包：实现确保函数引用的变量在它们活跃时一直存在。</p><p>这些例子不太实用，因为函数没有办法通知完成。为此，我们需要通道。</p><h4 id="通道（Channels）"><a href="#通道（Channels）" class="headerlink" title="通道（Channels）"></a>通道（Channels）</h4><p>与映射（map）一样，通道是用 <code>make</code> 分配的，结果值是对底层数据结构的引用。如果提供了一个可选的整数参数，它会设置通道的缓冲区大小。默认值为零，表示无缓冲或同步通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ci := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)            <span class="hljs-comment">// 无缓冲的整数通道</span><br>cj := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>)         <span class="hljs-comment">// 无缓冲的整数通道</span><br>cs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *os.File, <span class="hljs-number">100</span>)  <span class="hljs-comment">// 缓冲的文件指针通道</span><br></code></pre></td></tr></table></figure><p>无缓冲通道将通信（值的交换）与同步（保证两个计算（goroutine）处于已知状态）结合在一起。</p><p>使用通道有很多好的习惯用法。这里有一个例子。在上一节中，我们在后台启动了一个排序。通道可以让启动的 goroutine 等待排序完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <span class="hljs-comment">// 分配一个通道。</span><br><span class="hljs-comment">// 在 goroutine 中启动排序；完成后，通过通道发送信号。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    list.Sort()<br>    c &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">// 发送信号；值不重要。</span><br>&#125;()<br>doSomethingForAWhile()<br>&lt;-c   <span class="hljs-comment">// 等待排序完成；丢弃发送的值。</span><br></code></pre></td></tr></table></figure><p>接收者总是阻塞，直到有数据可以接收。如果通道是无缓冲的，发送者会阻塞，直到接收者接收到值。如果通道有缓冲区，发送者只会在值被复制到缓冲区之前阻塞；如果缓冲区已满，这意味着等待某个接收者检索一个值。</p><p>缓冲通道可以像信号量一样使用，例如限制吞吐量。在这个例子中，传入的请求被传递给 <code>handle</code>，它向通道发送一个值，处理请求，然后从通道接收一个值，以便为下一个消费者准备好“信号量”。通道缓冲区的容量限制了同时调用 <code>process</code> 的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, MaxOutstanding)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(r *Request)</span></span> &#123;<br>    sem &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 等待活动队列排空。</span><br>    process(r)  <span class="hljs-comment">// 可能需要很长时间。</span><br>    &lt;-sem       <span class="hljs-comment">// 完成；启用下一个请求运行。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        req := &lt;-queue<br>        <span class="hljs-keyword">go</span> handle(req)  <span class="hljs-comment">// 不要等待 handle 完成。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦 <code>MaxOutstanding</code> 个处理程序正在执行 <code>process</code>，任何更多的处理程序都会阻塞，尝试向已满的通道缓冲区发送数据，直到现有的处理程序之一完成并从缓冲区接收数据。</p><p>不过，这个设计有一个问题：<code>Serve</code> 为每个传入的请求创建一个新的 goroutine，即使在任何时刻只有 <code>MaxOutstanding</code> 个 goroutine 可以运行。因此，如果请求来得太快，程序可能会消耗无限的资源。我们可以通过修改 <code>Serve</code> 来限制 goroutine 的创建来解决这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue &#123;<br>        sem &lt;- <span class="hljs-number">1</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            process(req)<br>            &lt;-sem<br>        &#125;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（注意，在 Go 1.22 之前的版本中，这段代码有一个 bug：循环变量在所有 goroutine 之间共享。详情请参阅 Go wiki。）</p><p>另一种管理资源的方法是启动固定数量的 <code>handle</code> goroutine，它们都从请求通道中读取。goroutine 的数量限制了同时调用 <code>process</code> 的数量。这个 <code>Serve</code> 函数还接受一个通道，用于通知它退出；在启动 goroutine 后，它会阻塞接收该通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> r := <span class="hljs-keyword">range</span> queue &#123;<br>        process(r)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(clientRequests <span class="hljs-keyword">chan</span> *Request, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 启动处理程序</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; MaxOutstanding; i++ &#123;<br>        <span class="hljs-keyword">go</span> handle(clientRequests)<br>    &#125;<br>    &lt;-quit  <span class="hljs-comment">// 等待被告知退出。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通道的通道（Channels-of-channels）"><a href="#通道的通道（Channels-of-channels）" class="headerlink" title="通道的通道（Channels of channels）"></a>通道的通道（Channels of channels）</h4><p>Go 最重要的特性之一是通道是一等值，可以像其他值一样分配和传递。这个特性的一个常见用途是实现安全的并行多路分解。</p><p>在上一节的例子中，<code>handle</code> 是一个理想化的请求处理程序，但我们没有定义它处理的类型。如果该类型包含一个用于回复的通道，每个客户端都可以提供自己的答案路径。以下是 <code>Request</code> 类型的示意定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>    args        []<span class="hljs-type">int</span><br>    f           <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>    resultChan  <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>客户端提供一个函数及其参数，以及请求对象中的一个通道，用于接收答案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br>request := &amp;Request&#123;[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, sum, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)&#125;<br><span class="hljs-comment">// 发送请求</span><br>clientRequests &lt;- request<br><span class="hljs-comment">// 等待响应。</span><br>fmt.Printf(<span class="hljs-string">&quot;answer: %d\n&quot;</span>, &lt;-request.resultChan)<br></code></pre></td></tr></table></figure><p>在服务器端，处理函数是唯一改变的部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue &#123;<br>        req.resultChan &lt;- req.f(req.args)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，要使它更现实，还有很多工作要做，但这段代码是一个限速、并行、非阻塞 RPC 系统的框架，而且没有使用任何互斥锁。</p><h4 id="并行化（Parallelization）"><a href="#并行化（Parallelization）" class="headerlink" title="并行化（Parallelization）"></a>并行化（Parallelization）</h4><p>这些思想的另一个应用是在多个 CPU 核心上并行化计算。如果计算可以分解为可以独立执行的单独部分，那么它可以并行化，并使用通道来通知每个部分何时完成。</p><p>假设我们有一个对向量中的项目执行昂贵操作的需求，并且每个项目的操作值是独立的，如这个理想化的例子所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vector []<span class="hljs-type">float64</span><br><br><span class="hljs-comment">// 对 v[i], v[i+1] ... 直到 v[n-1] 应用操作。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vector)</span></span> DoSome(i, n <span class="hljs-type">int</span>, u Vector, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">for</span> ; i &lt; n; i++ &#123;<br>        v[i] += u.Op(v[i])<br>    &#125;<br>    c &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 发送信号表示这部分已完成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在循环中独立启动这些部分，每个 CPU 一个。它们可以以任何顺序完成，但这并不重要；我们只需在启动所有 goroutine 后通过排空通道来计算完成信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> numCPU = <span class="hljs-number">4</span> <span class="hljs-comment">// CPU 核心数</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vector)</span></span> DoAll(u Vector) &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numCPU)  <span class="hljs-comment">// 缓冲是可选的，但明智的。</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCPU; i++ &#123;<br>        <span class="hljs-keyword">go</span> v.DoSome(i*<span class="hljs-built_in">len</span>(v)/numCPU, (i+<span class="hljs-number">1</span>)*<span class="hljs-built_in">len</span>(v)/numCPU, u, c)<br>    &#125;<br>    <span class="hljs-comment">// 排空通道。</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCPU; i++ &#123;<br>        &lt;-c    <span class="hljs-comment">// 等待一个任务完成</span><br>    &#125;<br>    <span class="hljs-comment">// 全部完成。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与其为 <code>numCPU</code> 创建一个常量值，我们可以询问运行时什么值是合适的。函数 <code>runtime.NumCPU</code> 返回机器中的硬件 CPU 核心数，因此我们可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numCPU = runtime.NumCPU()<br></code></pre></td></tr></table></figure><p>还有一个函数 <code>runtime.GOMAXPROCS</code>，它报告（或设置）用户指定的 Go 程序可以同时运行的 CPU 核心数。它默认为 <code>runtime.NumCPU</code> 的值，但可以通过设置同名的 shell 环境变量或调用该函数并传递一个正数来覆盖。传递零只是查询该值。因此，如果我们想尊重用户的资源请求，我们应该这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numCPU = runtime.GOMAXPROCS(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>确保不要混淆并发（将程序结构化为独立执行的组件）和并行（在多个 CPU 上并行执行计算以提高效率）的概念。尽管 Go 的并发特性可以使一些问题容易结构化为并行计算，但 Go 是一种并发语言，而不是并行语言，并非所有并行化问题都适合 Go 的模型。有关区别的讨论，请参阅此博客文章中引用的演讲。</p><h4 id="漏桶（Leaky-buffer）"><a href="#漏桶（Leaky-buffer）" class="headerlink" title="漏桶（Leaky buffer）"></a>漏桶（Leaky buffer）</h4><p>并发编程的工具甚至可以使非并发的思想更容易表达。这里有一个从 RPC 包中抽象出来的例子。客户端 goroutine 循环从某个源（可能是网络）接收数据。为了避免分配和释放缓冲区，它保留一个空闲列表，并使用一个缓冲通道来表示它。如果通道为空，则分配一个新的缓冲区。一旦消息缓冲区准备好，它就会被发送到 <code>serverChan</code> 上的服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> freeList = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">var</span> serverChan = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">client</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">var</span> b *Buffer<br>        <span class="hljs-comment">// 如果有可用的缓冲区，则获取；否则分配一个新的。</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> b = &lt;-freeList:<br>            <span class="hljs-comment">// 获取一个；无需做更多操作。</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 没有空闲的，所以分配一个新的。</span><br>            b = <span class="hljs-built_in">new</span>(Buffer)<br>        &#125;<br>        load(b)              <span class="hljs-comment">// 从网络读取下一条消息。</span><br>        serverChan &lt;- b      <span class="hljs-comment">// 发送到服务器。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器循环接收来自客户端的每条消息，处理它，并将缓冲区返回到空闲列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        b := &lt;-serverChan    <span class="hljs-comment">// 等待工作。</span><br>        process(b)<br>        <span class="hljs-comment">// 如果有空间，则重用缓冲区。</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> freeList &lt;- b:<br>            <span class="hljs-comment">// 缓冲区在空闲列表上；无需做更多操作。</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 空闲列表已满，继续执行。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端尝试从 <code>freeList</code> 中检索一个缓冲区；如果没有可用的，则分配一个新的。服务器的发送到 <code>freeList</code> 将 <code>b</code> 放回空闲列表，除非列表已满，在这种情况下，缓冲区会被丢弃，由垃圾回收器回收。（<code>select</code> 语句中的 <code>default</code> 子句在没有其他 case 准备就绪时执行，这意味着 <code>select</code> 永远不会阻塞。）这个实现在几行代码中构建了一个漏桶空闲列表，依赖于缓冲通道和垃圾回收器进行簿记。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang错误处理</title>
    <link href="/2025/03/18/golang-error/"/>
    <url>/2025/03/18/golang-error/</url>
    
    <content type="html"><![CDATA[<h2 id="Golang-的错误处理（Error-Handling）"><a href="#Golang-的错误处理（Error-Handling）" class="headerlink" title="Golang 的错误处理（Error Handling）"></a>Golang 的错误处理（Error Handling）</h2><hr><h3 id="1-Errors-包"><a href="#1-Errors-包" class="headerlink" title="1. Errors 包"></a>1. Errors 包</h3><p>Error 是一个<code>interface</code>，只要实现了<code>Error() string</code>接口的结构体都是一个 Error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>最简单的 error 示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;division by zero is not allowed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result, err := divide(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-Sentinel-Error（预定义的-Error）"><a href="#2-Sentinel-Error（预定义的-Error）" class="headerlink" title="2. Sentinel Error（预定义的 Error）"></a>2. Sentinel Error（预定义的 Error）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// ErrNotFound 定义 Sentinel Error</span><br><span class="hljs-keyword">var</span> ErrNotFound = errors.New(<span class="hljs-string">&quot;item not found&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findItem</span><span class="hljs-params">(items []<span class="hljs-type">string</span>, target <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> item == target &#123;<br><span class="hljs-keyword">return</span> item, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, ErrNotFound<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>items := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;<br>_, err := findItem(items, <span class="hljs-string">&quot;grape&quot;</span>)<br><br><span class="hljs-keyword">if</span> errors.Is(err, ErrNotFound) &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error: Item not found in the list&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Unexpected error:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Item found&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-自定义错误类型"><a href="#3-自定义错误类型" class="headerlink" title="3. 自定义错误类型"></a>3. 自定义错误类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// MyError 自定义错误类型</span><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>Operation <span class="hljs-type">string</span><br>Err       <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;operation %s failed: %v&quot;</span>, e.Operation, e.Err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> e.Err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 模拟一个底层错误</span><br><span class="hljs-keyword">return</span> &amp;MyError&#123;<br>Operation: <span class="hljs-string">&quot;file_read&quot;</span>,<br>Err:       fmt.Errorf(<span class="hljs-string">&quot;file not found&quot;</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := doSomething()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-Wrap-Error"><a href="#4-Wrap-Error" class="headerlink" title="4. Wrap Error"></a>4. Wrap Error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 模拟底层错误</span><br><span class="hljs-keyword">return</span> os.ErrNotExist<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := readFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 包装底层错误</span><br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;processFile failed: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := processFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> errors.Is(err, os.ErrNotExist) &#123;<br>fmt.Println(<span class="hljs-string">&quot;File does not exist&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Unexpected error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Is 的源代码如下：</p><p><code>is</code>中会去<code>unwrap</code>最后确定这两个 <code>err</code> 的最底层是否一致。ß</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> || target == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err == target<br>&#125;<br><br>isComparable := reflectlite.TypeOf(target).Comparable()<br><span class="hljs-keyword">return</span> is(err, target, isComparable)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>, targetComparable <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> targetComparable &amp;&amp; err == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; Is(<span class="hljs-type">error</span>) <span class="hljs-type">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">switch</span> x := err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123; Unwrap() <span class="hljs-type">error</span> &#125;:<br>err = x.Unwrap()<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123; Unwrap() []<span class="hljs-type">error</span> &#125;:<br><span class="hljs-keyword">for</span> _, err := <span class="hljs-keyword">range</span> x.Unwrap() &#123;<br><span class="hljs-keyword">if</span> is(err, target, targetComparable) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-As-提取指定错误"><a href="#5-As-提取指定错误" class="headerlink" title="5. As 提取指定错误"></a>5. As 提取指定错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 模拟底层错误</span><br><span class="hljs-keyword">return</span> &amp;os.PathError&#123;<br>Op:   <span class="hljs-string">&quot;open&quot;</span>,<br>Path: <span class="hljs-string">&quot;/nonexistent/file&quot;</span>,<br>Err:  os.ErrNotExist,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := readFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> pathErr *os.PathError<br><span class="hljs-keyword">if</span> errors.As(err, &amp;pathErr) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;File operation failed: %v (path: %s)\n&quot;</span>, pathErr.Err, pathErr.Path)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Unexpected error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-整合日志记录与错误处理"><a href="#6-整合日志记录与错误处理" class="headerlink" title="6. 整合日志记录与错误处理"></a>6. <strong>整合日志记录与错误处理</strong></h3><p>在 Goroutine 的顶层统一记录日志并打印堆栈信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;something went wrong&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := process()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 顶层记录错误日志</span><br>fmt.Printf(<span class="hljs-string">&quot;Error occurred: %+v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Process completed successfully&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-模拟-DAO-错误处理"><a href="#7-模拟-DAO-错误处理" class="headerlink" title="7. 模拟 DAO 错误处理"></a>7. 模拟 DAO 错误处理</h3><p>数据库操作中的错误处理示例，注重上下文信息的传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟 DAO 层查询</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">queryUserByID</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> id == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, sql.ErrNoRows<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findUserByID</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>user, err := queryUserByID(id)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> errors.Is(err, sql.ErrNoRows) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;user with ID %d not found: %w&quot;</span>, id, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected database error: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_, err := findUserByID(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="8-pkg-errors"><a href="#8-pkg-errors" class="headerlink" title="8. pkg&#x2F;errors"></a>8. pkg&#x2F;errors</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;file not found&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := readFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;failed to process file&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := processFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// %+v 会打印堆栈信息</span><br>fmt.Printf(<span class="hljs-string">&quot;Error: %+v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wrap returns an error annotating err with a stack trace</span><br><span class="hljs-comment">// at the point Wrap is called, and the supplied message.</span><br><span class="hljs-comment">// If err is nil, Wrap returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>, message <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>err = &amp;withMessage&#123;<br>cause: err,<br>msg:   message,<br>&#125;<br><span class="hljs-keyword">return</span> &amp;withStack&#123;<br>err,<br>callers(),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Warp 会追踪栈的调用链。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_controller_manager</title>
    <link href="/2025/03/18/kubernetes-controller-manager/"/>
    <url>/2025/03/18/kubernetes-controller-manager/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-Controller-Manager"><a href="#k8s-Controller-Manager" class="headerlink" title="k8s-Controller-Manager"></a>k8s-Controller-Manager</h1><p><code>Controller Manager</code> 是 Kubernetes（K8S）中的一个核心组件，负责管理和运行各种控制器（Controllers）。控制器是 Kubernetes 的自动化机制之一，Controller Manager 通过与 API Server 的交互来获取和更新集群的状态信息。它使用 Kubernetes 的 <code>watch</code> API 来实时监控资源的变化，并根据这些变化执行相应的操作。</p><!--more---><h2 id="控制器的工作流程"><a href="#控制器的工作流程" class="headerlink" title="控制器的工作流程"></a>控制器的工作流程</h2><img src="/2025/03/18/kubernetes-controller-manager/image-20250319131225932.png" class=""><h3 id="Informer-和-Lister-的关系"><a href="#Informer-和-Lister-的关系" class="headerlink" title="Informer 和 Lister 的关系"></a>Informer 和 Lister 的关系</h3><p>Informer内部通过<code>Store</code>（基于<code>cache.FIFO</code>或<code>cache.RateLimiter</code>）存储资源对象数据，而Lister的接口实现（如<code>GridLister</code>）<strong>直接读取Informer的Store</strong>，因此Lister是Informer数据的<strong>查询接口</strong>。</p><p>Informer负责<strong>实时监听API Server变更</strong>（通过ListAndWatch机制），将资源变化事件（Add&#x2F;Update&#x2F;Delete）写入Store并触发处理链。</p><p>Lister提供<strong>快照式查询能力</strong>（如<code>List()</code>、<code>Get()</code>），通过直接访问Informer的Store实现低延迟查询，避免每次直接调用API Server。</p><h4 id="1-核心组件与流程"><a href="#1-核心组件与流程" class="headerlink" title="1. 核心组件与流程"></a>1. <strong>核心组件与流程</strong></h4><ul><li><p><strong>Lister</strong></p><ul><li>提供 <code>List()</code> 接口获取资源对象的全量快照（如 <code>ListPods()</code>）。</li><li>通过 <code>Informer</code> 的 <code>Lister()</code> 方法获取，确保与缓存数据同步。</li><li><strong>实现</strong>：基于 <code>Reflector</code> 的初始 List 操作，结合 Informer 缓存。</li></ul></li><li><p><strong>Informer</strong></p><ul><li>核心：<code>SharedIndexInformer</code>（实现 <code>Informers</code> 接口）。</li><li><strong>机制</strong>：<ol><li><strong>List+Watch</strong>：通过 API Server 获取资源初始列表（List）并建立 Watch 长连接（Watch）。</li><li><strong>缓存</strong>：本地缓存资源对象（线程安全，通过 <code>DeltaFIFO</code> 或 <code>Store</code> 实现）。</li><li><strong>事件分发</strong>：将 Watch 到的事件（Add&#x2F;Update&#x2F;Delete）传递给 <code>ResourceEventHandler</code>。</li></ol></li></ul></li><li><p><strong>EventHandler</strong></p><ul><li>定义事件处理逻辑：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourceEventHandler <span class="hljs-keyword">interface</span> &#123;<br>    OnAdd(obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    OnUpdate(oldObj, newObj <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    OnDelete(obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>关键点</strong>：<ul><li>Update 事件需通过 <code>obj.DeepCopy()</code> 避免直接操作缓存对象。</li><li>Delete 事件可能携带 <code>gracePeriod</code>，需处理最终状态。</li></ul></li></ul></li><li><p><strong>Enqueue 到 WorkQueue</strong></p><ul><li><strong>KeyFunc</strong>：生成队列键（如 <code>controller.KeyFunc</code> 默认使用 <code>&lt;namespace&gt;/&lt;name&gt;</code>）。</li><li><strong>Enqueue</strong>：将键加入 <code>workqueue.RateLimitingInterface</code>（如 <code>NewRateLimitingQueue</code>）。</li><li><strong>RateLimiter</strong>：<ul><li>配置指数退避算法（如 <code>ExponentialBackoff</code>），失败任务重试间隔随失败次数指数增长。</li><li>通过 <code>workqueue.NewMaxHeapRateLimiter</code> 设置最大&#x2F;最小重试间隔。</li></ul></li></ul></li></ul><h4 id="2-Worker-处理流程"><a href="#2-Worker-处理流程" class="headerlink" title="2. Worker 处理流程"></a>2. <strong>Worker 处理流程</strong></h4><ul><li><strong>Goroutine</strong>：<ul><li>启动多个 worker 从队列中 <code>Dequeue()</code> 任务。</li><li><strong>关键逻辑</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        key := queue.Get()<br>        obj, exists := store.GetByKey(key)<br>        <span class="hljs-keyword">if</span> !exists &#123; <span class="hljs-comment">// 对象已删除</span><br>            queue.Forget(key)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> err := process(obj) &#123;<br>            <span class="hljs-keyword">if</span> err == ErrTooEarly &#123; <span class="hljs-comment">// 需重试</span><br>                queue.AddRateLimited(key)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.Forget(key)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queue.Forget(key)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>指数退避</strong>：<ul><li><code>AddRateLimited</code> 触发 RateLimiter 计算延迟，失败次数越多，重试间隔越长。</li><li>通过 <code>workqueue.AddAfter</code> 或 <code>workqueue.Forget</code> 控制重试逻辑。</li></ul></li></ul></li></ul><h4 id="3-关键机制补充"><a href="#3-关键机制补充" class="headerlink" title="3. 关键机制补充"></a>3. <strong>关键机制补充</strong></h4><ul><li><p><strong>ReSync 机制</strong>：</p><ul><li>通过 <code>ResyncPeriod</code> 定期强制刷新缓存（如每 30 分钟 List 一次资源）。</li><li>作用：避免 Watch 断连导致的缓存不一致。</li></ul></li><li><p><strong>并发安全</strong>：</p><ul><li><code>SharedIndexInformer</code> 的缓存是线程安全的，但 <code>worker</code> 处理需自行保证业务逻辑的原子性。</li><li><code>workqueue</code> 的 <code>Add</code>&#x2F;<code>Get</code> 操作已原子化，但需通过 <code>Forget</code>&#x2F;<code>Done</code> 管理键状态。</li></ul></li><li><p><strong>错误处理策略</strong>：</p><ul><li><strong>永久错误</strong>（如无效配置）：直接 <code>queue.Forget</code>，避免无限重试。</li><li><strong>临时错误</strong>（如 API 限流）：通过 <code>queue.AddRateLimited</code> 触发指数退避。</li></ul></li></ul><h2 id="Informer-详解"><a href="#Informer-详解" class="headerlink" title="Informer 详解"></a>Informer 详解</h2><img src="/2025/03/18/kubernetes-controller-manager/image-20250319132531577.png" class="" title="image-20250319132531577"><hr><p>通用 Controller</p><img src="/2025/03/18/kubernetes-controller-manager/image-20250321170252430.png" class="" title="image-20250321170252430"><img src="/2025/03/18/kubernetes-controller-manager/image-20250321170234148.png" class="" title="image-20250321170213798"><h2 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h2><h3 id="Leader-Election-的工作原理"><a href="#Leader-Election-的工作原理" class="headerlink" title="Leader Election 的工作原理"></a>Leader Election 的工作原理</h3><p>Kubernetes 使用 <strong>分布式锁</strong> 来实现 Leader Election。具体来说，它利用了 Kubernetes 的 API Server 作为分布式锁的存储后端，通过 <code>Lease</code> 资源来实现选举。</p><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h4><ol><li><strong>Lease 资源</strong>：<ul><li>Lease 是 Kubernetes 中的一种资源类型，用于表示某个组件对 Leader 角色的持有权。</li><li>Lease 资源包含以下关键字段：<ul><li><code>holderIdentity</code>：当前持有锁的实例标识。</li><li><code>leaseDurationSeconds</code>：锁的持有时间。</li><li><code>renewTime</code>：最近一次续约的时间。</li></ul></li></ul></li><li><strong>选举流程</strong>：<ul><li>每个候选实例（Controller Manager 或 Scheduler）会尝试创建一个 Lease 资源或更新现有的 Lease 资源。</li><li>如果某个实例成功创建或更新 Lease 资源，它将成为 Leader。</li><li>Leader 会定期更新 Lease 资源的 <code>renewTime</code>，以表明它仍然活跃。</li><li>如果 Leader 在指定时间内未更新 Lease 资源，其他实例会认为 Leader 已失效，并尝试竞选新的 Leader。</li></ul></li></ol><p><strong>Leader Election 的作用</strong>：</p><ul><li>在 HA 环境中确保只有一个实例执行任务，避免冲突。</li><li>提高系统的可靠性和容错能力。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_scheduler</title>
    <link href="/2025/03/18/kubernetes-scheduler/"/>
    <url>/2025/03/18/kubernetes-scheduler/</url>
    
    <content type="html"><![CDATA[<h1 id="Kube-Schedular"><a href="#Kube-Schedular" class="headerlink" title="Kube-Schedular"></a>Kube-Schedular</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>kube-scheduler</code> 是 Kubernetes 核心组件之一，负责 Pod 的调度（Scheduling）。简而言之，它的主要职责是决定一个未绑定到节点的 Pod 应该被分配到哪个节点上运行。调度器在 Kubernetes 中起到“任务分派员”的作用，其调度的核心目标是满足工作负载的资源需求（如 CPU、内存等），并同时遵循用户定义的调度策略和约束（如 Pod 配置的 <code>nodeSelector</code>、<code>affinity</code> 等）。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="一、Pod-监听："><a href="#一、Pod-监听：" class="headerlink" title="一、Pod 监听："></a><strong>一、Pod 监听：</strong></h3><ol><li><p><strong>初始化 Informer</strong>：</p><ul><li><p><code>kube-scheduler</code> 在启动时，会创建一个 <code>Pod Informer</code>，用于监听和缓存 Pod 的变化（包括新增、修改、删除事件）。</p></li><li><p>只监听那些未绑定到节点（<code>spec.nodeName</code> 为空）的 Pod。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewScheduler</span><span class="hljs-params">(...)</span></span> (*Scheduler, <span class="hljs-type">error</span>) &#123;<br>    ...<br>    <span class="hljs-comment">// 创建 Pod Informer</span><br>    podInformer := informerFactory.Core().V1().Pods()<br>    <br>    <span class="hljs-comment">// 初始化调度器</span><br>    sched := &amp;Scheduler&#123;<br>        podQueue:         queue,                <span class="hljs-comment">// 调度队列</span><br>        podInformer:      podInformer,         <span class="hljs-comment">// Pod Informer</span><br>        podLister:        podInformer.Lister() <span class="hljs-comment">// 用于从缓存中获取 Pod 列表</span><br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过 List 和 Watch 获取数据</strong>：</p><ul><li><strong>List</strong>：在调度器启动时，通过 API Server 全量获取当前所有未被绑定的 Pod。</li><li><strong>Watch</strong>：之后通过 Watch API，订阅 Pod 的增量更新事件（新增、修改、删除）。</li></ul></li></ol><h3 id="二、接收调度请求："><a href="#二、接收调度请求：" class="headerlink" title="二、接收调度请求："></a>二、接收调度请求：</h3><ul><li><p>当用户创建一个 Pod 时，Pod <strong>没有绑定到特定的节点</strong>（<strong>即 <code>.spec.nodeName</code> 为空</strong>），此时 kube-scheduler 会将其视为候选调度对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在 Informer 的初始化过程中，设置了过滤器</span><br>podInformer := informerFactory.Core().V1().Pods().Informer()<br><br><span class="hljs-comment">// 过滤只监听未绑定到节点的 Pod</span><br>podInformer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;<br>    AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        pod := obj.(*v1.Pod)<br>        <span class="hljs-keyword">if</span> pod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// Pod 未被绑定，加入调度队列</span><br>            sched.AddPodToQueue(pod)<br>        &#125;<br>    &#125;,<br>  <br>    UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(oldObj, newObj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        oldPod := oldObj.(*v1.Pod)<br>        newPod := newObj.(*v1.Pod)<br>        <span class="hljs-keyword">if</span> oldPod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; newPod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// Pod 更新了但仍未绑定</span><br>            sched.AddPodToQueue(newPod)<br>        &#125;<br>    &#125;,<br>    DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        pod := obj.(*v1.Pod)<br>        <span class="hljs-keyword">if</span> pod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// Pod 被删除</span><br>            sched.DeletePodFromQueue(pod)<br>        &#125;<br>    &#125;,<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="三、可调度候选节点筛选（Predicate-Filter-Phase）："><a href="#三、可调度候选节点筛选（Predicate-Filter-Phase）：" class="headerlink" title="三、可调度候选节点筛选（Predicate&#x2F;Filter Phase）："></a>三、可调度候选节点筛选（Predicate&#x2F;Filter Phase）：</h3><p>kube-scheduler 会根据一系列过滤规则（称为 “Predicates”，目前叫 Filter Plugins），筛选出所有满足 Pod 调度需求的候选节点。例如：</p><img src="/2025/03/18/kubernetes-scheduler/image-20250318141606770.png" class="" title="image-20250318141606770"><h4 id="1-PodFitsHostPorts"><a href="#1-PodFitsHostPorts" class="headerlink" title="1. PodFitsHostPorts"></a>1. <strong>PodFitsHostPorts</strong></h4><ul><li><h5 id="含义：验证目标节点上是否有-Pod-使用了相同的-hostPort，避免端口冲突。"><a href="#含义：验证目标节点上是否有-Pod-使用了相同的-hostPort，避免端口冲突。" class="headerlink" title="含义：验证目标节点上是否有 Pod 使用了相同的 hostPort，避免端口冲突。"></a><strong>含义</strong>：验证目标节点上是否有 Pod 使用了相同的 <code>hostPort</code>，避免端口冲突。</h5></li><li><p><strong>场景</strong>：当 Pod 定义了容器的 <code>hostPort</code> 时，调度器会检查该端口在目标节点上是否已经被占用。</p></li></ul><h4 id="2-PodFitsResources"><a href="#2-PodFitsResources" class="headerlink" title="2. PodFitsResources"></a>2. <strong>PodFitsResources</strong></h4><ul><li><strong>含义</strong>：检查目标节点的资源是否足够，包括：<ul><li><code>CPU</code>、<code>内存</code>、GPU（通过 <code>OpaqueIntResources</code> 定义）。</li></ul></li><li><strong>实现逻辑</strong>：对比 Pod 的资源请求（<code>requests</code>）与节点的可用资源（考虑已分配和未分配资源）。如果资源不足，则调度失败。</li></ul><h4 id="3-HostName"><a href="#3-HostName" class="headerlink" title="3. HostName"></a>3. <strong>HostName</strong></h4><ul><li><strong>含义</strong>：检查 Pod 的 <code>spec.nodeName</code> 是否与候选节点的名称一致。</li><li><strong>场景</strong>：当 Pod 明确指定了运行的节点（通过 <code>spec.nodeName</code> 字段），调度器会检查是否匹配。</li></ul><h4 id="4-MatchNodeSelector"><a href="#4-MatchNodeSelector" class="headerlink" title="4. MatchNodeSelector"></a><strong>4. MatchNodeSelector</strong></h4><ul><li><strong>含义</strong>：检查候选节点是否满足 Pod 的 <code>nodeSelector</code> 条件。</li><li><strong>场景</strong>：当 Pod 使用 <code>nodeSelector</code> 指定了需要运行的节点特性（通常是节点的标签），调度器会验证候选节点是否满足这些条件。</li></ul><h4 id="5-NoVolumeZoneConflict"><a href="#5-NoVolumeZoneConflict" class="headerlink" title="5. NoVolumeZoneConflict"></a>5. <strong>NoVolumeZoneConflict</strong></h4><ul><li><strong>含义</strong>：验证 Pod 引用的 Volume（例如云存储卷）是否可以在目标节点所在的地域（Zone）使用。</li><li><strong>场景</strong>：某些存储类型（如 GCE PD、AWS EBS 等）具有区域限制，调度器需要检查节点的 Zone 是否匹配。</li></ul><h4 id="6-MatchInterPodAffinity"><a href="#6-MatchInterPodAffinity" class="headerlink" title="6. MatchInterPodAffinity"></a>6. <strong>MatchInterPodAffinity</strong></h4><ul><li><strong>含义</strong>：检查 Pod 是否匹配其他 Pod 的亲和性（Affinity）或反亲和性（Anti-Affinity）规则。</li><li><strong>场景</strong>：用于实现将相关的 Pod 放置在相同或不同节点上的需求。</li></ul><h4 id="7-NoDiskConflict"><a href="#7-NoDiskConflict" class="headerlink" title="7. NoDiskConflict"></a>7. <strong>NoDiskConflict</strong></h4><ul><li><strong>含义</strong>：验证目标节点上是否存在 Pod 的 Volume 冲突。</li><li><strong>支持的存储类型</strong>：仅限 GCE PD、AWS EBS、Ceph RBD、iSCSI 等。</li></ul><h4 id="8-PodToleratesNodeTaints"><a href="#8-PodToleratesNodeTaints" class="headerlink" title="8. PodToleratesNodeTaints"></a>8. <strong>PodToleratesNodeTaints</strong></h4><ul><li><strong>含义</strong>：检查 Pod 是否能容忍（Toleration）目标节点的污点（Taint）。</li><li><strong>场景</strong>：用于过滤那些不能容忍节点特殊属性（通过 Taints 表达）的 Pod。</li></ul><h4 id="9-CheckNodeMemoryPressure"><a href="#9-CheckNodeMemoryPressure" class="headerlink" title="9. CheckNodeMemoryPressure"></a>9. <strong>CheckNodeMemoryPressure</strong></h4><ul><li><strong>含义</strong>：验证目标节点是否处于内存压力（MemoryPressure）状态。</li><li><strong>场景</strong>：当节点内存使用接近或达到阈值，Pod 不应该调度到该节点。</li></ul><h4 id="10-CheckNodeDiskPressure"><a href="#10-CheckNodeDiskPressure" class="headerlink" title="10. CheckNodeDiskPressure"></a>10. <strong>CheckNodeDiskPressure</strong></h4><ul><li><strong>含义</strong>：验证目标节点是否处于磁盘压力（DiskPressure）状态。</li><li><strong>场景</strong>：当节点磁盘空间不足时，调度器会避免将新的 Pod 调度到该节点。</li></ul><h4 id="11-NoVolumeNodeConflict"><a href="#11-NoVolumeNodeConflict" class="headerlink" title="11. NoVolumeNodeConflict"></a>11. <strong>NoVolumeNodeConflict</strong></h4><ul><li><strong>含义</strong>：验证目标节点是否满足 Pod 所需 Volume 的条件，例如是否存在挂载冲突。</li><li><strong>场景</strong>：在某些存储驱动中，一个 Volume 可能只能挂载到一个节点上，因此需要检查是否有冲突。</li></ul><h3 id="四、候选节点评分（Priority-Scoring-Phase）："><a href="#四、候选节点评分（Priority-Scoring-Phase）：" class="headerlink" title="四、候选节点评分（Priority&#x2F;Scoring Phase）："></a><strong>四、候选节点评分（Priority&#x2F;Scoring Phase）</strong>：</h3><ul><li>对于通过过滤的候选节点，调度器会根据一系列优先级规则（称为 “Priorities”，现在叫 Scoring Plugins）为每个节点打分。</li><li>评分的目标是从所有可用节点中选择一个最优节点。例如：<ul><li>尽量将 Pod 调度到负载较低的节点。</li><li>尽量将 Pod 调度到与其数据存储位置较近的节点。</li><li>避免过多 Pod 调度到同一个节点，导致资源热点。</li></ul></li></ul><p>在 Kubernetes 中，<code>kube-scheduler</code> 是负责将 Pod 调度到合适的 Node 上的组件。调度过程分为两步：<strong>过滤（Filter）</strong> 和 <strong>打分（Score）</strong>。其中，<code>Priorities</code> 策略是调度器在打分阶段使用的规则，用于评估每个 Node 的优先级，通过分配得分来选择最优的候选节点。</p><p>下面详细介绍常见的 <code>Priorities</code> 策略：</p><hr><h4 id="1-SelectorSpreadPriority"><a href="#1-SelectorSpreadPriority" class="headerlink" title="1. SelectorSpreadPriority"></a><strong>1. SelectorSpreadPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先将 Pod 分布到不同的 Node 上，减少某个 Node 上同一个 Service 或 Replication Controller 的 Pod 数量。</li></ul></li><li><strong>目的：</strong><ul><li>达到负载均衡，避免将同一类型的 Pod 全部调度到一个 Node 上。</li></ul></li><li><strong>典型场景：</strong><ul><li>应用高可用性，提高服务容错能力（例如分布式系统）。</li></ul></li></ul><hr><h4 id="2-InterPodAffinityPriority"><a href="#2-InterPodAffinityPriority" class="headerlink" title="2. InterPodAffinityPriority"></a><strong>2. InterPodAffinityPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先将 Pod 调度到具有相同拓扑（如同一个节点、Rack、Zone 等）的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>符合 Pod 的亲和性要求，例如让 Pod 与相同组件的其他 Pod 部署在同一个区域中。</li></ul></li><li><strong>典型场景：</strong><ul><li>有数据本地性需求的应用或需要紧密协同的组件。</li></ul></li></ul><hr><h4 id="3-LeastRequestedPriority"><a href="#3-LeastRequestedPriority" class="headerlink" title="3. LeastRequestedPriority"></a><strong>3. LeastRequestedPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到资源请求最少的 Node 上。</li></ul></li><li><strong>目的：</strong><ul><li>避免资源紧张，提高资源利用率。</li></ul></li><li><strong>典型场景：</strong><ul><li>集群中存在部分节点资源接近饱和时，优先调度到空闲较多的节点。</li></ul></li></ul><hr><h4 id="4-BalancedResourceAllocation"><a href="#4-BalancedResourceAllocation" class="headerlink" title="4. BalancedResourceAllocation"></a><strong>4. BalancedResourceAllocation</strong></h4><ul><li><strong>作用：</strong><ul><li>优先选择 CPU 和内存使用率相对均衡的节点。</li></ul></li><li><strong>目的：</strong><ul><li>避免单一维度资源（如 CPU 或内存）成为瓶颈，优化集群资源利用。</li></ul></li><li><strong>典型场景：</strong><ul><li>资源分布不均的集群环境下，适合有高资源利用需求的场景。</li></ul></li></ul><hr><h4 id="5-NodePreferAvoidPodsPriority"><a href="#5-NodePreferAvoidPodsPriority" class="headerlink" title="5. NodePreferAvoidPodsPriority"></a><strong>5. NodePreferAvoidPodsPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先避开有 <code>preferAvoidPods</code> 字段标记的节点。</li></ul></li><li><strong>目的：</strong><ul><li>避免对某些节点施加额外负载。</li></ul></li><li><strong>典型场景：</strong><ul><li>某些节点需要保留资源或需要减少干扰。</li></ul></li></ul><hr><h4 id="6-NodeAffinityPriority"><a href="#6-NodeAffinityPriority" class="headerlink" title="6. NodeAffinityPriority"></a><strong>6. NodeAffinityPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到匹配 NodeAffinity 的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>符合节点亲和性规则，满足用户的调度要求。</li></ul></li><li><strong>典型场景：</strong><ul><li>应用对特定的硬件、标签等有明确需求。</li></ul></li></ul><hr><h4 id="7-TaintTolerationPriority"><a href="#7-TaintTolerationPriority" class="headerlink" title="7. TaintTolerationPriority"></a><strong>7. TaintTolerationPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到能容忍特定 Taint 的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>解决 Taint 和 Toleration 机制下的调度问题。</li></ul></li><li><strong>典型场景：</strong><ul><li>使用节点隔离机制时。</li></ul></li></ul><hr><h4 id="8-ServiceSpreadingPriority（已被替代）"><a href="#8-ServiceSpreadingPriority（已被替代）" class="headerlink" title="8. ServiceSpreadingPriority（已被替代）"></a><strong>8. ServiceSpreadingPriority</strong>（已被替代）</h4><ul><li><strong>作用：</strong><ul><li>将同一个 Service 的 Pod 分布到不同的 Node 上。</li></ul></li><li><strong>替代：</strong><ul><li>该策略已被 <code>SelectorSpreadPriority</code> 替代。</li></ul></li></ul><hr><h4 id="9-EqualPriority"><a href="#9-EqualPriority" class="headerlink" title="9. EqualPriority"></a><strong>9. EqualPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>为所有节点分配相同的优先级，优先级值为 1。</li></ul></li><li><strong>目的：</strong><ul><li>用于测试或没有特殊调度需求的场景。</li></ul></li></ul><hr><h4 id="10-ImageLocalityPriority"><a href="#10-ImageLocalityPriority" class="headerlink" title="10. ImageLocalityPriority"></a><strong>10. ImageLocalityPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到已经缓存了容器镜像的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>减少镜像拉取时间，提高调度效率。</li></ul></li><li><strong>典型场景：</strong><ul><li>集群节点镜像拉取速度较慢时。</li></ul></li></ul><hr><h4 id="11-MostRequestedPriority"><a href="#11-MostRequestedPriority" class="headerlink" title="11. MostRequestedPriority"></a><strong>11. MostRequestedPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到已经使用过资源的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>尤其适用于 <code>cluster-autoscaler</code>，提高已有节点的资源利用率。</li></ul></li><li><strong>典型场景：</strong><ul><li>自动扩容场景，避免浪费新的节点资源。</li></ul></li></ul><p><code>kube-scheduler</code> 的 Priorities 实现位于 <code>pkg/scheduler/framework/plugins</code> 中。例如，<code>BalancedResourceAllocation</code> 的代码实现可以参考该插件下的具体实现方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BalancedAllocation)</span></span> Score(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="hljs-type">string</span>) (<span class="hljs-type">int64</span>, *framework.Status) &#123;<br>    nodeInfo, err := b.nodeInfoLister.Get(nodeName)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, framework.NewStatus(framework.Error, err.Error())<br>    &#125;<br>    <span class="hljs-keyword">return</span> b.score(pod, nodeInfo.Node())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BalancedAllocation)</span></span> score(pod *v1.Pod, node *v1.Node) <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-comment">// 计算 CPU 和内存的使用率</span><br>    cpuFraction := node.UsedCPU() / node.TotalCPU()<br>    memoryFraction := node.UsedMemory() / node.TotalMemory()<br>    <span class="hljs-comment">// 计算得分</span><br>    score := <span class="hljs-number">100</span> - <span class="hljs-type">int64</span>(math.Abs(cpuFraction-memoryFraction)*<span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">return</span> score<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、决策和绑定（Bind-Phase）："><a href="#五、决策和绑定（Bind-Phase）：" class="headerlink" title="五、决策和绑定（Bind Phase）："></a><strong>五、决策和绑定（Bind Phase）</strong>：</h3><ul><li>从评分最高的节点中挑选一个节点，作为该 Pod 的最终调度目标。</li><li>调度器将调度结果写入到 <code>etcd</code> 中，将 Pod 绑定到目标节点。</li></ul><p>整体来说，调度过程可以概括为：<strong>过滤（Filter） -&gt; 评分（Score） -&gt; 绑定（Bind）</strong>。</p><p>在 Kubernetes（K8S）中，不同的 <code>QoS（Quality of Service）</code> 类表示 Pod 的服务质量保障级别，这对调度、资源管理和优先级管理起到重要作用。Kubernetes 基于 Pod 的资源请求和限制自动确定它的 QoS 类，因此理解 QoS 类以及它们如何影响调度至关重要。本文将系统介绍 QoS 类的划分及其调度行为。</p><hr><h2 id="K8S-的-QoS-类分类"><a href="#K8S-的-QoS-类分类" class="headerlink" title="K8S 的 QoS 类分类"></a>K8S 的 QoS 类分类</h2><p>Kubernetes 定义了三种 QoS 类，分别是：</p><h4 id="1-Guaranteed"><a href="#1-Guaranteed" class="headerlink" title="1. Guaranteed"></a>1. <strong>Guaranteed</strong></h4><ul><li><p>一个 Pod <strong>所有容器</strong>的 <code>requests</code> 和 <code>limits</code> 必须完全相等。</p></li><li><p>特性：这类 Pod 通常被视为最高优先级资源请求，因此在资源争夺时被保留。</p></li><li><p>场景：适用于需要强资源保证的关键性应用。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">guaranteed-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Burstable"><a href="#2-Burstable" class="headerlink" title="2. Burstable"></a>2. <strong>Burstable</strong></h4><ul><li><p>如果 Pod 至少有一个容器的 <code>requests</code> 设置了，但 <code>requests</code> 和 <code>limits</code> 不完全相等，则 Pod 被归为 <code>Burstable</code>。</p></li><li><p>特性：该类 Pod 会优先获取至少等于 <code>requests</code> 的资源，其余资源可在容量溢出时被收回。</p></li><li><p>场景：适合对资源核心需求较低，但能够在负载高峰期动态扩展的场景。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">burstable-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.2&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-BestEffort"><a href="#3-BestEffort" class="headerlink" title="3. BestEffort"></a>3. <strong>BestEffort</strong></h4><ul><li><p>如果 Pod <strong>所有容器</strong>都没有配置 <code>requests</code> 或 <code>limits</code>，则它属于 <code>BestEffort</code>。</p></li><li><p>特性：属于最低优先级 Pod，仅在其他资源有剩余时可分配资源。</p></li><li><p>场景：适用于非核心、无资源保障需求的后备工作负载。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">besteffort-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="QoS-Class-在调度中的运作机制"><a href="#QoS-Class-在调度中的运作机制" class="headerlink" title="QoS Class 在调度中的运作机制"></a>QoS Class 在调度中的运作机制</h3><p>Kubernetes 的调度器主要通过以下几个相关逻辑处理 QoS 类：</p><h4 id="1-资源分配优先级"><a href="#1-资源分配优先级" class="headerlink" title="1. 资源分配优先级"></a>1. <strong>资源分配优先级</strong></h4><ul><li><code>Guaranteed &gt; Burstable &gt; BestEffort</code></li><li>Kubernetes Scheduler 在评估节点资源是否充足时，对于 Guaranteed 的 Pod 会尝试确保其分配请求的资源总量和上限。</li><li>Burstable 会优先与 Requests 值匹配，但 Limits 超出部分可能因抢占而被剥夺。</li><li>BestEffort Pod 通常在资源充足时才被调度，但在资源紧张时可能完全无法运行。</li></ul><h4 id="2-Node-Eviction（节点逐出机制）"><a href="#2-Node-Eviction（节点逐出机制）" class="headerlink" title="2. Node Eviction（节点逐出机制）"></a>2. <strong>Node Eviction（节点逐出机制）</strong></h4><p>   当节点资源耗尽或压力过高（例如内存压力<code>MemoryPressure</code>），Kubernetes 使用 QoS 类来决定驱逐的优先级：</p><ul><li><strong>BestEffort</strong>：首当其冲被驱逐，适合非关键性负载。</li><li><strong>Burstable</strong>：在满足请求的基础上，超出的部分会被挤占或驱逐。</li><li><strong>Guaranteed</strong>：保证级别最高，最后才会被驱逐。</li></ul><h4 id="3-调度优先级"><a href="#3-调度优先级" class="headerlink" title="3. 调度优先级"></a>3. <strong>调度优先级</strong></h4><ul><li>调度器会根据节点的资源可用性优先分配高 QoS 的 Pod。</li><li>考虑结合 <code>Taints</code> 和 <code>Tolerations</code>、资源亲和性等规则提高具体调度的确定性。</li></ul><h4 id="举例：调度阶段中的-QoS-Decision"><a href="#举例：调度阶段中的-QoS-Decision" class="headerlink" title="举例：调度阶段中的 QoS Decision"></a>举例：调度阶段中的 QoS Decision</h4><p>当新的 Pod 到来时，Kubernetes Scheduler 会依次检查以下项：</p><ul><li>是否满足 Pod 的 <code>requests</code>（按 QoS 优先顺序检查）；</li><li>节点剩余容量能否满足 Pod 的 <code>limits</code>；</li><li>Resource Fit Filter（调度器中的 Fit 规则）根据 QoS 级别动态评估节点状态和适合性。</li></ul><hr><h3 id="调度-QoS-类的实际操作与优化"><a href="#调度-QoS-类的实际操作与优化" class="headerlink" title="调度 QoS 类的实际操作与优化"></a>调度 QoS 类的实际操作与优化</h3><p>为了更好地调度不同 QoS 的 Pod，我们可以采取以下策略：</p><h4 id="1-调整资源分配规则"><a href="#1-调整资源分配规则" class="headerlink" title="1. 调整资源分配规则"></a>1. <strong>调整资源分配规则</strong></h4><p>   为关键性的应用分配 QoS <code>Guaranteed</code>，明确资源上下界，保证资源独占或排他性。</p><h4 id="2-Taints-和-Tolerations"><a href="#2-Taints-和-Tolerations" class="headerlink" title="2. Taints 和 Tolerations"></a>2. <strong>Taints 和 Tolerations</strong></h4><p>   配合使用 Taints 和 Tolerations，将高 QoS 的应用调度到专用节点。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">taints:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">critical</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br></code></pre></td></tr></table></figure><h4 id="3-预留关键性资源节点"><a href="#3-预留关键性资源节点" class="headerlink" title="3. 预留关键性资源节点"></a>3. <strong>预留关键性资源节点</strong></h4><p>   Kubernetes 支持通过 <code>kube-reserved</code>、<code>system-reserved</code> 等方式预留关键性资源，保证平台本身稳定运行。</p><h4 id="4-配额管理"><a href="#4-配额管理" class="headerlink" title="4. 配额管理"></a>4. <strong>配额管理</strong></h4><p>   使用 ResourceQuotas 限制低 QoS 的资源消耗，如限制 <code>BestEffort</code> Pod 数量，确保资源可为高 QoS 的 Pod 使用。</p><h2 id="API-对象：requests-limits"><a href="#API-对象：requests-limits" class="headerlink" title="API 对象：requests limits"></a>API 对象：requests limits</h2><p>在 Kubernetes 中，<code>requests</code> 和 <code>limits</code> 是 Pod 或容器级别的资源管理功能，用于定义对 CPU 和内存等资源的需求和限制。这两个参数是 Kubernetes 调度器和 Kubelet 的关键配置，它们分别用于调度和运行时资源管理。</p><hr><h3 id="1-什么是-requests-和-limits"><a href="#1-什么是-requests-和-limits" class="headerlink" title="1. 什么是 requests 和 limits"></a>1. 什么是 <code>requests</code> 和 <code>limits</code></h3><h4 id="1-1-requests"><a href="#1-1-requests" class="headerlink" title="1.1 requests"></a>1.1 <code>requests</code></h4><ul><li><strong>定义</strong>: 容器运行时的<strong>最低资源需求</strong>。Kubernetes 调度器在调度 Pod 时会使用 <code>requests</code> 的值来决定是否有足够的资源可用。</li><li><strong>作用</strong>: <ul><li>决定 Pod 是否能被调度到某个 Node。</li><li>一旦 Pod 被调度到某个 Node，Node 上必须预留至少 <code>requests</code> 定义的资源量。</li></ul></li></ul><h4 id="1-2-limits"><a href="#1-2-limits" class="headerlink" title="1.2 limits"></a>1.2 <code>limits</code></h4><ul><li><strong>定义</strong>: 容器运行时的<strong>资源上限</strong>。Kubelet 和容器运行时会根据 <code>limits</code> 限制容器使用的资源量，超过此限制可能会被杀死或降速。</li><li><strong>作用</strong>:<ul><li>防止容器使用的资源超出指定的上限，从而保护其他容器的稳定性。</li></ul></li></ul><h4 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h4><p>以一个简单的 Pod 配置为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>requests.memory: 64Mi</code>: 容器至少需要 64Mi 内存才能正常运行。</li><li><code>limits.memory: 128Mi</code>: 容器最多只能使用 128Mi 内存，超过时可能会被 OOM（Out of Memory）杀死。</li><li><code>requests.cpu: 250m</code>: 容器需要 250 毫核的 CPU，调度器会确保目标节点能够提供这部分资源。</li><li><code>limits.cpu: 500m</code>: 容器最多只能使用 500 毫核的 CPU。</li></ul><hr><h3 id="2-Kubernetes-调度器如何使用-requests"><a href="#2-Kubernetes-调度器如何使用-requests" class="headerlink" title="2. Kubernetes 调度器如何使用 requests"></a>2. Kubernetes 调度器如何使用 <code>requests</code></h3><p>调度器是 Kubernetes 的核心组件之一，负责将待调度的 Pod 分配到合适的节点上。调度器通过以下步骤使用 <code>requests</code> 值来进行资源调度：</p><h4 id="2-1-节点资源过滤"><a href="#2-1-节点资源过滤" class="headerlink" title="2.1 节点资源过滤"></a>2.1 节点资源过滤</h4><p>调度器首先会根据 Pod 的 <code>requests</code> 值过滤掉不满足资源需求的节点：</p><ul><li>对比节点的 <strong>可用资源</strong> 和 Pod 的 <code>requests</code>。</li><li>如果节点的可用资源小于 Pod 的 <code>requests</code>，则该节点会被过滤掉。</li></ul><p><strong>节点可用资源计算公式</strong>:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">节点可用资源 = 节点总资源 - <span class="hljs-function"><span class="hljs-title">sum</span>(所有已分配 <span class="hljs-variable">Pod</span> 的 <span class="hljs-variable">requests</span>)</span><br></code></pre></td></tr></table></figure><p>示例：</p><ul><li>假设一个节点有 4 核 CPU 和 8 Gi 内存。</li><li>已经运行了 2 个 Pod，分别请求了以下资源：<ul><li>Pod1: <code>requests.cpu=1</code> 和 <code>requests.memory=2Gi</code></li><li>Pod2: <code>requests.cpu=1</code> 和 <code>requests.memory=2Gi</code></li></ul></li><li>节点剩余资源：<ul><li>剩余 CPU: <code>4 - (1 + 1) = 2</code></li><li>剩余内存：<code>8Gi - (2Gi + 2Gi) = 4Gi</code></li></ul></li><li>如果新创建一个 Pod 需要 <code>requests.cpu=3</code>，调度器会过滤掉这个节点，因为剩余 CPU 不足。</li></ul><h4 id="2-2-优化节点选择"><a href="#2-2-优化节点选择" class="headerlink" title="2.2 优化节点选择"></a>2.2 优化节点选择</h4><p>在过滤掉不满足 <code>requests</code> 的节点后，调度器会根据调度策略（例如：<strong>最少资源利用策略</strong> 或 <strong>均衡策略</strong>）选择最佳节点。例如：</p><ul><li>找出当前负载最小的节点。</li><li>确保资源分配均匀，避免资源热点。</li></ul><hr><h3 id="3-Kubelet-和容器运行时如何使用-limits"><a href="#3-Kubelet-和容器运行时如何使用-limits" class="headerlink" title="3. Kubelet 和容器运行时如何使用 limits"></a>3. Kubelet 和容器运行时如何使用 <code>limits</code></h3><p>在 Pod 被调度到节点上之后，Kubelet 和容器运行时会使用 <code>limits</code> 来限制容器运行时的资源使用：</p><h4 id="3-1-CPU-限制"><a href="#3-1-CPU-限制" class="headerlink" title="3.1 CPU 限制"></a>3.1 CPU 限制</h4><ul><li><code>limits.cpu</code> 通过 Cgroup 的 <strong>CPU Shares</strong> 和 <strong>CPU Quota</strong> 实现：<ul><li><strong>CPU Shares</strong>: 控制 CPU 调度的优先级。例如，<code>requests.cpu=500m</code> 会分配较低优先级，但如果节点空闲，容器可以使用更多 CPU。</li><li><strong>CPU Quota</strong>: 硬性限制 CPU 使用总量。例如，<code>limits.cpu=500m</code> 意味着容器最多只能使用 50% 的 CPU 核心时间。</li></ul></li></ul><p>相关 cgroup 配置路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/cpu/kubepods/&lt;pod_id&gt;/&lt;container_id&gt;/cpu.shares<br>/sys/fs/cgroup/cpu/kubepods/&lt;pod_id&gt;/&lt;container_id&gt;/cpu.cfs_quota_us<br></code></pre></td></tr></table></figure><h4 id="3-2-内存限制"><a href="#3-2-内存限制" class="headerlink" title="3.2 内存限制"></a>3.2 内存限制</h4><ul><li><code>limits.memory</code> 是一个硬限制，通过 Cgroup 的 <strong>memory limit</strong> 配置。</li><li>如果容器超出 <code>limits.memory</code> 的值，会触发 OOM（Out of Memory）杀死容器。</li></ul><p>相关 cgroup 配置路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/memory/kubepods/&lt;pod_id&gt;/&lt;container_id&gt;/memory.limit_in_bytes<br></code></pre></td></tr></table></figure><hr><h3 id="4-使用-requests-和-limits-的最佳实践"><a href="#4-使用-requests-和-limits-的最佳实践" class="headerlink" title="4. 使用 requests 和 limits 的最佳实践"></a>4. 使用 <code>requests</code> 和 <code>limits</code> 的最佳实践</h3><ul><li><p><strong>合理分配 <code>requests</code> 和 <code>limits</code></strong>:</p><ul><li><code>requests</code> 应根据容器的最低需求来设置，避免调度失败。</li><li><code>limits</code> 应根据容器的最大允许使用量来设置，避免资源抢占。</li></ul></li><li><p><strong>避免 <code>requests</code> 和 <code>limits</code> 间差距过大</strong>:</p><ul><li>如果 <code>limits</code> 远大于 <code>requests</code>，容易导致节点资源超分配，运行时引发不稳定。</li><li>如果 <code>requests</code> 远大于实际需求，可能导致资源浪费，降低集群整体利用率。</li></ul></li><li><p><strong>结合资源配额（Resource Quotas）和限制（Limit Ranges）</strong>:</p><ul><li>使用 Resource Quotas 在命名空间层面限制资源总量。</li><li>使用 Limit Ranges 强制为 Pod 配置合理的 <code>requests</code> 和 <code>limits</code>。</li></ul></li></ul><hr><h2 id="将-Pod-调度到指定的-Node-上"><a href="#将-Pod-调度到指定的-Node-上" class="headerlink" title="将 Pod 调度到指定的 Node 上"></a>将 Pod 调度到指定的 Node 上</h2><p><code>NodeSelector</code> 是 Kubernetes 中用来将 Pod 调度到特定的 Node 上的一种机制。它本质上是一种调度约束，让你可以通过为 Pod 定义一个条件来指定只允许它运行在满足该条件的节点上。</p><p>在 Kubernetes 中，Node 通常会有一组标签（labels），比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br>    <span class="hljs-attr">region:</span> <span class="hljs-string">us-west</span><br></code></pre></td></tr></table></figure><p>而 <code>NodeSelector</code> 是 Pod 的 <code>spec</code> 部分中的一个字段，允许你通过指定这些标签来选择目标节点。</p><hr><h3 id="NodeSelector-的工作原理"><a href="#NodeSelector-的工作原理" class="headerlink" title="NodeSelector 的工作原理"></a><code>NodeSelector</code> 的工作原理</h3><p><code>NodeSelector</code> 的核心是通过键值对匹配来选择 Node。Kubernetes 的调度器会检查集群中所有可用的节点，只有满足 <code>NodeSelector</code> 条件的节点才会被作为候选节点来运行该 Pod。</p><hr><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="1-定义节点标签"><a href="#1-定义节点标签" class="headerlink" title="1. 定义节点标签"></a>1. 定义节点标签</h4><p>给一个节点打上标签。假设我们有一个节点名为 <code>node1</code>，我们通过以下命令给它加上一个标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl label nodes node1 disktype=ssd<br></code></pre></td></tr></table></figure><h4 id="2-配置-Pod-的-NodeSelector"><a href="#2-配置-Pod-的-NodeSelector" class="headerlink" title="2. 配置 Pod 的 NodeSelector"></a>2. 配置 Pod 的 <code>NodeSelector</code></h4><p>定义一个 Pod，并使用 <code>nodeSelector</code> 来选择节点：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">nodeSelector:</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>nodeSelector</code> 指定了 <code>disktype: ssd</code>，所以 Kubernetes 只会尝试将该 Pod 调度到具有标签 <code>disktype=ssd</code> 的节点上。</p><hr><h3 id="多个条件的-NodeSelector"><a href="#多个条件的-NodeSelector" class="headerlink" title="多个条件的 NodeSelector"></a>多个条件的 <code>NodeSelector</code></h3><p><code>NodeSelector</code> 可以指定多个键值对条件，所有条件必须同时满足。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nodeSelector:</span><br>  <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br>  <span class="hljs-attr">region:</span> <span class="hljs-string">us-west</span><br></code></pre></td></tr></table></figure><p>这种情况下，目标节点必须同时满足以下条件：</p><ul><li>标签 <code>disktype=ssd</code></li><li>标签 <code>region=us-west</code></li></ul><p><strong>注意：</strong> <code>NodeSelector</code> 的匹配条件是 AND 逻辑，所有条件都必须满足，不能用 OR 逻辑。</p><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>性能优化：</strong> 你可以将特定的工作负载调度到具有高性能硬件的节点上，比如 SSD 存储或高 CPU 内核的节点。</li><li><strong>地理分布：</strong> 通过标签标识区域（region）和可用区（zone），你可以将工作负载调度到离用户更近的节点上。</li><li><strong>隔离性：</strong> 可以使用一些特殊标签将敏感的工作负载调度到专门的隔离节点上。</li></ol><hr><h3 id="为什么只用-NodeSelector-是不够的？"><a href="#为什么只用-NodeSelector-是不够的？" class="headerlink" title="为什么只用 NodeSelector 是不够的？"></a>为什么只用 <code>NodeSelector</code> 是不够的？</h3><p><code>NodeSelector</code> 是 Kubernetes 中最简单的调度约束工具，但它有以下局限性：</p><ol><li><p><strong>无法表达复杂条件：</strong> <code>NodeSelector</code> 只支持简单的键值对，并且只能用 AND 逻辑，无法表达更复杂的调度规则（例如 OR 或 NOT）。</p></li><li><p><strong>不够灵活：</strong> 如果节点标签被更改，Pod 不会自动重新调度到符合新条件的节点。</p></li><li><p>替代方案：</p><p>更强大的调度工具包括：</p><ul><li><strong>Node Affinity</strong>：支持更复杂的调度规则，并允许使用 OR&#x2F;NOT 等逻辑。</li><li><strong>Taints and Tolerations</strong>：允许特定 Pod 避免或容忍某些节点的特殊污点条件。</li><li><strong>Custom Schedulers</strong>：你可以实现自己的调度器来处理更复杂的需求。</li></ul></li></ol><p>在 Kubernetes 中，<code>NodeAffinity</code> (节点亲和性) 是一种调度约束，用于决定某些 Pod 应该运行在哪些节点上。它是 Pod 调度器的重要配置之一，可以帮助用户控制 Pod 在集群中的分布。通过 <code>NodeAffinity</code>，用户可以定义 Pod 如何选择合适的节点。它是 Kubernetes 中 “亲和性和反亲和性” 特性的一部分。</p><p>下面我们详细讲解一下 <code>NodeAffinity</code> 的概念、工作原理和使用方法：</p><hr><h2 id="NodeAffinity"><a href="#NodeAffinity" class="headerlink" title="NodeAffinity"></a>NodeAffinity</h2><h3 id="1-什么是-NodeAffinity？"><a href="#1-什么是-NodeAffinity？" class="headerlink" title="1. 什么是 NodeAffinity？"></a>1. 什么是 <code>NodeAffinity</code>？</h3><p><code>NodeAffinity</code> 是一个与节点标签匹配的调度策略。它允许你基于节点的标签设置调度规则，从而指定：</p><ul><li><strong>Pod 更倾向于调度到哪些节点上（软约束）</strong>。</li><li><strong>Pod 必须调度到哪些节点上（硬约束）</strong>。</li></ul><p><code>NodeAffinity</code> 是 Pod 的属性，定义在 Pod 的 Spec 中。调度器会根据 <code>NodeAffinity</code> 的规则，在集群中选择合适的节点来运行 Pod。</p><hr><h3 id="2-NodeAffinity-的分类"><a href="#2-NodeAffinity-的分类" class="headerlink" title="2. NodeAffinity 的分类"></a>2. <code>NodeAffinity</code> 的分类</h3><p><code>NodeAffinity</code> 有两种主要类型：</p><ol><li><p><strong>硬约束</strong> (<code>requiredDuringSchedulingIgnoredDuringExecution</code>)</p><ul><li>Pod 必须调度到符合条件的节点上。</li><li>如果没有符合条件的节点，Pod 会一直待在 Pending 状态，直到有满足条件的节点出现。</li><li>等价于硬性规则。</li></ul></li><li><p><strong>软约束</strong> (<code>preferredDuringSchedulingIgnoredDuringExecution</code>)</p><ul><li>Pod 优先调度到符合条件的节点，但如果没有符合条件的节点，也可以调度到其他节点。</li><li>等价于建议性规则。</li></ul></li></ol><h4 id="键名解释："><a href="#键名解释：" class="headerlink" title="键名解释："></a>键名解释：</h4><ul><li><strong><code>DuringScheduling</code></strong>：调度时检查规则是否满足。</li><li><strong><code>IgnoredDuringExecution</code></strong>：调度完成后，不再检查规则是否持续满足。</li></ul><hr><h3 id="3-NodeAffinity-的语法"><a href="#3-NodeAffinity-的语法" class="headerlink" title="3. NodeAffinity 的语法"></a>3. <code>NodeAffinity</code> 的语法</h3><p><code>NodeAffinity</code> 的定义在 Pod Spec 的 <code>affinity.nodeAffinity</code> 字段下，采用 <code>MatchExpressions</code> 或 <code>MatchFields</code> 的形式。以下是一个典型的 YAML 配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">node-affinity-example</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">demo-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">nodeAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬约束</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node2</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软约束</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">disktype</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ol><li><p><strong>硬约束：<code>requiredDuringSchedulingIgnoredDuringExecution</code></strong></p><ul><li>定义了 Pod 只允许调度到 <code>kubernetes.io/hostname</code> 为 <code>node1</code> 或 <code>node2</code> 的节点。</li><li>如果没有满足条件的节点，Pod 不会调度。</li></ul></li><li><p><strong>软约束：<code>preferredDuringSchedulingIgnoredDuringExecution</code></strong></p><ul><li>定义了 Pod 优先调度到 <code>disktype</code> 为 <code>ssd</code> 的节点。</li><li>如果没有满足条件的节点，Pod 仍然可以调度到其他节点。</li></ul></li></ol><hr><h3 id="4-NodeAffinity-的高级配置"><a href="#4-NodeAffinity-的高级配置" class="headerlink" title="4. NodeAffinity 的高级配置"></a>4. <code>NodeAffinity</code> 的高级配置</h3><h4 id="4-1-matchExpressions-的语法"><a href="#4-1-matchExpressions-的语法" class="headerlink" title="4.1 matchExpressions 的语法"></a>4.1 <code>matchExpressions</code> 的语法</h4><p><code>matchExpressions</code> 是常见的表达式，用来定义约束规则。它支持以下操作符：</p><ul><li><strong><code>In</code></strong>：匹配标签的值在指定的值列表中。</li><li><strong><code>NotIn</code></strong>：匹配标签的值不在指定的值列表中。</li><li><strong><code>Exists</code></strong>：匹配节点是否具有某个标签（不用指定值）。</li><li><strong><code>DoesNotExist</code></strong>：匹配节点是否没有某个标签。</li><li><strong><code>Gt</code></strong>：匹配标签的值大于指定值。</li><li><strong><code>Lt</code></strong>：匹配标签的值小于指定值。</li></ul><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">matchExpressions:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">environment</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>  <span class="hljs-attr">values:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">production</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">staging</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">disktype</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br></code></pre></td></tr></table></figure><h4 id="4-2-多标签规则"><a href="#4-2-多标签规则" class="headerlink" title="4.2 多标签规则"></a>4.2 多标签规则</h4><p><code>NodeAffinity</code> 支持多标签条件的组合。一个 <code>nodeSelectorTerms</code> 的条件是 <strong>“或”</strong> 的关系（满足任意一个条件即可）。而 <code>matchExpressions</code> 中的多个表达式是 <strong>“且”</strong> 的关系（需要同时满足）。</p><hr><h2 id="PodAffinity"><a href="#PodAffinity" class="headerlink" title="PodAffinity"></a>PodAffinity</h2><p>在 Kubernetes 中，<code>PodAffinity</code> 是调度器中一种高级的调度约束，用于控制 Pod 在集群中的调度位置。它允许用户定义一个 Pod 应该尽量调度在哪些节点上，基于与其他 Pod 的亲和性规则。通过 <code>PodAffinity</code>，用户可以确保某些服务之间的 Pod 被调度到更接近的位置，优化性能、减少网络延迟或者提高数据访问效率。</p><p>Kubernetes 为 <code>PodAffinity</code> 提供了以下两个类型的亲和性：</p><ul><li><strong>Pod Affinity (亲和性)</strong>：指示 Pod 应该调度到与特定 Pod 接近的节点。</li><li><strong>Pod Anti-Affinity (反亲和性)</strong>：指示 Pod 应该调度到远离特定 Pod 的节点。</li></ul><h3 id="PodAffinity-的应用场景"><a href="#PodAffinity-的应用场景" class="headerlink" title="PodAffinity 的应用场景"></a>PodAffinity 的应用场景</h3><p>通过 <code>PodAffinity</code>，可以实现以下常见需求：</p><ol><li>加强服务间的局部性。例如，某些微服务需要与缓存服务位于同一个节点或同一个拓扑域（区域、可用区）以提高性能。</li><li>数据密集型应用需要靠近数据所在的节点。</li><li>降低集群内的网络延迟。</li><li>节约跨节点流量的带宽开销。</li></ol><p>而通过 <code>PodAntiAffinity</code>，可以实现以下需求：</p><ol><li>增强高可用性，确保副本分散在不同的节点上，避免单点故障。</li><li>降低资源争用的可能性，避免同类型 Pod 集中在一个节点上。</li></ol><hr><h3 id="PodAffinity-的核心字段"><a href="#PodAffinity-的核心字段" class="headerlink" title="PodAffinity 的核心字段"></a><code>PodAffinity</code> 的核心字段</h3><p><code>PodAffinity</code> 是 Pod 的调度策略的一部分，它位于 Pod 的 <code>spec.affinity</code> 字段下。主要相关的字段如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">affinity:</span><br>  <span class="hljs-attr">podAffinity:</span><br>    <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬性亲和性规则</span><br>    <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软性亲和性规则</span><br></code></pre></td></tr></table></figure><p>类似的结构也适用于 <code>PodAntiAffinity</code>。</p><h4 id="1-requiredDuringSchedulingIgnoredDuringExecution"><a href="#1-requiredDuringSchedulingIgnoredDuringExecution" class="headerlink" title="1. requiredDuringSchedulingIgnoredDuringExecution"></a>1. <code>requiredDuringSchedulingIgnoredDuringExecution</code></h4><p>表示强制规则（硬性约束），如果规则无法被满足，Pod 将不会被调度到某个节点上。<br>这个字段适合用在要求非常严格的场景，比如某些关键服务之间的紧密绑定。</p><h4 id="2-preferredDuringSchedulingIgnoredDuringExecution"><a href="#2-preferredDuringSchedulingIgnoredDuringExecution" class="headerlink" title="2. preferredDuringSchedulingIgnoredDuringExecution"></a>2. <code>preferredDuringSchedulingIgnoredDuringExecution</code></h4><p>表示偏好规则（软性约束），如果规则能够满足，调度器会优先选择满足条件的节点；但如果无法满足，Pod 仍然可以被调度到其他节点上。<br>这个字段适合用在需要优化但不强制的场景。</p><hr><h3 id="PodAffinity-的使用示例"><a href="#PodAffinity-的使用示例" class="headerlink" title="PodAffinity 的使用示例"></a>PodAffinity 的使用示例</h3><h4 id="1-配置-Pod-Affinity（亲和性）"><a href="#1-配置-Pod-Affinity（亲和性）" class="headerlink" title="1. 配置 Pod Affinity（亲和性）"></a>1. 配置 Pod Affinity（亲和性）</h4><p>假如你希望一个应用的 Pod 调度到与指定标签 <code>app=webserver</code> 的 Pod 所在的节点上，可以使用以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchLabels:</span><br>            <span class="hljs-attr">app:</span> <span class="hljs-string">webserver</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p><strong>字段解释：</strong></p><ul><li><code>labelSelector</code>: 指定需要与哪些 Pod 匹配，这里是所有具备 <code>app=webserver</code> 标签的 Pod。</li><li><code>topologyKey</code>: 指定亲和性的拓扑域。在这个例子中，它是 <code>kubernetes.io/hostname</code>，表示 Pod 会被调度到与目标 Pod 位于相同主机的节点上。</li></ul><h4 id="2-配置-Pod-Anti-Affinity（反亲和性）"><a href="#2-配置-Pod-Anti-Affinity（反亲和性）" class="headerlink" title="2. 配置 Pod Anti-Affinity（反亲和性）"></a>2. 配置 Pod Anti-Affinity（反亲和性）</h4><p>如果你希望 Pod 避开与指定标签 <code>app=webserver</code> 的 Pod 所在的节点，可以使用如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAntiAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchLabels:</span><br>            <span class="hljs-attr">app:</span> <span class="hljs-string">webserver</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>这会确保 Pod 避开任何有 <code>app=webserver</code> 的节点。</p><hr><h3 id="结合-TopologyKey-的使用"><a href="#结合-TopologyKey-的使用" class="headerlink" title="结合 TopologyKey 的使用"></a>结合 TopologyKey 的使用</h3><p>Kubernetes 中的 <code>topologyKey</code> 是一个关键字段，它指定亲和性或反亲和性规则所应用的拓扑域。常见的值包括：</p><ol><li><code>kubernetes.io/hostname</code> - 节点级别的亲和性。</li><li><code>failure-domain.beta.kubernetes.io/zone</code> - 可用区级别的亲和性。</li><li><code>failure-domain.beta.kubernetes.io/region</code> - 区域级别的亲和性。</li></ol><p>假设你希望 Pod 调度到与目标 Pod 位于相同的可用区，而不是完全相同的节点，你可以将 <code>topologyKey</code> 设置为 <code>failure-domain.beta.kubernetes.io/zone</code>s</p><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><strong>性能开销：</strong></p><ul><li>使用复杂的亲和性规则可能会显著增加调度器的计算负担，因为调度器需要检查每个节点是否满足约束。</li><li>如果集群规模较大、规则复杂，可能会对调度器性能产生负面影响。</li></ul></li><li><p><strong>节点资源竞争：</strong></p><ul><li>当 PodAffinity 被强制使用为硬性约束时，可能导致 Pod 在资源不足时无法调度。</li></ul></li><li><p><strong>与节点亲和性（NodeAffinity）的对比：</strong></p><ul><li><code>NodeAffinity</code> 是基于节点标签的调度规则，而 <code>PodAffinity</code> 是基于 Pod 标签的调度规则。</li><li>两者可以结合使用，形成更灵活的调度策略。</li></ul></li></ol><p>在 Kubernetes 中，<code>Taints</code> 和 <code>Tolerations</code> 是用来控制 Pod 调度的机制。通过它们，集群管理员可以实现更细粒度的调度控制，确保工作负载被调度到最合适的节点上执行。</p><h2 id="Taints-和-Tolerations"><a href="#Taints-和-Tolerations" class="headerlink" title="Taints 和 Tolerations"></a>Taints 和 Tolerations</h2><h3 id="1-Taints-和-Tolerations-概念"><a href="#1-Taints-和-Tolerations-概念" class="headerlink" title="1. Taints 和 Tolerations 概念"></a>1. Taints 和 Tolerations 概念</h3><h4 id="Taints（污点）"><a href="#Taints（污点）" class="headerlink" title="Taints（污点）"></a>Taints（污点）</h4><p><code>Taints</code> 是对节点（Node）设置的一种标记，用来表示该节点存在某种“特殊性”，不能随便调度任意的 Pod。只有那些显式声明“能够容忍”这些污点的 Pod 才能调度到这些节点上。</p><p>每个 Taint 由以下三部分组成：</p><ul><li><strong>Key</strong>：一个字符串，表示污点的键。</li><li><strong>Value</strong>：一个字符串，表示污点的值。（可选）</li><li><strong>Effect</strong>：污点的影响，表示不满足某些条件的 Pod 会被如何处理。</li></ul><p><code>Effect</code> 的取值有以下三种：</p><ul><li><strong><code>NoSchedule</code>: 不允许 Pod 被调度到这个节点上。</strong></li><li><strong><code>PreferNoSchedule</code>: 尽量不要调度 Pod 到这个节点上，但不是强制的。</strong></li><li><strong><code>NoExecute</code>: 如果 Pod 已经运行在这个节点上，也会驱逐它，同时阻止新的 Pod 被调度到这个节点上。</strong></li></ul><p>创建一个 <code>Taint</code> 的语法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:&lt;effect&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes node1 dedicated=special-workload:NoSchedule<br></code></pre></td></tr></table></figure><p>这表示节点 <code>node1</code> 上有一个污点 <code>dedicated=special-workload</code>，任何没有适当 <code>Toleration</code> 的 Pod 都不能调度到该节点。</p><h4 id="Tolerations（容忍）"><a href="#Tolerations（容忍）" class="headerlink" title="Tolerations（容忍）"></a>Tolerations（容忍）</h4><p><code>Tolerations</code> 是对 Pod 的配置，用于声明该 Pod 可以“容忍”哪些节点上的污点，从而允许自己被调度到这些节点上。</p><p>每个 Toleration 的结构如下：</p><ul><li><strong>Key</strong>: 和节点的 Taints 的 Key 对应。</li><li><strong>Operator</strong>: 表示如何匹配 Key，可能的值有 <code>Equal</code> 和 <code>Exists</code>。<ul><li><code>Equal</code>: Key 和 Value 必须完全相等。</li><li><code>Exists</code>: Key 必须存在，而不要求 Value。</li></ul></li><li><strong>Value</strong>: 和节点的 Taints 的 Value 对应。（可选）</li><li><strong>Effect</strong>: 与节点上的污点的 Effect 对应。</li><li><strong>TolerationSeconds</strong>: 仅对 <code>NoExecute</code> 生效。如果指定了该字段，表示 Pod 在被驱逐前可以容忍这个污点的时间。</li></ul><p>一个 Toleration 的 YAML 配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;dedicated&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;special-workload&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-Taints-和-Tolerations-的工作机制"><a href="#2-Taints-和-Tolerations-的工作机制" class="headerlink" title="2. Taints 和 Tolerations 的工作机制"></a>2. Taints 和 Tolerations 的工作机制</h3><ul><li>当一个节点上有污点（Taint）时，Kubernetes 调度器会检查所有待调度的 Pod，只有那些有匹配的 Toleration 的 Pod 才会被调度到该节点。</li><li>如果 Pod 没有匹配的 Toleration，则调度器会跳过这个节点，继续寻找其他合适的节点。</li></ul><p>需要注意的是：</p><ul><li><strong>Taints 是主动的</strong>：节点上有污点时，会对不满足条件的 Pod 施加限制。</li><li><strong>Tolerations 是被动的</strong>：Pod 上有 Toleration 时，表明它可以容忍某种污点，但它不会主动要求调度到有特定污点的节点上。</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><h4 id="3-1-在特定节点上添加-Taint"><a href="#3-1-在特定节点上添加-Taint" class="headerlink" title="3.1 在特定节点上添加 Taint"></a>3.1 在特定节点上添加 Taint</h4><p>假设我们希望将节点 <code>node1</code> 设为专用节点，用于跑某些特定工作负载（如后台任务）。我们可以给这个节点添加如下 Taint：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes node1 dedicated=background-tasks:NoSchedule<br></code></pre></td></tr></table></figure><h4 id="3-2-配置-Pod-的-Toleration"><a href="#3-2-配置-Pod-的-Toleration" class="headerlink" title="3.2 配置 Pod 的 Toleration"></a>3.2 配置 Pod 的 Toleration</h4><p>假设我们有一个 Pod 专门用于后台任务，我们希望它能够调度到 <code>node1</code> 上。可以在 Pod 的 YAML 文件中添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-background-task</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;dedicated&quot;</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;background-tasks&quot;</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="3-3-添加-NoExecute-的场景"><a href="#3-3-添加-NoExecute-的场景" class="headerlink" title="3.3 添加 NoExecute 的场景"></a>3.3 添加 <code>NoExecute</code> 的场景</h4><p>假设我们希望标记一个节点为不可用（例如硬件维护时），并且希望正在运行的 Pod 能够在 60 秒内迁移到其他节点。可以这样设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes node1 maintenance=<span class="hljs-literal">true</span>:NoExecute<br></code></pre></td></tr></table></figure><p>然后，在 Pod 的 Toleration 中，我们可以指定容忍时间：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;maintenance&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>  <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>此时，Pod 会在 60 秒内迁移到其他节点。</p><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h3><h4 id="场景-1：专用节点调度"><a href="#场景-1：专用节点调度" class="headerlink" title="场景 1：专用节点调度"></a>场景 1：专用节点调度</h4><p>通过设置 <code>Taints</code> 和 <code>Tolerations</code>，可以实现节点专用于某些特殊工作负载（如 GPU 工作负载、日志收集等）。</p><h4 id="场景-2：节点维护"><a href="#场景-2：节点维护" class="headerlink" title="场景 2：节点维护"></a>场景 2：节点维护</h4><p>当节点需要下线维护时，可以添加 <code>NoExecute</code> 类型的 Taint，将该节点上的所有 Pod 驱逐，同时阻止新 Pod 调度到该节点。</p><h4 id="场景-3：负载隔离"><a href="#场景-3：负载隔离" class="headerlink" title="场景 3：负载隔离"></a>场景 3：负载隔离</h4><p>通过对节点添加 <code>PreferNoSchedule</code> 类型的 Taint，可以降低调度到该节点的优先级，但仍然允许在特殊情况下将 Pod 调度到该节点。</p><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ol><li><strong>Taints 和 Tolerations 并不主动分配工作负载到特定节点</strong>：它们只是限制哪些节点可以运行哪些 Pod。如果需要主动分配，可以结合 <code>nodeSelector</code> 或 <code>nodeAffinity</code>。</li><li><strong>Tolerations 只允许调度，不强制调度</strong>：即使 Pod 有符合条件的 Toleration，也可能因为资源不足等原因无法调度到对应节点。</li><li><strong>TolerationSeconds 仅适用于 <code>NoExecute</code></strong>：当节点添加 <code>NoExecute</code> 类型的 Taint 时，容忍时间才会生效。</li></ol><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>Kubernetes 通过 <code>Taints</code> 和 <code>Tolerations</code> 配合来实现节点的故障转移（Failover），当某些节点出现故障（如离线或不可用）时，<code>Taints</code> 可以标记这些节点不适合继续运行 Pod，而调度器（Scheduler）会将受影响的 Pod 迁移到其他可用节点，从而实现故障转移。</p><h3 id="故障转移的核心机制"><a href="#故障转移的核心机制" class="headerlink" title="故障转移的核心机制"></a>故障转移的核心机制</h3><p>在 Kubernetes 中，故障转移通常依赖以下几个机制：</p><ol><li><p><strong>节点不可用的检测</strong>：<br>Kubernetes 使用 <code>kubelet</code> 和 <code>Node Controller</code> 来监控节点的可用性。如果节点未在指定时间内报告心跳（默认 40 秒内未响应），Node Controller 会将该节点标记为不可用，进而触发相应的处理。</p></li><li><p><strong>节点的 <code>NoExecute</code> Taint</strong>：<br>当节点被标记为不可用时，Kubernetes 会自动为该节点添加一个特殊的 Taint：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">node.kubernetes.io/unreachable:NoExecute<br></code></pre></td></tr></table></figure><p>这是一个系统级的 Taint，表示该节点已不可达。</p></li><li><p><strong>Pod 的 Tolerations</strong>：<br>如果部署的 Pod 没有显式声明可以容忍这个 Taint，它们会被驱逐（Evicted）并重新调度到其他健康的节点上。</p></li><li><p><strong>驱逐与重新调度</strong>：<br>调度器检测到 Pod 因为 Taints 被驱逐后，会在其他节点上重新调度这些 Pod（前提是集群中有其他符合条件的健康节点）。</p></li></ol><hr><h3 id="故障转移中的-Tolerations-作用"><a href="#故障转移中的-Tolerations-作用" class="headerlink" title="故障转移中的 Tolerations 作用"></a>故障转移中的 <code>Tolerations</code> 作用</h3><p><code>Tolerations</code> 是用来定义 Pod 能够容忍哪些类型的 Taints 的。如果一个 Pod 声明了能够容忍 <code>NoExecute</code> 类型的 Taint，会影响 Pod 的行为：</p><ol><li><p><strong>没有 Tolerations</strong>：</p><ul><li>当节点被标记为不可用（添加 <code>NoExecute</code> Taint）时，Pod 会立即被驱逐，并重新调度到其他健康节点。</li></ul></li><li><p><strong>有 Toleration，但没有 <code>tolerationSeconds</code></strong>：</p><ul><li>如果 Pod 声明了可以容忍 <code>node.kubernetes.io/unreachable:NoExecute</code> 的 Taint，但没有指定 <code>tolerationSeconds</code>，它会无限期地留在该节点上，即使节点不可达也不会被驱逐。</li></ul></li><li><p><strong>有 Toleration，且指定了 <code>tolerationSeconds</code></strong>：</p><ul><li>如果 Pod 声明了可以容忍 <code>node.kubernetes.io/unreachable:NoExecute</code> 的 Taint，并设置了 <code>tolerationSeconds</code>，Pod 会在节点不可达的指定时间后被驱逐。例如：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node.kubernetes.io/unreachable&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>  <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>这表示该 Pod 当节点不可达时，可以容忍 60 秒，超过这个时间后会被驱逐。</li></ul></li></ol><hr><h3 id="故障转移示例"><a href="#故障转移示例" class="headerlink" title="故障转移示例"></a>故障转移示例</h3><h4 id="1-模拟节点故障"><a href="#1-模拟节点故障" class="headerlink" title="1. 模拟节点故障"></a>1. 模拟节点故障</h4><p>假设有一个 Pod 被调度到了节点 <code>node1</code>，我们可以通过以下命令模拟该节点的不可用状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 标记节点为不可用</span><br>kubectl taint nodes node1 node.kubernetes.io/unreachable:NoExecute<br></code></pre></td></tr></table></figure><p>这和节点因为健康检查失败被自动添加 <code>NoExecute</code> Taint 的情况等价。</p><h4 id="2-Pod-的行为"><a href="#2-Pod-的行为" class="headerlink" title="2. Pod 的行为"></a>2. Pod 的行为</h4><ul><li><p>如果 Pod 没有定义任何 Toleration：</p><ul><li>Pod 会被立即驱逐并重新调度到其他健康节点（如果有可用节点）。</li></ul></li><li><p>如果 Pod 有定义以下 Toleration：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node.kubernetes.io/unreachable&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>  <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><ul><li>Pod 在 <code>node1</code> 上可以继续运行，但最多容忍 30 秒。如果在 30 秒内节点状态恢复，Pod 不会被驱逐；如果超过 30 秒节点仍不可用，Pod 会被驱逐并重新调度。</li></ul></li></ul><hr><h3 id="故障转移的工作流程"><a href="#故障转移的工作流程" class="headerlink" title="故障转移的工作流程"></a>故障转移的工作流程</h3><p>以下是 Kubernetes 故障转移的完整工作流程：</p><ol><li><p><strong>节点检测与标记</strong>：</p><ul><li><code>kubelet</code> 定期向 <code>kube-apiserver</code> 发送心跳。如果节点的心跳在 40 秒内没有响应（通过 <code>node-status-update-frequency</code> 和 <code>node-monitor-grace-period</code> 参数控制），Node Controller 会将节点标记为 <code>NotReady</code> 并添加一个 <code>NoExecute</code> Taint：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">node.kubernetes.io/unreachable:NoExecute<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Pod 驱逐逻辑</strong>：</p><ul><li>对于运行在该节点上的 Pod，调度器会检查它们是否有 <code>Toleration</code> 能容忍 <code>NoExecute</code> Taint：<ul><li>没有 Tolerations 的 Pod 会被立刻驱逐。</li><li>有 <code>tolerationSeconds</code> 的 Pod 会在指定时间后被驱逐。</li><li>有 Tolerations 且无限期容忍的 Pod 会继续保留在节点上（即使节点不可用）。</li></ul></li></ul></li><li><p><strong>重新调度</strong>：</p><ul><li>被驱逐的 Pod 状态会变为 <code>Pending</code>，调度器会尝试将 Pod 分配到其他符合条件的健康节点。</li><li>如果集群中没有足够的资源，Pod 会一直处于 <code>Pending</code> 状态，直到有可用资源。</li></ul></li><li><p><strong>节点恢复</strong>：</p><ul><li>如果节点恢复（心跳正常），Taint 会被自动移除，新的 Pod 可以调度到该节点。</li></ul></li></ol><hr><h3 id="实际使用场景"><a href="#实际使用场景" class="headerlink" title="实际使用场景"></a>实际使用场景</h3><ol><li><p><strong>无状态应用（Stateless Applications）</strong>：</p><ul><li>对于无状态应用（如 Web 服务器），通常不会定义 <code>NoExecute</code> Taint 的 Tolerations。当节点不可用时，这些 Pod 会被快速驱逐并重新调度到其他节点。</li></ul></li><li><p><strong>有状态应用（Stateful Applications）</strong>：</p><ul><li>对于有状态应用（如数据库），可以使用 <code>tolerationSeconds</code> 为 Pod 设置一个宽限期，以允许节点临时不可用的情况下减少不必要的驱逐。例如，数据库可能会因为网络抖动而短时间失联，此时无需立即驱逐 Pod。</li></ul></li><li><p><strong>关键任务负载（Critical Workloads）</strong>：</p><ul><li>如果某些 Pod 是关键任务，且对节点的不可用有更高的容忍度，可以为其设置无限期容忍：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node.kubernetes.io/unreachable&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h3><ol><li><p><strong>合理设置心跳间隔</strong>：</p><ul><li>如果节点的不可用只是暂时的（例如网络抖动），可以通过调整 <code>node-monitor-grace-period</code> 参数来避免误判。</li></ul></li><li><p><strong>为不同类型的应用设置不同的 <code>tolerationSeconds</code></strong>：</p><ul><li>无状态应用可以设置较短的容忍时间（甚至不容忍）。</li><li>有状态应用可以设置较长的容忍时间，避免频繁驱逐。</li></ul></li><li><p><strong>结合 Pod 的 Liveness Probe 和 Readiness Probe</strong>：</p><ul><li>确保 Pod 本身的健康状态，避免将调度问题与 Pod 内部问题混淆。</li></ul></li></ol><p>在 Kubernetes 中，调度器是负责将 Pod 分配到集群中的合适节点上的组件。对于复杂的生产环境，可能会遇到调度效率、资源竞争和容灾等挑战，Kubernetes 提供了多种功能来优化调度策略，其中包括 <strong>PriorityClass（优先级调度）</strong> 和 <strong>多调度器（Multiple Schedulers）</strong>。</p><hr><h2 id="PriorityClass"><a href="#PriorityClass" class="headerlink" title="PriorityClass"></a>PriorityClass</h2><h3 id="1-优先级调度（PriorityClass）"><a href="#1-优先级调度（PriorityClass）" class="headerlink" title="1. 优先级调度（PriorityClass）"></a>1. <strong>优先级调度（PriorityClass）</strong></h3><p><strong>PriorityClass</strong> 是 Kubernetes 提供的一种机制，用于给不同 Pod 设置调度优先级。它允许用户指定某些工作负载的重要性，从而确保高优先级的工作负载能够获得优先调度。</p><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a><strong>关键概念</strong></h4><ul><li><strong>PriorityClass 对象</strong>: 定义了优先级名称和其对应的整数字段（<code>value</code>），<code>value</code> 越大，优先级越高。</li><li><strong>系统优先级范围</strong>: <ul><li><code>system-cluster-critical</code> 和 <code>system-node-critical</code> 是 Kubernetes 预定义的最高优先级，通常用于核心组件（如 <code>coredns</code>、<code>kube-proxy</code>）。</li><li>自定义的优先级值取值范围为正整数，通常由管理员定义。</li></ul></li><li><strong>抢占（Preemption）</strong>:<ul><li>如果没有足够的资源调度高优先级 Pod，会触发抢占机制，驱逐低优先级的 Pod 为高优先级的 Pod 腾出资源。</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><p>定义一个 PriorityClass:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">high-priority</span><br><span class="hljs-attr">value:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">globalDefault:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&quot;This priority class is for high-priority workloads.&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>value</code>: 优先级值。</li><li><code>globalDefault</code>: 是否默认应用到没有指定优先级的 Pod。</li></ul></li><li><p>使用 PriorityClass 的 Pod 定义:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">high-priority-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">high-priority</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li><strong>关键工作负载保障</strong>: 确保核心服务（如监控、日志）优先获得资源。</li><li><strong>抢占低优先级任务</strong>: 在资源紧张时，驱逐低优先级的任务以调度高优先级任务。</li></ul><h4 id="生产问题分析"><a href="#生产问题分析" class="headerlink" title="生产问题分析"></a><strong>生产问题分析</strong></h4><ul><li><strong>调度放大效应</strong>: 如图所示，当集群资源紧张或 Node 出现问题时，优先级调度可能导致某些 Pod（如低优先级的批量任务）无法被调度。</li><li><strong>长时间调度失败问题</strong>: 调度缓存（scheduler cache）滞后可能导致调度错误。</li></ul><hr><h3 id="2-多调度器（Multiple-Schedulers）"><a href="#2-多调度器（Multiple-Schedulers）" class="headerlink" title="2. 多调度器（Multiple Schedulers）"></a>2. <strong>多调度器（Multiple Schedulers）</strong></h3><p>Kubernetes 默认使用 <code>kube-scheduler</code> 作为调度器，但在某些场景下，我们可能需要自定义调度逻辑。这时可以部署多个调度器，每个调度器负责调度特定的 Pod 子集。</p><h4 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a><strong>关键概念</strong></h4><ul><li><strong>调度器名称（SchedulerName）</strong>: 每个调度器需要有一个唯一的名称，Pod 可以通过 <code>spec.schedulerName</code> 指定其使用哪个调度器。</li><li><strong>自定义调度器</strong>: 使用调度框架（如 Kubernetes 的调度器扩展 API 或自定义调度器）实现需求。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><p><strong>部署多个调度器</strong></p><ul><li>部署默认调度器 <code>kube-scheduler</code>。</li><li>部署一个自定义调度器。</li></ul><p>自定义调度器示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">custom-scheduler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">custom-scheduler</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">custom-scheduler-image</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--scheduler-name=custom-scheduler</span><br></code></pre></td></tr></table></figure></li><li><p><strong>指定 Pod 使用自定义调度器</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">custom-scheduled-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">custom-scheduler</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li><strong>隔离调度逻辑</strong>: 不同调度器负责不同类型的任务（如批量任务、在线服务）。</li><li><strong>性能优化</strong>: 当单一调度器无法满足高并发 Pod 创建需求时，使用多调度器分担调度压力。</li><li><strong>自定义调度需求</strong>: 特定业务场景下需要定制复杂的调度策略，如基于 GPU 资源、拓扑感知等。</li></ul><h4 id="生产问题分析-1"><a href="#生产问题分析-1" class="headerlink" title="生产问题分析"></a><strong>生产问题分析</strong></h4><ul><li><strong>小集群高并发调度问题</strong>: 如图所示，在高并发情况下，调度器可能因为缓存更新滞后导致调度失败，增加一个专用调度器可能缓解问题。</li><li><strong>危险 Pod 爆炸问题</strong>: 自定义调度器可以用来隔离潜在的危险 Pod，从而避免调度到非预期的 Node。</li></ul><hr><h3 id="3-总结生产经验"><a href="#3-总结生产经验" class="headerlink" title="3. 总结生产经验"></a>3. <strong>总结生产经验</strong></h3><p>根据图中的生产经验提示，我们可以结合优先级调度和多调度器功能来优化生产环境。</p><ul><li><strong>小集群高并发场景</strong>: 通过多调度器分摊调度压力，或优化调度器的缓存刷新机制。</li><li><strong>资源倾斜与放大效应</strong>: 使用 PriorityClass 控制任务优先级，同时监控 Pod 的分布，避免过载单一 Node。</li><li><strong>危险 Pod 防护</strong>: 结合资源配额（ResourceQuota）和自定义调度器，隔离潜在的恶意或异常工作负载。</li></ul><p>通过这些改进，可以有效提升系统的稳定性和调度效率，同时避免因调度问题引发的级联故障。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_API_server</title>
    <link href="/2025/03/17/kubernetes-API-server/"/>
    <url>/2025/03/17/kubernetes-API-server/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-Kubernetes-API-Server：访问控制、限流与对象实现"><a href="#深入理解-Kubernetes-API-Server：访问控制、限流与对象实现" class="headerlink" title="深入理解 Kubernetes API Server：访问控制、限流与对象实现"></a>深入理解 Kubernetes API Server：访问控制、限流与对象实现</h1><p>kube-apiserver 是 Kubernetes 集群的”大脑”，负责处理所有请求，是集群管理的核心组件。本文将深入探讨 kube-apiserver 的访问控制机制（认证、鉴权、准入控制）、限流策略以及 APIServer 对象的实现原理。</p><span id="more"></span><h2 id="1-API-Server-的核心功能"><a href="#1-API-Server-的核心功能" class="headerlink" title="1. API Server 的核心功能"></a>1. API Server 的核心功能</h2><p>kube-apiserver 主要提供以下功能：</p><ul><li><strong>集群管理的 REST API 接口</strong>：提供认证授权、数据校验、集群状态变更等功能。</li><li><strong>模块间数据交互枢纽</strong>：其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001413236.png" class="" title="image-20250317001413236"><h2 id="2-访问控制"><a href="#2-访问控制" class="headerlink" title="2. 访问控制"></a>2. 访问控制</h2><img src="/2025/03/17/kubernetes-API-server/image-20250317001401046.png" class="" title="image-20250317001401046"><p>客户端（例如 <code>kubectl</code>、自定义控制器或其他 K8s 组件）发出的 API 请求首先到达 <code>kube-apiserver</code>。这些请求经过一系列处理步骤，最终被处理并存储到 <code>etcd</code> 中（或从 <code>etcd</code> 中检索）。</p><img src="/2025/03/17/kubernetes-API-server/image-20250317141928036.png" class="" title="image-20250317141928036"><ul><li><p><strong>Panic Recovery</strong>: 捕获并处理任何 panic，防止整个 apiserver 崩溃。</p></li><li><p><strong>Request Timeout</strong>: 设置请求的超时时间，防止请求无限期挂起。</p></li><li><p><strong>Authentication</strong>: 验证请求者的身份。K8s 支持多种认证机制，如 X.509 证书、Service Account Tokens、Bearer Tokens 等。</p></li><li><p><strong>Audit</strong>: 记录请求的审计日志，用于安全审计和故障排除。</p></li><li><p><strong>Impersonation</strong>: 允许一个用户或服务账户以另一个用户或服务账户的身份执行操作。</p></li><li><p><strong>Max-in-flight</strong>: 限制并发处理的请求数量，防止服务器过载。</p></li><li><p><strong>Authorization</strong>: 确定经过身份验证的用户是否有权限执行请求的操作。K8s 支持多种授权机制，如 RBAC (Role-Based Access Control)、ABAC (Attribute-Based Access Control) 等。</p></li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317141918159.png" class="" title="image-20250317141918159"><h3 id="2-1-认证（Authentication）"><a href="#2-1-认证（Authentication）" class="headerlink" title="2.1 认证（Authentication）"></a>2.1 认证（Authentication）</h3><p>在 Kubernetes 中，认证是指对请求的发送者（用户或服务）进行身份识别，以确保只有合法的实体可以访问 Kubernetes API Server。以下是 Kubernetes 支持的多种认证机制的详细说明：</p><hr><h4 id="1-X-509-证书"><a href="#1-X-509-证书" class="headerlink" title="1. X.509 证书"></a><strong>1. X.509 证书</strong></h4><p><strong>概念</strong>：<br>X.509 是一种基于公钥基础设施 (PKI) 的证书标准，通常用于安全通信。Kubernetes 支持通过客户端证书进行身份验证。</p><p><strong>工作原理</strong>：</p><ol><li>用户使用私钥和证书向 API Server 发起 HTTPS 请求。</li><li>API Server 使用信任的 CA 证书对客户端证书进行验证。</li><li>若验证通过，则认证成功。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>生成 CA 和用户证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 CA 私钥和证书</span><br>openssl genrsa -out ca.key 2048<br>openssl req -x509 -new -nodes -key ca.key -subj <span class="hljs-string">&quot;/CN=kube-ca&quot;</span> -days 10000 -out ca.crt<br><br><span class="hljs-comment"># 生成用户私钥和 CSR</span><br>openssl genrsa -out user.key 2048<br>openssl req -new -key user.key -subj <span class="hljs-string">&quot;/CN=my-user/O=my-group&quot;</span> -out user.csr<br><br><span class="hljs-comment"># 使用 CA 签发用户证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> user.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out user.crt -days 10000 -extensions v3_ext<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --client-ca-file=/path/to/ca.crt<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong>：</p><ul><li>用户名（CN）由证书中的 <code>Common Name</code> 字段指定。</li><li>组（Group）由证书中的 <code>Organization</code> 字段指定。</li></ul><hr><h4 id="2-静态-Token-文件"><a href="#2-静态-Token-文件" class="headerlink" title="2. 静态 Token 文件"></a><strong>2. 静态 Token 文件</strong></h4><p><strong>概念</strong>：<br>静态 Token 是预定义的令牌，用于认证用户。它适合小型测试集群，但不推荐生产环境中使用。</p><p><strong>工作原理</strong>：</p><ol><li>用户请求中携带 <code>Authorization: Bearer &lt;token&gt;</code>。</li><li>API Server 从配置的 Token 文件中查找匹配的 Token。</li><li>若匹配成功，则认证通过。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>创建 Token 文件（CSV 格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csv">token1234,my-user,uid1234,&quot;group1,group2&quot;<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --token-auth-file=/path/to/tokens.csv<br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：简单易用，易于共享。</li><li><strong>缺点</strong>：缺乏安全性（Token 没有过期机制）。</li></ul><hr><h4 id="3-引导-Token-Bootstrap-Token"><a href="#3-引导-Token-Bootstrap-Token" class="headerlink" title="3. 引导 Token (Bootstrap Token)"></a><strong>3. 引导 Token (Bootstrap Token)</strong></h4><p><strong>概念</strong>：<br>引导 Token 是一种动态令牌，主要用于集群引导阶段（例如 <code>kubeadm join</code>）。Token 生命周期由 <code>kube-controller-manager</code> 管理。</p><p><strong>工作原理</strong>：</p><ol><li>Token 以 Kubernetes Secret 的形式存储于 <code>kube-system</code> 命名空间。</li><li>当客户端请求使用 Token 时，API Server 查询对应的 Secret 以验证其合法性。</li><li><code>TokenCleaner</code> 控制器会自动清理过期的 Token。</li></ol><p><strong>常见命令</strong>：</p><ul><li><p>查看引导 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm token list<br></code></pre></td></tr></table></figure></li><li><p>创建引导 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm token create<br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：动态管理，支持自动过期。</li><li><strong>缺点</strong>：只适合用于集群引导。</li></ul><hr><h4 id="4-静态密码文件"><a href="#4-静态密码文件" class="headerlink" title="4. 静态密码文件"></a><strong>4. 静态密码文件</strong></h4><p><strong>概念</strong>：<br>通过用户名和密码进行认证。这种方式简单但不安全，因此不推荐在生产环境中使用。</p><p><strong>配置方式</strong>：</p><ul><li><p>创建密码文件（CSV 格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csv">password1234,my-user,uid1234,&quot;group1,group2&quot;<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --basic-auth-file=/path/to/passwords.csv<br></code></pre></td></tr></table></figure></li></ul><p><strong>缺点</strong>：</p><ul><li>用户名和密码以明文方式存储。</li><li>缺乏强制密码保护机制。</li></ul><hr><h4 id="5-Service-Account-Token"><a href="#5-Service-Account-Token" class="headerlink" title="5. Service Account Token"></a><strong>5. Service Account Token</strong></h4><p><strong>概念</strong>：<br>Service Account 是 Kubernetes 原生的认证机制，主要为 Pod 提供身份认证。</p><p><strong>工作原理</strong>：</p><ol><li>每个 Pod 都可以绑定一个 Service Account。</li><li>默认情况下，Service Account 的 Token 会自动挂载到 Pod 的文件系统路径 <code>/run/secrets/kubernetes.io/serviceaccount</code>。</li><li>Pod 使用 Token 与 API Server 通信。</li></ol><p><strong>优点</strong>：</p><ul><li>安全性高，自动管理。</li><li>适合 Pod 内部访问 API Server。</li></ul><hr><h4 id="6-OpenID-Connect-OIDC"><a href="#6-OpenID-Connect-OIDC" class="headerlink" title="6. OpenID Connect (OIDC)"></a><strong>6. OpenID Connect (OIDC)</strong></h4><p><strong>概念</strong>：<br>OIDC 是基于 OAuth 2.0 的身份认证协议，用于对接外部身份认证服务（例如 Google, Keycloak）。</p><p><strong>工作原理</strong>：</p><ol><li>用户向 OIDC 提供商请求 Token。</li><li>用户携带 Token 向 API Server 发起请求。</li><li>API Server 验证 Token 的签名及有效性。</li><li>验证成功后，返回认证成功。</li></ol><p><strong>配置方式</strong>：</p><ul><li>配置 API Server：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver \<br>  --oidc-issuer-url=https://issuer.example.com \<br>  --oidc-client-id=kubernetes \<br>  --oidc-username-claim=email \<br>  --oidc-groups-claim=<span class="hljs-built_in">groups</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>集成第三方身份认证系统。</li><li>支持复杂身份和组管理。</li></ul><hr><h4 id="7-Webhook-Token-认证"><a href="#7-Webhook-Token-认证" class="headerlink" title="7. Webhook Token 认证"></a><strong>7. Webhook Token 认证</strong></h4><p><strong>概念</strong>：<br>通过 Webhook 调用外部服务来验证 Token 的合法性。</p><p><strong>工作原理</strong>：</p><ol><li>用户携带 Token 向 API Server 发起请求。</li><li>API Server 将 Token 转发到配置的 Webhook 服务。</li><li>Webhook 服务返回认证结果。</li><li>API Server 根据认证结果决定是否通过。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>配置 Webhook：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># webhook-config.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://auth.example.com/authenticate</span><br><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-context</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">example-context</span><br></code></pre></td></tr></table></figure></li><li><p>启用 Webhook：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --authentication-token-webhook-config-file=/path/to/webhook-config.yaml<br></code></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>灵活性高，可以集成复杂的认证逻辑。</li></ul><hr><h4 id="8-匿名请求"><a href="#8-匿名请求" class="headerlink" title="8. 匿名请求"></a><strong>8. 匿名请求</strong></h4><p><strong>概念</strong>：<br>当未提供身份凭据时，API Server 将请求识别为匿名请求。匿名请求默认启用，但可以禁用。</p><p><strong>配置方式</strong>：</p><ul><li>禁用匿名请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --anonymous-auth=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：允许调试和测试。</li><li><strong>缺点</strong>：不适合生产环境，可能引发安全问题。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317145348516.png" class="" title="image-20250317145348516"><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="2-1-1-基于-Webhook-的认证服务集成"><a href="#2-1-1-基于-Webhook-的认证服务集成" class="headerlink" title="2.1.1 基于 Webhook 的认证服务集成"></a>2.1.1 基于 Webhook 的认证服务集成</h4><p>可以构建符合 Kubernetes 规范的自定义认证服务。以下是构建认证服务的要点：</p><ul><li><strong>规范</strong>：<ul><li>URL：<code>https://authn.example.com/authenticate</code></li><li>Method：<code>POST</code></li><li>Input：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TokenReview&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;spec&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(BEARERTOKEN)&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>Output：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TokenReview&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;authenticated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;janedoe@example.com&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;42&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;groups&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;developers&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;qa&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>以下为go代码示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//解码认证请求</span><br>decoder := json.NewDecoder(r.Body)<br><span class="hljs-keyword">var</span> tr authentication.TokenReview<br>err := decoder.Decode(&amp;tr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 转发认证请求至认证服务器(以github为例)</span><br>ts := oauth2.StaticTokenSource(<br>&amp;oauth2.Token&#123;AccessToken: tr.Spec.Token&#125;,<br>)<br>tc := oauth2.NewClient(oauth2.NoContext, ts)<br>client := github.NewClient(tc)<br>user, _, err := client.Users.Get(context.Background(), <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 认证结果返回给APIServer</span><br>w.WriteHeader(http.StatusOK)<br>trs := authentication.TokenReviewStatus&#123;<br>Authenticated: <span class="hljs-literal">true</span>,<br>User: authentication.UserInfo&#123;<br>Username: *user.Login,<br>UID:      *user.Login,<br>&#125;,<br>&#125;<br>json.NewEncoder(w).Encode(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span>,<br><span class="hljs-string">&quot;kind&quot;</span>:       <span class="hljs-string">&quot;TokenReview&quot;</span>,<br><span class="hljs-string">&quot;status&quot;</span>:     trs,<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-1-2-keystone认证的陷阱"><a href="#2-1-2-keystone认证的陷阱" class="headerlink" title="2.1.2 keystone认证的陷阱"></a>2.1.2 keystone认证的陷阱</h4><p>Keystone 是很多企业的核心认证服务。Kubernetes 中使用 Keystone 作为认证插件可能会导致 Keystone 故障且无法恢复。<br>原因：gophercloud 针对过期 token 会一直 retry,导致服务无法恢复</p><p><strong>解决方案:</strong></p><ul><li>熔断</li><li>限流</li></ul><h3 id="2-2-授权"><a href="#2-2-授权" class="headerlink" title="2.2 授权"></a>2.2 授权</h3><p>授权阶段负责确定已认证的用户是否有权限执行请求的操作。Kubernetes 支持以下授权模式：</p><ul><li><strong>ABAC (Attribute-Based Access Control)</strong>：基于属性的访问控制，配置复杂，不推荐。</li><li><strong>RBAC (Role-Based Access Control)</strong>：基于角色的访问控制，推荐使用。</li><li><strong>Webhook</strong>：将授权决策委托给外部 Webhook 服务。</li><li><strong>Node</strong>：一种特殊用途的授权模式，用于授予 kubelet 访问特定资源的权限。</li></ul><h4 id="2-2-1-RBAC"><a href="#2-2-1-RBAC" class="headerlink" title="2.2.1 RBAC"></a>2.2.1 RBAC</h4><p>RBAC 的核心概念：</p><ul><li><strong>Role（角色）</strong>：定义了一组权限规则。</li><li><strong>ClusterRole（集群角色）</strong>：与 Role 类似，但作用于整个集群。</li><li><strong>RoleBinding（角色绑定）</strong>：将 Role 或 ClusterRole 与用户、组或 ServiceAccount 绑定。</li><li><strong>ClusterRoleBinding（集群角色绑定）</strong>：将 ClusterRole 与用户、组或 ServiceAccount 绑定。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001000991.png" class="" title="image-20250317001000991"><ul><li><strong>针对群组授权</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">read-secrets-global</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">manager</span> <span class="hljs-comment"># &#x27;name&#x27; 是区分大小写的</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-reader</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-规划系统角色"><a href="#2-2-2-规划系统角色" class="headerlink" title="2.2.2 规划系统角色"></a>2.2.2 规划系统角色</h4><p>在规划 Kubernetes 集群的权限时，需要考虑以下角色：</p><ul><li><strong>管理员</strong>：拥有集群的最高权限。</li><li><strong>普通用户</strong>：拥有其创建的命名空间内资源的操作权限，对其他命名空间可能有只读权限。</li><li><strong>SystemAccount</strong>：用于 Kubernetes 组件或自定义应用与 API Server 通信。</li></ul><h4 id="2-2-3-实现自定义授权逻辑的方案"><a href="#2-2-3-实现自定义授权逻辑的方案" class="headerlink" title="2.2.3 实现自定义授权逻辑的方案"></a>2.2.3 实现自定义授权逻辑的方案</h4><ol><li>在集群创建时，创建自定义的 Role，例如 <code>namespace-creator</code>，定义用户可操作的对象和读写权限。</li><li>创建自定义的 Namespace 准入控制器，在 Namespace 创建请求被处理时，获取当前用户信息并将其添加到 Namespace 的 Annotation 中。</li><li>创建 RBAC 控制器，监视 Namespace 的创建事件，获取 Namespace 创建者信息，并在当前 Namespace 中创建 RoleBinding 对象，将 <code>namespace-creator</code> 角色与用户绑定。</li></ol><h4 id="2-2-4-权限相关的最佳实践"><a href="#2-2-4-权限相关的最佳实践" class="headerlink" title="2.2.4 权限相关的最佳实践"></a>2.2.4 权限相关的最佳实践</h4><ul><li>ClusterRole 是非命名空间绑定的，针对整个集群生效。</li><li>通常需要创建一个管理员角色，并且绑定给开发运营团队成员。</li><li>ThirdPartyResource 和 CustomResourceDefinition 是全局资源，普通用户创建<br>ThirdPartyResource 以后，需要管理员授予相应权限后才能真正操作该对象。</li><li>针对所有的角色管理，建议创建 spec，用源代码驱动。</li><li>权限是可以传递的，用户 A 可以将其对某对象的某操作，抽取成一个权限，并赋给用户 B。</li><li>防止海量的角色和角色绑定对象，因为大量的对象会导致鉴权效率低，同时给 apiserver 增加负担。</li><li>ServiceAccount 也需要授权的。</li><li>Tips：SSH 到 master 节点通过 insecure port 访问 apiserver 可绕过鉴权，当需要做管理操作又没有权限时可以使用（不推荐）</li></ul><p><strong>授权相关的坑：</strong><br>研发人员忘记在生产环境更新 rolebinding 导致权限不足</p><h3 id="2-3-准入控制"><a href="#2-3-准入控制" class="headerlink" title="2.3 准入控制"></a>2.3 准入控制</h3><p>准入控制在授权之后对请求进行进一步的验证或修改。与认证和授权不同，准入控制可以处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等操作有效。</p><p>Kubernetes 内置了许多准入控制插件，例如：</p><ul><li><strong>AlwaysPullImages</strong>：强制拉取最新镜像。</li><li><strong>DenyEscalatingExec</strong>：禁止特权容器的 exec 和 attach 操作。</li><li><strong>ServiceAccount</strong>：自动创建默认 ServiceAccount。</li><li><strong>ResourceQuota</strong>：限制 Pod 的资源请求。</li><li><strong>LimitRanger</strong>：为 Pod 设置默认资源请求和限制。</li><li><strong>NamespaceLifecycle</strong>：确保处于 termination 状态的命名空间不再接收新的对象创建请求。</li><li><strong>PodSecurityPolicy</strong>：实施 Pod 安全策略。</li><li><strong>NodeRestriction</strong>：限制 kubelet 仅可访问 node、endpoint、pod、service 以及 secret、<br> configmap、PV 和 PVC 等相关的资源</li></ul><h4 id="2-3-1-准入控制插件的开发"><a href="#2-3-1-准入控制插件的开发" class="headerlink" title="2.3.1 准入控制插件的开发"></a>2.3.1 准入控制插件的开发</h4><p>除了默认的准入控制插件，Kubernetes 还支持自定义准入控制插件：</p><ul><li><strong>MutatingWebhookConfiguration</strong>：修改准入对象。</li><li><strong>ValidatingWebhookConfiguration</strong>：校验准入对象，但不修改。<br>准入控制例子：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span><br><span class="hljs-string">admissionregistration.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">MutatingWebhookConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ns-mutating.webhook.k8s.io</span><br><span class="hljs-attr">webhooks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">clientConfig:</span><br>    <span class="hljs-attr">caBundle:</span> &#123;&#123;<span class="hljs-string">.serverca_base64</span>&#125;&#125;<br>    <span class="hljs-attr">url:</span><br><span class="hljs-string">https://admission.local.tess.io/apis/admission.k8s.io/v1alpha1/ns-mutating</span><br>  <span class="hljs-attr">failurePolicy:</span> <span class="hljs-string">Fail</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ns-mutating.webhook.k8s.io</span><br>  <span class="hljs-attr">namespaceSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>     <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">apiVersions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">operations:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CREATE</span><br>    <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>    <span class="hljs-attr">sideEffects:</span> <span class="hljs-string">Unknown</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-配额管理"><a href="#2-3-2-配额管理" class="headerlink" title="2.3.2 配额管理"></a>2.3.2 配额管理</h4><p><strong>原因：</strong><br>资源有限，如何限定某个用户有多少资源？<br><strong>方案：</strong></p><ul><li>预定义每个Namespace的ResourceQuota，并把spec保存为configmap</li><li>创建ResourceQuota Controller</li><li>apiserver中开启ResourceQuota的admission plugin</li></ul><h2 id="3-限流"><a href="#3-限流" class="headerlink" title="3. 限流"></a>3. 限流</h2><p>限流是保护 API Server 免受过多请求影响的重要机制。</p><h3 id="3-1-传统限流算法"><a href="#3-1-传统限流算法" class="headerlink" title="3.1 传统限流算法"></a>3.1 传统限流算法</h3><ul><li><strong>计数器固定窗口算法</strong>：在固定时间窗口内对请求计数，超过阈值则拒绝。</li><li><strong>计数器滑动窗口算法</strong>：将固定窗口划分为多个小窗口，分别计数，窗口滑动时更新计数。</li><li><strong>漏斗算法</strong>：请求进入漏斗，以恒定速率流出，漏斗满时溢出。</li><li><strong>令牌桶算法</strong>：以恒定速率向令牌桶中放入令牌，请求消耗令牌，桶空时拒绝。</li></ul><h3 id="3-2-APIServer-中的限流"><a href="#3-2-APIServer-中的限流" class="headerlink" title="3.2 APIServer 中的限流"></a>3.2 APIServer 中的限流</h3><p>kube-apiserver 通过以下参数进行限流：</p><ul><li><code>--max-requests-inflight</code>：最大非 mutating 请求数。</li><li><code>--max-mutating-requests-inflight</code>：最大 mutating 请求数。</li><li>代码： <code>staging/src/k8s.io/apiserver/pkg/server/filters/maxinflight.go:WithMaxInFlightLimit()</code></li></ul><p>默认值：</p><table><thead><tr><th>节点数</th><th>max-requests-inflight</th><th>max-mutating-requests-inflight</th></tr></thead><tbody><tr><td>1000-3000</td><td>400&#x2F;1500</td><td>200&#x2F;500</td></tr><tr><td>&gt;3000</td><td>3000</td><td>1000</td></tr></tbody></table><h3 id="3-3-传统限流方法的局限性"><a href="#3-3-传统限流方法的局限性" class="headerlink" title="3.3 传统限流方法的局限性"></a>3.3 传统限流方法的局限性</h3><ul><li><strong>粒度粗</strong>：无法针对不同用户、场景进行精细化限流。</li><li><strong>单队列</strong>：所有请求共享限流资源，可能导致单个用户的行为影响整个系统。</li><li><strong>不公平</strong>：正常用户的请求可能被排在队尾，无法及时处理。</li><li><strong>无优先级</strong>：重要请求可能被限流，导致系统故障难以恢复。</li></ul><h3 id="3-4-API-Priority-and-Fairness-APF"><a href="#3-4-API-Priority-and-Fairness-APF" class="headerlink" title="3.4 API Priority and Fairness (APF)"></a>3.4 API Priority and Fairness (APF)</h3><p>APF 是 Kubernetes 1.18 引入的新特性，提供更细粒度的请求分类和隔离，以及有限的排队机制，避免短暂突发流量导致请求被拒绝。</p><h4 id="3-4-1-APF-的核心概念"><a href="#3-4-1-APF-的核心概念" class="headerlink" title="3.4.1 APF 的核心概念"></a>3.4.1 APF 的核心概念</h4><ul><li><strong>多等级 (Priority Level)</strong>：不同优先级的请求拥有独立的并发资源。</li><li><strong>多队列 (Multiple Queues)</strong>：每个优先级内部使用多个队列，通过公平排队算法避免单个 Flow 饿死其他 Flow。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001019487.png" class="" title="image-20250317001019487"><h4 id="3-4-2-关键概念"><a href="#3-4-2-关键概念" class="headerlink" title="3.4.2 关键概念"></a>3.4.2 关键概念</h4><ul><li><strong>FlowSchema</strong>：将请求分类到不同的 Flow。</li><li><strong>PriorityLevelConfiguration</strong>：定义每个优先级的并发限制和排队参数。</li><li><strong>Distinguisher</strong>：在 FlowSchema 内部进一步区分请求（例如，按用户或命名空间）。</li><li><strong>Shuffle Sharding</strong>：将请求分配到队列的算法，隔离低强度和高强度流量。</li><li><strong>Fair Queuing</strong>：从队列中选择请求的算法，确保同一优先级内不同 Flow 的公平性。</li></ul><h4 id="3-4-3-豁免请求"><a href="#3-4-3-豁免请求" class="headerlink" title="3.4.3 豁免请求"></a>3.4.3 豁免请求</h4><p>某些特别重要的请求（例如，<code>system:masters</code> 组的请求）不受 APF 限制。</p><h4 id="3-4-4-默认配置"><a href="#3-4-4-默认配置" class="headerlink" title="3.4.4 默认配置"></a>3.4.4 默认配置</h4><p>Kubernetes 提供了以下默认配置：</p><ul><li><code>system</code>：用于 <code>system:nodes</code> 组的请求。</li><li><code>leader-election</code>：用于内置控制器的领导者选举请求。</li><li><code>workload-high</code>：用于内置控制器的请求。</li><li><code>workload-low</code>：用于来自任何服务帐户的请求。</li><li><code>global-default</code>：处理所有其他流量。</li><li><code>exempt</code>：完全不受流控限制。</li><li><code>catch-all</code>：确保每个请求都被分类。</li></ul><h4 id="3-4-5-PriorityLevelConfiguration"><a href="#3-4-5-PriorityLevelConfiguration" class="headerlink" title="3.4.5 PriorityLevelConfiguration"></a>3.4.5 PriorityLevelConfiguration</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityLevelConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">global-default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">limited:</span><br>    <span class="hljs-attr">assuredConcurrencyShares:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">limitResponse:</span><br>      <span class="hljs-attr">queuing:</span><br>        <span class="hljs-attr">handSize:</span> <span class="hljs-number">6</span><br>        <span class="hljs-attr">queueLengthLimit:</span> <span class="hljs-number">50</span><br>        <span class="hljs-attr">queues:</span> <span class="hljs-number">128</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Queue</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">Limited</span><br></code></pre></td></tr></table></figure><h4 id="3-4-6-FlowSchema"><a href="#3-4-6-FlowSchema" class="headerlink" title="3.4.6 FlowSchema"></a>3.4.6 FlowSchema</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">FlowSchema</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-scheduler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">distinguisherMethod:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">ByNamespace</span><br>  <span class="hljs-attr">matchingPrecedence:</span> <span class="hljs-number">800</span><br>  <span class="hljs-attr">priorityLevelConfiguration:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">workload-high</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">resourceRules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>      <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">subjects:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>      <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-scheduler</span><br></code></pre></td></tr></table></figure><h4 id="3-4-7-调试"><a href="#3-4-7-调试" class="headerlink" title="3.4.7 调试"></a>3.4.7 调试</h4><p>可以使用以下命令调试 APF：</p><ul><li><code>/debug/api_priority_and_fairness/dump_priority_levels</code></li><li><code>/debug/api_priority_and_fairness/dump_queues</code></li><li><code>/debug/api_priority_and_fairness/dump_requests</code></li></ul><h2 id="4-高可用-APIServer"><a href="#4-高可用-APIServer" class="headerlink" title="4. 高可用 APIServer"></a>4. 高可用 APIServer</h2><h3 id="4-1-启动-apiserver-示例"><a href="#4-1-启动-apiserver-示例" class="headerlink" title="4.1 启动 apiserver 示例"></a>4.1 启动 apiserver 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --feature-gates=AllAlpha=<span class="hljs-literal">true</span> --runtime-config=api/all=<span class="hljs-literal">true</span> \<br>--requestheader-allowed-names=front-proxy-client \<br>--client-ca-file=/etc/kubernetes/pki/ca.crt \<br>--allow-privileged=<span class="hljs-literal">true</span> \<br>--experimental-bootstrap-token-auth=<span class="hljs-literal">true</span> \<br>--storage-backend=etcd3 \<br>--requestheader-username-headers=X-Remote-User \<br>--requestheader-extra-headers-prefix=X-Remote-Extra- \<br>--service-account-key-file=/etc/kubernetes/pki/sa.pub \<br>--tls-cert-file=/etc/kubernetes/pki/apiserver.crt \<br>--tls-private-key-file=/etc/kubernetes/pki/apiserver.key \<br>--kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt \<br>--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt \<br>--enabled-hooks=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota \<br>--requestheader-group-headers=X-Remote-Group \<br>--kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key \<br>--secure-port=6443 \<br>--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \<br>--service-cluster-ip-range=10.96.0.0/12 \<br>--advertise-address=192.168.0.20 --etcd-servers=http://127.0.0.1:2379<br></code></pre></td></tr></table></figure><h3 id="4-2-构建高可用的多副本-apiserver"><a href="#4-2-构建高可用的多副本-apiserver" class="headerlink" title="4.2 构建高可用的多副本 apiserver"></a>4.2 构建高可用的多副本 apiserver</h3><p>apiserver是无状态的Rest Server,无状态所以方便Scale Up／down,在多个apiserver实例之上，配置负载均衡,证书可能需要加上Loadbalancer VIP重新生成</p><h3 id="4-3-其他最佳实践"><a href="#4-3-其他最佳实践" class="headerlink" title="4.3 其他最佳实践"></a>4.3 其他最佳实践</h3><ul><li><strong>预留充足的 CPU、内存资源</strong>。</li><li><strong>善用速率限制（RateLimit）</strong>。</li><li><strong>设置合适的缓存大小</strong>。</li><li><strong>客户端尽量使用长连接</strong>。</li><li><strong>访问 APIServer</strong>:<ul><li>外部客户：通过 LoadBalancer 访问。</li><li>内部客户端：优先访问 Cluster IP。</li></ul></li></ul><h2 id="5-搭建多租户的-Kubernetes-集群"><a href="#5-搭建多租户的-Kubernetes-集群" class="headerlink" title="5. 搭建多租户的 Kubernetes 集群"></a>5. 搭建多租户的 Kubernetes 集群</h2><h3 id="5-1-目标"><a href="#5-1-目标" class="headerlink" title="5.1 目标"></a>5.1 目标</h3><ul><li><strong>授信</strong>：认证和授权，确保只有可信用户才能访问集群，并防止用户越权操作。</li><li><strong>隔离</strong>：可见性隔离、资源隔离、应用访问隔离，确保不同租户之间的隔离性。</li><li><strong>资源管理</strong>：Quota 管理，控制每个租户的资源使用量。</li></ul><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><ul><li><strong>认证</strong>：与企业现有认证系统集成（例如，使用 Webhook 认证插件与 Microsoft Active Directory 集成）。</li><li><strong>授权</strong>：使用 RBAC 进行细粒度的权限控制。</li><li><strong>可见性隔离</strong>：通过命名空间对不同租户可见的资源进行隔离</li><li><strong>资源隔离</strong>：通过专有设备给特定租户使用</li><li><strong>应用访问隔离</strong>： 通过设置，只允许特定租户访问某些应用</li><li><strong>Quota 管理</strong>：通过 ResourceQuota 控制每个命名空间的资源使用。</li></ul><h2 id="6-APIServer-对象的实现"><a href="#6-APIServer-对象的实现" class="headerlink" title="6. APIServer 对象的实现"></a>6. APIServer 对象的实现</h2><h3 id="6-1-GKV-Group-Kind-Version"><a href="#6-1-GKV-Group-Kind-Version" class="headerlink" title="6.1  GKV (Group, Kind, Version)"></a>6.1  GKV (Group, Kind, Version)</h3><ul><li><strong>Group</strong>：API 资源的分组。</li><li><strong>Kind</strong>：API 资源的类型。</li><li><strong>Version</strong>：API 资源的版本（Internal version 和 External version）。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001025889.png" class="" title="image-20250317001025889"><h3 id="6-2-定义-Group"><a href="#6-2-定义-Group" class="headerlink" title="6.2  定义 Group"></a>6.2  定义 Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apis/core/register.go</span><br><span class="hljs-keyword">package</span> core<br><span class="hljs-keyword">const</span> GroupName = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// core group 的 GroupName 为空</span><br><span class="hljs-keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: runtime.APIVersionInternal&#125;<br><br><span class="hljs-keyword">var</span> (<br>SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)<br>AddToScheme   = SchemeBuilder.AddToScheme<br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addKnownTypes</span><span class="hljs-params">(scheme *runtime.Scheme)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := scheme.AddIgnoredConversionType(&amp;metav1.TypeMeta&#123;&#125;, &amp;metav1.TypeMeta&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>scheme.AddKnownTypes(SchemeGroupVersion,<br>&amp;Pod&#123;&#125;,<br>&amp;PodList&#123;&#125;,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-定义对象类型"><a href="#6-3-定义对象类型" class="headerlink" title="6.3 定义对象类型"></a>6.3 定义对象类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// types.go</span><br><span class="hljs-keyword">type</span> Pod <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br>Spec PodSpec <span class="hljs-string">`json:&quot;spec,omitempty&quot; protobuf:&quot;bytes,2,opt,name=spec&quot;`</span><br>Status PodStatus <span class="hljs-string">`json:&quot;status,omitempty&quot; protobuf:&quot;bytes,3,opt,name=status&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PodList <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ListMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br>Items []Pod <span class="hljs-string">`json:&quot;items&quot; protobuf:&quot;bytes,2,rep,name=items&quot;`</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-4-代码生成-Tags"><a href="#6-4-代码生成-Tags" class="headerlink" title="6.4 代码生成 Tags"></a>6.4 代码生成 Tags</h3><ul><li><strong>Global Tags</strong>：定义在 <code>doc.go</code> 中，例如 <code>// +k8s:deepcopy-gen=package</code>。</li><li><strong>Local Tags</strong>：定义在 <code>types.go</code> 中的每个对象里，例如 <code>// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>。</li></ul><h3 id="6-5-实现-etcd-storage"><a href="#6-5-实现-etcd-storage" class="headerlink" title="6.5  实现 etcd storage"></a>6.5  实现 etcd storage</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/configmap/storage/storage.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewREST</span><span class="hljs-params">(optsGetter generic.RESTOptionsGetter)</span></span> *REST &#123;<br>store := &amp;genericregistry.Store&#123;<br>NewFunc:                  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;api.ConfigMap&#123;&#125; &#125;,<br>NewListFunc:              <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;api.ConfigMapList&#123;&#125; &#125;,<br>DefaultQualifiedResource: api.Resource(<span class="hljs-string">&quot;configmaps&quot;</span>),<br>CreateStrategy:           configmap.Strategy,<br>UpdateStrategy:           configmap.Strategy,<br>DeleteStrategy:           configmap.Strategy,<br>TableConvertor:           printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,<br>&#125;<br>options := &amp;generic.StoreOptions&#123;RESTOptions: optsGetter&#125;<br><span class="hljs-keyword">if</span> err := store.CompleteWithOptions(options); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Propagate error up</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;REST&#123;store&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-6-创建和更新对象时的业务逻辑-Strategy"><a href="#6-6-创建和更新对象时的业务逻辑-Strategy" class="headerlink" title="6.6  创建和更新对象时的业务逻辑-Strategy"></a>6.6  创建和更新对象时的业务逻辑-Strategy</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/configmap/strategy.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> PrepareForCreate(ctx context.Context, obj runtime.Object) &#123;<br>_ = obj.(*api.ConfigMap)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> Validate(ctx context.Context, obj runtime.Object) field.ErrorList &#123;<br>cfg := obj.(*api.ConfigMap)<br><span class="hljs-keyword">return</span> validation.ValidateConfigMap(cfg)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> PrepareForUpdate(ctx context.Context, newObj, oldObj runtime.Object) &#123;<br>_ = oldObj.(*api.ConfigMap)<br>_ = newObj.(*api.ConfigMap)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-7-subresource"><a href="#6-7-subresource" class="headerlink" title="6.7 subresource"></a>6.7 subresource</h3><p>内嵌在kubernetes对象中，有独立的操作逻辑的属性集合，如podstatus</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">statusStore.UpdateStrategy = pod.StatusStrategy<br><span class="hljs-keyword">var</span> StatusStrategy = podStatusStrategy&#123;Strategy&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStatusStrategy)</span></span> PrepareForUpdate(ctx context.Context, obj, old runtime.Object)<br>&#123;<br>newPod := obj.(*api.Pod)<br>oldPod := old.(*api.Pod)<br>newPod.Spec = oldPod.Spec<br>newPod.DeletionTimestamp = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// don&#x27;t allow the pods/status endpoint to touch owner references since old kubelets corrupt them in a way</span><br><span class="hljs-comment">// that breaks garbage collection</span><br>newPod.OwnerReferences = oldPod.OwnerReferences<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-8-注册-APIGroup"><a href="#6-8-注册-APIGroup" class="headerlink" title="6.8 注册 APIGroup"></a>6.8 注册 APIGroup</h3><ol><li>定义 Storage：<code>configMapStorage := configmapstore.NewREST(restOptionsGetter)</code>。</li><li>定义对象的 StorageMap：<code>apiGroupInfo.VersionedResourcesStorageMap[&quot;v1&quot;] = restStorageMap</code>。</li><li>将对象注册至 APIServer（挂载 handler）：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err :=<br>m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix,<br>&amp;apiGroupInfo); err != <span class="hljs-literal">nil</span> &#123;<br>    klog.Fatalf(<span class="hljs-string">&quot;Error in registering group versions: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-9-代码生成"><a href="#6-9-代码生成" class="headerlink" title="6.9 代码生成"></a>6.9 代码生成</h3><p>Kubernetes 使用以下代码生成器：</p><ul><li><code>deepcopy-gen</code>：为对象生成 DeepCopy 方法。</li><li><code>client-gen</code>：创建 Clientset。</li><li><code>informer-gen</code>：创建 Informer 框架。</li><li><code>lister-gen</code>：创建 Lister 框架。</li><li><code>conversion-gen</code>：创建版本转换方法。</li></ul><p>代码生成器位于：<a href="https://github.com/kubernetes/code-generator">https://github.com/kubernetes/code-generator</a></p><p><code>hack/update-codegen.sh</code> 脚本用于生成代码。<br>命令示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;GOPATH&#125;</span>/bin/deepcopy-gen --input-dirs &#123;versioned-package-pach&#125; \<br>-O zz_generated.deepcopy \<br>--bounding-dirs &#123;output-package-path&#125; \<br>--go-header-file <span class="hljs-variable">$&#123;SCRIPT_ROOT&#125;</span>/hack/boilerplate.go.txt<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入探讨了 Kubernetes API Server 的内部机制，包括访问控制、限流策略和 APIServer 对象的实现。理解这些概念对于构建和管理 Kubernetes 集群至关重要。希望这篇博客能帮助你更好地理解 Kubernetes API Server 的工作原理。<br>apiserver 代码走读可以参考：<a href="https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d">https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes架构原则与对象设计</title>
    <link href="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>这篇文章解析了 Kubernetes 的对象设计。</p><span id="more"></span><h3 id="1-云计算的演变：从虚拟机到容器"><a href="#1-云计算的演变：从虚拟机到容器" class="headerlink" title="1. 云计算的演变：从虚拟机到容器"></a>1. 云计算的演变：从虚拟机到容器</h3><p>云计算，简单来说，就是把计算资源（比如CPU、内存、存储、网络）放到“云”上，大家按需使用，不用自己买服务器、搭机房。</p><p>云计算平台大致经历了两个阶段：</p><ul><li><p><strong>第一阶段：虚拟化平台 (以 OpenStack 为代表)</strong></p><ul><li>想象一下，你有一台大电脑，通过虚拟化技术，把它“切”成很多小电脑（虚拟机），每个小电脑可以独立运行不同的应用。</li><li><strong>优点：</strong> 资源利用率提高了，不用每部署一个应用就买一台服务器。</li><li><strong>缺点：</strong> 虚拟机的创建和业务代码的部署是分开的，每次部署应用都要先创建虚拟机，再安装各种依赖，比较麻烦。而且，虚拟机的底层环境（操作系统、各种库）可能不一样，维护起来比较头疼。</li></ul></li><li><p><strong>第二阶段：基于进程的作业调度平台 (以谷歌 Borg 为代表)</strong></p><ul><li>Borg 是谷歌内部使用的容器集群管理系统，它直接管理进程，而不是虚拟机。</li><li><strong>优点：</strong> 资源利用率更高，应用部署更快，故障恢复也更快。</li><li><strong>缺点：</strong> Borg 的设计比较复杂，有一些不太合理的地方，比如：<ul><li>对象之间的依赖关系太强，不够灵活。</li><li>所有容器共享 IP，容易导致端口冲突。</li><li>给超级用户添加了太多复杂逻辑，系统变得臃肿。</li></ul></li></ul></li></ul><h3 id="2-谷歌-Borg：Kubernetes-的灵感之源"><a href="#2-谷歌-Borg：Kubernetes-的灵感之源" class="headerlink" title="2. 谷歌 Borg：Kubernetes 的灵感之源"></a>2. 谷歌 Borg：Kubernetes 的灵感之源</h3><p>Borg 在谷歌内部发挥了巨大作用，支撑了 Gmail、Google Docs、Web Search 等众多核心业务。</p><h4 id="2-1-Borg-的核心特性"><a href="#2-1-Borg-的核心特性" class="headerlink" title="2.1 Borg 的核心特性"></a>2.1 Borg 的核心特性</h4><ul><li><strong>高资源利用率：</strong> 通过共享服务器，在进程级别进行隔离，充分利用硬件资源。</li><li><strong>高可用性：</strong> 应用故障时，可以快速恢复，保证服务不中断。</li><li><strong>灵活的调度：</strong> 可以根据不同的应用需求，灵活地分配资源。</li><li><strong>方便易用：</strong> 提供了完善的工具，方便用户部署、管理应用。</li></ul><h4 id="2-2-Borg-的基本概念"><a href="#2-2-Borg-的基本概念" class="headerlink" title="2.2 Borg 的基本概念"></a>2.2 Borg 的基本概念</h4><ul><li><strong>Workload（工作负载）：</strong> 分为两种：<ul><li><strong>prod：</strong> 在线任务，比如网站、邮件服务等，对延迟敏感，需要长期运行。</li><li><strong>non-prod：</strong> 离线任务，比如数据分析、批量计算等，可以容忍一定的延迟。</li></ul></li><li><strong>Cell（单元）：</strong> 一个 Cell 包含一个 Borg 集群管理系统，用户不需要关心应用具体跑在哪台机器上，Borg 会自动分配资源、处理故障。</li><li><strong>Job 和 Task：</strong><ul><li><strong>Job：</strong> 用户提交的应用部署请求，包含一个或多个相同的 Task。</li><li><strong>Task：</strong> 运行相同应用程序的副本，Task 的数量就是应用的副本数。</li></ul></li><li><strong>Naming（命名）：</strong> Borg 通过 BNS（Borg Name Service）实现服务发现。例如：<code>50.jfoo.ubar.cc.borg.google.com</code> 表示在名为 <code>cc</code> 的 Cell 中，由用户 <code>uBar</code> 部署的名为 <code>jFoo</code> 的 Job 下的第 50 个 Task。</li></ul><h4 id="2-3-Borg-的架构"><a href="#2-3-Borg-的架构" class="headerlink" title="2.3 Borg 的架构"></a>2.3 Borg 的架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235410146.png" class="" title="image-20250316235410146"><pre class="mermaid">graph LR    subgraph Borg        A[客户端] --> B(Borgmaster)        B --> C{Scheduler}        B --> D[Borglet]        D --> E[应用程序进程]    end</pre><ul><li><strong>Borgmaster：</strong><ul><li>处理客户端请求（创建 Job、查询 Job 等）。</li><li>维护系统组件和服务状态。</li><li>与 Borglet 通信。</li></ul></li><li><strong>Scheduler：</strong><ul><li>负责调度 Task 到合适的机器上。</li><li>采用多种优化策略，提高调度效率。</li></ul></li><li><strong>Borglet：</strong><ul><li>部署在每台服务器上的 Agent。</li><li>接收 Borgmaster 的指令，管理 Task。</li></ul></li></ul><h4 id="2-4-Borg-的高可用性"><a href="#2-4-Borg-的高可用性" class="headerlink" title="2.4 Borg 的高可用性"></a>2.4 Borg 的高可用性</h4><ul><li><strong>应用高可用：</strong><ul><li>多副本部署，跨故障域（不同机器、机架、电源等）。</li><li>控制节点故障时的任务调度速率，避免网络分区误判。</li><li>记录详细信息，方便故障排查。</li><li><strong>关键原则：</strong> 即使 Borgmaster 或 Borglet 挂掉，也不能杀掉正在运行的服务。</li></ul></li><li><strong>Borg 系统自身高可用：</strong><ul><li>Borgmaster 多副本设计。</li><li>使用简单工具部署 Borg，避免过多外部依赖。</li><li>每个 Cell 的 Borg 独立部署，避免相互影响。</li></ul></li></ul><h4 id="2-5-Borg-的资源利用率"><a href="#2-5-Borg-的资源利用率" class="headerlink" title="2.5 Borg 的资源利用率"></a>2.5 Borg 的资源利用率</h4><ul><li><strong>混部：</strong> 在线任务（prod）和离线任务（non-prod）混合部署，充分利用资源。<ul><li>空闲时，离线任务可以使用更多资源。</li><li>繁忙时，在线任务优先执行。</li></ul></li><li><strong>效果：</strong><ul><li>98% 的服务器实现了混部。</li><li>90% 的服务器运行了超过 25 个 Task 和 4500 个线程。</li><li>相比独立部署，混合部署可以节省 20%-30% 的服务器。</li></ul></li></ul><h4 id="2-6-Borg-的调度原理"><a href="#2-6-Borg-的调度原理" class="headerlink" title="2.6 Borg 的调度原理"></a>2.6 Borg 的调度原理</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235416843.png" class="" title="image-20250316235416843"><pre class="mermaid">graph LR    A[machine] --> B(task)    B --> C[实际使用资源]    B --> D[保留资源]    B --> E[回收资源]    B --> F[限制资源]</pre><ul><li><strong>资源回收：</strong> 在 task 启动一段时间后，进行资源回收，将保留资源设置为实际使用资源加上一定的安全余量，并定期重新计算。</li></ul><h4 id="2-7-Borg-的隔离性"><a href="#2-7-Borg-的隔离性" class="headerlink" title="2.7 Borg 的隔离性"></a>2.7 Borg 的隔离性</h4><ul><li><strong>安全性隔离：</strong> 早期采用 Chroot jail，后期基于 Namespace。</li><li><strong>性能隔离：</strong> 采用基于 Cgroup 的容器技术。<ul><li>在线任务优先级高，离线任务优先级低。</li><li>通过抢占式调度，优先保障在线任务性能。</li><li>资源分为可压榨（如 CPU）和不可压榨（如内存）两种。</li></ul></li></ul><h3 id="3-Kubernetes：Borg-的开源版本"><a href="#3-Kubernetes：Borg-的开源版本" class="headerlink" title="3. Kubernetes：Borg 的开源版本"></a>3. Kubernetes：Borg 的开源版本</h3><p>Kubernetes（K8s）是谷歌开源的容器集群管理系统，是 Borg 的开源版本。</p><h4 id="3-1-K8s-的主要功能"><a href="#3-1-K8s-的主要功能" class="headerlink" title="3.1 K8s 的主要功能"></a>3.1 K8s 的主要功能</h4><ul><li>基于容器的应用部署、维护和滚动升级。</li><li>负载均衡和服务发现。</li><li>跨机器和跨地区的集群调度。</li><li>自动伸缩。</li><li>无状态服务和有状态服务。</li><li>插件机制保证扩展性。</li></ul><h4 id="3-2-命令式-vs-声明式"><a href="#3-2-命令式-vs-声明式" class="headerlink" title="3.2 命令式 vs 声明式"></a>3.2 命令式 vs 声明式</h4><ul><li><strong>命令式系统：</strong> 关注“如何做”，需要明确告诉系统每一步做什么。</li><li><strong>声明式系统：</strong> 关注“做什么”，只需要告诉系统你想要什么，系统会自动完成。</li></ul><p>Kubernetes 是一个声明式系统，具有以下特点：</p><ul><li><strong>声明式规范：</strong><ul><li>直接声明：直接告诉系统你的需求。</li><li>间接声明：把需求放在特定地方，系统会自动处理。</li></ul></li><li><strong>幂等性：</strong> 状态固定，每次操作返回相同结果。</li><li><strong>面向对象：</strong> 把一切抽象成对象。</li></ul><h4 id="3-3-Kubernetes-的核心对象"><a href="#3-3-Kubernetes-的核心对象" class="headerlink" title="3.3 Kubernetes 的核心对象"></a>3.3 Kubernetes 的核心对象</h4><ul><li><strong>Node：</strong> 计算节点的抽象。</li><li><strong>Namespace：</strong> 资源隔离的基本单位。</li><li><strong>Pod：</strong> 应用实例的抽象，包含镜像地址、资源需求等，是 K8s 最核心的对象。</li><li><strong>Service：</strong> 将应用发布成服务，本质上是负载均衡和域名服务的声明。</li></ul><h4 id="3-4-Kubernetes-的架构"><a href="#3-4-Kubernetes-的架构" class="headerlink" title="3.4 Kubernetes 的架构"></a>3.4 Kubernetes 的架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/kubernetes-cluster-architecture-2265122.svg" class="" title="image-20250316235421656"><ul><li><strong>Master Node（主节点）：</strong><ul><li><strong>API Server：</strong> 暴露 Kubernetes API，是集群的入口。</li><li><strong>Cluster Data Store (etcd)：</strong> 存储集群所有数据。</li><li><strong>Controller Manager：</strong> 运行各种控制器，确保集群状态与期望状态一致。</li><li><strong>Scheduler：</strong> 负责将 Pod 调度到合适的节点。</li></ul></li><li><strong>Worker Node（工作节点）：</strong><ul><li><strong>Kubelet：</strong> 管理 Pod 的生命周期，向 Master 节点汇报状态。</li><li><strong>Kube-proxy：</strong> 负责网络，维护网络规则，执行连接转发。</li><li><strong>Container Runtime：</strong> 负责运行容器（如 Docker）。</li></ul></li></ul><h4 id="3-5-Kubernetes-的其他组件"><a href="#3-5-Kubernetes-的其他组件" class="headerlink" title="3.5 Kubernetes 的其他组件"></a>3.5 Kubernetes 的其他组件</h4><ul><li><strong>etcd：</strong> 分布式 key-value 存储，用于服务发现、共享配置和一致性保障。</li><li><strong>APIServer：</strong> 提供集群管理的 REST API 接口，包括认证、授权、准入控制等。</li><li><strong>Controller Manager：</strong> 确保集群的真实状态与用户定义的期望状态一致。</li><li><strong>Scheduler：</strong> 监控未调度的 Pod，选择最佳节点进行调度。</li><li><strong>Kubelet：</strong> 从不同源获取 Pod 清单，并按需求启停 Pod。</li><li><strong>Kube-Proxy：</strong> 监控集群中用户发布的服务，并完成负载均衡配置。</li></ul><h4 id="3-6-Kubernetes-的常用-Add-ons"><a href="#3-6-Kubernetes-的常用-Add-ons" class="headerlink" title="3.6 Kubernetes 的常用 Add-ons"></a>3.6 Kubernetes 的常用 Add-ons</h4><ul><li><strong>kube-dns：</strong> 提供 DNS 服务。</li><li><strong>Ingress Controller：</strong> 提供外网入口。</li><li><strong>Metrics Server：</strong> 提供资源监控。</li><li><strong>Dashboard：</strong> 提供 GUI。</li><li><strong>Fluentd-Elasticsearch：</strong> 提供日志采集、存储与查询。</li></ul><h4 id="3-7-kubectl：Kubernetes-的命令行工具"><a href="#3-7-kubectl：Kubernetes-的命令行工具" class="headerlink" title="3.7 kubectl：Kubernetes 的命令行工具"></a>3.7 kubectl：Kubernetes 的命令行工具</h4><ul><li><strong>kubectl：</strong> 允许用户以命令行的方式与 Kubernetes 交互。</li><li><strong>kubeconfig：</strong> 配置文件，包含 apiserver 地址、用户信息等。</li><li><strong>常用命令：</strong><ul><li><code>kubectl get po -oyaml -w</code>：查看对象，输出 yaml 格式，并 watch 变化。</li><li><code>kubectl describe po &lt;pod_name&gt;</code>：展示资源的详细信息和相关 Event。</li><li><code>kubectl exec -it &lt;pod_name&gt; bash</code>：进入运行的容器。</li><li><code>kubectl logs &lt;pod_name&gt;</code>：查看 pod 的标准输出。</li></ul></li></ul><h3 id="4-深入理解-Kubernetes"><a href="#4-深入理解-Kubernetes" class="headerlink" title="4. 深入理解 Kubernetes"></a>4. 深入理解 Kubernetes</h3><h4 id="4-1-云计算的传统分类"><a href="#4-1-云计算的传统分类" class="headerlink" title="4.1 云计算的传统分类"></a>4.1 云计算的传统分类</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235428142.png" class="" title="image-20250316235428142"><ul><li><strong>IaaS (Infrastructure as a Service)：</strong> 提供基础设施，如虚拟机、存储、网络。</li><li><strong>PaaS (Platform as a Service)：</strong> 提供平台，如操作系统、运行时环境、数据库。</li><li><strong>SaaS (Software as a Service)：</strong> 提供软件，如邮件服务、CRM 系统。</li></ul><h4 id="4-2-Kubernetes-生态系统"><a href="#4-2-Kubernetes-生态系统" class="headerlink" title="4.2 Kubernetes 生态系统"></a>4.2 Kubernetes 生态系统</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235435441.png" class="" title="image-20250316235435441"><h4 id="4-3-Kubernetes-设计理念"><a href="#4-3-Kubernetes-设计理念" class="headerlink" title="4.3 Kubernetes 设计理念"></a>4.3 Kubernetes 设计理念</h4><ul><li><strong>可扩展性：</strong> 基于 CRD 的扩展，插件化的生态系统。</li><li><strong>高可用：</strong> 基于 replicaset、statefulset 的应用高可用，Kubernetes 组件本身高可用。</li><li><strong>可移植性：</strong> 多种 host OS 选择，多种基础架构的选择，多云和混合云。</li><li><strong>安全：</strong> 基于 TLS 提供服务，Serviceaccount 和 user，基于 Namespace 的隔离，secret，Taints，psp，networkpolicy。</li></ul><h4 id="4-4-Kubernetes-分层架构"><a href="#4-4-Kubernetes-分层架构" class="headerlink" title="4.4 Kubernetes 分层架构"></a>4.4 Kubernetes 分层架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235445064.png" class="" title="image-20250316235445064"><ul><li><strong>核心层：</strong> 提供 API 构建高层应用，提供插件式应用执行环境。</li><li><strong>应用层：</strong> 部署和路由。</li><li><strong>管理层：</strong> 系统度量、自动化、策略管理。</li><li><strong>接口层：</strong> kubectl 命令行工具、客户端 SDK 以及集群联邦。</li><li><strong>生态系统：</strong><ul><li>Kubernetes 外部：日志、监控、配置管理、CI&#x2F;CD 等。</li><li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider 等。</li></ul></li></ul><h4 id="4-5-API-设计原则"><a href="#4-5-API-设计原则" class="headerlink" title="4.5 API 设计原则"></a>4.5 API 设计原则</h4><ul><li>所有 API 都应是声明式的。</li><li>API 对象是彼此互补而且可组合的。</li><li>高层 API 以操作意图为基础设计。</li><li>低层 API 根据高层 API 的控制需要设计。</li><li>尽量避免简单封装。</li><li>API 操作复杂度与对象数量成正比。</li><li>API 对象状态不能依赖于网络连接状态。</li><li>尽量避免让操作机制依赖于全局状态。</li></ul><h4 id="4-6-Kubernetes-对象的组合"><a href="#4-6-Kubernetes-对象的组合" class="headerlink" title="4.6 Kubernetes 对象的组合"></a>4.6 Kubernetes 对象的组合</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235450125.png" class="" title="image-20250316235450125"><pre class="mermaid">graph LR    A[Deployment] --> B(滚动升级策略)    A --> C(副本数)    A --> D[PodTemplate]    D --> E[Replicaset]    E --> F(版本信息)    E --> G(副本数)    E --> H[PodTemplate]    H --> I[Node]    H --> J[Pod]    H --> K[Service]    H --> L[Ingress]    I --> M(计算资源)    I --> N(健康状况)    J --> O(镜像地址)    J --> P(资源需求)    K --> Q(服务协议)    K --> R(服务端口)    L --> S(域名)    L --> T(访问 URL)    L --> U(目标服务)</pre><h4 id="4-7-架构设计原则"><a href="#4-7-架构设计原则" class="headerlink" title="4.7 架构设计原则"></a>4.7 架构设计原则</h4><ul><li>只有 APIServer 可以直接访问 etcd 存储。</li><li>单节点故障不应该影响集群的状态。</li><li>所有组件应该在内存中保持所需要的状态。</li><li>优先使用事件监听而不是轮询。</li></ul><h4 id="4-8-引导（Bootstrapping）原则"><a href="#4-8-引导（Bootstrapping）原则" class="headerlink" title="4.8 引导（Bootstrapping）原则"></a>4.8 引导（Bootstrapping）原则</h4><ul><li>Self-hosting 是目标。</li><li>减少依赖。</li><li>通过分层的原则管理依赖。</li><li>循环依赖问题的原则：<ul><li>接受其他方式的数据输入。</li><li>状态应该是可恢复或可重新发现的。</li><li>支持简单的启动临时实例来创建稳态运行所需要的状态。</li><li>自动重启异常退出的服务。</li></ul></li></ul><h4 id="4-9-核心技术概念和-API-对象"><a href="#4-9-核心技术概念和-API-对象" class="headerlink" title="4.9 核心技术概念和 API 对象"></a>4.9 核心技术概念和 API 对象</h4><ul><li><strong>API 对象：</strong> Kubernetes 集群中的管理操作单元。</li><li><strong>四大类属性：</strong><ul><li><strong>TypeMeta：</strong> 对象的类型定义（GKV 模型）。<ul><li>Group：对象的分组。</li><li>Kind：对象的基本类型。</li><li>Version：对象的版本。</li></ul></li><li><strong>MetaData：</strong> 对象的元数据。<ul><li>Namespace：对象的命名空间。</li><li>Name：对象的名称。</li><li>Label：对象的标签，用于识别和选择对象。</li><li>Annotation：对象的注解，用于记录附加信息。</li><li>Finalizer：资源锁，用于控制对象的删除。</li><li>ResourceVersion：乐观锁，用于并发访问对象。</li></ul></li><li><strong>Spec：</strong> 用户的期望状态。</li><li><strong>Status：</strong> 对象的实际状态。</li></ul></li></ul><h4 id="4-10-常用-Kubernetes-对象及其分组"><a href="#4-10-常用-Kubernetes-对象及其分组" class="headerlink" title="4.10 常用 Kubernetes 对象及其分组"></a>4.10 常用 Kubernetes 对象及其分组</h4><ul><li><strong>Node：</strong> Pod 运行的主机。</li><li><strong>Namespace：</strong> 资源和对象的抽象集合。</li><li><strong>Pod：</strong> 一组紧密关联的容器集合，共享 PID、IPC、Network 和 UTS namespace。<ul><li><strong>环境变量：</strong> 设置容器的环境变量。</li><li><strong>存储卷：</strong> 将外挂存储挂载到 Pod 内部。</li><li><strong>Pod 网络：</strong> 多个容器共享网络 Namespace。</li><li><strong>资源限制：</strong> 限制每个容器的 CPU 和内存使用。</li><li><strong>健康检查：</strong> 探测应用是否健康和就绪。</li></ul></li><li><strong>ConfigMap：</strong> 保存非机密性的数据到键值对中。</li><li><strong>Secret：</strong> 保存和传递密码、密钥、认证凭证等敏感信息。</li><li><strong>User Account &amp; Service Account：</strong><ul><li>User Account：为人提供账户标识。</li><li>Service Account：为计算机进程和 Pod 提供账户标识。</li></ul></li><li><strong>Service：</strong> 应用服务的抽象，通过 labels 提供负载均衡和服务发现。</li><li><strong>Replica Set：</strong> 定义 Pod 的副本数，保证指定数量的 Pod 正常运行。</li><li><strong>Deployment：</strong> 表示用户对 Kubernetes 集群的一次更新操作。</li><li><strong>StatefulSet：</strong> 用于管理有状态应用，每个 Pod 挂载自己独立的存储。</li><li><strong>Job：</strong> 控制批处理型任务。</li><li><strong>DaemonSet：</strong> 保证每个节点上都有一个 Pod 运行。</li><li><strong>PersistentVolume (PV) &amp; PersistentVolumeClaim (PVC)：</strong><ul><li>PV：集群中的一块存储卷。</li><li>PVC：用户对存储的请求。</li></ul></li><li><strong>CustomResourceDefinition (CRD)：</strong> 允许用户自定义对象。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言进阶</title>
    <link href="/2025/03/16/golang%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/03/16/golang%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>这篇博客将深入探讨 Go 语言的一些核心概念，包括并发编程中的线程加锁和调度、内存管理机制，以及依赖管理。这些概念是构建高性能、可扩展的 Go 应用程序的基础。</p><span id="more"></span><h3 id="1-线程加锁"><a href="#1-线程加锁" class="headerlink" title="1. 线程加锁"></a>1. 线程加锁</h3><p>在并发编程中，多个 goroutine（Go 语言的轻量级线程）可能会同时访问和修改共享资源。为了防止数据竞争和不一致，我们需要使用锁机制来协调对共享资源的访问。</p><p><strong>Go 语言的锁机制</strong></p><p>Go 语言不仅提供了基于 CSP（Communicating Sequential Processes）的通道（channel）通信模型，还支持基于共享内存的多线程数据访问。<code>sync</code> 包提供了多种锁原语，以满足不同的并发场景需求：</p><ul><li><strong><code>sync.Mutex</code>（互斥锁）</strong>:<ul><li>最基本的锁类型，用于保护临界区，确保同一时间只有一个 goroutine 可以访问共享资源。</li><li>使用 <code>Lock()</code> 方法加锁，<code>Unlock()</code> 方法解锁。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    counter <span class="hljs-type">int</span><br>    mutex   sync.Mutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock() <span class="hljs-comment">// 加锁</span><br>    counter++<br>    mutex.Unlock() <span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.RWMutex</code>（读写锁）</strong>:<ul><li>适用于读多写少的场景。</li><li>允许多个 goroutine 同时读取共享资源，但在写入时会阻塞所有其他 goroutine（包括读取和写入）。</li><li>使用 <code>RLock()</code> 和 <code>RUnlock()</code> 方法进行读锁定，<code>Lock()</code> 和 <code>Unlock()</code> 方法进行写锁定。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    data    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    rwMutex sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readData</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    rwMutex.RLock() <span class="hljs-comment">// 读锁定</span><br>    <span class="hljs-keyword">defer</span> rwMutex.RUnlock()<br>    <span class="hljs-keyword">return</span> data[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeData</span><span class="hljs-params">(key, value <span class="hljs-type">string</span>)</span></span> &#123;<br>    rwMutex.Lock() <span class="hljs-comment">// 写锁定</span><br>    <span class="hljs-keyword">defer</span> rwMutex.Unlock()<br>    data[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.WaitGroup</code></strong>:<ul><li>用于等待一组 goroutine 完成。</li><li><code>Add(n)</code> 方法增加等待的 goroutine 数量，<code>Done()</code> 方法表示一个 goroutine 完成，<code>Wait()</code> 方法阻塞直到所有 goroutine 完成。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 表示当前 goroutine 完成</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d starting\n&quot;</span>, id)<br>    <span class="hljs-comment">// 执行任务...</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d done\n&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 增加等待的 goroutine 数量</span><br>        <span class="hljs-keyword">go</span> worker(i, &amp;wg)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 阻塞，直到所有 goroutine 完成</span><br>    fmt.Println(<span class="hljs-string">&quot;All workers done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.Once</code></strong>:<ul><li>确保某个函数只执行一次，常用于单例模式的初始化。</li><li><code>Do(f)</code> 方法接收一个函数 <code>f</code> 作为参数，并保证 <code>f</code> 只会被调用一次。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    once     sync.Once<br>    instance *MySingleton<br>)<br><br><span class="hljs-keyword">type</span> MySingleton <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *MySingleton &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 保证只执行一次</span><br>        instance = &amp;MySingleton&#123;&#125;<br>        <span class="hljs-comment">// 初始化 instance...</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.Cond</code>（条件变量）</strong>:<ul><li>用于协调多个 goroutine 在满足特定条件时等待或被唤醒。</li><li><code>Wait()</code> 方法阻塞当前 goroutine，直到其他 goroutine 调用 <code>Signal()</code> 或 <code>Broadcast()</code> 方法唤醒。</li><li><code>Signal()</code> 方法唤醒一个等待的 goroutine，<code>Broadcast()</code> 方法唤醒所有等待的 goroutine。</li><li>通常与互斥锁一起使用，以保护条件。</li><li>下面是 Kubernetes 中使用的 <code>sync.Cond</code> 示例：</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>cond sync.Cond<br><span class="hljs-comment">// ... 其他字段</span><br>&#125;<br><br><span class="hljs-comment">// Add marks item as needing processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span></span> Add(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>q.cond.L.Lock()<br><span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><span class="hljs-comment">// ... 添加 item 到队列的逻辑 ...</span><br>q.cond.Signal() <span class="hljs-comment">// 唤醒一个等待的 goroutine</span><br>&#125;<br><br><span class="hljs-comment">// Get blocks until it can return an item to be processed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span></span> Get() (item <span class="hljs-keyword">interface</span>&#123;&#125;, shutdown <span class="hljs-type">bool</span>) &#123;<br>q.cond.L.Lock()<br><span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.queue) == <span class="hljs-number">0</span> &amp;&amp; !q.shuttingDown &#123;<br>q.cond.Wait() <span class="hljs-comment">// 等待条件满足（队列中有元素）</span><br>&#125;<br><span class="hljs-comment">// ... 从队列中取出 item 的逻辑 ...</span><br><span class="hljs-keyword">return</span> item, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码示例：Kubernetes 中的锁应用</strong></p><ul><li><strong><code>sharedInformerFactory</code> 中的 <code>sync.Mutex</code></strong>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// Start initializes all requested informers.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    f.lock.Lock() <span class="hljs-comment">// 加锁</span><br>    <span class="hljs-keyword">defer</span> f.lock.Unlock() <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br>        <span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<br>            <span class="hljs-keyword">go</span> informer.Run(stopCh)<br>            f.startedInformers[informerType] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了 Kubernetes 的 <code>sharedInformerFactory</code> 如何使用互斥锁来保护 <code>informers</code> 和 <code>startedInformers</code> 字段，确保在启动 informer 时不会发生并发冲突。</p><ul><li><strong><code>PodClient</code> 中的 <code>sync.WaitGroup</code></strong>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// CreateBatch create a batch of pods. All pods are created before</span><br><span class="hljs-comment">// waiting.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;<br>    ps := <span class="hljs-built_in">make</span>([]*v1.Pod, <span class="hljs-built_in">len</span>(pods))<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 增加等待的 goroutine 数量</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, pod *v1.Pod)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 表示当前 goroutine 完成</span><br>            <span class="hljs-keyword">defer</span> GinkgoRecover()<br>            ps[i] = c.CreateSync(pod)<br>        &#125;(i, pod)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 阻塞，直到所有 goroutine 完成</span><br>    <span class="hljs-keyword">return</span> ps<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了 Kubernetes 的 <code>PodClient</code> 如何使用 <code>sync.WaitGroup</code> 来并发创建多个 Pod，并在所有 Pod 创建完成后返回结果。</p><h3 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a>2. 线程调度</h3><p>在操作系统层面，线程是调度的基本单位。理解线程调度对于理解 Go 语言的 goroutine 调度至关重要。</p><p><strong>进程与线程</strong></p><ul><li><strong>进程</strong>: 资源分配的基本单位。每个进程都有独立的内存空间、文件句柄、信号处理等。</li><li><strong>线程</strong>: 调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源（如内存空间），但有各自的栈和寄存器。</li></ul><p>在 Linux 中，无论是进程还是线程，都由 <code>task_struct</code> 结构体表示。从内核的角度来看，进程和线程没有本质区别。Glibc 提供的 <code>pthread</code> 库实现了 NPTL（Native POSIX Threading Library），为用户空间提供了线程支持。</p><p><strong>Linux 进程的内存模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235836393.png" class="" title="image-20250316235836393"><pre class="mermaid">graph LR    subgraph 虚拟地址空间        A[内核空间] --> B(参数环境变量)        B --> C[栈 Stack]        C --> D[未分配内存]        D --> E[堆 Heap]        E --> F[未初始化数据 BSS]        F --> G[已初始化数据 Data]        G --> H[程序代码 Text]    end      subgraph 物理内存        I[物理内存]    end    subgraph 磁盘        J[磁盘_虚拟内存]    end      H --> PGD    PGD --> PUD    PUD --> PMD    PMD --> PT    PT --> I    I -- 换出/换入 --> J      A -.->|用户空间不可见| I    style D fill:#f9f,stroke:#333,stroke-width:2px</pre><ul><li><strong>内核空间</strong>: 存放内核代码和数据，用户程序不能直接访问。</li><li><strong>栈 (Stack)</strong>: 存储局部变量、函数参数、返回值等。栈的大小是有限的，由操作系统或编译器决定。</li><li><strong>堆 (Heap)</strong>: 动态分配的内存区域，用于存储程序运行时创建的对象。</li><li><strong>BSS 段</strong>: 存储未初始化的全局变量和静态变量。</li><li><strong>数据段 (Data)</strong>: 存储已初始化的全局变量和静态变量。</li><li><strong>代码段 (Text)</strong>: 存储程序的机器指令。</li></ul><p><strong>CPU 对内存的访问</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235840260.png" class="" title="image-20250316235840260"><pre class="mermaid">graph LR    A[CPU] --> B(MMU)    B --> C{TLB}    C -- 命中 --> F[总线]    C -- 未命中 --> D[页表 PGD/PUD/PMD/PT]    D --> F    F --> E[物理内存]</pre><ol><li>CPU 发出虚拟地址。</li><li>MMU（Memory Management Unit）首先在 TLB（Translation Lookaside Buffer）中查找虚拟地址对应的物理地址。</li><li>如果 TLB 命中，则直接从 TLB 中获取物理地址。</li><li>如果 TLB 未命中，则 MMU 需要查询页表（PGD、PUD、PMD、PT）来获取物理地址，并将映射关系缓存到 TLB 中。</li><li>CPU 使用物理地址访问内存。</li></ol><p><strong>进程切换开销</strong></p><p>进程切换的开销主要包括：</p><ul><li><strong>直接开销</strong>:<ul><li>切换页表全局目录（PGD）。</li><li>切换内核态堆栈。</li><li>切换硬件上下文（寄存器等）。</li><li>刷新 TLB。</li><li>执行系统调度器的代码。</li></ul></li><li><strong>间接开销</strong>:<ul><li>CPU 缓存失效，导致访问内存的次数增加。</li></ul></li></ul><p><strong>线程切换开销</strong></p><p>线程切换比进程切换开销小，因为同一进程内的线程共享虚拟地址空间，不需要切换页表。但线程切换仍然需要内核参与，进行上下文切换。</p><p><strong>用户线程 vs. 内核线程</strong></p><ul><li><strong>用户线程</strong>: 在用户空间创建和管理，无需内核支持。创建和销毁速度快，但不能利用多核 CPU。</li><li><strong>内核线程</strong>: 由内核创建和管理，可以利用多核 CPU，但创建和销毁开销较大。</li></ul><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235844279.png" class="" title="image-20250316235844279"><pre class="mermaid">graph LR    subgraph 用户态        A[Process] --> B[User Thread]        A --> C[User Thread]        D[Process] --> E[User Thread]        D --> F[User Thread]        G[Process] --> H[User Thread]        G --> I[User Thread]    end    subgraph 内核态        B --> J[Kernel Thread]        C --> J        E --> K[Kernel Thread]        F --> K        H --> L[Kernel Thread]        I --> L    end    J --> M[CPU]    K --> M    L --> M</pre><p><strong>Goroutine</strong></p><p>Go 语言通过 GMP 模型实现了用户态线程（goroutine）：</p><ul><li><strong>G (Goroutine)</strong>: 代表一个 goroutine，拥有自己的栈空间、定时器等。初始栈大小为 2KB，可按需增长。</li><li><strong>M (Machine)</strong>: 代表内核线程，负责执行 goroutine。M 会保存 goroutine 的栈信息，以便在调度时恢复执行。</li><li><strong>P (Processor)</strong>: 代表逻辑处理器，负责调度 goroutine。P 维护一个本地 goroutine 队列，M 从 P 获取 goroutine 并执行。P 还负责部分内存管理。</li></ul><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235849700.png" class="" title="image-20250316235849700"><pre class="mermaid">graph LR    subgraph 全局资源        A(GRQ - 全局可运行G队列)        B(sudog - 阻塞队列)        C(gFree - 全局自由G列表)        D(pidle - 全局空闲P列表)    end    subgraph P的本地资源        E(LRQ - 本地可运行G队列)        F(gFree - 本地自由G列表)    end    A -- G --> E    B -- G --> M    C -- G --> C      D -- P --> D      E -- G --> M    F -- G --> F    M --> P    P --> CPU    G1(G - Grunnable) -- 状态 --> G2(G - Grunning)    G2 -- 状态 --> G3(G - Gwaiting)    G2 -- 状态 --> G4(G - Gsyscall)    G3 -- 状态 --> G1    G4 -- 状态 --> G1    G2 -- 状态 --> G5(G - Gdead)    G5 -- 状态 --> F    P1(P - Pidle) -- 状态 --> P2(P - Prunning)    P2 -- 状态 --> P3(P - Psyscall)    P3 -- 状态 --> P1</pre><p><strong>Goroutine 的创建过程</strong></p><ol><li>获取或创建新的 Goroutine 结构体：<ul><li>尝试从 P 的 <code>gFree</code> 列表中获取空闲的 Goroutine。</li><li>如果 <code>gFree</code> 列表为空，则通过 <code>runtime.malg</code> 创建一个新的 Goroutine 结构体。</li></ul></li><li>将函数参数复制到 Goroutine 的栈上。</li><li>更新 Goroutine 的调度信息，将其状态设置为 <code>_Grunnable</code>。</li><li>将 Goroutine 存储到全局变量 <code>allgs</code> 中。</li><li>将 Goroutine 放入运行队列：<ul><li>优先放入 P 的 <code>runnext</code> 字段，作为下一个要执行的 Goroutine。</li><li>如果 P 的本地运行队列已满，则将一部分 Goroutine 和待加入的 Goroutine 放入全局运行队列。</li></ul></li></ol><p><strong>调度器行为</strong></p><ol><li><strong>公平性</strong>: 如果全局运行队列中有待执行的 Goroutine，调度器会以一定概率从全局队列中选择 Goroutine 执行。</li><li><strong>本地队列</strong>: 调度器优先从 P 的本地运行队列中选择 Goroutine 执行。</li><li><strong>阻塞查找</strong>: 如果本地队列和全局队列都为空，调度器会通过 <code>runtime.findrunnable</code> 函数阻塞地查找可运行的 Goroutine：<ul><li>从本地队列、全局队列、网络轮询器中查找。</li><li>尝试从其他 P 的本地队列中窃取 Goroutine。</li></ul></li></ol><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><p>内存管理是程序设计中的关键问题。手动管理内存容易出错，而自动管理内存（垃圾回收）可能会影响性能。Go 语言采用了自动垃圾回收机制，并对内存管理进行了优化。</p><p><strong>堆内存管理</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235855215.png" class="" title="image-20250316235855215"><pre class="mermaid">graph LR    A{Mutator} --> B{Allocator}    B --> C{Heap}    C --> D{Object Header}    C --> E{Collector}    B --> E    style C fill:#ccf,stroke:#333,stroke-width:2px</pre><ul><li><strong>Mutator</strong>: 用户程序，通过 Allocator 申请内存。</li><li><strong>Allocator</strong>: 内存分配器，负责从堆中分配内存块。</li><li><strong>Heap</strong>: 堆，一块连续的内存区域，用于动态分配。</li><li><strong>Object Header</strong>: 对象头，存储对象的元数据（大小、是否被使用、下一个对象的地址等）。</li><li><strong>Collector</strong>: 垃圾回收器，负责回收不再使用的内存。</li></ul><p><strong>TCMalloc</strong></p><p>Go 语言的内存分配器借鉴了 TCMalloc（Thread-Caching Malloc）的思想。</p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235905932.png" class="" title="image-20250316235905932"><pre class="mermaid">graph LR    subgraph        A["Virtual Memory"]    end    subgraph "PageHeap"        B["PageHeap"] --> C["Span list 1 (1 page)"]        B --> D["Span list 2 (2 pages)"]        B --> E["... (3-127 pages)"]        B --> F["Span list 128 (128 pages = 1MB)"]        B --> G["Large span set (Large and medium object)"]    end      subgraph "CentralCache"      H["CentralCache"] --> I["Size class 0"]      H --> J["Size class 1"]      H --> K["..."]      H --> L["Size class n"]      I --> C      J --> D      L --> F    end    subgraph "ThreadCache"        M["ThreadCache 1"] --> N["Size class 0"]        M --> O["Size class 1"]        M --> P["..."]        M --> Q["Size class n"]        N --> FreeObject["(Free Object)"]    end      subgraph "ThreadCache"      R["ThreadCache 2"]    end    subgraph "ThreadCache"        S["ThreadCache n"]    end      M --> H    R --> H    S --> H    T["Application"] --> M    T --> R    T --> S</pre><ul><li><strong>page</strong>: 内存页，8KB 大小的内存块。Go 语言与操作系统之间的内存申请和释放都以 page 为单位。</li><li><strong>span</strong>: 内存块，由一个或多个连续的 page 组成。</li><li><strong>sizeclass</strong>: 空间规格，每个 span 都有一个 sizeclass，表示 span 中的 page 应该如何使用。</li><li><strong>object</strong>: 对象，用于存储变量数据的内存空间。一个 span 在初始化时会被分割成多个等大小的 object。</li></ul><p><strong>对象大小</strong></p><ul><li><strong>小对象</strong>: 0 ~ 256KB</li><li><strong>中对象</strong>: 256KB ~ 1MB</li><li><strong>大对象</strong>: &gt; 1MB</li></ul><p><strong>分配流程</strong></p><ul><li><strong>小对象</strong>: ThreadCache -&gt; CentralCache -&gt; HeapPage。通常情况下，ThreadCache 足够满足小对象的分配需求，无需访问 CentralCache 和 HeapPage。</li><li><strong>中对象</strong>: 直接从 PageHeap 中选择合适大小的 span。</li><li><strong>大对象</strong>: 从 large span set 中选择合适数量的 page 组成 span。</li></ul><p><strong>Go 语言内存分配</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235913087.png" class="" title="image-20250316235913087"><pre class="mermaid">graph LR    subgraph 虚拟内存        A[Virtual Memory]    end      subgraph arenas        B[arenas] --> C[heapArena]        B --> D[heapArena]        B --> E[...]        C --> F[span class 133]        C --> G[span class 134]        D --> H[span class 134]    end    subgraph mheap        I[mheap] --> J[free]        I --> K[scav]        I --> L[mcentral]        I --> B        L --> M[span class 0]        L --> N[span class 1]        L --> O[...]        M --> P[Span]        P --> Q[Pages]    end      subgraph mcache        R[mcache of P1] --> S[span class 0]        R --> T[span class 1]        R --> U[...]        S --> V[Free Object]    end    subgraph mcache        W[mcache of P2]    end    subgraph mcache        X[mcache of P3]    end      R --> L    W --> L    X --> L      Y[Application] --> R    Y --> W    Y --> X    Y --> LargeObject[(Large and medium object)]    Y --> TinyObject[(Tiny object)]    LargeObject --> B</pre><ul><li><strong><code>mcache</code></strong>: 小对象的内存分配直接从 <code>mcache</code> 获取。<code>mcache</code> 包含多个 size class（1 到 66），每个 class 有两个 span。span 大小为 8KB，根据 size class 的大小进行切分。</li><li><strong><code>mcentral</code></strong>: 当 <code>mcache</code> 中的 span 没有剩余空间时，会向 <code>mcentral</code> 申请一个 span。<code>mcentral</code> 如果没有符合条件的 span，则会向 <code>mheap</code> 申请。</li><li><strong><code>mheap</code></strong>: 当 <code>mheap</code> 没有足够的内存时，会向操作系统申请内存。<code>mheap</code> 将 span 组织成树结构，并分配到 <code>heapArena</code> 进行管理。<code>heapArena</code> 包含地址映射和 span 是否包含指针等位图信息。</li></ul><p><strong>内存回收</strong></p><p>常见的垃圾回收算法包括：</p><ul><li><strong>引用计数</strong>: 为每个对象维护一个引用计数，当引用计数为 0 时回收对象。<ul><li>优点：对象可以很快被回收。</li><li>缺点：无法处理循环引用，维护引用计数有开销。</li></ul></li><li><strong>标记-清除</strong>: 从根对象开始遍历所有可达对象，标记为“被引用”，未被标记的对象被回收。<ul><li>优点：可以处理循环引用。</li><li>缺点：需要 STW（Stop The World），暂停程序运行。</li></ul></li><li><strong>分代收集</strong>: 根据对象的生命周期将内存划分为不同的代，对不同代采用不同的回收频率。<ul><li>优点：提高回收效率。</li><li>缺点：实现复杂。</li></ul></li></ul><p>Go 语言采用<strong>标记-清除</strong>算法，并进行了优化。</p><p><strong><code>mspan</code></strong></p><ul><li><strong><code>allocBits</code></strong>: 记录了每块内存的分配情况。</li><li><strong><code>gcmarkBits</code></strong>: 记录了每块内存的引用情况。在标记阶段，有对象引用的内存块被标记为 1，没有的标记为 0。</li></ul><p>标记结束后，<code>allocBits</code> 指向 <code>gcmarkBits</code>，被标记的内存块保留，未标记的被回收。</p><p><strong>GC 工作流程</strong></p><p>Go 语言的 GC 大部分过程与用户代码并发执行。</p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235919958.png" class="" title="image-20250316235919958"><pre class="mermaid">graph LR    A[关闭 GC] --> B{栈扫描}    B -- 开启写屏障 --> C["STW (开启写屏障等准备工作)"]    C --> D["标记 (从全局空间和 goroutine 栈扫描变量)"]    D -- "三色标记，直到没有灰色对象" --> E["标记结束 (STW, 重新扫描 root 区域新变量)"]    E --> F["清除 (关闭 STW 和写屏障，清除白色对象)"]    F --> A</pre><ol><li><strong>Mark</strong>:<ul><li><strong>Mark Prepare</strong>: 初始化 GC 任务，开启写屏障（write barrier）和辅助 GC（mutator assist），统计 root 对象的数量。这个阶段需要 STW。</li><li><strong>GC Drains</strong>: 扫描所有 root 对象（全局指针和 goroutine 栈上的指针），将它们加入标记队列（灰色队列），并循环处理灰色队列中的对象，直到队列为空。这个阶段并发执行。</li><li><strong>Mark Termination</strong>: 完成标记工作，重新扫描全局指针和栈。由于 Mark 阶段与用户程序并发执行，可能会有新的对象分配和指针赋值，写屏障会记录这些变化，re-scan 阶段会再次检查。这个阶段需要 STW。</li></ul></li><li><strong>Sweep</strong>: 根据标记结果回收所有白色对象。这个阶段并发执行。</li><li><strong>Sweep Termination</strong>: 清扫未被清扫的 span。只有上一轮 GC 的清扫工作完成后，才能开始新一轮 GC。</li></ol><p><strong>三色标记</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235925383.png" class="" title="image-20250316235925383"><pre class="mermaid">graph LR    A["a"] --> B["b"]    A["a"] --> C["c"]    B["b"] --> D["d"]    subgraph "初始状态"        A1["a (白色)"] --> B1["b (白色)"]        A1["a (白色)"] --> C1["c (白色)"]        B1["b (白色)"] --> D1["d (白色)"]    end    subgraph "第一次遍历"        A2["a (灰色)"] --> B2["b (白色)"]        A2["a (灰色)"] --> C2["c (白色)"]        B2["b (白色)"] --> D2["d (白色)"]    end    subgraph "第二次遍历"        A3["a (黑色)"] --> B3["b (灰色)"]        A3["a (黑色)"] --> C3["c (灰色)"]        B3["b (灰色)"] --> D3["d (白色)"]    end    subgraph "第三次遍历"        A4["a (黑色)"] --> B4["b (黑色)"]        A4["a (黑色)"] --> C4["c (灰色)"]        B4["b (黑色)"] --> D4["d (白色)"]    end      subgraph "第四次遍历"        A5["a (黑色)"] --> B5["b (黑色)"]        A5["a (黑色)"] --> C5["c (黑色)"]        B5["b (黑色)"] --> D5["d (灰色)"]    end        subgraph "第五次遍历"        A6["a (黑色)"] --> B6["b (黑色)"]        A6["a (黑色)"] --> C6["c (黑色)"]        B6["b (黑色)"] --> D6["d (黑色)"]    end</pre><ol><li>GC 开始时，所有对象都被认为是白色（垃圾）。</li><li>从 root 对象开始遍历，可达对象被标记为灰色。</li><li>遍历所有灰色对象，将它们引用的对象标记为灰色，自身标记为黑色。</li><li>重复第 3 步，直到没有灰色对象，只剩下黑色和白色对象。白色对象即为垃圾。</li><li>对于黑色对象，如果在标记期间发生了写操作，写屏障会在赋值前将新对象标记为灰色。</li><li>标记过程中新分配的对象会被直接标记为黑色。</li></ol><p><strong>垃圾回收触发机制</strong></p><ul><li><strong>内存分配量达到阈值</strong>:<ul><li>每次内存分配时都会检查当前内存分配量是否达到阈值。</li><li>阈值 &#x3D; 上次 GC 内存分配量 * 内存增长率。</li><li>内存增长率由环境变量 <code>GOGC</code> 控制，默认为 100（即内存扩大一倍时触发 GC）。</li></ul></li><li><strong>定期触发</strong>: 默认情况下，每 2 分钟触发一次 GC。</li><li><strong>手动触发</strong>: 使用 <code>runtime.GC()</code> 函数手动触发 GC。</li></ul><h3 id="4-包引用与依赖管理"><a href="#4-包引用与依赖管理" class="headerlink" title="4. 包引用与依赖管理"></a>4. 包引用与依赖管理</h3><p>Go 语言的依赖管理经历了从 GOPATH 到 vendor，再到 Go Modules 的演变过程。</p><p><strong>GOPATH</strong></p><ul><li>通过环境变量 <code>GOPATH</code> 设置 Go 语言类库的目录。</li><li>问题：<ul><li>不同项目可能依赖同一库的不同版本。</li><li>代码被克隆后需要设置 <code>GOPATH</code> 才能编译。</li></ul></li></ul><p><strong>vendor</strong></p><ul><li>Go 1.6 版本引入了 <code>vendor</code> 目录。</li><li>每个项目创建一个 <code>vendor</code> 目录，并将依赖复制到该目录。</li><li>Go 语言项目会自动将 <code>vendor</code> 目录作为依赖路径。</li><li>优点：<ul><li>每个项目的 <code>vendor</code> 目录独立，可以灵活选择版本。</li><li><code>vendor</code> 目录与源代码一起提交，其他人克隆后可以直接编译。</li><li>编译期间无需下载依赖。</li></ul></li></ul><p><strong>vendor 管理工具</strong></p><ul><li>Godeps, Glide</li><li>Go 官方的依赖管理工具 Gopkg</li><li>Go Modules (gomod)</li></ul><p><strong>Go Modules (gomod)</strong></p><ul><li>通过 <code>go mod</code> 命令开启：<code>export GO111MODULE=on/off/auto</code></li><li>更灵活易用，基本统一了 Go 语言的依赖管理。</li></ul><p><strong>Go Modules 的目的</strong></p><ul><li>版本管理</li><li>防止篡改</li></ul><p><strong>Go Modules 使用</strong></p><ol><li>创建项目。</li><li>初始化 Go 模块：<code>go mod init</code></li><li>下载依赖包：<code>go mod download</code>（依赖包下载到 <code>$GOPATH/pkg</code>，如果没有设置 <code>GOPATH</code>，则下载到项目根目录下的 <code>pkg</code> 目录）。</li><li>在代码中使用依赖包，例如 <code>github.com/emicklei/go-restful</code>。</li><li>添加缺少的依赖并清理：<code>go mod tidy</code></li><li>将依赖复制到 <code>vendor</code> 目录：<code>go mod vendor</code></li></ol><p><strong><code>go.mod</code> 文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">module k8s.io/apiserver<br><br>go 1.13<br><br>require (<br>github.com/evanphx/json-patch v4.9.0+incompatible<br>github.com/go-openapi/jsonreference v0.19.3 // indirect<br>github.com/go-openapi/spec v0.19.3<br>github.com/gogo/protobuf v1.3.2<br>github.com/google/go-cmp v0.3.0<br>github.com/google/gofuzz v1.1.0<br>k8s.io/apimachinery v0.0.0-20210518100737-44f1264f7b6b<br>)<br><br>replace (<br>golang.org/x/crypto =&gt; golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975<br>golang.org/x/text =&gt; golang.org/x/text v0.3.2<br>k8s.io/api =&gt; k8s.io/api v0.0.0-20210518101910-53468e23a787<br>k8s.io/apimachinery =&gt; k8s.io/apimachinery v0.0.0-20210518100737-44f1264f7b6b<br>k8s.io/client-go =&gt; k8s.io/client-go v0.0.0-20210518104342-fa3acefe68f3<br>k8s.io/component-base =&gt; k8s.io/component-base v0.0.0-20210518111421-67c12a31a26a<br>)<br></code></pre></td></tr></table></figure><ul><li><code>module</code>: 定义模块的导入路径。</li><li><code>go</code>: 指定 Go 语言版本。</li><li><code>require</code>: 指定依赖包及其版本。</li><li><code>replace</code>: 替换依赖包。</li></ul><p><strong><code>GOPROXY</code> 和 <code>GOPRIVATE</code></strong></p><ul><li><strong><code>GOPROXY</code></strong>: 设置 Go 依赖的代理。<ul><li><code>export GOPROXY=https://goproxy.cn</code></li><li>设置 <code>GOPROXY</code> 后，默认所有依赖都会通过代理拉取，并进行 checksum 校验。</li></ul></li><li><strong><code>GOPRIVATE</code></strong>: 声明私有代码仓库，避免通过 <code>GOPROXY</code> 拉取。<ul><li><code>GOPRIVATE=*.corp.example.com</code></li><li><code>GONOPROXY=myrepo.corp.example.com</code></li><li><code>GOPROXY=proxy.example.com</code></li></ul></li></ul><h3 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5. Makefile"></a>5. Makefile</h3><p>Go 语言项目通常使用 Makefile 来组织编译过程。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ROOT=github.com/cncamp/golang<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: root</span><br><span class="hljs-section">root:</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: release</span><br><span class="hljs-section">release:</span><br>@echo <span class="hljs-string">&quot;building httpserver binary&quot;</span><br>@mkdir -p bin/amd64<br>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/amd64 .<br></code></pre></td></tr></table></figure><ul><li><code>.PHONY</code>: 声明伪目标。</li><li><code>release</code>: 定义构建目标，设置环境变量 <code>CGO_ENABLED</code>、<code>GOOS</code> 和 <code>GOARCH</code>，然后使用 <code>go build</code> 编译程序。</li></ul><h3 id="6-编写-HTTP-Server"><a href="#6-编写-HTTP-Server" class="headerlink" title="6. 编写 HTTP Server"></a>6. 编写 HTTP Server</h3><p><strong>理解 <code>net/http</code> 包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">healthz</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>io.WriteString(w, <span class="hljs-string">&quot;ok\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/healthz&quot;</span>, healthz) <span class="hljs-comment">// 注册处理函数</span><br>err := http.ListenAndServe(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 监听端口，使用默认的 DefaultServeMux</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>http.HandleFunc</code>: 注册处理函数，将 URL 路径与处理函数关联起来。</li><li><code>http.ListenAndServe</code>: 启动 HTTP 服务器，监听指定端口。第二个参数为 <code>nil</code> 时，使用默认的 <code>DefaultServeMux</code>。</li><li><code>healthz</code>: 处理函数，接收 <code>http.ResponseWriter</code> 和 <code>http.Request</code> 作为参数。</li></ul><p><strong>阻塞 IO 模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235937032.png" class="" title="image-20250316235937032"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    Note over 应用进程,系统内核: 进程阻塞于 recvfrom 调用    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据    Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>非阻塞 IO 模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235942132.png" class="" title="image-20250316235942132"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    系统内核-->>应用进程: 返回错误    Note over 应用进程: 进程重复调用 recvfrom    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    系统内核-->>应用进程: 返回错误    Note over 应用进程: ...    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据     Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>IO 多路复用</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235948370.png" class="" title="image-20250316235948370"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: select/poll (系统调用)    Note over 系统内核: 数据报文尚未就绪    Note over 应用进程,系统内核: 进程阻塞于 select/poll 调用，等待有可读的 socket    系统内核-->>应用进程: 返回可读    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据    Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>异步 IO</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235953003.png" class="" title="image-20250316235953003"><pre><code class="language-mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程-&gt;&gt;系统内核: 异步 IO 读 (系统调用)    Note over 系统内核: 数据报文尚未就绪  </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言基础与实践</title>
    <link href="/2025/03/16/golang/"/>
    <url>/2025/03/16/golang/</url>
    
    <content type="html"><![CDATA[<p>Golang 基本使用。</p><span id="more"></span><h3 id="一、统一思想：12-因素应用宣言"><a href="#一、统一思想：12-因素应用宣言" class="headerlink" title="一、统一思想：12 因素应用宣言"></a>一、统一思想：12 因素应用宣言</h3><p>在深入学习 Go 语言之前，我们先来了解一下构建云原生应用的指导原则——12 因素应用宣言（The Twelve-Factor App）。这套方法论由 Heroku 平台的开发者总结，旨在帮助开发者构建可扩展、可维护、易部署的云原生应用。</p><ol><li><p><strong>基准代码 (Codebase)</strong>：一份基准代码，多份部署。使用版本控制系统（如 Git）管理代码，确保不同环境（开发、测试、生产）使用同一份代码的不同版本。</p></li><li><p><strong>依赖 (Dependencies)</strong>：显式声明依赖关系。使用依赖管理工具（如 Go Modules）管理项目依赖，确保依赖的明确性和可重复性。</p></li><li><p><strong>配置 (Config)</strong>：在环境中存储配置。将配置信息（如数据库连接、API 密钥）存储在环境变量中，而不是硬编码在代码中，提高应用的可移植性和安全性。</p></li><li><p><strong>后端服务 (Backing Services)</strong>：把后端服务当作附加资源。将数据库、消息队列、缓存等后端服务视为可插拔的资源，通过 URL 或配置信息进行连接，方便应用的迁移和扩展。</p></li><li><p><strong>构建，发布，运行 (Build, Release, Run)</strong>：严格分离构建和运行。将应用构建、发布和运行三个阶段分离，确保每个阶段的独立性和可重复性。</p></li><li><p><strong>进程 (Processes)</strong>：以一个或多个无状态进程运行应用。将应用设计为无状态进程，方便水平扩展和故障恢复。</p></li><li><p><strong>端口绑定 (Port Binding)</strong>：通过端口绑定提供服务。应用通过绑定端口对外提供服务，不依赖于特定的 Web 服务器或容器。</p></li><li><p><strong>并发 (Concurrency)</strong>：通过进程模型进行扩展。利用进程或线程模型实现应用的并发，提高应用的吞吐量和响应速度。</p></li><li><p><strong>易处理 (Disposability)</strong>：快速启动和优雅终止可最大化健壮性。应用应能够快速启动和优雅终止，方便部署、重启和故障恢复。</p></li><li><p><strong>开发环境与线上环境等价 (Dev&#x2F;Prod Parity)</strong>：尽可能地保持开发、预发布、线上环境相同。使用相同的操作系统、依赖和配置，减少环境差异导致的问题。</p></li><li><p><strong>日志 (Logs)</strong>：把日志当作事件流。将应用的日志输出到标准输出（stdout），由外部系统（如日志收集器）进行处理和分析。</p></li><li><p><strong>管理进程 (Admin Processes)</strong>：后台管理任务当作一次性进程运行。将后台管理任务（如数据库迁移、数据备份）作为一次性进程运行，与应用的主进程分离。</p></li></ol><p><strong>面试知识点：</strong></p><ul><li>什么是 12 因素应用宣言？它的核心原则是什么？</li><li>为什么要在环境中存储配置？这样做有什么好处？</li><li>如何理解应用的无状态性？无状态应用有什么优势？</li></ul><h3 id="二、Go-语言的诞生与设计哲学"><a href="#二、Go-语言的诞生与设计哲学" class="headerlink" title="二、Go 语言的诞生与设计哲学"></a>二、Go 语言的诞生与设计哲学</h3><h4 id="1-为什么需要-Go-语言？"><a href="#1-为什么需要-Go-语言？" class="headerlink" title="1. 为什么需要 Go 语言？"></a>1. 为什么需要 Go 语言？</h4><p>在 Go 语言出现之前，开发者面临着一些挑战：</p><ul><li><strong>硬件发展与软件瓶颈</strong>：硬件性能不断提升，但软件开发效率却没有同步提升。</li><li><strong>现有语言的不足</strong>：<ul><li>C&#x2F;C++ 等原生语言缺乏好的依赖管理，编译速度慢。</li><li>Java&#x2F;C# 等语言过于庞大，启动速度慢，内存占用高。</li><li>现有语言对并发编程的支持不够友好，难以充分利用多核处理器。</li></ul></li></ul><p>Go 语言的出现，正是为了解决这些问题。</p><h4 id="2-Go-语言的设计哲学"><a href="#2-Go-语言的设计哲学" class="headerlink" title="2. Go 语言的设计哲学"></a>2. Go 语言的设计哲学</h4><p>Go 语言的设计哲学可以用以下几个关键词概括：</p><ul><li><strong>Less is exponentially more</strong>（少即是多）：Go 语言追求简洁，避免过度设计，减少不必要的复杂性。</li><li><strong>Do Less, Enable More</strong>（做更少，成更多）：Go 语言提供了一套精简但强大的工具集，让开发者能够更高效地完成工作。</li><li><strong>面向工程</strong>：Go 语言的设计目标是解决实际工程问题，而不是追求学术上的完美。</li><li><strong>正交性</strong>：Go 语言的特性之间相互独立，组合起来却能发挥强大的威力。</li></ul><h4 id="3-Go-语言的主要特性"><a href="#3-Go-语言的主要特性" class="headerlink" title="3. Go 语言的主要特性"></a>3. Go 语言的主要特性</h4><ul><li><strong>编译型语言</strong>：Go 语言是一种编译型语言，可以将代码编译成机器码，执行效率高。</li><li><strong>静态类型</strong>：Go 语言是一种静态类型语言，在编译时进行类型检查，可以减少运行时错误。</li><li><strong>垃圾回收</strong>：Go 语言内置垃圾回收机制，开发者无需手动管理内存，降低了开发难度。</li><li><strong>并发编程</strong>：Go 语言通过 goroutine 和 channel 提供了强大的并发编程支持，可以轻松编写高并发程序。</li><li><strong>简洁的语法</strong>：Go 语言的语法简洁明了，易于学习和使用。</li><li><strong>丰富的标准库</strong>：Go 语言提供了丰富的标准库，涵盖了网络编程、系统编程、数据处理等多个领域。</li></ul><h4 id="4-Go-语言不支持的特性"><a href="#4-Go-语言不支持的特性" class="headerlink" title="4. Go 语言不支持的特性"></a>4. Go 语言不支持的特性</h4><p>为了保持语言的简洁性和一致性，Go 语言有意不支持一些常见的特性：</p><ul><li><strong>函数重载和操作符重载</strong>：避免代码的歧义和复杂性。</li><li><strong>隐式类型转换</strong>：减少潜在的错误和不确定性。</li><li><strong>继承</strong>：Go 语言使用组合来实现代码复用，而不是继承。</li><li><strong>异常处理</strong>：Go 语言使用显式的错误处理机制（error），而不是异常。</li><li><strong>断言</strong>：Go 语言鼓励开发者编写更健壮的代码，而不是依赖断言来捕获错误。</li><li><strong>静态变量</strong>：Go 语言不支持静态变量，避免全局状态带来的问题。</li></ul><p><strong>面试知识点：</strong></p><ul><li>Go 语言的设计目标是什么？它解决了哪些问题？</li><li>Go 语言有哪些主要的特性？这些特性有什么优势？</li><li>为什么 Go 语言不支持某些常见的特性（如继承、异常）？</li></ul><h3 id="三、Go-语言环境搭建与基础"><a href="#三、Go-语言环境搭建与基础" class="headerlink" title="三、Go 语言环境搭建与基础"></a>三、Go 语言环境搭建与基础</h3><h4 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1. 下载与安装"></a>1. 下载与安装</h4><ul><li>访问 Go 语言官网（<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a>）下载对应平台的安装包。</li><li>按照官方文档的指引进行安装。</li></ul><h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h4><ul><li><strong>GOROOT</strong>：Go 语言的安装目录。</li><li><strong>GOPATH</strong>：Go 语言的工作目录，用于存放项目代码、依赖包和可执行文件。<ul><li><code>src</code>：存放项目源代码。</li><li><code>pkg</code>：存放编译后的包文件。</li><li><code>bin</code>：存放可执行文件。</li></ul></li><li><strong>GOOS</strong>：目标操作系统（如 linux、windows、darwin）。</li><li><strong>GOARCH</strong>：目标处理器架构（如 amd64、arm64）。</li><li><strong>GOPROXY</strong>：Go 模块代理，用于加速依赖包的下载。国内用户建议设置为 <code>https://goproxy.cn</code>。</li></ul><h4 id="3-IDE-设置"><a href="#3-IDE-设置" class="headerlink" title="3. IDE 设置"></a>3. IDE 设置</h4><ul><li>推荐使用 VS Code，并安装 Go 插件。</li><li>其他可选的 IDE 包括：<ul><li>Goland（JetBrains 出品，收费）</li><li>Vim、Sublime Text 等（需要配置相关插件）</li></ul></li></ul><h4 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h4><ul><li><code>go build</code>：编译 Go 程序。<ul><li><code>-o</code>：指定输出文件名。</li><li><code>GOOS</code> 和 <code>GOARCH</code> 环境变量可以用于交叉编译。</li></ul></li><li><code>go run</code>：编译并运行 Go 程序。</li><li><code>go test</code>：运行测试。<ul><li><code>./...</code>：运行当前目录及子目录下的所有测试。</li><li><code>-v</code>：显示详细的测试输出。</li></ul></li><li><code>go vet</code>：静态代码检查，发现潜在的错误。</li><li><code>go fmt</code>：格式化 Go 代码。</li><li><code>go get</code>：下载并安装依赖包。</li><li><code>go mod</code>：Go 模块管理工具。</li><li><code>go doc</code>：查看文档。</li><li><code>go env</code>：查看 Go 环境变量。</li></ul><h4 id="5-代码版本控制"><a href="#5-代码版本控制" class="headerlink" title="5. 代码版本控制"></a>5. 代码版本控制</h4><ul><li>推荐使用 Git 进行代码版本控制。</li><li>将代码托管到 GitHub、GitLab 等平台。</li></ul><h4 id="6-Golang-Playground"><a href="#6-Golang-Playground" class="headerlink" title="6. Golang Playground"></a>6. Golang Playground</h4><ul><li>官方 Playground：<a href="https://play.golang.org/">https://play.golang.org/</a></li><li>国内可访问的 Playground：<a href="https://goplay.tools/">https://goplay.tools/</a></li></ul><p><strong>面试知识点：</strong></p><ul><li><code>go build</code> 和 <code>go run</code> 有什么区别？</li><li><code>go vet</code> 可以检查出哪些类型的错误？</li><li>如何使用 Go Modules 管理项目依赖？</li><li>如何进行交叉编译？</li></ul><h3 id="四、Go-语言控制结构"><a href="#四、Go-语言控制结构" class="headerlink" title="四、Go 语言控制结构"></a>四、Go 语言控制结构</h3><h4 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition1 &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2 &#123;<br>    <span class="hljs-comment">// do something else</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// catch-all or default</span><br>&#125;<br><br><span class="hljs-comment">// 简短语句</span><br><span class="hljs-keyword">if</span> v := x - <span class="hljs-number">100</span>; v &lt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-switch-语句"><a href="#2-switch-语句" class="headerlink" title="2. switch 语句"></a>2. switch 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br><span class="hljs-keyword">case</span> val1:<br>    <span class="hljs-comment">// 空分支</span><br><span class="hljs-keyword">case</span> val2:<br>    <span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">// 执行 case3 中的代码</span><br><span class="hljs-keyword">case</span> val3:<br>    f()<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计数器循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>    sum += sum<br>&#125;<br><br><span class="hljs-comment">// 无限循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// for-range 循环</span><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> myArray &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>Go 语言中如何实现类似于 while 循环的功能？</li><li>for-range 循环遍历不同类型的数据时，有哪些需要注意的地方？</li></ul><h3 id="五、Go-语言常用数据结构"><a href="#五、Go-语言常用数据结构" class="headerlink" title="五、Go 语言常用数据结构"></a>五、Go 语言常用数据结构</h3><h4 id="1-变量与常量"><a href="#1-变量与常量" class="headerlink" title="1. 变量与常量"></a>1. 变量与常量</h4><ul><li><strong>常量</strong>：使用 <code>const</code> 关键字定义。</li><li><strong>变量</strong>：使用 <code>var</code> 关键字定义。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Go&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-变量定义与初始化"><a href="#2-变量定义与初始化" class="headerlink" title="2. 变量定义与初始化"></a>2. 变量定义与初始化</h4><ul><li><strong>变量声明</strong>：<code>var identifier type</code></li><li><strong>变量初始化</strong>：<code>var i, j int = 1, 2</code></li><li><strong>短变量声明</strong>：<code>c, python, java := true, false, &quot;no!&quot;</code> （只能在函数内部使用）</li></ul><h4 id="3-类型转换与推导"><a href="#3-类型转换与推导" class="headerlink" title="3. 类型转换与推导"></a>3. 类型转换与推导</h4><ul><li><strong>类型转换</strong>：<code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</li><li><strong>类型推导</strong>：在声明变量时不指定类型，Go 编译器会根据右值的类型自动推导。</li></ul><h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h4><ul><li><strong>定义</strong>：<code>var identifier [len]type</code></li><li><strong>特点</strong>：相同类型、长度固定、连续内存。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myArray := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-切片-slice"><a href="#5-切片-slice" class="headerlink" title="5. 切片 (slice)"></a>5. 切片 (slice)</h4><ul><li><strong>定义</strong>：<code>var identifier []type</code></li><li><strong>特点</strong>：对数组的引用、动态长度、连续内存。</li><li><strong>常用方法</strong>：<ul><li><code>append</code>：追加元素。</li><li><code>make</code>：创建切片。</li><li>切片操作：<code>myArray[1:3]</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>mySlice = <span class="hljs-built_in">append</span>(mySlice, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="6-make-和-new"><a href="#6-make-和-new" class="headerlink" title="6. make 和 new"></a>6. make 和 new</h4><ul><li><strong>new</strong>：返回指针地址。</li><li><strong>make</strong>：返回第一个元素，可预设内存空间。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice1 := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// 返回 *[]int</span><br>mySlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 返回 []int，长度为 0</span><br>mySlice3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 返回 []int，长度为 10，容量为 20</span><br></code></pre></td></tr></table></figure><h4 id="7-Map"><a href="#7-Map" class="headerlink" title="7. Map"></a>7. Map</h4><ul><li><strong>声明</strong>：<code>var map1 map[keytype]valuetype</code></li><li><strong>特点</strong>：键值对、无序。</li><li><strong>常用方法</strong>：<ul><li><code>make</code>：创建 Map。</li><li><code>delete</code>：删除键值对。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="8-访问-Map-元素"><a href="#8-访问-Map-元素" class="headerlink" title="8. 访问 Map 元素"></a>8. 访问 Map 元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按 Key 取值</span><br>value, exists := myMap[<span class="hljs-string">&quot;a&quot;</span>]<br><span class="hljs-keyword">if</span> exists &#123;<br>    <span class="hljs-built_in">println</span>(value)<br>&#125;<br><br><span class="hljs-comment">// 遍历 Map</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-built_in">println</span>(k, v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-结构体和指针"><a href="#9-结构体和指针" class="headerlink" title="9. 结构体和指针"></a>9. 结构体和指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMyType</span><span class="hljs-params">(t *MyType)</span></span> &#123;<br><span class="hljs-built_in">println</span>(t.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>printMyType(&amp;t) <span class="hljs-comment">// 传入指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>type … struct</code> 关键字自定义结构体</li><li>Go 语言支持指针，但不支持指针运算</li><li>指针变量的值为内存地址</li><li>未赋值的指针为 <code>nil</code></li></ul><h4 id="10-结构体标签"><a href="#10-结构体标签" class="headerlink" title="10. 结构体标签"></a>10. 结构体标签</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mt := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>myType := reflect.TypeOf(mt)<br>name := myType.Field(<span class="hljs-number">0</span>)<br>tag := name.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br><span class="hljs-built_in">println</span>(tag)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li><li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag</li><li><code>NodeName string  json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li></ul><h4 id="11-类型别名"><a href="#11-类型别名" class="headerlink" title="11. 类型别名"></a>11. 类型别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Service Type string describes ingress methods for a service</span><br><span class="hljs-keyword">type</span> ServiceType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span><br><span class="hljs-comment">// cluster, via the ClusterIP.</span><br>ServiceTypeClusterIP ServiceType = <span class="hljs-string">&quot;ClusterIP&quot;</span><br><br><span class="hljs-comment">// ServiceTypeNodePort means a service will be exposed on one port of</span><br><span class="hljs-comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span><br>ServiceTypeNodePort ServiceType = <span class="hljs-string">&quot;NodePort&quot;</span><br><br><span class="hljs-comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span><br><span class="hljs-comment">// external load balancer (if the cloud provider supports it), in addition</span><br><span class="hljs-comment">// to &#x27;NodePort&#x27; type.</span><br>ServiceTypeLoadBalancer ServiceType = <span class="hljs-string">&quot;LoadBalancer&quot;</span><br><br><span class="hljs-comment">// ServiceTypeExternalName means a service consists of only a reference to</span><br><span class="hljs-comment">// an external name that kubedns or equivalent will return as a CNAME</span><br><span class="hljs-comment">// record, with no exposing or proxying of any pods involved.</span><br>ServiceTypeExternalName ServiceType = <span class="hljs-string">&quot;ExternalName&quot;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>数组和切片有什么区别？</li><li><code>make</code> 和 <code>new</code> 有什么区别？</li><li>如何判断一个 Map 中是否存在某个键？</li><li>结构体标签有什么作用？</li></ul><h3 id="课后练习-1-1"><a href="#课后练习-1-1" class="headerlink" title="课后练习 1.1"></a>课后练习 1.1</h3><ul><li>安装 Go</li><li>安装 IDE 并安装 Go 语言插件</li><li>编写一个小程序</li></ul><p>给定一个字符串数组<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;stupid&quot;,&quot;and&quot;,&quot;weak&quot;]</code><br>用 <code>for</code> 循环遍历该数组并修改为<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;smart&quot;,&quot;and&quot;,&quot;strong&quot;]</code></p><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;am&quot;</span>, <span class="hljs-string">&quot;stupid&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;weak&quot;</span>&#125;<br>replacements := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;stupid&quot;</span>: <span class="hljs-string">&quot;smart&quot;</span>,<br><span class="hljs-string">&quot;weak&quot;</span>:   <span class="hljs-string">&quot;strong&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> words &#123;<br><span class="hljs-keyword">if</span> replacement, ok := replacements[word]; ok &#123;<br>words[i] = replacement<br>&#125;<br>&#125;<br><br>fmt.Println(words) <span class="hljs-comment">// 输出 [&quot;I&quot;, &quot;am&quot;, &quot;smart&quot;, &quot;and&quot;, &quot;strong&quot;]</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六、Go-语言函数"><a href="#六、Go-语言函数" class="headerlink" title="六、Go 语言函数"></a>六、Go 语言函数</h3><h4 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main 函数"></a>1. main 函数</h4><ul><li>每个 Go 程序都应该有一个 <code>main</code> 包。</li><li><code>main</code> 包里的 <code>main</code> 函数是程序的入口。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-参数解析"><a href="#2-参数解析" class="headerlink" title="2. 参数解析"></a>2. 参数解析</h4><ul><li><code>main</code> 函数没有参数，不同于其他语言的<code>[]string args</code>。</li><li>可以使用 <code>os.Args</code> 获取命令行参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>args := os.Args<br>fmt.Println(<span class="hljs-string">&quot;Arguments:&quot;</span>, args)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>flag</code> 包解析命令行参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name := flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;specify the name you want to say hi&quot;</span>)<br>flag.Parse()<br>fmt.Println(<span class="hljs-string">&quot;Hello,&quot;</span>, *name)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-init-函数"><a href="#3-init-函数" class="headerlink" title="3. init 函数"></a>3. init 函数</h4><ul><li><code>init</code> 函数会在包初始化时自动执行。</li><li>谨慎使用 <code>init</code> 函数，避免循环依赖和不可重复运行的问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> myVariable = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>myVariable = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>多值返回</strong>：函数可以返回多个值。</li><li><strong>命名返回值</strong>：可以给返回值命名，并在函数体中直接使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(sum <span class="hljs-type">int</span>)</span></span> (x, y <span class="hljs-type">int</span>) &#123;<br>    x = sum * <span class="hljs-number">4</span> / <span class="hljs-number">9</span><br>    y = sum - x<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 裸返回，返回已命名的 x 和 y</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-调用者忽略部分返回值"><a href="#5-调用者忽略部分返回值" class="headerlink" title="5. 调用者忽略部分返回值"></a>5. 调用者忽略部分返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result, _ = strconv.Atoi(origStr) <span class="hljs-comment">// 忽略错误返回值</span><br></code></pre></td></tr></table></figure><h4 id="6-传递变长参数"><a href="#6-传递变长参数" class="headerlink" title="6. 传递变长参数"></a>6. 传递变长参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []Type, elems ...Type)</span></span> []Type <span class="hljs-comment">// 接收任意多个 Type 类型的参数</span><br></code></pre></td></tr></table></figure><h4 id="7-内置函数"><a href="#7-内置函数" class="headerlink" title="7. 内置函数"></a>7. 内置函数</h4><table><thead><tr><th align="left">函数名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>close</code></td><td align="left">管道关闭</td></tr><tr><td align="left"><code>len</code>, <code>cap</code></td><td align="left">返回数组、切片、Map 的长度或容量</td></tr><tr><td align="left"><code>new</code>, <code>make</code></td><td align="left">内存分配</td></tr><tr><td align="left"><code>copy</code>, <code>append</code></td><td align="left">操作切片</td></tr><tr><td align="left"><code>panic</code>, <code>recover</code></td><td align="left">错误处理</td></tr><tr><td align="left"><code>print</code>, <code>println</code></td><td align="left">打印</td></tr><tr><td align="left"><code>complex</code>, <code>real</code>, <code>imag</code></td><td align="left">操作复数</td></tr></tbody></table><h4 id="8-回调函数-Callback"><a href="#8-回调函数-Callback" class="headerlink" title="8. 回调函数 (Callback)"></a>8. 回调函数 (Callback)</h4><ul><li>将函数作为参数传递给其他函数，并在其他函数内部调用执行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doOperation</span><span class="hljs-params">(y <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>) &#123;<br>    f(y, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increase</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;increase result is:&quot;</span>, a+b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    doOperation(<span class="hljs-number">1</span>, increase)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9. 闭包"></a>9. 闭包</h4><ul><li>匿名函数，可以访问其外部作用域的变量。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        sum += x<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pos, neg := adder(), adder()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<br>            pos(i),<br>            neg(<span class="hljs-number">-2</span>*i),<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-方法"><a href="#10-方法" class="headerlink" title="10. 方法"></a>10. 方法</h4><ul><li>作用在接收者上的函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-传值还是传指针"><a href="#11-传值还是传指针" class="headerlink" title="11. 传值还是传指针"></a>11. 传值还是传指针</h4><ul><li>Go 语言只有一种规则-传值</li><li>函数内修改参数的值不会影响函数外原始变量的值</li><li>可以传递指针参数将变量地址传递给调用函数，Go 语言会<br>复制该指针作为函数内的地址，但指向同一地址</li><li>思考：当我们写代码的时候，函数的参数传递应该用<code>struct</code><br>还是<code>pointer</code>？<ul><li>如果需要修改参数的值，或者参数较大，传递指针更高效。</li><li>如果不需要修改参数的值，且参数较小，传递值更安全。</li></ul></li></ul><h4 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h4><ul><li>接口定义一组方法集合。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>    Abs() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(-f)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a Abser<br>    f := MyFloat(-math.Sqrt2)<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>    a = f  <span class="hljs-comment">// MyFloat 实现了 Abser</span><br>    a = &amp;v <span class="hljs-comment">// *Vertex 实现了 Abser</span><br><br>    <span class="hljs-comment">// a = v // 错误：Vertex 没有实现 Abser（Abs 方法的接收者是 *Vertex）</span><br><br>    fmt.Println(a.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-注意事项"><a href="#13-注意事项" class="headerlink" title="13. 注意事项"></a>13. 注意事项</h4><ul><li><code>Interface</code> 是可能为 <code>nil</code> 的，所以针对 <code>interface</code> 的使用一定要预先判空，否则会引起程序 <code>crash(nil panic)</code></li><li><code>Struct</code> 初始化意味着空间分配，对 <code>struct</code> 的引用不会出现空指针</li></ul><h4 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14. 反射机制"></a>14. 反射机制</h4><ul><li><code>reflect.TypeOf()</code> 返回被检查对象的类型</li><li><code>reflect.ValueOf()</code> 返回被检查对象的值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br>t := reflect.TypeOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, t)<br>v := reflect.ValueOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, v)<br></code></pre></td></tr></table></figure><h4 id="15-基于-struct-的反射"><a href="#15-基于-struct-的反射" class="headerlink" title="15. 基于 struct 的反射"></a>15. 基于 struct 的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// struct</span><br>myStruct := T&#123;A: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>v1 := reflect.ValueOf(myStruct)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumField(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumMethod(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))<br>&#125;<br><br><span class="hljs-comment">// 需要注意receive是struct还是指针</span><br>result := v1.Method(<span class="hljs-number">0</span>).Call(<span class="hljs-literal">nil</span>)<br>fmt.Println(<span class="hljs-string">&quot;result:&quot;</span>, result)<br></code></pre></td></tr></table></figure><h4 id="16-Go-语言中的面向对象编程"><a href="#16-Go-语言中的面向对象编程" class="headerlink" title="16. Go 语言中的面向对象编程"></a>16. Go 语言中的面向对象编程</h4><ul><li>可见性控制<ul><li><code>public</code>-常量、变量、类型、接口、结构、函数等的名称大写</li><li><code>private</code> -非大写就只能在包内使用</li></ul></li><li>继承<ul><li>通过组合实现，内嵌一个或多个<code>struct</code></li></ul></li><li>多态<ul><li>通过接口实现，通过接口定义方法集，编写多套实现</li></ul></li></ul><h4 id="17-Json-编解码"><a href="#17-Json-编解码" class="headerlink" title="17. Json 编解码"></a>17. Json 编解码</h4><ul><li><code>Unmarshal</code>: 从 <code>string</code> 转换至 <code>struct</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unmarshal2Struct</span><span class="hljs-params">(humanStr <span class="hljs-type">string</span>)</span></span> Human &#123;<br>h := Human&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;h)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">println</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Marshal</code>: 从 <code>struct</code> 转换至 <code>string</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">marshal2JsonString</span><span class="hljs-params">(h Human)</span></span> <span class="hljs-type">string</span> &#123;<br>h.Age = <span class="hljs-number">30</span><br>updatedBytes, err := json.Marshal(&amp;h)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">println</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(updatedBytes)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>json</code> 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 类型保存任意对象</li><li>可通过如下逻辑解析任意 <code>json</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> obj <span class="hljs-keyword">interface</span>&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;obj)<br>objMap, ok := obj.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> objMap &#123;<br><span class="hljs-keyword">switch</span> value := v.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>Go 语言中如何实现函数的重载？</li><li>什么是闭包？闭包有什么作用？</li><li>Go 语言中的方法和普通函数有什么区别？</li><li>Go 语言中如何实现接口？接口和抽象类有什么区别？</li><li>什么是反射？反射有什么作用？</li><li>如何使用 <code>encoding/json</code> 包进行 JSON 编解码？</li></ul><h3 id="六、常用语法"><a href="#六、常用语法" class="headerlink" title="六、常用语法"></a>六、常用语法</h3><h4 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1. 错误处理"></a>1. 错误处理</h4><p>Go 语言无内置 <code>exceptio</code> 机制，只提供 <code>error</code> 接口供定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可通过 <code>errors.New</code> 或 <code>fmt.Errorf</code> 创建新的 <code>error</code></li><li><code>var errNotFound error = errors.New(&quot;NotFound&quot;)</code></li><li>通常应用程序对 <code>error</code> 的处理大部分是判断 <code>error</code> 是否为 <code>nil</code><br>如需将 <code>error</code> 归类，通常交给应用程序自定义，比如 <code>kubernetes</code> 自定义了与 <code>apiserver</code> 交互的不同类型错误</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StatusError <span class="hljs-keyword">struct</span> &#123;<br>ErrStatus metav1.Status<br>&#125;<br><br><span class="hljs-keyword">var</span> _ <span class="hljs-type">error</span> = &amp;StatusError&#123;&#125;<br><br><span class="hljs-comment">// Error implements the Error interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StatusError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.ErrStatus.Message<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-defer"><a href="#2-defer" class="headerlink" title="2. defer"></a>2. defer</h4><ul><li>函数返回之前执行某个语句或函数</li><li>等同于Java 和C# 的finally</li><li>常见的 <code>defer</code> 使用场景：记得关闭你打开的资源<ul><li><code>defer file.Close()</code></li><li><code>defer mu.Unlock()</code></li><li><code>defer println(&quot;&quot;)</code></li></ul></li></ul><h4 id="3-Panic-和-recover"><a href="#3-Panic-和-recover" class="headerlink" title="3. Panic 和 recover"></a>3. Panic 和 recover</h4><ul><li><code>panic</code>: 可在系统出现不可恢复错误时主动调用 <code>panic</code>, <code>panic</code> 会使当前线程直接 <code>crash</code></li><li><code>defer</code>: 保证执行并把控制权交还给接收到 <code>panic</code> 的函数调用者</li><li><code>recover</code>: 函数从 <code>panic</code> 或 错误场景中恢复</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer func is called&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;a panic is triggered&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七. 多线程"></a>七. 多线程</h3><h4 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h4><ul><li>并发（concurrency）<ul><li>两个或多个事件在同一时间间隔发生</li></ul></li><li>并行（parallellism）<ul><li>两个或者多个事件在同一时刻发生</li></ul></li></ul><h4 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h4><ul><li>进程：<ul><li>分配系统资源（CPU 时间、内存等）基本单位</li><li>有独立的内存空间，切换开销大</li></ul></li><li>线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位<ul><li>同一进程中的多线程共享内存空间，线程切换代价小</li><li>多线程通信方便</li><li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li></ul></li><li>协程<ul><li>Go语言中的轻量级线程实现</li><li>Golang 在<code>runtime</code>、系统调用等多方面对<code>goroutine</code> 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前<code>goroutine</code> 的<code>CPU (P)</code> 转让出去，让其他<code>goroutine</code> 能被调度<br>并执行，也就是<code>Golang</code> 从语言层面支持了协程</li></ul></li></ul><h4 id="3-Communicating-Sequential-Process"><a href="#3-Communicating-Sequential-Process" class="headerlink" title="3. Communicating Sequential Process"></a>3. Communicating Sequential Process</h4><ul><li>CSP<ul><li>描述两个独立的并发实体通过共享的通讯<code>channel</code>进行通信的并发模型。</li></ul></li><li>Go 协程 <code>goroutine</code><ul><li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度。</li><li>是一种绿色线程，微线程，它与<code>Coroutine</code>协程也有区别，能够在发现堵塞后启动新的微线程。</li></ul></li><li>通道 <code>channel</code><ul><li>类似<code>Unix</code>的<code>Pipe</code>，用于协程之间通讯和同步。</li><li>协程之间虽然解耦，但是它们和<code>Channel</code>有着耦合。</li></ul></li></ul><h4 id="4-线程和协程的差异"><a href="#4-线程和协程的差异" class="headerlink" title="4. 线程和协程的差异"></a>4. 线程和协程的差异</h4><ul><li>每个 <code>goroutine</code> (协程) 默认占用内存远比 <code>Java</code> 、<code>C</code> 的线程少<ul><li><code>goroutine</code>：<code>2KB</code></li><li>线程：<code>8MB</code></li></ul></li><li>线程&#x2F;<code>goroutine</code> 切换开销方面，<code>goroutine</code> 远比线程小<ul><li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、<code>PC</code>、<code>SP</code>…等寄存器的刷新</li><li><code>goroutine</code>：只有三个寄存器的值修改-<code>PC</code> &#x2F; <code>SP</code> &#x2F; <code>DX</code>.</li></ul></li><li>GOMAXPROCS<ul><li>控制并行线程数量</li></ul></li></ul><h4 id="5-协程示例"><a href="#5-协程示例" class="headerlink" title="5. 协程示例"></a>5. 协程示例</h4><ul><li>启动新协程：<code>go functionName()</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> fmt.Println(i)<br>&#125;<br>time.Sleep(time.Second)<br></code></pre></td></tr></table></figure><h4 id="6-channel-多线程通信"><a href="#6-channel-多线程通信" class="headerlink" title="6. channel - 多线程通信"></a>6. channel - 多线程通信</h4><ul><li><code>Channel</code> 是多个协程之间通讯的管道</li><li>一端发送数据，一端接收数据</li><li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li><li>协调协程的执行顺序</li><li>声明方式<ul><li><code>var identifier chan datatype</code></li></ul></li><li>操作符<code>&lt;-</code></li><li>示例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello from goroutine&quot;</span>)<br>ch &lt;- <span class="hljs-number">0</span> <span class="hljs-comment">//数据写入Channel</span><br>&#125;()<br>i := &lt;-ch <span class="hljs-comment">//从Channel中取数据并赋值</span><br></code></pre></td></tr></table></figure><h4 id="7-通道缓冲"><a href="#7-通道缓冲" class="headerlink" title="7. 通道缓冲"></a>7. 通道缓冲</h4><ul><li>基于 <code>Channel</code> 的通信是同步的</li><li>当缓冲区满时，数据的发送是阻塞的</li><li>通过 <code>make</code> 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li><li>下面两个定义的区别？<ul><li><code>ch:= make(chan int)</code></li><li><code>ch:= make(chan int,1)</code></li></ul></li></ul><h4 id="8-遍历通道缓冲区"><a href="#8-遍历通道缓冲区" class="headerlink" title="8. 遍历通道缓冲区"></a>8. 遍历通道缓冲区</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>rand.Seed(time.Now().UnixNano())<br>n := rand.Intn(<span class="hljs-number">10</span>) <span class="hljs-comment">// n will be between 0 and 10</span><br>fmt.Println(<span class="hljs-string">&quot;putting: &quot;</span>, n)<br>ch &lt;- n<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;hello from main&quot;</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(<span class="hljs-string">&quot;receiving: &quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-单向通道"><a href="#9-单向通道" class="headerlink" title="9. 单向通道"></a>9. 单向通道</h4><ul><li>只发送通道<ul><li><code>var sendOnly chan&lt;- int</code></li></ul></li><li>只接收通道<ul><li><code>var readOnly &lt;-chan int</code></li></ul></li><li><code>Istio webhook controller</code><ul><li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li></ul></li><li>如何用: 双向通道转换</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> prod(c)<br><span class="hljs-keyword">go</span> consume(c)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prod</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>ch &lt;- <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>&lt;-ch<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-关闭通道"><a href="#10-关闭通道" class="headerlink" title="10. 关闭通道"></a>10. 关闭通道</h4><ul><li>通道无需每次关闭</li><li>关闭的作用是告诉接收者该通道再无新数据发送</li><li>只有发送方需要关闭通道</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br><span class="hljs-keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;<br>fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-select"><a href="#11-select" class="headerlink" title="11. select"></a>11. select</h4><ul><li>当多个协程同时运行时，可通过 <code>select</code> 轮询多个通道</li><li>如果所有通道都阻塞则等待，如定义了 <code>default</code> 则执行 <code>default</code></li><li>如多个通道就绪则随机选择</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-ch1:<br>...<br><span class="hljs-keyword">case</span> v := &lt;-ch2:<br>...<br><span class="hljs-keyword">default</span>:<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-定时器-Timer"><a href="#12-定时器-Timer" class="headerlink" title="12. 定时器 Timer"></a>12. 定时器 Timer</h4><ul><li><code>time.Ticker</code> 以指定的时间间隔重复的向通道 <code>C</code> 发送时间值</li><li>使用场景<ul><li>为协程设定超时时间</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">timer := time.NewTimer(time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// check normal channel</span><br><span class="hljs-keyword">case</span> &lt;-ch:<br>fmt.Println(<span class="hljs-string">&quot;received from ch&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br>fmt.Println(<span class="hljs-string">&quot;timeout waiting from channel ch&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-上下文-Context"><a href="#13-上下文-Context" class="headerlink" title="13. 上下文 Context"></a>13. 上下文 Context</h4><ul><li>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</li><li><code>Context</code> 是设置截止日期、同步信号，传递请求相关值的结构体</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用法<ul><li><code>context.Background</code></li><li><code>context.TODO</code></li><li><code>context.WithDeadline</code></li><li><code>context.WithValue</code></li><li><code>context.WithCancel</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如何停止一个子协程</span><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-done:<br>            fmt.Println(<span class="hljs-string">&quot;done channel is triggerred, exit child go routine&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(done)<br><br><span class="hljs-comment">// 基于 Context 停止子协程</span><br><span class="hljs-comment">// Context 是 Go 语言对 go routine 和 timer 的封装</span><br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">go</span> process(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br>&lt;-ctx.Done()<br>fmt.Println(<span class="hljs-string">&quot;main:&quot;</span>, ctx.Err())<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ctx context.Context, duration time.Duration)</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(duration):<br>        fmt.Println(<span class="hljs-string">&quot;process successfully&quot;</span>)<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        fmt.Println(<span class="hljs-string">&quot;process cancelled&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>context</code> 包, 可以取消 <code>goroutine</code> 的执行, 或者给 <code>goroutine</code> 设置 Deadline, 超时后 <code>goroutine</code> 会退出。</li></ul><p><strong>面试知识点:</strong></p><ul><li>Go 语言中如何实现并发编程？</li><li><code>goroutine</code> 和线程有什么区别？</li><li><code>channel</code> 的作用是什么？如何使用 <code>channel</code> 进行协程间通信？</li><li>如何实现一个有缓冲的 <code>channel</code>？</li><li>如何使用 <code>select</code> 语句处理多个 <code>channel</code>？</li><li>如何使用 <code>context</code> 包取消 <code>goroutine</code> 的执行？</li></ul><h3 id="课后练习-1-2"><a href="#课后练习-1-2" class="headerlink" title="课后练习 1.2"></a>课后练习 1.2</h3><ul><li>基于 <code>Channel</code> 编写一个简单的单线程生产者消费者模型<ul><li>队列：<br>队列长度 10，队列元素类型为 <code>int</code></li><li>生产者：<br>每 1 秒往队列中放入一个类型为 <code>int</code> 的元素，队列满时生产者可以阻塞</li><li>消费者：<br>每一秒从队列中获取一个元素并打印，队列为空时消费者阻塞</li></ul></li></ul><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>ch &lt;- i<br>fmt.Println(<span class="hljs-string">&quot;Produced:&quot;</span>, i)<br>i++<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>i := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;Consumed:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 缓冲大小为 10 的 channel</span><br><br><span class="hljs-keyword">go</span> producer(ch)<br><span class="hljs-keyword">go</span> consumer(ch)<br><br><span class="hljs-keyword">select</span> &#123;&#125; <span class="hljs-comment">// 阻塞主 goroutine，防止程序退出</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八、Go-Modules"><a href="#八、Go-Modules" class="headerlink" title="八、Go Modules"></a>八、Go Modules</h3><h4 id="1-为什么需要-Go-Modules"><a href="#1-为什么需要-Go-Modules" class="headerlink" title="1. 为什么需要 Go Modules"></a>1. 为什么需要 Go Modules</h4><p>在 Go 1.11 版本之前，Go 语言的依赖管理一直是一个痛点。<code>GOPATH</code> 模式存在以下问题：</p><ul><li><strong>项目必须放在 <code>$GOPATH/src</code> 目录下</strong>：限制了项目存放的位置，不够灵活。</li><li><strong>没有版本控制</strong>：无法指定项目依赖的特定版本，容易出现版本冲突。</li><li><strong>无法处理 vendor 依赖</strong>：无法将依赖包复制到项目内部，不利于项目的独立性和可移植性。</li></ul><p>Go Modules 的出现，解决了这些问题，成为了 Go 语言官方推荐的依赖管理方式。</p><h4 id="2-Go-Modules-的主要特性"><a href="#2-Go-Modules-的主要特性" class="headerlink" title="2. Go Modules 的主要特性"></a>2. Go Modules 的主要特性</h4><ul><li><strong>项目可以放在任何位置</strong>：不再受限于 <code>$GOPATH/src</code> 目录。</li><li><strong>版本控制</strong>：可以指定项目依赖的特定版本，解决了版本冲突问题。</li><li><strong>vendor 支持</strong>：可以将依赖包复制到项目内部的 <code>vendor</code> 目录，提高了项目的独立性和可移植性。</li><li><strong>模块代理</strong>：可以通过设置 <code>GOPROXY</code> 环境变量，使用模块代理加速依赖包的下载。</li></ul><h4 id="3-Go-Modules-的基本使用"><a href="#3-Go-Modules-的基本使用" class="headerlink" title="3. Go Modules 的基本使用"></a>3. Go Modules 的基本使用</h4><ul><li><strong>初始化模块</strong>：在项目根目录下执行 <code>go mod init &lt;module_name&gt;</code>，创建 <code>go.mod</code> 文件。</li><li><strong>添加依赖</strong>：执行 <code>go get &lt;package_name&gt;@&lt;version&gt;</code>，会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li><li><strong>构建项目</strong>：执行 <code>go build</code>，会自动下载并构建依赖。</li><li><strong>运行项目</strong>：执行 <code>go run</code>，会自动下载、构建并运行项目。</li><li><strong>整理依赖</strong>：执行 <code>go mod tidy</code>，会移除未使用的依赖，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li><li><strong>vendor 依赖</strong>：执行 <code>go mod vendor</code>，会将依赖包复制到项目内部的 <code>vendor</code> 目录。</li></ul><p><strong>面试知识点：</strong></p><ul><li>Go Modules 解决了 <code>GOPATH</code> 模式的哪些问题？</li><li><code>go.mod</code> 和 <code>go.sum</code> 文件有什么作用？</li><li>如何使用 Go Modules 添加、更新和删除依赖？</li><li>如何使用 vendor 依赖？</li></ul><h3 id="九、Go-语言与云原生"><a href="#九、Go-语言与云原生" class="headerlink" title="九、Go 语言与云原生"></a>九、Go 语言与云原生</h3><p>Go 语言的特性使其非常适合云原生应用开发：</p><ul><li><strong>高效的编译和执行速度</strong>：Go 语言的编译速度快，生成的二进制文件小，启动速度快，非常适合云原生环境下的快速部署和弹性伸缩。</li><li><strong>强大的并发编程支持</strong>：Go 语言的 goroutine 和 channel 机制，可以轻松编写高并发程序，充分利用多核处理器，提高应用的吞吐量和响应速度。</li><li><strong>简洁的语法和丰富的标准库</strong>：Go 语言的语法简洁易学，标准库功能丰富，可以减少开发者的工作量，提高开发效率。</li><li><strong>跨平台编译</strong>：Go 语言支持交叉编译，可以方便地为不同的操作系统和处理器架构构建应用。</li><li><strong>容器友好</strong>：Go 语言生成的二进制文件不依赖于外部库，非常适合打包成 Docker 镜像，方便部署和管理。</li></ul><p>Go 语言已经成为云原生领域的主流语言，许多知名的云原生项目都是用 Go 语言开发的，例如：</p><ul><li><strong>Docker</strong>：容器引擎。</li><li><strong>Kubernetes</strong>：容器编排平台。</li><li><strong>Istio</strong>：服务网格。</li><li><strong>Etcd</strong>：分布式键值存储。</li><li><strong>Prometheus</strong>：监控系统。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker核心技术</title>
    <link href="/2025/03/16/docker/"/>
    <url>/2025/03/16/docker/</url>
    
    <content type="html"><![CDATA[<p>Cgroups,Namespace,Union FS</p> <span id="more"></span><h3 id="1-从系统架构谈起：传统分层架构-vs-微服务"><a href="#1-从系统架构谈起：传统分层架构-vs-微服务" class="headerlink" title="1. 从系统架构谈起：传统分层架构 vs 微服务"></a>1. 从系统架构谈起：传统分层架构 vs 微服务</h3><p>在深入 Docker 之前，我们先来聊聊系统架构的演变。</p><h4 id="传统分层架构"><a href="#传统分层架构" class="headerlink" title="传统分层架构"></a>传统分层架构</h4><p>传统的单体应用通常采用分层架构，如下图所示：</p><img src="/2025/03/16/docker/image-20250316235507888.png" class="" title="image-20250316235507888"><pre class="mermaid">graph LR    A[Presentation Layer] --> B(Business Logic Layer)    B --> C(Data Access Layer)    C --> D{Database}</pre><p><strong>优点：</strong></p><ul><li>对于简单的系统，易于部署、测试和横向扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>对于复杂的系统：<ul><li>难以理解整体</li><li>不易快速维护</li><li>启动和部署慢</li><li>变更引起的回归问题多</li><li>难以持续集成和持续部署</li></ul></li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>为了解决传统分层架构的痛点，微服务架构应运而生。它将一个庞大的系统分解成多个独立的小服务，每个服务负责特定的业务功能。</p><img src="/2025/03/16/docker/image-20250316235512635.png" class="" title="image-20250316235512635"><pre class="mermaid">graph LR    subgraph Microservices        A[Service 1] -->|API| B(API Gateway)        C[Service 2] -->|API| B        D[Service 3] -->|API| B    end    B --> E{External Services}</pre><p><strong>优点：</strong></p><ul><li>系统部署更快，更易理解和维护。</li><li>不同服务可由不同团队维护，分工更细。</li><li>可自主选择技术栈。</li><li>易于持续集成和持续部署。</li><li>每个微服务独立扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂性（分布式部署）。</li><li>需要处理分布式系统的复杂问题（如进程间通信、部分失败）。</li><li>分布式事务更复杂（失败回滚）。</li><li>测试和部署监控更复杂。</li></ul><h4 id="微服务改造"><a href="#微服务改造" class="headerlink" title="微服务改造"></a>微服务改造</h4><p>将单体应用拆分成微服务，可以遵循以下原则：</p><ul><li><strong>分离业务逻辑：</strong> 审视并发现可以分离的业务逻辑。</li><li><strong>寻找隔离模块：</strong> 寻找天生隔离的代码模块（可借助静态代码分析工具）。</li><li><strong>考虑性能需求：</strong> 不同并发规模、不同内存需求的模块可分离成不同的微服务。</li></ul><p>一些常用的可微服务化的组件：</p><ul><li>用户和账户管理</li><li>授权和会话管理</li><li>系统配置</li><li>通知和通讯服务</li><li>照片、多媒体、元数据等</li></ul><p><strong>分解原则：</strong> 基于 size, scope and capabilities</p><h4 id="微服务间通讯"><a href="#微服务间通讯" class="headerlink" title="微服务间通讯"></a>微服务间通讯</h4><p>微服务之间通常有两种通讯方式：</p><ol><li><p><strong>点对点：</strong></p><ul><li>多用于系统内部组件间通讯。</li><li>存在大量重复模块（如认证授权）。</li><li>缺少统一规范（如监控、审计）。</li><li>后期维护成本高。</li></ul></li><li><p><strong>API 网关：</strong></p><ul><li>基于一个轻量级的 message gateway。</li><li>新 API 通过注册至 Gateway 实现。</li><li>整合实现 Common function。</li></ul></li></ol><h3 id="2-理解-Docker"><a href="#2-理解-Docker" class="headerlink" title="2. 理解 Docker"></a>2. 理解 Docker</h3><p>Docker 是一种容器化技术，可以将应用程序及其依赖项打包到一个可移植的容器中，从而实现快速部署、一致的运行环境和高效的资源利用。</p><h4 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h4><ul><li>Docker 基于 Linux 内核的 Cgroup、Namespace 以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li><li>Docker 容器独立于宿主机和其他容器。</li><li>Docker 在容器的基础上进行了进一步的封装，简化了容器的创建和维护。</li></ul><h4 id="为什么要用-Docker？"><a href="#为什么要用-Docker？" class="headerlink" title="为什么要用 Docker？"></a>为什么要用 Docker？</h4><ul><li><strong>更高效地利用系统资源：</strong> 容器共享宿主机内核，资源开销更小。</li><li><strong>更快速的启动时间：</strong> 容器启动只需几秒钟，远快于虚拟机。</li><li><strong>一致的运行环境：</strong> 容器打包了应用程序及其依赖项，保证在不同环境中的一致性。</li><li><strong>持续交付和部署：</strong> 容器易于构建、测试和部署，方便实现持续交付。</li><li><strong>更轻松地迁移：</strong> 容器可轻松迁移到不同的平台和环境。</li><li><strong>更轻松地维护和扩展：</strong> 容器易于管理和扩展，可根据需求动态调整资源。</li></ul><h4 id="虚拟机和容器运行态的对比"><a href="#虚拟机和容器运行态的对比" class="headerlink" title="虚拟机和容器运行态的对比"></a>虚拟机和容器运行态的对比</h4><img src="/2025/03/16/docker/image-20250316235519406.png" class="" title="image-20250316235519406"><pre class="mermaid">graph LR    subgraph 虚拟机        A[虚拟机 1] --> B(Hypervisor)        C[虚拟机 2] --> B        D[虚拟机 3] --> B        B --> E(Host OS)        E --> F{Hardware}    end    subgraph 容器        G[容器 1] --> H(Docker Engine)        I[容器 2] --> H        J[容器 3] --> H        H --> K(Host OS)        K --> L{Hardware}    end</pre><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机上千个容器</td><td>一般几十个</td></tr></tbody></table><h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><p>在 Ubuntu 上安装 Docker 的步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 更新 apt 包索引</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 2. 安装依赖包</span><br><span class="hljs-built_in">sudo</span> apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg-agent \<br>    software-properties-common<br><br><span class="hljs-comment"># 3. 添加 Docker 的官方 GPG 密钥</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> apt-key add -<br><br><span class="hljs-comment"># 4. 设置稳定版仓库</span><br><span class="hljs-built_in">sudo</span> add-apt-repository \<br>   <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">   <span class="hljs-subst">$(lsb_release -cs)</span> \</span><br><span class="hljs-string">   stable&quot;</span><br><br><span class="hljs-comment"># 5. 再次更新 apt 包索引</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 6. 安装 Docker Engine</span><br><span class="hljs-built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul><li><strong>启动容器：</strong><ul><li><code>docker run</code>：创建并启动一个新的容器。<ul><li><code>-it</code>：交互式运行。</li><li><code>-d</code>：后台运行。</li><li><code>-p</code>：端口映射。</li><li><code>-v</code>：磁盘挂载。</li></ul></li><li><code>docker start</code>：启动已终止的容器。</li></ul></li><li><strong>停止容器：</strong><ul><li><code>docker stop</code>：停止正在运行的容器。</li></ul></li><li><strong>查看容器进程：</strong><ul><li><code>docker ps</code>：列出正在运行的容器。</li><li><code>docker ps -a</code>：列出所有容器（包括已停止的）。</li></ul></li><li><strong>查看容器细节</strong></li></ul><pre><code class="hljs">* `docker inspect &lt;containerid&gt;`</code></pre><ul><li><strong>进入容器</strong><ul><li><code>docker attach</code></li><li><code>nsenter</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PID=$(docker inspect --format <span class="hljs-string">&quot;&#123;&#123; .State.Pid &#125;&#125;&quot;</span><br>&lt;container&gt;)<br>$ nsenter --target <span class="hljs-variable">$PID</span> --mount --uts --ipc --net --pid<br></code></pre></td></tr></table></figure></li><li><strong>拷贝文件至容器内</strong><ul><li><code>docker cp file1 &lt;containerid&gt;:/file-to-path</code></li></ul></li></ul><h4 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h4><p>让我们通过一个简单的例子来体验 Docker 的魅力。</p><ol><li><p><strong>编写 Dockerfile：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">ENV</span> MY_SERVICE_PORT=<span class="hljs-number">80</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> bin/amd64/httpserver /httpserver</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> /httpserver</span><br></code></pre></td></tr></table></figure><ul><li><code>FROM</code>：指定基础镜像（这里使用 Ubuntu）。</li><li><code>ENV</code>：设置环境变量。</li><li><code>ADD</code>：将本地文件复制到容器中。</li><li><code>ENTRYPOINT</code>：指定容器启动时执行的命令。</li></ul></li><li><p><strong>构建镜像：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t cncamp/httpserver:<span class="hljs-variable">$&#123;tag&#125;</span> .<br>docker push cncamp/httpserver:v1.0<br></code></pre></td></tr></table></figure><ul><li><code>-t</code>：指定镜像的名称和标签。</li><li><code>.</code>：表示 Dockerfile 所在的当前目录。</li></ul></li><li><p><strong>运行容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d cncamp/httpserver:v1.0<br></code></pre></td></tr></table></figure></li></ol><h4 id="容器标准"><a href="#容器标准" class="headerlink" title="容器标准"></a>容器标准</h4><p>为了规范容器技术的发展，业界制定了 OCI（Open Container Initiative）标准。</p><ul><li><strong>OCI 是什么？</strong><ul><li>一个轻量级开放式管理组织。</li><li>主要定义两个规范：<ul><li><strong>Runtime Specification：</strong> 定义如何解压文件系统包并在运行时运行。</li><li><strong>Image Specification：</strong> 定义如何打包镜像、生成清单、文件系统序列化文件和镜像配置。</li></ul></li></ul></li></ul><h4 id="容器主要特性"><a href="#容器主要特性" class="headerlink" title="容器主要特性"></a>容器主要特性</h4><ul><li><strong>安全性：</strong> 容器提供了隔离的运行环境，增强了安全性。</li><li><strong>便携性：</strong> 容器可在不同平台和环境中轻松迁移。</li><li><strong>隔离性：</strong> 容器之间相互隔离，互不影响。</li><li><strong>可配额：</strong> 可对容器的资源使用进行限制。</li></ul><h3 id="3-Docker-核心技术：Namespace、Cgroups、UnionFS"><a href="#3-Docker-核心技术：Namespace、Cgroups、UnionFS" class="headerlink" title="3. Docker 核心技术：Namespace、Cgroups、UnionFS"></a>3. Docker 核心技术：Namespace、Cgroups、UnionFS</h3><p>Docker 的核心技术主要包括 Namespace、Cgroups 和 UnionFS。</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>Namespace 是 Linux 内核提供的一种资源隔离方案。它可以为进程分配不同的 Namespace，保证不同 Namespace 下的资源独立分配，进程彼此隔离。</p><ul><li><p><strong>Linux 内核代码中 Namespace 的实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进程数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-comment">/* namespaces */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> *<span class="hljs-title">nsproxy</span>;</span><br>    ...<br>&#125;<br><br><span class="hljs-comment">// Namespace 数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> &#123;</span><br>    <span class="hljs-type">atomic_t</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uts_namespace</span> *<span class="hljs-title">uts_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ipc_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mnt_namespace</span> *<span class="hljs-title">mnt_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns_for_children</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net_ns</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Linux 对 Namespace 操作方法：</strong></p><ul><li><code>clone</code>：创建新进程时，可通过 <code>flags</code> 参数指定需要新建的 Namespace 类型。</li><li><code>setns</code>：将调用进程加入某个已存在的 Namespace。</li><li><code>unshare</code>：将调用进程移动到新的 Namespace。</li></ul></li><li><p><strong>Namespace 类型：</strong></p><table><thead><tr><th>Namespace 类型</th><th>隔离资源</th><th>Kernel 版本</th></tr></thead><tbody><tr><td>IPC</td><td>System V IPC 和 POSIX 消息队列</td><td>2.6.19</td></tr><tr><td>Network</td><td>网络设备、网络协议栈、网络端口等</td><td>2.6.29</td></tr><tr><td>PID</td><td>进程</td><td>2.6.14</td></tr><tr><td>Mount</td><td>挂载点</td><td>2.4.19</td></tr><tr><td>UTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>User</td><td>用户和用户组</td><td>3.8</td></tr></tbody></table></li><li><p><strong>Namespace 常用操作：</strong></p><ul><li>查看当前系统的 namespace：<code>lsns -t &lt;type&gt;</code></li><li>查看某进程的 namespace：<code>ls -la /proc/&lt;pid&gt;/ns/</code></li><li>进入某 namespace 运行命令：<code>nsenter -t &lt;pid&gt; -n ip addr</code></li></ul></li><li><p><strong>Namespace 练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在新 network namespace 执行 sleep 指令</span><br>unshare -fn <span class="hljs-built_in">sleep</span> 60<br><br><span class="hljs-comment"># 查看进程信息</span><br>ps -ef | grep <span class="hljs-built_in">sleep</span><br><br><span class="hljs-comment"># 查看网络 Namespace</span><br>lsns -t net<br><br><span class="hljs-comment"># 进入该进程所在 Namespace 查看网络配置</span><br>nsenter -t &lt;pid&gt; -n ip a<br></code></pre></td></tr></table></figure></li></ul><h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><p>Cgroups（Control Groups）是 Linux 下用于对一个或一组进程进行资源控制和监控的机制。它可以对 CPU 使用时间、内存、磁盘 I&#x2F;O 等进程所需的资源进行限制。</p><ul><li><p><strong>Linux 内核代码中 Cgroups 的实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CGROUPS</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cgroups</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cg_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Set of subsystem states, one for each subsystem. This array is</span><br><span class="hljs-comment">    * immutable after creation apart from the init_css_set during</span><br><span class="hljs-comment">    * subsystem registration (at boot time).</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">subsys</span>[<span class="hljs-title">CGROUP_SUBSYS_COUNT</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>Cgroups 子系统：</strong></p><table><thead><tr><th>子系统</th><th>作用</th></tr></thead><tbody><tr><td>blkio</td><td>限制每个块设备的输入输出</td></tr><tr><td>cpu</td><td>使用调度程序为 cgroup 任务提供 CPU 的访问</td></tr><tr><td>cpuacct</td><td>产生 cgroup 任务的 CPU 资源报告</td></tr><tr><td>cpuset</td><td>为 cgroup 任务分配单独的 CPU 和内存</td></tr><tr><td>devices</td><td>允许或拒绝 cgroup 任务对设备的访问</td></tr><tr><td>freezer</td><td>暂停和恢复 cgroup 任务</td></tr><tr><td>memory</td><td>设置每个 cgroup 的内存限制以及产生内存资源报告</td></tr><tr><td>net_cls</td><td>标记每个网络包以供 cgroup 方便使用</td></tr><tr><td>ns</td><td>名称空间子系统</td></tr><tr><td>pid</td><td>进程标识子系统</td></tr></tbody></table></li><li><p><strong>CPU 子系统：</strong></p><ul><li><code>cpu.shares</code>：可出让的能获得 CPU 使用时间的相对值。</li><li><code>cpu.cfs_period_us</code>：时间周期长度（微秒）。</li><li><code>cpu.cfs_quota_us</code>：当前 Cgroup 在 <code>cfs_period_us</code> 时间内最多能使用的 CPU 时间数（微秒）。</li><li><code>cpu.stat</code>：Cgroup 内的进程使用的 CPU 时间统计。<ul><li><code>nr_periods</code>：经过 <code>cpu.cfs_period_us</code> 的时间周期数量。</li><li><code>nr_throttled</code>：进程受限次数。</li><li><code>throttled_time</code>：进程被限制使用 CPU 的总用时（纳秒）。</li></ul></li></ul></li><li><p><strong>Linux 调度器：</strong></p><ul><li><strong>Stop 调度器（<code>stop_sched_class</code>）：</strong> 优先级最高，可抢占其他所有进程。</li><li><strong>Deadline 调度器（<code>dl_sched_class</code>）：</strong> 使用红黑树，按绝对截止期限排序进程。</li><li><strong>RT 调度器（<code>rt_sched_class</code>）：</strong> 实时调度器，为每个优先级维护一个队列。</li><li><strong>CFS 调度器（<code>cfs_sched_class</code>）：</strong> 完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念。</li><li><strong>IDLE-Task 调度器（<code>idle_sched_class</code>）：</strong> 空闲调度器，每个 CPU 都有一个 idle 线程。</li></ul></li><li><p><strong>CFS 调度器：</strong></p><ul><li>维护任务提供处理器时间方面的平衡。</li><li>通过虚拟运行时间（vruntime）来实现平衡。</li><li><code>vruntime = 实际运行时间 * 1024 / 进程权重</code></li><li>进程按各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</li></ul><img src="/2025/03/16/docker/image-20250316235528868.png" class="" title="image-20250316235528868"></li></ul><pre class="mermaid">graph LR    subgraph 红黑树    A[vruntime 最小] --> B    B --> C    C --> D    D --> E[vruntime 最大]    end</pre><ul><li><p><strong>CFS 进程调度：</strong></p><ol><li>时钟周期开始时，调用 <code>__schedule()</code> 函数。</li><li><code>__schedule()</code> 调用 <code>pick_next_task()</code> 选择最合适的进程（红黑树最左边的节点）。</li><li>通过 <code>context_switch()</code> 切换到新的地址空间，保证进程运行。</li><li>时钟周期结束时，调用 <code>entity_tick()</code> 函数更新进程负载、状态和 vruntime。</li><li>将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，决定是否触发调度。</li></ol></li><li><p><strong>CPU 子系统练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cgroup cpu 子系统目录中创建目录结构</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu<br><span class="hljs-built_in">mkdir</span> cpudemo<br><span class="hljs-built_in">cd</span> cpudemo<br><br><span class="hljs-comment"># 运行 busyloop</span><br><br><span class="hljs-comment"># 查看 CPU 使用情况</span><br>top<br><br><span class="hljs-comment"># 通过 cgroup 限制 cpu</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu/cpudemo<br><br><span class="hljs-comment"># 把进程添加到 cgroup 进程配置组</span><br><span class="hljs-built_in">echo</span> $(ps -ef | grep busyloop | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>) &gt; cgroup.procs<br><br><span class="hljs-comment"># 设置 cpuquota</span><br><span class="hljs-built_in">echo</span> 10000 &gt; cpu.cfs_quota_us<br><br><span class="hljs-comment"># 再次查看 CPU 使用情况</span><br>top<br></code></pre></td></tr></table></figure></li><li><p><strong>cpuacct 子系统：</strong></p><ul><li><code>cpuacct.usage</code>：Cgroup 及其子 Cgroup 下进程使用 CPU 的时间（纳秒）。</li><li><code>cpuacct.stat</code>：Cgroup 及其子 Cgroup 下进程使用的 CPU 时间（用户态和内核态）。</li></ul></li><li><p><strong>Memory 子系统：</strong></p><ul><li><code>memory.usage_in_bytes</code>：Cgroup 下进程使用的内存。</li><li><code>memory.max_usage_in_bytes</code>：Cgroup 下进程使用内存的最大值。</li><li><code>memory.limit_in_bytes</code>：设置 Cgroup 下进程最多能使用的内存。</li><li><code>memory.soft_limit_in_bytes</code>：软限制，系统内存足够时优先回收超过限额的内存。</li><li><code>memory.oom_control</code>：设置是否在 Cgroup 中使用 OOM Killer。</li></ul></li><li><p><strong>Cgroup driver：</strong></p><ul><li><strong>systemd：</strong> 当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup 管理器。</li><li><strong>cgroupfs：</strong> Docker 默认使用 cgroupfs 作为 cgroup 驱动。<ul><li><strong>存在问题：</strong> 在 systemd 作为 init system 的系统中，可能存在两套 group driver，导致管理混乱。</li><li><strong>建议：</strong> 将 kubelet 的 <code>--cgroup-driver</code> 设置为 <code>systemd</code>。</li></ul></li></ul></li><li><p><strong>课后练习 3.1：Memory 子系统练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cgroup memory 子系统目录中创建目录结构</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory<br><span class="hljs-built_in">mkdir</span> memorydemo<br><span class="hljs-built_in">cd</span> memorydemo<br><br><span class="hljs-comment"># 运行 malloc（在 linux 机器 make build）</span><br><br><span class="hljs-comment"># 查看内存使用情况</span><br>watch <span class="hljs-string">&#x27;ps -aux|grep malloc|grep -v grep&#x27;</span><br><br><span class="hljs-comment"># 通过 cgroup 限制 memory</span><br><span class="hljs-comment"># 把进程添加到 cgroup 进程配置组</span><br><span class="hljs-built_in">echo</span> $(ps -ef | grep malloc | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>) &gt; cgroup.procs<br><br><span class="hljs-comment"># 设置 memory.limit_in_bytes</span><br><span class="hljs-built_in">echo</span> 104960000 &gt; memory.limit_in_bytes<br><br><span class="hljs-comment"># 等待进程被 oom kill</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Union-FS"><a href="#Union-FS" class="headerlink" title="Union FS"></a>Union FS</h4><p>Union FS 是一种将不同目录挂载到同一个虚拟文件系统下的文件系统。</p><ul><li><p><strong>特点：</strong></p><ul><li>支持为每一个成员目录设定 readonly、readwrite 和 whiteout-able 权限。</li><li>文件系统分层，对 readonly 权限的 branch 可以逻辑上进行修改（增量地，不影响 readonly 部分）。</li></ul></li><li><p><strong>用途：</strong></p><ul><li>将多个 disk 挂到同一个目录下。</li><li>将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起。</li></ul><img src="/2025/03/16/docker/image-20250316235535631.png" class="" title="image-20250316235535631"></li></ul><pre class="mermaid">graph LR    subgraph Union FS        A[Read-Only Layer 1] --> C(Merged View)        B[Read-Write Layer 2] --> C    end</pre><h4 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h4><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile-java:</span><br><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y default-jre</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /app.jar</span><br><span class="hljs-keyword">EntryPoint</span><span class="language-bash"> [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;app1.jar&quot;</span>]</span><br><br><span class="hljs-comment"># Dockerfile-elasticsearch:</span><br><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y default-jre</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget elasticseach</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> untar elasticseach</span><br><span class="hljs-keyword">EntryPoint</span><span class="language-bash">: [<span class="hljs-string">&quot;./elasticseach&quot;</span>]</span><br></code></pre></td></tr></table></figure><pre class="mermaid">graph LR    subgraph "myapp:v1.0"        A["BaseImage(ubuntu)"] --> B("install default-jre")        B --> C("copy app1.jar")        C --> D("EntryPoint: [Java, app1.jar]")    end    subgraph "elasticsearch:v7.14"        E["BaseImage(ubuntu)"] --> F("install default-jre")        F --> G("wget elasticseach")        G --> H("untar elasticseach")        H --> I("EntryPoint: [./elasticseach]")    end    subgraph "通用层"    A --> B    E --> F    end</pre><img src="/2025/03/16/docker/image-20250316235712098.png" class="" title="image-20250316235712098"><h4 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h4><p>典型的 Linux 文件系统组成：</p><ul><li><strong>Bootfs（boot file system）：</strong><ul><li>Bootloader：引导加载 kernel。</li><li>Kernel：当 kernel 被加载到内存中后 umount bootfs。</li></ul></li><li><strong>rootfs（root file system）：</strong><ul><li><code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件。</li><li>不同的 linux 发行版，bootfs 基本一致，但 rootfs 会有差别。</li></ul></li></ul><p><strong>Docker 启动：</strong></p><ul><li>Linux：启动后，首先将 rootfs 设置为 readonly，进行一系列检查，然后将其切换为 “readwrite” 供用户使用。</li><li>Docker：初始化时也是将 rootfs 以 readonly 方式加载并检查，然后利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上。</li></ul><img src="/2025/03/16/docker/image-20250316235736584.png" class="" title="image-20250316235736584"><pre class="mermaid">graph LR    subgraph Docker File System        A["Read-Only Layer 1 (Base Image)"] --> C(Container Layer - Read-Write)        B[Read-Only Layer 2] --> C        C --> D{Running Container}    end</pre><p><strong>写操作：</strong></p><ul><li><strong>写时复制（Copy-on-Write）：</strong><ul><li>一个镜像可以被多个容器使用，不需要在内存和磁盘上做多个拷贝。</li><li>需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改。</li><li>不同容器对文件的修改相互独立。</li></ul></li><li><strong>用时分配：</strong><ul><li>按需分配空间，而非提前分配。</li></ul></li></ul><h4 id="容器存储驱动"><a href="#容器存储驱动" class="headerlink" title="容器存储驱动"></a>容器存储驱动</h4><table><thead><tr><th>存储驱动</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>AUFS</td><td>Docker 最早支持的驱动类型，稳定性高</td><td>未进入主线内核，只能在有限场合下使用。实现上具有多层结构，在层比较多的场景下，做写时复制有时会需要比较长的时间</td><td>少 I&#x2F;O 的场景</td></tr><tr><td>OverlayFS</td><td>并入主线内核，可在几乎所有发行版本上使用。实现上只有两层，性能比 AUFS 高</td><td>写时复制机制需要复制整个文件，不能只针对修改部分进行复制，对大文件操作会需要比较长的时间。其中 Overlay 在 Docker 的后续版本中被移除</td><td>少 I&#x2F;O 的场景</td></tr><tr><td>Device Mapper</td><td>并入主线内核，针对块操作，性能比较高。修改文件时只需复制需要修改的块，效率高</td><td>不同容器之间不能共享缓存。在 Docker 的后续版本中会被移除</td><td>I&#x2F;O 密集场景</td></tr><tr><td>BtrFS</td><td>并入主线内核，虽然是文件级操作系统，但是可以对块进行操作。</td><td>需要消耗比较多的内存，稳定性相对比较差</td><td>需要支持 Snapshot 等比较特</td></tr><tr><td>ZFS</td><td>不同的容器之间可以共享缓存，多个容器访问相同的文件能够共享一个单一的 Page Cache。</td><td>在频繁写操作的场景下，会产生比较严重的磁盘碎片。需要消耗比较多的内存，另外稳定性相对比较差</td><td>容器高密度部署的场景</td></tr></tbody></table><p><strong>以 OverlayFS 为例：</strong></p><ul><li>OverlayFS 是一种与 AUFS 类似的联合文件系统，属于文件级的存储驱动。</li><li>包含最初的 Overlay 和更新更稳定的 overlay2。</li><li>Overlay 只有两层：upper 层和 lower 层。<ul><li>Lower 层：镜像层。</li><li>Upper 层：容器可写层。</li></ul></li></ul><p><strong>OverlayFS 文件系统练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> upper lower merged work<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from lower&quot;</span> &gt; lower/in_lower.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from upper&quot;</span> &gt; upper/in_upper.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from lower&quot;</span> &gt; lower/in_both.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from upper&quot;</span> &gt; upper/in_both.txt<br><span class="hljs-built_in">sudo</span> mount -t overlay overlay -o lowerdir=`<span class="hljs-built_in">pwd</span>`/lower,upperdir=`<span class="hljs-built_in">pwd</span>`/upper,workdir=`<span class="hljs-built_in">pwd</span>`/work `<span class="hljs-built_in">pwd</span>`/merged<br><span class="hljs-built_in">cat</span> merged/in_both.txt<br><span class="hljs-built_in">rm</span> merged/in_both.txt<br><span class="hljs-built_in">rm</span> merged/in_lower.txt<br><span class="hljs-built_in">rm</span> merged/in_upper.txt<br></code></pre></td></tr></table></figure><h4 id="OCI-容器标准"><a href="#OCI-容器标准" class="headerlink" title="OCI 容器标准"></a>OCI 容器标准</h4><ul><li><strong>Open Container Initiative：</strong><ul><li>OCI 组织于 2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织。</li><li>OCI 定义了镜像标准（Runtime Specification）、运行时标准（Image Specification）和分发标准（Distribution Specification）。<ul><li>镜像标准：定义应用如何打包。</li><li>运行时标准：定义如何解压应用包并运行。</li><li>分发标准：定义如何分发容器镜像。</li></ul></li></ul></li></ul><h4 id="Docker-引擎架构"><a href="#Docker-引擎架构" class="headerlink" title="Docker 引擎架构"></a>Docker 引擎架构</h4><img src="/2025/03/16/docker/image-20250316235742348.png" class="" title="image-20250316235742348"><pre class="mermaid">graph LR    A[Docker Client] --> B(Docker Daemon)    B --> C{Images}    B --> D{Containers}    B --> E{Networks}    B --> F{Volumes}</pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li><p><strong>Null（<code>--net=None</code>）：</strong></p><ul><li>把容器放入独立的网络空间但不做任何网络配置。</li><li>用户需要通过运行 docker network 命令来完成网络配置。</li></ul></li><li><p><strong>Host：</strong></p><ul><li>使用主机网络名空间，复用主机网络。</li></ul></li><li><p><strong>Container：</strong></p><ul><li>重用其他容器的网络。</li></ul></li><li><p><strong>Bridge（<code>--net=bridge</code>）：</strong></p><ul><li>使用 Linux 网桥和 iptables 提供容器互联。</li><li>Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint。</li></ul><img src="/2025/03/16/docker/image-20250316235751842.png" class="" title="image-20250316235751842"></li></ul><pre class="mermaid">graph LR    subgraph Host        A[Container 1] -->|veth pair| B(docker0 bridge)        C[Container 2] -->|veth pair| B        B --> D{External Network}    end</pre><ul><li><p><strong>Overlay（libnetwork, libkv）：</strong></p><ul><li>通过网络封包实现。</li></ul></li><li><p><strong>Remote (work with remote drivers)</strong></p><ul><li>Underlay<ul><li>使用现有底层网络，为每一个容器配置可路由的网络 IP。</li></ul></li><li>Overlay<ul><li>通过网络封包实现。</li></ul></li></ul></li><li><p><strong>Null 模式</strong></p><ul><li>Null 模式是一个空实现；</li><li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /var/run/netns<br>find -L /var/run/netns -<span class="hljs-built_in">type</span> l -delete<br><span class="hljs-built_in">ln</span> -s /proc/<span class="hljs-variable">$pid</span>/ns/net /var/run/netns/<span class="hljs-variable">$pid</span><br>ip <span class="hljs-built_in">link</span> add A <span class="hljs-built_in">type</span> veth peer name B<br>brctl addif br0 A<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> A up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> B netns <span class="hljs-variable">$pid</span><br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev B name eth0<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip addr add<br><span class="hljs-variable">$SETIP</span>/<span class="hljs-variable">$SETMASK</span> dev eth0<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip route add default via<br><span class="hljs-variable">$GATEWAY</span><br></code></pre></td></tr></table></figure></li><li><p><strong>默认模式– 网桥和 NAT</strong></p></li><li><img src="/2025/03/16/docker/image-20250316235758666.png" class="" title="image-20250316235758666"><pre class="mermaid">    graph LR    subgraph Host A        A[Container 1] -->|eth0 172.17.0.2| B(veth)        B --> C(docker0 172.17.0.1/16)        D[Container 2] -->|eth0 172.17.0.3| E(veth)        E --> C        C -->|NAT| F(eth0 192.168.0.101)    end</pre><ul><li>为主机 eth0 分配 IP 192.168.0.101。</li><li>启动 docker daemon，查看主机 iptables。<ul><li><code>POSTROUTING -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code></li></ul></li><li>在主机启动容器：<ul><li><code>docker run -d --name ssh -p 2333:22 centos-ssh</code></li><li>Docker 会以标准模式配置网络：<ul><li>创建 veth pair。</li><li>将 veth pair 的一端连接到 docker0 网桥。</li><li>veth pair 的另外一端设置为容器名空间的 eth0。</li><li>为容器名空间的 eth0 分配 ip。</li><li>主机上的 Iptables 规则：<code>PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp --dport 2333 -j DNAT --to-destination 172.17.0.2:22</code>。</li></ul></li></ul></li></ul></li><li><p><strong>Underlay</strong></p><img src="/2025/03/16/docker/image-20250316235807168.png" class="" title="image-20250316235807168"><pre class="mermaid">  graph LR    subgraph Host A        A[Container 1] -->|eth0 10.249.67.31| B(veth)        B --> C(mydr0 10.249.67.30)        D[Container 2] -->|eth0 10.249.67.32| E(veth)        E --> C        C -->|eth0| F{External Network}    end</pre><ul><li>采用 Linux 网桥设备（<code>brctl</code>），通过物理网络连通容器。</li><li>创建新的网桥设备 mydr0。</li><li>将主机网卡加入网桥。</li><li>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 mydr0。</li><li>启动容器。</li><li>创建 veth 对，并且把一个 peer 添加到网桥 mydr0。</li><li>配置容器把 veth 的另一个 peer 分配给容器网卡。</li></ul></li><li><p><strong>Docker Libnetwork Overlay</strong></p><ul><li>Docker overlay 网络驱动原生支持多主机网络。</li><li>Libnetwork 是一个内置的基于 VXLAN 的网络驱动。</li></ul></li></ul><h4 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h4><img src="/2025/03/16/docker/image-20250316235814269.png" class="" title="image-20250316235814269"><pre class="mermaid">graph LR    subgraph Host 1        A[VM 1] --> B(VXLAN Tunnel Endpoint)        B -->|VXLAN Encapsulation| C(Underlay Network)    end    subgraph Host 2        C --> D(VXLAN Tunnel Endpoint)        D --> E[VM 2]    end</pre><h4 id="Overlay-network-sample-–-Flannel"><a href="#Overlay-network-sample-–-Flannel" class="headerlink" title="Overlay network sample – Flannel"></a>Overlay network sample – Flannel</h4><img src="/2025/03/16/docker/image-20250316235818388.png" class="" title="image-20250316235818388"><pre class="mermaid">graph LR    subgraph Host 1        A[Pod 1] -->|Bridge| B(Flannel)        B -->|UDP Encapsulation| C(Underlay Network)    end    subgraph Host 2        C --> D(Flannel)        D -->|Bridge| E[Pod 2]    end</pre><ul><li>同一主机内的 Pod 可以使用网桥进行通信。</li><li>不同主机上的 Pod 将通过 flanneld 将其流量封装在 UDP 数据包中。</li></ul><h4 id="Flannel-packet-sample"><a href="#Flannel-packet-sample" class="headerlink" title="Flannel packet sample"></a>Flannel packet sample</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">Outer</span> Ethernet <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Outer</span> IP <span class="hljs-keyword">Header</span>]<br>[UDP <span class="hljs-keyword">Header</span>]<br>[VXLAN <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Inner</span> Ethernet <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Inner</span> IP <span class="hljs-keyword">Header</span>]<br>[Payload]<br></code></pre></td></tr></table></figure><h4 id="创建-docker-镜像"><a href="#创建-docker-镜像" class="headerlink" title="创建 docker 镜像"></a>创建 docker 镜像</h4><ul><li><strong>定义 dockerfile</strong><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-comment"># so apt - get doesn&#x27;t complain</span><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND=noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/^exit 101/exit 0/&#x27;</span> /usr/sbin/policy-rc.d</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> \</span><br><span class="language-bash">apt-get update &amp;&amp; \</span><br><span class="language-bash">apt-get install -y ca-certificates &amp;&amp; \</span><br><span class="language-bash">apt-get install -y curl &amp;&amp; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> ./bin/eic eic</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/eic&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><strong>docker build</strong></li></ul><h3 id="4-Dockerfile-的最佳实践"><a href="#4-Dockerfile-的最佳实践" class="headerlink" title="4. Dockerfile 的最佳实践"></a>4. Dockerfile 的最佳实践</h3><h4 id="回顾-12-Factor-之进程"><a href="#回顾-12-Factor-之进程" class="headerlink" title="回顾 12 Factor 之进程"></a>回顾 12 Factor 之进程</h4><ul><li>运行环境中，应用程序通常是以一个和多个进程运行的。</li><li>12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。</li><li>任何需要持久化的数据都要存储在后端服务内，比如数据库。</li><li>应在构建阶段将源代码编译成待执行应用。</li><li>Session Sticky 是 12-Factor 极力反对的。</li><li>Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</li></ul><p>Docker 遵循以上原则管理和构建应用。</p><h4 id="理解构建上下文（Build-Context）"><a href="#理解构建上下文（Build-Context）" class="headerlink" title="理解构建上下文（Build Context）"></a>理解构建上下文（Build Context）</h4><ul><li>当运行 <code>docker build</code> 命令时，当前工作目录被称为构建上下文。</li><li><code>docker build</code> 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 <code>-f</code> 指定 Dockerfile。<ul><li><code>docker build -f ./Dockerfile</code></li></ul></li><li>当 <code>docker build</code> 运行时，首先会把构建上下文传输给 docker daemon。</li><li>可以通过 <code>.dockerignore</code> 文件从编译上下文排除某些文件。</li></ul><h4 id="镜像构建日志"><a href="#镜像构建日志" class="headerlink" title="镜像构建日志"></a>镜像构建日志</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker build $GOPATH/src/github.com/cncamp/golang/httpserver/<br>Sending build context to Docker daemon <span class="hljs-number">14.57</span>MB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">4</span> : <span class="hljs-type">FROM</span> ubuntu<br><span class="hljs-comment">---&gt; cf0f3ca922e0</span><br>Step <span class="hljs-number">2</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ENV</span> MY_SERVICE_PORT=<span class="hljs-number">80</span><br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; a7d824f74410</span><br>Step <span class="hljs-number">3</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ADD</span> bin/amd64/httpserver /httpserver<br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; 00bb47fce704</span><br>Step <span class="hljs-number">4</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ENTRYPOINT</span> /httpserver<br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; f77ee3366d08</span><br>Successfully built f77ee3366d08<br></code></pre></td></tr></table></figure><h4 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h4><ul><li><p>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p></li><li><p>通常 Docker 简单判断 Dockerfile 中的指令与镜像。</p></li><li><p>针对 <code>ADD</code> 和 <code>COPY</code> 指令，Docker 会比较文件的 checksum。</p></li><li><p>其他指令（如 <code>RUN apt-get -y update</code>），Docker 简单比较指令字串。</p></li><li><p>当某一层 cache 失效，所有后续层级的 cache 均一并失效。</p></li></ul><h4 id="多段构建（Multi-stage-build）"><a href="#多段构建（Multi-stage-build）" class="headerlink" title="多段构建（Multi-stage build）"></a>多段构建（Multi-stage build）</h4><p>多段构建是减少镜像层级、缩小镜像体积的有效方式。它允许您在一个 Dockerfile 中使用多个 <code>FROM</code> 指令，每个 <code>FROM</code> 指令都可以使用不同的基础镜像，并且可以从之前的构建阶段复制文件到当前阶段。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第一阶段：构建阶段</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span>-alpine AS build<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache git</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go get github.com/golang/dep/cmd/dep</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src/project/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> dep ensure -vendor-only</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /go/src/project/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o /bin/project  <span class="hljs-comment"># 只有这个二进制文件是最终需要的</span></span><br><br><span class="hljs-comment"># 第二阶段：运行阶段</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=build /bin/project /bin/project</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/project&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><strong>第一阶段 (build)：</strong><ul><li>使用 <code>golang:1.16-alpine</code> 作为基础镜像。</li><li>安装依赖、复制代码、编译项目。</li><li>最终生成可执行文件 <code>/bin/project</code>。</li></ul></li><li><strong>第二阶段 (无基础镜像)：</strong><ul><li>使用 <code>scratch</code> 作为基础镜像（一个空的镜像）。</li><li>从第一阶段（<code>build</code>）复制 <code>/bin/project</code> 到当前阶段。</li><li>设置 <code>ENTRYPOINT</code> 和 <code>CMD</code>。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>最终镜像只包含运行所需的二进制文件，极大地减小了镜像体积。</li><li>避免了将编译工具、依赖库等不必要的文件包含在最终镜像中。</li></ul><h4 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h4><ul><li><p><strong><code>FROM</code>：</strong> 选择基础镜像，推荐使用 Alpine Linux（体积小）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>LABEL</code>：</strong> 按标签组织项目。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> multi.label1=<span class="hljs-string">&quot;value1&quot;</span> multi.label2=<span class="hljs-string">&quot;value2&quot;</span> other=<span class="hljs-string">&quot;value3&quot;</span></span><br></code></pre></td></tr></table></figure><p>配合 <code>label filter</code> 可过滤镜像查询结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images -f label=multi.label1=<span class="hljs-string">&quot;value1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>RUN</code>：</strong> 执行命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y &lt;package&gt;</span><br></code></pre></td></tr></table></figure><ul><li>最常见的用法是 <code>RUN apt-get update &amp;&amp; apt-get install</code>，这两条命令应该永远用 <code>&amp;&amp;</code> 连接，以避免缓存导致的问题。</li></ul></li><li><p><strong><code>CMD</code>：</strong> 容器镜像中包含应用的运行命令（需要带参数）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>...]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>EXPOSE</code>：</strong> 发布端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br></code></pre></td></tr></table></figure><ul><li>是镜像创建者和使用者的约定。</li><li><code>docker run -P</code> 时，Docker 会自动映射 <code>EXPOSE</code> 的端口到主机大端口。</li></ul></li><li><p><strong><code>ENV</code>：</strong> 设置环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li><li><p><strong><code>ADD</code>：</strong> 从源地址（文件、目录或者 URL）复制文件到目标路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 路径中有空格时使用</span></span><br></code></pre></td></tr></table></figure><ul><li><code>ADD</code> 支持 Go 风格的通配符，如 <code>ADD check* /testdir/</code>。</li><li><code>src</code> 如果是文件，则必须包含在编译上下文中。</li><li><code>src</code> 如果是 URL：<ul><li>如果 <code>dest</code> 结尾没有 <code>/</code>，则 <code>dest</code> 是目标文件名。</li><li>如果 <code>dest</code> 结尾有 <code>/</code>，则 <code>dest</code> 是目标目录名。</li></ul></li><li>如果 <code>src</code> 是一个目录，则所有文件都会被复制至 <code>dest</code>。</li><li>如果 <code>src</code> 是一个本地压缩文件，则在 <code>ADD</code> 的同时完整解压操作。</li><li>如果 <code>dest</code> 不存在，则 <code>ADD</code> 指令会创建目标目录。</li><li>应尽量减少通过 <code>ADD URL</code> 添加 remote 文件，建议使用 <code>curl</code> 或者 <code>wget &amp;&amp; untar</code>。</li></ul></li><li><p><strong><code>COPY</code>：</strong> 从源地址（文件、目录）复制文件到目标路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 路径中有空格时使用</span></span><br></code></pre></td></tr></table></figure><ul><li><code>COPY</code> 的使用与 <code>ADD</code> 类似，但有如下区别：<ul><li><code>COPY</code> 只支持本地文件的复制，不支持 URL。</li><li><code>COPY</code> 不解压文件。</li><li><code>COPY</code> 可以用于多阶段编译场景。</li></ul></li><li><code>COPY</code> 语义上更直白，复制本地文件时，优先使用 <code>COPY</code>。</li></ul></li><li><p><strong><code>ENTRYPOINT</code>：</strong> 定义可以执行的容器镜像入口命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  <span class="hljs-comment"># docker run 参数追加模式</span></span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2              <span class="hljs-comment"># docker run 参数替换模式</span></span><br></code></pre></td></tr></table></figure><ul><li><code>docker run --entrypoint</code> 可替换 Dockerfile 中定义的 <code>ENTRYPOINT</code>。</li><li>最佳实践：用 <code>ENTRYPOINT</code> 定义镜像主命令，并通过 <code>CMD</code> 定义主要参数。<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;s3cmd&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>VOLUME</code>：</strong> 将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>等价于 <code>docker run -v /data</code>，可通过 <code>docker inspect</code> 查看主机的 mount point。</p></li><li><p><strong><code>USER</code>：</strong> 切换运行镜像的用户和用户组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">USER</span> &lt;<span class="hljs-keyword">user</span>&gt;[:&lt;group&gt;]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>WORKDIR</code>：</strong> 等价于 <code>cd</code>，切换工作目录。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br></code></pre></td></tr></table></figure></li><li><p><strong>其他非常用指令：</strong></p><ul><li><code>ARG</code></li><li><code>ONBUILD</code></li><li><code>STOPSIGNAL</code></li><li><code>HEALTHCHECK</code></li><li><code>SHELL</code></li></ul></li></ul><h4 id="Dockerfile-最佳实践总结"><a href="#Dockerfile-最佳实践总结" class="headerlink" title="Dockerfile 最佳实践总结"></a>Dockerfile 最佳实践总结</h4><ul><li><strong>不要安装无效软件包。</strong></li><li><strong>简化镜像中同时运行的进程数：</strong> 理想状况下，每个镜像应该只有一个进程。</li><li><strong>最小化层级数：</strong><ul><li>最新的 Docker 只有 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 创建新层。</li><li>多条 <code>RUN</code> 命令可通过连接符连接成一条指令集。</li><li>通过多段构建减少镜像层数。</li></ul></li><li><strong>把多行参数按字母排序。</strong></li><li><strong>编写 dockerfile 的时候，应该把变更频率低的编译指令优先构建。</strong></li><li><strong>复制文件时，每个文件应独立复制。</strong></li></ul><p><strong>目标：</strong> 易管理、少漏洞、镜像小、层级少、利用缓存。</p><h4 id="多进程的容器镜像"><a href="#多进程的容器镜像" class="headerlink" title="多进程的容器镜像"></a>多进程的容器镜像</h4><ul><li><strong>选择适当的 init 进程：</strong><ul><li>需要捕获 <code>SIGTERM</code> 信号并完成子进程的优雅终止。</li><li>负责清理退出的子进程以避免僵尸进程。</li></ul></li><li><strong>开源项目：</strong> <a href="https://github.com/krallin/tini">https://github.com/krallin/tini</a></li></ul><h3 id="5-Docker-镜像管理"><a href="#5-Docker-镜像管理" class="headerlink" title="5. Docker 镜像管理"></a>5. Docker 镜像管理</h3><ul><li><code>docker save/load</code>：保存和加载镜像。</li><li><code>docker tag</code>：为镜像打标签。</li><li><code>docker push/pull</code>：推送和拉取镜像。</li></ul><h4 id="基于-Docker-镜像的版本管理"><a href="#基于-Docker-镜像的版本管理" class="headerlink" title="基于 Docker 镜像的版本管理"></a>基于 Docker 镜像的版本管理</h4><ul><li><p><strong><code>docker tag</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag &lt;image_id&gt; &lt;repository&gt;/&lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li><code>hub.docker.com</code>：镜像仓库地址（如果不填，默认为 <code>hub.docker.com</code>）。</li><li><code>cncamp</code>：repository。</li><li><code>httpserver</code>：镜像名。</li><li><code>v1.0</code>：tag（常用来记录版本信息）。</li></ul></li><li><p><strong>Docker tag 与 GitHub 的版本管理合力：</strong></p><p>以 Kubernetes 为例：</p><ol><li><strong>开发分支：</strong> <code>git checkout master</code></li><li><strong>Release 分支：</strong> <code>git checkout -b release-1.21</code></li><li><strong>版本发布：</strong><ul><li>以 release branch 为基础构建镜像，并为镜像标记版本信息：<code>docker tag &lt;image_id&gt; k8s.io/kubernetes/apiserver:v1.21</code></li><li>在 GitHub 中保存 release 代码快照：<code>git tag v1.21</code></li></ul></li></ol></li></ul><h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4><ul><li><p><strong>Docker Hub：</strong> <a href="https://hub.docker.com/">https://hub.docker.com/</a></p></li><li><p><strong>创建私有镜像仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -d -p 5000:5000 registry<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-Docker-优势与劣势"><a href="#6-Docker-优势与劣势" class="headerlink" title="6. Docker 优势与劣势"></a>6. Docker 优势与劣势</h3><h4 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h4><ul><li><strong>封装性：</strong><ul><li>应用扩缩容时可以秒速启动。</li><li>资源利用率高。</li><li>方便的 CPU、内存资源调整。</li><li>能实现秒级快速回滚。</li><li>一键启动所有依赖服务。</li><li>镜像一次编译，随处使用。</li><li>测试、生产环境高度一致。</li></ul></li><li><strong>隔离性：</strong><ul><li>应用的运行环境和宿主机环境无关，完全由镜像控制。</li><li>多个应用版本可以并存在机器上。</li></ul></li><li><strong>社区活跃：</strong><ul><li>Docker 命令简单、易用，社区十分活跃，且周边组件丰富。</li></ul></li></ul><h4 id="Docker-劣势"><a href="#Docker-劣势" class="headerlink" title="Docker 劣势"></a>Docker 劣势</h4><ul><li><strong>隔离性不如虚拟机：</strong> 容器共享宿主机内核，隔离性相对较弱。</li><li><strong>安全性：</strong> 如果容器内的应用存在漏洞，可能会影响到宿主机或其他容器。</li><li><strong>网络配置复杂：</strong> 跨主机容器网络配置相对复杂。</li><li><strong>资源限制：</strong> 虽然可以使用 Cgroups 进行资源限制，但配置和管理相对复杂。</li><li><strong>持久化存储：</strong> 容器的持久化存储需要额外的配置和管理。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker,k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2025/03/14/%E5%89%91%E6%8C%87offer/"/>
    <url>/2025/03/14/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<p>剑指 offer 算法刷题记录（Golang 版）</p><span id="more"></span><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><strong>从尾到头打印链表</strong></h2><p>描述</p><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>如输入{1,2,3}的链表如下图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F" alt="img"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(head *ListNode)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>stack=<span class="hljs-built_in">append</span>(stack, head.Val)<br>        head = head.Next<br>&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&#123;<br>        res = <span class="hljs-built_in">append</span>(res, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>思路解释：</p><p>从尾到头的顺序，很容易想到栈的结构，后进先出即可。具体步骤如下：</p><ol><li>初始化一个空的栈 <code>stack</code> 和结果数组 <code>res</code>。</li><li>遍历链表，将每个节点的值压入栈中。</li><li>遍历栈，将栈顶元素弹出并添加到结果数组中，直到栈为空。</li><li>返回结果数组 <code>res</code>。</li></ol><p>这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是链表的长度。</p><p>好的，下面是对你提供的链表反转问题的总结：</p><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><p>题目</p><p>给定一个单链表的头节点，反转该链表，并返回反转后的链表的头节点。</p><p><strong>示例：</strong></p><ul><li>输入：<code>&#123;1, 2, 3&#125;</code></li><li>输出：<code>&#123;3, 2, 1&#125;</code></li></ul><p>思路</p><p>链表反转的思路可以用一个非常经典的比喻来理解：<strong>想象你有一堆牌，你需要把它们的顺序颠倒过来。</strong></p><ol><li><p><strong>三个指针：</strong> 我们需要三个指针来完成这个任务：</p><ul><li><code>prev</code>：指向已经反转好的链表的头节点。初始时，它指向 <code>nil</code>，因为最开始还没有反转任何节点。</li><li><code>current</code>：指向当前正在处理的节点。</li><li><code>next</code>：指向 <code>current</code> 节点的下一个节点，用于在断开 <code>current</code> 节点的 <code>Next</code> 指针之前，保存后续节点的引用，防止链表断裂。</li></ul></li><li><p><strong>迭代反转：</strong> 遍历链表，对于每个 <code>current</code> 节点，执行以下操作：</p><ul><li><strong>保存 <code>next</code>：</strong> 首先，用 <code>next</code> 指针保存 <code>current.Next</code>，因为接下来要修改 <code>current.Next</code>。</li><li><strong>反转指针：</strong> 将 <code>current.Next</code> 指向 <code>prev</code>，实现反转。</li><li><strong>移动指针：</strong> 将 <code>prev</code> 移动到 <code>current</code>，<code>current</code> 移动到 <code>next</code>，为处理下一个节点做准备。</li></ul></li><li><p><strong>新的头节点：</strong> 当 <code>current</code> 指针到达链表末尾（<code>nil</code>）时，<code>prev</code> 指针指向的就是反转后链表的头节点。</p></li></ol><p><strong>图解：</strong></p><p>假设链表为 <code>1 -&gt; 2 -&gt; 3 -&gt; nil</code></p><ol><li>初始状态：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> nil<br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ol start="2"><li>第一次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">1</span> -&gt; nil<br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 -&gt; 3 -&gt; nil</code> (1 指向 nil)</p><ol start="3"><li>第二次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 &lt;- 3 -&gt; nil</code> (2 指向 1)</p><ol start="4"><li>第三次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> nil<br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">3</span> -&gt; <span class="hljs-number">2</span><br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> nil<br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 &lt;- 3</code> (3 指向 2)</p><ol start="5"><li>循环结束：<code>current</code> 为 <code>nil</code>，<code>prev</code> 指向新的头节点 <code>3</code>。</li></ol><p>算法代码 (Go)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-comment">// write code here</span><br><span class="hljs-keyword">var</span> prev *ListNode = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">var</span> current *ListNode = head<br><span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &#123;<br>next := current.Next <span class="hljs-comment">// 保存下一个节点</span><br>current.Next = prev  <span class="hljs-comment">// 反转指针</span><br>prev = current       <span class="hljs-comment">// 移动 prev 指针</span><br>current = next       <span class="hljs-comment">// 移动 current 指针</span><br>&#125;<br><span class="hljs-keyword">return</span> prev <span class="hljs-comment">// prev 指向新的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li><strong>适用场景：</strong> 这种反转链表的方法适用于单链表结构。它是一种原地反转算法，只需要常数级别的额外空间（三个指针），因此空间复杂度为 O(1)。时间复杂度为 O(n)，因为需要遍历链表一次。</li><li><strong>算法类型：</strong> 链表操作</li><li><strong>技巧：</strong> 使用多个指针来辅助完成链表结构的修改是非常常见的技巧。一定要理清指针的指向关系，防止链表断裂。</li><li><strong>易错点：</strong> 在反转指针之前，一定要先保存下一个节点的引用，否则链表会断裂。</li><li><strong>变体：</strong> 链表反转有很多变体，例如反转链表的一部分（指定起始和结束位置）。基本思路都是类似的，需要仔细处理指针的指向。</li></ul><p>好的，下面是对你提供的题目和代码的总结：</p><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>题目描述</p><p>输入两个递增的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>数据范围：</strong></p><ul><li>单个链表的长度 <code>n</code> 满足 <code>0 &lt;= n &lt;= 1000</code></li><li>节点值满足 <code>-1000 &lt;= 节点值 &lt;= 1000</code></li></ul><p><strong>要求：</strong></p><ul><li>空间复杂度 O(1)</li><li>时间复杂度 O(n)</li></ul><p>解题思路</p><p>这道题的解题思路非常经典，就是<strong>迭代</strong>比较两个链表的当前节点，将较小的节点添加到新的链表中。  由于输入链表是递增的，所以我们只需要比较两个链表的头节点，将较小的节点作为新链表的头节点，然后递归地处理剩余的链表即可。</p><p>具体步骤如下：</p><ol><li><p><strong>初始化：</strong></p><ul><li>创建一个哑节点（dummy node），作为合并后链表的头节点。哑节点不存储实际数据，只是为了方便操作。</li><li>创建一个指针 <code>current</code>，指向哑节点，用于构建合并后的链表。</li></ul></li><li><p><strong>迭代比较：</strong></p><ul><li>循环比较 <code>pHead1</code> 和 <code>pHead2</code> 指向的节点的值，直到其中一个链表为空。</li><li>如果 <code>pHead1.Val &lt;= pHead2.Val</code>，则将 <code>pHead1</code> 指向的节点添加到 <code>current</code> 的 <code>Next</code> 指针，并将 <code>pHead1</code> 向后移动一位。</li><li>否则，将 <code>pHead2</code> 指向的节点添加到 <code>current</code> 的 <code>Next</code> 指针，并将 <code>pHead2</code> 向后移动一位。</li><li>将 <code>current</code> 指针向后移动一位。</li></ul></li><li><p><strong>处理剩余节点：</strong></p><ul><li>当其中一个链表为空时，将另一个链表剩余的节点直接添加到 <code>current</code> 的 <code>Next</code> 指针。</li></ul></li><li><p><strong>返回结果：</strong></p><ul><li>返回哑节点的 <code>Next</code> 指针，即合并后的链表的头节点。</li></ul></li></ol><p><strong>为什么使用哑节点？</strong></p><p>使用哑节点可以避免对头节点的特殊处理，使代码更加简洁。如果没有哑节点，我们需要判断合并后的链表的头节点是 <code>pHead1</code> 还是 <code>pHead2</code>，这会增加代码的复杂性。</p><p>代码实现 (Go)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param pHead1 ListNode类</span><br><span class="hljs-comment"> * @param pHead2 ListNode类</span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(pHead1 *ListNode, pHead2 *ListNode)</span></span> *ListNode &#123;<br>dummy := &amp;ListNode&#123;&#125; <span class="hljs-comment">// 创建哑节点</span><br>current := dummy     <span class="hljs-comment">// current 指针指向哑节点</span><br><br><span class="hljs-comment">// 循环比较两个链表的节点</span><br><span class="hljs-keyword">for</span> pHead1 != <span class="hljs-literal">nil</span> &amp;&amp; pHead2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pHead1.Val &lt;= pHead2.Val &#123;<br>current.Next = pHead1 <span class="hljs-comment">// 将 pHead1 的节点添加到新链表</span><br>pHead1 = pHead1.Next    <span class="hljs-comment">// pHead1 向后移动</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>current.Next = pHead2 <span class="hljs-comment">// 将 pHead2 的节点添加到新链表</span><br>pHead2 = pHead2.Next    <span class="hljs-comment">// pHead2 向后移动</span><br>&#125;<br>current = current.Next <span class="hljs-comment">// current 向后移动</span><br>&#125;<br><br><span class="hljs-comment">// 处理剩余节点</span><br><span class="hljs-keyword">if</span> pHead1 != <span class="hljs-literal">nil</span> &#123;<br>current.Next = pHead1 <span class="hljs-comment">// 将 pHead1 剩余的节点添加到新链表</span><br>&#125;<br><span class="hljs-keyword">if</span> pHead2 != <span class="hljs-literal">nil</span> &#123;<br>current.Next = pHead2 <span class="hljs-comment">// 将 pHead2 剩余的节点添加到新链表</span><br>&#125;<br><br><span class="hljs-keyword">return</span> dummy.Next <span class="hljs-comment">// 返回新链表的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><strong>时间复杂度：</strong> O(n)，其中 n 是两个链表的总长度。我们需要遍历两个链表的所有节点。</li><li><strong>空间复杂度：</strong> O(1)。我们只使用了常量级的额外空间，例如哑节点和 <code>current</code> 指针。</li></ul><p>适用题目类型</p><p>这种合并排序链表的思路，通常适用于以下类型的题目：</p><ul><li><strong>涉及到两个或多个有序数据结构的合并问题。</strong>  例如，合并 k 个排序链表。</li><li><strong>需要保持合并后的数据结构仍然有序的问题。</strong></li><li><strong>对空间复杂度有要求的题目。</strong>  由于该算法的空间复杂度为 O(1)，因此非常适合对空间复杂度有严格限制的题目。</li></ul><p><strong>举例：</strong></p><ul><li><strong>LeetCode 23. 合并 K 个排序链表</strong></li><li><strong>类似本题的变种，例如要求合并后链表为降序排列。</strong></li></ul><p>好的，我们来一起梳理一下这道寻找链表公共节点的题目。我会用易懂的方式解释思路，并提供带有详细注释的 Golang 代码。</p><h2 id="寻找链表的第一个公共节点"><a href="#寻找链表的第一个公共节点" class="headerlink" title="寻找链表的第一个公共节点"></a>寻找链表的第一个公共节点</h2><p><strong>题目描述：</strong></p><p>给定两个无环的单向链表，找到它们的第一个公共节点。如果不存在公共节点，则返回 <code>nil</code>。</p><p><strong>要求：</strong></p><ul><li>空间复杂度为 O(1)。</li><li>时间复杂度为 O(n)。</li></ul><p>思路解析</p><p>想象一下，你在两条不同的河流上划船。两条河流最终汇入同一条河流，那么汇入点就是它们的第一个公共点。</p><ol><li><strong>长度差：</strong> 首先，我们需要知道两条河流（链表）的长度差。如果一条河流比另一条长，我们需要让较长的河流先划一段时间，直到它们到达同一起跑线。</li><li><strong>同步前进：</strong> 然后，两条河流同时开始划船，每次都前进一步。当两条船在同一个位置时，我们就找到了它们的第一个公共点。</li><li><strong>没有公共点：</strong> 如果两条河流一直没有相遇，那么它们就没有公共点。</li></ol><p><strong>图解：</strong></p><p>假设我们有两个链表：</p><ul><li>链表 A: <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code></li><li>链表 B: <code>      a -&gt; b -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code></li></ul><p>它们的第一个公共节点是 <code>4</code>。</p><p>用 Mermaid 图表示如下：</p><pre class="mermaid">graph LR    A1(1) --> A2(2)    A2 --> A3(3)    A3 --> A4(4)    A4 --> A5(5)    A5 --> A6(6)    A6 --> A7(7)    B1(a) --> B2(b)    B2 --> A4</pre><p><strong>步骤：</strong></p><ol><li>计算链表 A 的长度（lenA &#x3D; 7）。</li><li>计算链表 B 的长度（lenB &#x3D; 2 + 5 &#x3D; 7）。</li><li>计算长度差（diff &#x3D; lenA - lenB &#x3D; 0）。</li><li>因为长度相等，所以不需要移动任何链表的头指针。</li><li>同时遍历链表 A 和链表 B，直到找到相同的节点（即节点 4）。</li></ol><p>Golang 代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param pHead1 ListNode类</span><br><span class="hljs-comment"> * @param pHead2 ListNode类</span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(pHead1 *ListNode, pHead2 *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-comment">// 1. 判空处理：如果任一链表为空，则没有公共节点</span><br><span class="hljs-keyword">if</span> pHead1 == <span class="hljs-literal">nil</span> || pHead2 == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 2. 获取两个链表的长度</span><br>len1 := GetLength(pHead1)<br>len2 := GetLength(pHead2)<br><br><span class="hljs-comment">// 3. 计算长度差，让较长的链表先走几步</span><br>diff := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> len1 &gt; len2 &#123;<br>diff = len1 - len2<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; diff; i++ &#123;<br>pHead1 = pHead1.Next <span class="hljs-comment">// 移动 pHead1 到同一起跑线</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>diff = len2 - len1<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; diff; i++ &#123;<br>pHead2 = pHead2.Next <span class="hljs-comment">// 移动 pHead2 到同一起跑线</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 同时遍历两个链表，查找相同节点</span><br><span class="hljs-keyword">for</span> pHead1 != <span class="hljs-literal">nil</span> &amp;&amp; pHead2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pHead1 == pHead2 &#123; <span class="hljs-comment">// 直接比较指针，如果指针相同则找到公共节点</span><br><span class="hljs-keyword">return</span> pHead1<br>&#125;<br>pHead1 = pHead1.Next <span class="hljs-comment">// 同时移动 pHead1</span><br>pHead2 = pHead2.Next <span class="hljs-comment">// 同时移动 pHead2</span><br>&#125;<br><br><span class="hljs-comment">// 5. 如果没有找到公共节点，则返回 nil</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// GetLength 获取链表的长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">int</span> &#123;<br>length := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>length++        <span class="hljs-comment">// 累加长度</span><br>head = head.Next <span class="hljs-comment">// 移动到下一个节点</span><br>&#125;<br><span class="hljs-keyword">return</span> length<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>判空处理：</strong>  如果任何一个链表为空，那么它们不可能有公共节点，直接返回 <code>nil</code>。</li><li><strong>获取链表长度：</strong>  <code>GetLength</code> 函数用于计算链表的长度。</li><li><strong>调整起始位置：</strong>  计算长度差，并让较长的链表先移动，直到两个链表在同一起跑线上。</li><li><strong>同步遍历：</strong>  同时遍历两个链表，比较节点是否相同。如果找到相同的节点，则返回该节点。</li><li><strong>没有公共节点：</strong>  如果遍历完整个链表都没有找到公共节点，则返回 <code>nil</code>。</li></ol><p>适用场景</p><p>这种方法特别适用于以下场景：</p><ul><li>寻找两个单链表的第一个公共节点。</li><li>要求时间复杂度为 O(n)，空间复杂度为 O(1)。</li><li>链表没有环。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 etcd</title>
    <link href="/2025/03/13/etcd/"/>
    <url>/2025/03/13/etcd/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-etcd：一个分布式键值存储系统"><a href="#深入理解-etcd：一个分布式键值存储系统" class="headerlink" title="深入理解 etcd：一个分布式键值存储系统"></a>深入理解 etcd：一个分布式键值存储系统</h1> <span id="more"></span><img src="/2025/03/13/etcd/image-20250315134912712.png" class="" title="image-20250315134912712"><p>好的，根据您提供的内容，我整理了一篇关于 Kubernetes 控制平面组件 etcd 的技术博客，内容如下：</p><h1 id="深入理解-Kubernetes-基石：etcd-详解"><a href="#深入理解-Kubernetes-基石：etcd-详解" class="headerlink" title="深入理解 Kubernetes 基石：etcd 详解"></a>深入理解 Kubernetes 基石：etcd 详解</h1><p><strong>作者：</strong> 孟凡杰（前 eBay 资深架构师）</p><p><strong>引言</strong></p><p>在 Kubernetes（K8s）集群中，etcd 扮演着至关重要的角色。它是整个集群的“大脑”，负责存储集群状态、配置信息以及进行服务发现。本文将深入探讨 etcd 的核心概念、功能、使用场景、Raft 协议、存储机制、高可用方案以及在 Kubernetes 中的应用，帮助您全面理解这一关键组件。</p><h2 id="什么是-etcd？"><a href="#什么是-etcd？" class="headerlink" title="什么是 etcd？"></a>什么是 etcd？</h2><p>etcd 是由 CoreOS（现已被 Red Hat 收购）开发的一个开源、分布式、高可用的键值存储系统。它基于 Raft 一致性算法，确保数据在多个节点之间保持一致性，即使在部分节点故障的情况下也能正常运行。</p><p>etcd 的主要特点：</p><ul><li><strong>键值对存储：</strong> 数据以键值对的形式存储在分层目录结构中，类似于文件系统。</li><li><strong>变更监测：</strong> 可以监测特定键或目录的变化，并在发生变化时做出反应。</li><li><strong>简单易用：</strong> 提供 HTTP+JSON 的 API，易于使用 curl 等工具进行访问。</li><li><strong>安全可靠：</strong> 支持 SSL 客户端证书认证，使用 Raft 算法保证数据一致性。</li><li><strong>高性能：</strong> 单实例每秒可处理数千次读写操作。</li></ul><h2 id="etcd-的核心功能"><a href="#etcd-的核心功能" class="headerlink" title="etcd 的核心功能"></a>etcd 的核心功能</h2><p>etcd 主要提供以下功能：</p><ol><li><strong>基本的键值存储：</strong> 存储和检索数据。</li><li><strong>监听机制：</strong> 监听键或目录的变化，实现实时通知。</li><li><strong>键的过期及续约：</strong> 用于监控和服务发现，确保服务的可用性。</li><li><strong>原子 Compare And Swap (CAS) 和 Compare And Delete (CAD)：</strong> 用于实现分布式锁和领导者选举。</li></ol><h2 id="etcd-的典型应用场景"><a href="#etcd-的典型应用场景" class="headerlink" title="etcd 的典型应用场景"></a>etcd 的典型应用场景</h2><p>etcd 在分布式系统中有着广泛的应用，常见的场景包括：</p><ol><li><strong>服务注册与发现：</strong> 服务提供者将自己的信息注册到 etcd，服务消费者通过 etcd 发现可用的服务实例。</li><li><strong>消息发布与订阅：</strong> 构建配置共享中心，实现配置的集中管理和动态更新。</li><li><strong>分布式锁：</strong> 利用 CAS 或 CAD 操作实现分布式锁，协调多个进程对共享资源的访问。</li><li><strong>领导者选举：</strong> 在分布式系统中选举出一个领导者，负责协调和管理其他节点。</li><li><strong>键值对存储:</strong> 作为数据库存储集群数据。</li></ol><p><strong>服务注册与发现示例（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000021831.png" class="" title="image-20250317000021831"><pre class="mermaid">graph LR    subgraph 服务注册        A[服务提供者] --> B(向 etcd 注册服务)    end    subgraph 服务发现        C[服务消费者] --> D(从 etcd 查询服务)    end    B --> E[etcd]    D --> E    subgraph 服务绑定        F[服务消费者] --> G[服务提供者]    end</pre><p><strong>消息发布与订阅示例（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000027311.png" class="" title="image-20250317000027311"><pre class="mermaid">graph LR    subgraph 消息发布        A[生产者] --> B(向 etcd 发布消息)    end    subgraph 消息订阅        C[服务消费者] --> D(从 etcd 订阅消息)    end    B --> E[etcd]    D --> E</pre><h2 id="etcd-的安装与使用"><a href="#etcd-的安装与使用" class="headerlink" title="etcd 的安装与使用"></a>etcd 的安装与使用</h2><p>etcd 的安装非常简单，可以从 GitHub Releases 页面下载预编译的二进制文件，解压后即可运行。</p><p><strong>安装步骤（示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ETCD_VER=v3.4.17<br>DOWNLOAD_URL=https://github.com/etcd-io/etcd/releases/download<br><span class="hljs-built_in">rm</span> -f /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br><span class="hljs-built_in">rm</span> -rf /tmp/etcd-download-test &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /tmp/etcd-download-test<br>curl -L <span class="hljs-variable">$&#123;DOWNLOAD_URL&#125;</span>/<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -o /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br>tar xzvf /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1<br><span class="hljs-built_in">rm</span> -f /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p><strong>常用客户端工具：</strong></p><ul><li><strong>etcdctl：</strong> 命令行客户端工具，用于与 etcd 集群交互。</li><li><strong>go-etcd：</strong> Go 语言客户端库。</li><li><strong>jetcd：</strong> Java 客户端库。</li><li><strong>python-etcd：</strong> Python 客户端库。</li></ul><p><strong>基本数据读写操作（etcdctl 示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 写入数据</span><br>etcdctl --endpoints=localhost:12379 put /a b<br><br><span class="hljs-comment"># 读取数据</span><br>etcdctl --endpoints=localhost:12379 get /a<br><br><span class="hljs-comment"># 按 key 的前缀查询数据</span><br>etcdctl --endpoints=localhost:12379 get --prefix /<br><br><span class="hljs-comment"># 只显示键值</span><br>etcdctl --endpoints=localhost:12379 get --prefix / --keys-only --debug<br></code></pre></td></tr></table></figure><h2 id="深入理解-Raft-一致性协议"><a href="#深入理解-Raft-一致性协议" class="headerlink" title="深入理解 Raft 一致性协议"></a>深入理解 Raft 一致性协议</h2><p>etcd 的数据一致性是基于 Raft 协议实现的。Raft 是一种易于理解的分布式一致性算法，它将一致性问题分解为几个子问题：</p><ol><li><strong>领导者选举（Leader Election）：</strong> 初始启动或领导者失效时，集群中的节点会通过投票选举出一个新的领导者。</li><li><strong>日志复制（Log Replication）：</strong> 领导者接收客户端的请求，并将请求作为日志条目复制到其他节点。</li><li><strong>安全性（Safety）：</strong> 确保每个节点都执行相同序列的命令，保证数据的一致性。</li></ol><p><strong>Raft 协议角色：</strong></p><ul><li><strong>Leader（领导者）：</strong> 负责接收客户端请求、日志复制和向 Follower 发送心跳。</li><li><strong>Follower（跟随者）：</strong> 接收 Leader 的日志并复制到本地，参与投票选举 Leader。</li><li><strong>Candidate（候选者）：</strong> 在 Leader 选举过程中，Follower 会转变为 Candidate，发起投票。</li><li><strong>Learner:</strong> 新加入的节点，只接收数据而不参与投票，因此增加<br>learner节点时，集群的quorum不变。</li></ul><p><strong>Raft 协议流程（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000031277.png" class="" title="image-20250317000031277"><pre class="mermaid">graph LR    subgraph 客户端请求        A[客户端] --> B[Leader]    end    subgraph Leader 处理        B --> C[将请求追加到本地日志]        B --> D[通过心跳将日志同步给 Follower]    end    subgraph Follower 处理        D --> E[Follower 接收日志并记录]        E --> F[向 Leader 发送 ACK]    end    subgraph Leader 提交        B -- 收到多数 Follower ACK --> G[将日志设置为已提交]        G --> H[通知客户端]        B -- 下次心跳 --> I[通知 Follower 提交日志]    end</pre><p><strong>Raft 协议失效处理：</strong></p><ol><li><strong>Leader 失效：</strong> Follower 在超时时间内未收到 Leader 心跳，会发起选举。</li><li><strong>Follower 失效：</strong> 重新加入集群后，从 Leader 复制日志。</li><li><strong>多个 Candidate：</strong> 随机等待一段时间后再次发起投票。</li></ol><p><strong>WAL 日志：</strong></p><p>etcd 使用预写式日志（WAL）来记录所有的数据变更。WAL 日志是二进制格式的，包含以下字段：</p><ul><li><strong>type：</strong> 0 表示 Normal，1 表示 ConfChange（配置变更）。</li><li><strong>term：</strong> 主节点任期，每次主节点变更时递增。</li><li><strong>index：</strong> 变更序号，严格有序递增。</li><li><strong>data：</strong> Raft 请求对象的 pb 结构。</li></ul><h2 id="etcd-的存储机制"><a href="#etcd-的存储机制" class="headerlink" title="etcd 的存储机制"></a>etcd 的存储机制</h2><p>etcd v3 的存储分为两部分：</p><ol><li><strong>内存索引（kvindex）：</strong> 基于 Google 开源的 btree 实现，用于加速查询。</li><li><strong>后端存储（backend）：</strong> 目前使用 boltdb，一个单机的支持事务的 KV 存储。</li></ol><p>etcd 在 boltdb 中存储的 key 是 reversion，value 是 etcd 自己的 key-value 组合，实现了多版本机制。</p><p><strong>reversion:</strong> 由两部分组成:</p><ol><li><strong>main rev：</strong> 每次事务进行加一。</li><li><strong>sub rev:</strong> 同一个事务中的每次操作加一。</li></ol><p><strong>存储机制示意图（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000035671.png" class="" title="image-20250317000035671"><pre class="mermaid">graph LR    subgraph etcd v3 存储        A[客户端请求] --> B[Leader]        B --> C["一致性模块 (Raft)"]        C --> D["预检查 (鉴权, 包大小等)"]        C --> E["配额, 限速, 选主, 日志复制"]        E --> F["写 WAL 日志"]        F --> G["写 raftLog (内存)"]        G --> H["收到半数确认, 更新 MatchIndex, Apply"]        H --> I["MVCC 模块"]        I --> J["treeIndex (内存索引)"]        I --> K["BoltDB (后端存储)"]    end</pre><h2 id="etcd-的-Watch-机制"><a href="#etcd-的-Watch-机制" class="headerlink" title="etcd 的 Watch 机制"></a>etcd 的 Watch 机制</h2><p>etcd v3 的 Watch 机制支持监听特定 key 或范围（模拟目录结构）。每个 WatchableStore 包含两种 watcherGroup：</p><ol><li><strong>synced：</strong> watcher 数据已同步完毕，等待新的变更。</li><li><strong>unsynced：</strong> watcher 数据同步落后于当前最新变更，还在追赶。</li></ol><p>etcd 会启动一个后台 goroutine 持续同步 unsynced 的 watcher，然后将其迁移到 synced 组。</p><img src="/2025/03/13/etcd/image-20250317001558102.png" class="" title="image-20250317001558102"><h2 id="etcd-的高可用方案"><a href="#etcd-的高可用方案" class="headerlink" title="etcd 的高可用方案"></a>etcd 的高可用方案</h2><p>为了确保 etcd 集群的高可用性，通常采用以下方案：</p><ol><li><strong>多节点部署：</strong> 部署 3 个或 5 个 etcd 节点，形成集群。</li><li><strong>故障转移：</strong> 当 Leader 节点故障时，其他节点会通过 Raft 协议选举出新的 Leader。</li><li><strong>数据备份：</strong> 定期创建快照，并将快照上传到网络存储设备，以防数据丢失。</li></ol><p><strong>高可用 etcd 解决方案：</strong></p><ul><li><strong>etcd-operator：</strong> CoreOS 开源的基于 Kubernetes CRD 的 etcd 集群配置工具（已归档）。</li></ul><img src="/2025/03/13/etcd/image-20250317001627420.png" class="" title="image-20250317001627420"><ul><li><strong>Etcd statefulset Helm chart：</strong> Bitnami 提供的 Helm chart，用于在 Kubernetes 上部署高可用 etcd 集群。</li></ul><p><strong>使用 Bitnami Helm chart 安装 etcd 高可用集群（示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 helm</span><br><span class="hljs-comment"># 参考 https://github.com/helm/helm/releases</span><br><br><span class="hljs-comment"># 通过 helm 安装 etcd</span><br>helm repo add bitnami https://charts.bitnami.com/bitnami<br>helm install my-release bitnami/etcd<br></code></pre></td></tr></table></figure><h2 id="etcd-在-Kubernetes-中的应用"><a href="#etcd-在-Kubernetes-中的应用" class="headerlink" title="etcd 在 Kubernetes 中的应用"></a>etcd 在 Kubernetes 中的应用</h2><p>etcd 是 Kubernetes 的后端存储，用于存储集群的所有状态信息。</p><ul><li>对于每一个 Kubernetes Object，都有对应的 <code>storage.go</code> 文件负责对象的存储操作（例如 <code>pkg/registry/core/pod/storage/storage.go</code>）。</li><li>API Server 启动脚本中会指定 etcd servers 集群的地址。</li><li>早期 API server 对 etcd 做简单的 Ping check，现在已经改为真实的 etcd api call。</li></ul><p><strong>Kubernetes 对象在 etcd 中的存储路径示例：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-regexp">/registry/</span>namespaces<span class="hljs-operator">/</span>calico<span class="hljs-operator">-</span>apiserver<br><span class="hljs-regexp">/registry/</span>networkpolicies<span class="hljs-regexp">/calico-apiserver/</span>allow<span class="hljs-operator">-</span>apiserver<br><span class="hljs-regexp">/registry/</span><span class="hljs-keyword">operator</span>.tigera.io<span class="hljs-regexp">/tigerastatuses/</span>apiserver<br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/calico-apiserver/</span>calico<span class="hljs-operator">-</span>apiserver<span class="hljs-operator">-</span>77dffffcdf<span class="hljs-operator">-</span>g2tcx<br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/default/</span>toolbox<span class="hljs-operator">-</span>68f79dd5f8<span class="hljs-operator">-</span>4664n<br></code></pre></td></tr></table></figure><p><strong>Kubernetes 集群中 etcd 的部署拓扑：</strong></p><ol><li><p><strong>堆叠式（Stacked）：</strong> 控制平面和 etcd 成员位于同一节点。</p><ul><li>优点：易于建立和管理。</li><li>缺点：存在耦合失败的风险。</li></ul></li><li><p><strong>外部（External）：</strong> 控制平面和 etcd 成员解耦。</p><ul><li>优点：降低耦合失败的风险。</li><li>缺点：需要更多的主机。</li></ul><img src="/2025/03/13/etcd/image-20250317001643290.png" class="" title="image-20250317001643290"></li></ol><img src="/2025/03/13/etcd/image-20250317001741454.png" class="" title="image-20250317001741454"><img src="/2025/03/13/etcd/image-20250317001746455.png" class="" title="image-20250317001746455"><h2 id="最佳实践和优化"><a href="#最佳实践和优化" class="headerlink" title="最佳实践和优化"></a>最佳实践和优化</h2><ol><li><strong>集群规模：</strong> 建议使用 3 或 5 个 etcd 节点，根据集群规模进行调整。</li><li><strong>网络延迟：</strong> 尽量将 etcd 集群部署在同一地域，减少网络延迟。</li><li><strong>磁盘 I&#x2F;O：</strong> 使用 SSD，并将 etcd 数据存放在单独的磁盘。</li><li><strong>日志文件大小：</strong> 定期创建快照，并设置合理的存储配额。</li><li><strong>历史版本压缩：</strong> 自动压缩历史版本，释放存储空间。</li><li><strong>碎片整理：</strong> 定期消除存储碎片。</li><li><strong>数据备份：</strong> 定期创建快照，并上传到网络存储设备。</li></ol><img src="/2025/03/13/etcd/image-20250317001853663.png" class="" title="image-20250317001853663"><ol><li><strong>参数优化：</strong> 根据网络延迟调整心跳周期和选举超时时间。</li><li><strong>安全性：</strong> 启用 peer 和 client 之间的 TLS 加密，并考虑数据加密。</li><li><strong>事件分离：</strong> 对于大规模集群，可以将事件存储在单独的 etcd 集群中。</li></ol><h2 id="etcd-常见问题与解决方案"><a href="#etcd-常见问题与解决方案" class="headerlink" title="etcd 常见问题与解决方案"></a>etcd 常见问题与解决方案</h2><ol><li><strong>频繁的leader election</strong>： 检查网络，查看是否有丢包现象</li><li><strong>etcd 分裂</strong>：检查集群配置。</li><li><strong>etcd 不响应</strong>： 检查磁盘，网络。</li><li><strong>与apiserver之间的链路阻塞</strong>: 检查客户端并发。</li><li><strong>磁盘暴涨</strong>： 检查是否有大量数据写入。</li><li><strong>少数etcd 成员Down</strong>:  检查 down 掉的 etcd 日志。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的Cgroup</title>
    <link href="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/"/>
    <url>/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/</url>
    
    <content type="html"><![CDATA[<p><strong>cgroup（Control Groups）</strong> 是 Linux 内核中的一项重要功能，用于管理和限制系统资源的使用。它允许用户按照需求对 CPU、内存、I&#x2F;O 等资源进行精细化的控制，从而为容器化技术（如 Docker 和 Kubernetes）提供了基础支持。</p><span id="more"></span><p>Linux 的 cgroup 有两个版本：<strong>cgroup v1</strong> 和 <strong>cgroup v2</strong>。随着 Linux 内核的发展，cgroup v2 在功能和设计上对 v1 做了很多改进。本文将详细探讨 cgroup v1 和 v2 的区别，并提供技术细节和实际应用示例。</p><hr><h2 id="什么是-cgroup？"><a href="#什么是-cgroup？" class="headerlink" title="什么是 cgroup？"></a>什么是 cgroup？</h2><p>cgroup 是 Linux 内核的一项功能，用于：</p><ol><li><strong>资源限制</strong>：限制某些进程可以使用的资源量（如 CPU、内存等）。</li><li><strong>资源优先级</strong>：为不同的进程分配不同的资源优先级。</li><li><strong>资源计费</strong>：跟踪进程使用的资源量。</li><li><strong>进程管理</strong>：将一组进程组织为一个组，并对其统一管理。</li></ol><p>它的主要应用场景包括：</p><ul><li>容器技术（如 Docker、Kubernetes）。</li><li>虚拟化技术。</li><li>系统性能调优。</li></ul><hr><h2 id="cgroup-v1-和-v2-的区别"><a href="#cgroup-v1-和-v2-的区别" class="headerlink" title="cgroup v1 和 v2 的区别"></a>cgroup v1 和 v2 的区别</h2><h3 id="1-文件结构对比"><a href="#1-文件结构对比" class="headerlink" title="1.文件结构对比"></a>1.<strong>文件结构对比</strong></h3><h4 id="cgroup-v1-的文件结构"><a href="#cgroup-v1-的文件结构" class="headerlink" title="cgroup v1 的文件结构"></a>cgroup v1 的文件结构</h4><p>在 cgroup v1 中，每种资源（如 CPU、内存、I&#x2F;O）都有独立的子系统，每个子系统都有自己的目录和控制文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/<br>├── cpu/<br>│   ├── cpu.cfs_quota_us<br>│   ├── cpu.cfs_period_us<br>│   ├── tasks<br>│   └── ...<br>├── memory/<br>│   ├── memory.limit_in_bytes<br>│   ├── memory.usage_in_bytes<br>│   ├── tasks<br>│   └── ...<br>└── blkio/<br>    ├── blkio.throttle.read_bps_device<br>    ├── blkio.throttle.write_bps_device<br>    ├── tasks<br>    └── ...<br></code></pre></td></tr></table></figure><ul><li>每个子系统（如 <code>cpu</code>、<code>memory</code>）管理自己的资源。</li><li>配置文件分散在不同的目录中，容易导致配置冲突。</li></ul><h4 id="cgroup-v2-的文件结构"><a href="#cgroup-v2-的文件结构" class="headerlink" title="cgroup v2 的文件结构"></a>cgroup v2 的文件结构</h4><p>在 cgroup v2 中，所有控制器共享一个统一的层次结构和文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/<br>├── cgroup.controllers<br>├── cgroup.procs<br>├── cgroup.subtree_control<br>├── cpu.max<br>├── memory.max<br>├── io.max<br>└── ...<br></code></pre></td></tr></table></figure><ul><li>统一的文件结构，所有资源控制参数（如 CPU、内存、I&#x2F;O）都在同一目录下。</li><li>减少了配置冲突，更加简洁和高效。</li></ul><hr><h3 id="2-资源控制参数对比"><a href="#2-资源控制参数对比" class="headerlink" title="2. 资源控制参数对比"></a>2. <strong>资源控制参数对比</strong></h3><p>以下是 cgroup v1 和 v2 在资源控制方面的主要参数对比：</p><h4 id="CPU-控制参数"><a href="#CPU-控制参数" class="headerlink" title="CPU 控制参数"></a>CPU 控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>设置 CPU 时间配额</td><td><code>cpu.cfs_quota_us</code></td><td><code>cpu.max</code></td></tr><tr><td>设置 CPU 时间周期</td><td><code>cpu.cfs_period_us</code></td><td><code>cpu.max</code></td></tr><tr><td>设置 CPU 权重（优先级）</td><td><code>cpu.shares</code></td><td><code>cpu.weight</code></td></tr></tbody></table><ul><li>在 cgroup v2 中，<code>cpu.max</code> 替代了 <code>cpu.cfs_quota_us</code> 和 <code>cpu.cfs_period_us</code>，格式为 <code>&lt;quota&gt; &lt;period&gt;</code>。</li><li><code>cpu.weight</code> 替代了 <code>cpu.shares</code>，用于设置 CPU 权重。</li></ul><h4 id="内存控制参数"><a href="#内存控制参数" class="headerlink" title="内存控制参数"></a>内存控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>设置内存上限</td><td><code>memory.limit_in_bytes</code></td><td><code>memory.max</code></td></tr><tr><td>设置内存软限制</td><td><code>memory.soft_limit_in_bytes</code></td><td>不支持</td></tr><tr><td>内存使用量</td><td><code>memory.usage_in_bytes</code></td><td><code>memory.current</code></td></tr></tbody></table><ul><li>cgroup v2 简化了内存控制，废弃了一些复杂的参数（如软限制）。</li></ul><h4 id="I-O-控制参数"><a href="#I-O-控制参数" class="headerlink" title="I&#x2F;O 控制参数"></a>I&#x2F;O 控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>限制读写带宽</td><td><code>blkio.throttle.read_bps_device</code></td><td><code>io.max</code></td></tr><tr><td>限制 IOPS</td><td><code>blkio.throttle.write_iops_device</code></td><td><code>io.max</code></td></tr></tbody></table><ul><li>cgroup v2 使用 <code>io.max</code> 统一配置 I&#x2F;O 带宽和 IOPS 限制。</li></ul><hr><h2 id="控制-CPU-使用率示例："><a href="#控制-CPU-使用率示例：" class="headerlink" title="控制 CPU 使用率示例："></a>控制 CPU 使用率示例：</h2><p>运行以下 Go 程序，会吃掉两个 CPU：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">for</span> &#123;<br>                &#125;<br>        &#125;()<br>        <span class="hljs-keyword">for</span> &#123;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">go build -o busyloop</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./busyloop<br></code></pre></td></tr></table></figure><p>此时运行<code>top</code>命令，会显示 200%CPU 占用。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">PID</span> USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                <br><span class="hljs-attribute">426388</span> cadmin    <span class="hljs-number">20</span>   <span class="hljs-number">0</span>  <span class="hljs-number">702356</span>   <span class="hljs-number">1024</span>    <span class="hljs-number">640</span> R <span class="hljs-number">210</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>:<span class="hljs-number">18</span>.<span class="hljs-number">75</span> busyloop  <br></code></pre></td></tr></table></figure><p>他的 PID 号是<code>426388</code>，我们可以<code>mkdir /sys/fs/cgroup/cpudemo</code>，然后将它添加到<code>cpu.procs</code>中。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-keyword">ps</span> -ef|<span class="hljs-keyword">grep</span> busyloop|<span class="hljs-keyword">grep</span> -v <span class="hljs-keyword">grep</span>|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> &gt; cgroup.procs<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;100000 1000000&quot;</span> &gt; cpu.<span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><p>此时限制 100000&#x2F;1000000 就是使用 10% 的 CPU 了。</p><hr><h2 id="如何检查系统使用的是-cgroup-v1-还是-v2？"><a href="#如何检查系统使用的是-cgroup-v1-还是-v2？" class="headerlink" title="如何检查系统使用的是 cgroup v1 还是 v2？"></a>如何检查系统使用的是 cgroup v1 还是 v2？</h2><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount | grep cgroup<br></code></pre></td></tr></table></figure><ul><li>如果输出中包含 <code>cgroup2</code>，说明系统使用的是 cgroup v2。</li><li>如果输出中包含多个子系统（如 <code>cpu</code>、<code>memory</code> 等），说明使用的是 cgroup v1。</li></ul><hr><h2 id="可视化对比"><a href="#可视化对比" class="headerlink" title="可视化对比"></a>可视化对比</h2><p>以下是 cgroup v1 和 v2 的结构对比：</p><img src="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/image-20250315141042299.png" class="" title="image-20250315141042299"><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft协议</title>
    <link href="/2025/03/13/Raft%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/03/13/Raft%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>Raft 协议是一种分布式一致性协议，主要用于实现多个节点之间的一致性，为系统提供强一致性保证。本文描述了 Raft 的四种角色、选举机制、日志复制机制以及 <code>Learner</code> 角色的用途和场景。</p><span id="more"></span><hr><h3 id="Raft-协议的角色"><a href="#Raft-协议的角色" class="headerlink" title="Raft 协议的角色"></a><strong>Raft 协议的角色</strong></h3><p>在 Raft 协议中，一个节点可以处于以下四个角色之一：</p><ol><li><p><strong>Follower</strong>（跟随者）</p><ul><li>默认状态，每个节点在初始阶段或者重新加入集群时都会处于该状态。</li><li>被动接收来自 Leader 的心跳包（heartbeat）或日志更新请求。</li><li>如果一段时间（<code>Election Timeout</code>）内没有接收到 Leader 的心跳包，会转变为 Candidate。</li></ul></li><li><p><strong>Candidate</strong>（候选者）</p><ul><li>当一个 Follower 超过 <code>Election Timeout</code> 没有接收到心跳包时，会变为 Candidate 并发起选举。</li><li>向其他节点广播请求投票（<code>RequestVote</code>）。</li><li>如果获得超过半数的节点投票，即成为 Leader。</li><li>如果选举超时且没有节点获胜，会重新开始下一轮选举。</li></ul></li><li><p><strong>Leader</strong>（领导者）</p><ul><li>集群中的核心角色，处理客户端请求，管理日志复制并维持系统一致性。</li><li>定期向 Follower 发送心跳包，表明自己是当前的 Leader。</li><li>负责接收并提交客户端的写操作（通过日志复制机制实现）。</li></ul></li><li><p><strong>Learner</strong>（学习者）</p><ul><li>一个特殊角色，负责接收日志更新但不参与选举或投票。</li><li>通常用于读取副本（read-only replica），主要目的是增加系统的容错性和可扩展性。</li><li>在一些场景下，Learner 扮演只读节点的角色，例如为了避免对选举过程产生影响，同时满足读扩展需求。</li></ul></li></ol><hr><h3 id="Raft-的-Leader-选举"><a href="#Raft-的-Leader-选举" class="headerlink" title="Raft 的 Leader 选举"></a><strong>Raft 的 Leader 选举</strong></h3><p>起初，所有节点的状态都是 Follower。每个 Follower 都会设置一个随机的 <code>Election Timeout</code>，当这个时间段内没有收到 Leader 的心跳包时，将会发起选举。选举机制如下：</p><ol><li><p><strong>依次选举：</strong></p><ul><li>某个节点首先触发选举状态，变为 Candidate。</li><li>Candidate 向其他节点广播请求投票的消息（<code>RequestVote</code>）。</li><li>其他节点根据候选者的任期（term）和日志完整性决定是否投票给该候选者。</li><li>如果 Candidate 获得集群中过半数节点的选票，则当选 Leader，并开始发送心跳包。</li></ul></li><li><p><strong>冲突处理：</strong></p><ul><li>如果两个或多个节点同时发起选举，且得票数相同，最终导致没有节点获得多数投票，则会进入下一轮选举。</li><li>在进入下一轮选举时，每个节点会重新设置一个随机的 <code>Election Timeout</code>，从而减少下一次选举冲突的概率。</li></ul></li><li><p><strong>Leader 的权威性：</strong><br>当 Leader 当选后，会定期发送心跳包（<code>AppendEntries</code> RPC）。如果其他节点接收到心跳包，则会重置自己的 Election Timeout，确保不会触发新一轮选举。</p></li></ol><hr><h3 id="Raft-的日志复制机制"><a href="#Raft-的日志复制机制" class="headerlink" title="Raft 的日志复制机制"></a><strong>Raft 的日志复制机制</strong></h3><p>当集群中选出了 Leader 后，Leader 开始接收客户端的请求，并通过日志复制机制（Log Replication）确保所有节点状态一致。</p><h4 id="弱一致性："><a href="#弱一致性：" class="headerlink" title="弱一致性："></a><strong>弱一致性：</strong></h4><ol><li>客户端发送请求到 Leader。</li><li>Leader 将操作记录为日志条目，并将其同步到所有 Follower 节点的日志中。</li><li>一旦操作被写入 Leader 的日志，Leader 会直接向客户端返回确认。</li><li>Leader 后续再通知 Follower 提交（Commit）该日志操作。<ul><li>弱一致性具有较低的延迟，但无法保证所有节点都立即同步完成。</li></ul></li></ol><h4 id="强一致性："><a href="#强一致性：" class="headerlink" title="强一致性："></a><strong>强一致性：</strong></h4><ol><li>客户端发送请求到 Leader。</li><li>Leader 将操作记录到自身的日志，然后将该日志条目复制到 Follower 节点。</li><li>Follower 收到日志条目后，会向 Leader 发送确认（ack）信息。</li><li>当 Leader 收到大多数（过半数）节点的确认后，Leader 可以提交（commit）该日志操作，并将结果返回客户端。<ul><li>通过等待大多数节点的确认，确保一致性（即强一致性）。</li></ul></li></ol><p>总结：为了在不同场景下平衡性能和一致性要求，弱一致性和强一致性可以根据系统需求进行选择。</p><hr><h3 id="为什么需要-Learner？有什么应用场景？"><a href="#为什么需要-Learner？有什么应用场景？" class="headerlink" title="为什么需要 Learner？有什么应用场景？"></a><strong>为什么需要 Learner？有什么应用场景？</strong></h3><h4 id="1-什么是-Learner？"><a href="#1-什么是-Learner？" class="headerlink" title="1. 什么是 Learner？"></a><strong>1. 什么是 Learner？</strong></h4><p>Learner 是 Raft 协议中一个特殊的角色：</p><ul><li>Learner 节点被设计为一个只读节点（Read-Only）。</li><li>Learner 不参与选举过程，也不会被要求投票。</li><li>Learner 只接收 Leader 发送的日志复制数据，只用作数据同步，用于扩展系统的读性能或提升容错性。</li></ul><h4 id="2-Learner-的应用场景："><a href="#2-Learner-的应用场景：" class="headerlink" title="2. Learner 的应用场景："></a><strong>2. Learner 的应用场景：</strong></h4><ul><li><p><strong>非核心节点：</strong><br>在一个分布式系统中，为了扩展读取性能，我们可能希望新增更多副本节点。但这些节点不一定需要参与选举和投票。采用 Learner 角色可以减轻选举过程的压力，并不会直接影响一致性协议的核心流程。</p></li><li><p><strong>数据同步：</strong><br>在分布式存储系统中，某些节点因为距离（比如跨地域部署）或硬件性能问题无法及时响应，但仍需要同步集群的最新日志状态。Learner 可以被用作这样的从属节点。</p></li><li><p><strong>新节点加入：</strong><br>通过 Learner 角色将新节点加入到集群中，可以避免直接参与选举和投票所带来的干扰，并且在数据同步完成后，节点可以变为 Follower 正式加入集群。</p></li><li><p><strong>备份和容灾：</strong><br>Learner 节点可以被用于构建灾备集群。其日志内容与主集群一致，在灾难发生时可以切换为 Leader，以实现数据恢复和服务接管。</p></li><li><p><strong>读扩展：</strong><br>通过增加 Learner 节点，可以显著提升系统的读性能，因为这些节点专用于处理只读请求而不会承担写操作（日志复制除外）。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
