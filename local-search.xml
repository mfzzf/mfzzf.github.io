<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kube_proxy</title>
    <link href="/2025/04/10/kube-proxy/"/>
    <url>/2025/04/10/kube-proxy/</url>
    
    <content type="html"><![CDATA[<h1 id="Kube-proxy-的深度解析"><a href="#Kube-proxy-的深度解析" class="headerlink" title="Kube-proxy 的深度解析"></a>Kube-proxy 的深度解析</h1><h2 id="核心定位与设计目标"><a href="#核心定位与设计目标" class="headerlink" title="核心定位与设计目标"></a>核心定位与设计目标</h2><p>kube-proxy 是 Kubernetes 网络体系的核心组件，本质是<strong>集群服务的智能流量调度器</strong>。它以 <strong>DaemonSet 形式</strong>部署于每个节点，通过监听 API Server 的 Service 和 Endpoints 对象变化，动态维护节点网络规则，实现两大核心功能：<strong>服务发现（将抽象服务名解析为具体后端实例）和负载均衡（智能分配服务流量）</strong>。其设计演进史本质是追求高性能、低延迟、大规模场景适应性的过程。</p><h2 id="底层网络模型演进"><a href="#底层网络模型演进" class="headerlink" title="底层网络模型演进"></a>底层网络模型演进</h2><h3 id="1-Userspace-模式：初代方案的性能困局"><a href="#1-Userspace-模式：初代方案的性能困局" class="headerlink" title="1. Userspace 模式：初代方案的性能困局"></a>1. Userspace 模式：初代方案的性能困局</h3><p>在 userspace 模式下，kube-proxy 通过用户态进程监听随机端口（如 31453），配合 iptables 的 DNAT 规则将服务流量重定向到该端口。进程内部维护轮询队列进行负载均衡，最终通过二次连接建立到实际 Pod 的通道。</p><p><strong>性能缺陷根源</strong>：</p><ul><li>双重上下文切换：数据包需经历<strong>内核态-&gt;用户态-&gt;内核态</strong>的完整路径</li><li>内存拷贝开销：每次转发都需要完整复制数据包内容</li><li>单进程瓶颈：所有流量集中处理，无法利用多核优势</li></ul><p>典型场景下吞吐量下降 50% 以上，时延增加 2-3 倍，仅适用于小规模测试环境。</p><h3 id="2-Iptables-模式：内核加速的代价"><a href="#2-Iptables-模式：内核加速的代价" class="headerlink" title="2. Iptables 模式：内核加速的代价"></a>2. Iptables 模式：内核加速的代价</h3><p>通过完全基于 netfilter 框架实现，kube-proxy 生成 iptables 规则链处理流量。以 ClusterIP 类型服务为例，关键规则链包括：</p><ul><li>KUBE-SERVICES：服务入口匹配</li><li>KUBE-SVC-XXXX：服务负载均衡链</li><li>KUBE-SEP-XXXX：具体 endpoint 转发规则</li></ul><p><strong>性能挑战</strong>：</p><ul><li>规则爆炸问题：每个 Service&#x2F;Endpoint 对应多条规则，500 服务即可产生数万条规则</li><li>全量更新延迟：规则变更需要整体刷新，万级规则时更新延迟可达分钟级</li><li>Conntrack 压力：SNAT 会话跟踪消耗大量内存，极端情况导致丢包</li></ul><p>实测显示 10,000 个服务时，iptables 模式新增规则耗时可达 5 分钟，且存在 30% 以上的转发性能衰减。</p><h3 id="3-IPVS-模式：生产级负载均衡方案"><a href="#3-IPVS-模式：生产级负载均衡方案" class="headerlink" title="3. IPVS 模式：生产级负载均衡方案"></a>3. IPVS 模式：生产级负载均衡方案</h3><p>基于 Linux 内核的 LVS（Linux Virtual Server）实现，通过 netlink 接口操作 IPVS 规则。核心优势体现在：</p><ul><li>哈希表存储规则：O(1) 时间复杂度查找，万级服务无性能衰减</li><li>增量式更新：仅修改变化部分，规则更新毫秒级完成</li><li>丰富调度算法：支持 rr&#x2F;wrr&#x2F;lc&#x2F;wlc&#x2F;ip_hash 等 10 余种算法</li><li>连接保持优化：通过 sh-port 等 flags 实现会话保持</li></ul><p><strong>关键技术实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/proxy/ipvs/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ln *linuxNetworking)</span></span> setupIPVSService(svc *ipvs.Service, bindAddr <span class="hljs-type">string</span>, port <span class="hljs-type">int</span>, protocol <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 使用 netlink 与内核 IPVS 子系统交互</span><br>    _, err := ln.ipvsHandle.NewService(svc)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;error creating IPVS service: %v&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>IPVS 模式在万级服务规模下仍能保持微秒级转发延迟，比 iptables 模式提升 10 倍以上的规则处理效率。 </p><h2 id="生产环境选型建议"><a href="#生产环境选型建议" class="headerlink" title="生产环境选型建议"></a>生产环境选型建议</h2><h3 id="性能基准对比"><a href="#性能基准对比" class="headerlink" title="性能基准对比"></a>性能基准对比</h3><table><thead><tr><th>模式</th><th>万规则更新时延</th><th>并发连接能力</th><th>CPU 消耗</th><th>内存占用</th></tr></thead><tbody><tr><td>Userspace</td><td>N&#x2F;A</td><td>1k</td><td>高</td><td>高</td></tr><tr><td>Iptables</td><td>5min</td><td>10k</td><td>中高</td><td>高</td></tr><tr><td>IPVS</td><td>100ms</td><td>100k+</td><td>低</td><td>低</td></tr></tbody></table><h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><ol><li>内核要求：确保 Linux 内核 ≥4.15 并加载 ip_vs 相关模块</li><li>算法选择：默认 rr 轮询，有状态服务建议 sh 源地址哈希</li><li>配合 CNI：Calico&#x2F;Cilium 等插件需开启 IPVS 兼容模式</li><li>监控重点：关注 ipvs_connections 等指标，防范 SNAT 端口耗尽</li></ol><h2 id="架构演进启示"><a href="#架构演进启示" class="headerlink" title="架构演进启示"></a>架构演进启示</h2><p>从 userspace 到 IPVS 的演进路径，体现了 Kubernetes 网络模型从功能实现到生产可用的成熟过程。IPVS 模式通过内核级数据路径、零拷贝转发、增量更新等机制，完美解决了大规模微服务架构下的四层负载均衡需求。未来 eBPF 技术的引入（如 Cilium 方案）可能带来新一轮性能革命，但 IPVS 仍是当前生产环境最稳健的选择。</p><h1 id="Netfilter-框架深度解析"><a href="#Netfilter-框架深度解析" class="headerlink" title="Netfilter 框架深度解析"></a>Netfilter 框架深度解析</h1><img src="/2025/04/10/kube-proxy/image-20250410103718455.png" class="" title="image-20250410103718455"><p>Netfilter 是 Linux 内核中一个强大而灵活的网络数据包处理框架。它不仅仅是防火墙的基础，更是许多高级网络功能（如网络地址转换 NAT、数据包修改、连接跟踪）的核心。在云原生时代，理解 Netfilter 对于深入掌握 Kubernetes 网络（例如 kube-proxy 的 iptables 模式、CNI 插件如 Calico 的网络策略实现）至关重要。</p><h2 id="Iptables-与-Netfilter-的关系：用户空间与内核空间的协作"><a href="#Iptables-与-Netfilter-的关系：用户空间与内核空间的协作" class="headerlink" title="Iptables 与 Netfilter 的关系：用户空间与内核空间的协作"></a>Iptables 与 Netfilter 的关系：用户空间与内核空间的协作</h2><img src="/2025/04/10/kube-proxy/image-20250412130128351.png" class="" title="image-20250412130128351"><p>首先需要明确，<code>iptables</code> 和 <code>Netfilter</code> 并非同一事物，而是紧密协作的用户空间工具与内核空间框架的关系。<code>iptables</code> 是一个运行在用户空间的命令行工具，它允许系统管理员定义<strong>网络数据包的处理规则（例如允许、拒绝、修改数据包）</strong>。然而，<code>iptables</code> 本身并不直接执行这些规则。它扮演的是一个“规则配置器”的角色，将用户定义的规则翻译并加载到 Linux 内核中。</p><p>真正负责在网络协议栈中执行这些规则的是 <code>Netfilter</code> 框架。<code>Netfilter</code> 在内核的网络协议栈的关键路径上预设了一系列“钩子”（Hooks）。当网络数据包流经协议栈时，会触发这些钩子。内核模块（包括 <code>iptables</code> 相关的内核模块，如 <code>ip_tables</code>, <code>iptable_filter</code>, <code>iptable_nat</code> 等）可以通过 <code>Netfilter</code> 提供的接口，在这些钩子上注册自己的处理函数。当钩子被触发时，注册在此钩子上的函数会按照预设的优先级顺序被调用，对数据包进行检查、修改、放行或丢弃等操作。因此，<code>iptables</code> 定义策略，<code>Netfilter</code> 提供执行点和机制，两者结合实现了对网络流量的精细控制。</p><h2 id="Netfilter-Hooks：内核网络栈的关键切入点"><a href="#Netfilter-Hooks：内核网络栈的关键切入点" class="headerlink" title="Netfilter Hooks：内核网络栈的关键切入点"></a>Netfilter Hooks：内核网络栈的关键切入点</h2><img src="/2025/04/10/kube-proxy/image-20250412130500507.png" class="" title="image-20250412130500507"><p><code>Netfilter</code> 为 IPv4 协议栈定义了五个核心的钩子点（Hooks）。这些钩子点战略性地分布在数据包处理流程的关键位置，允许内核模块在不同阶段介入数据包的处理。数据包触发哪个钩子，取决于它的流向（流入、流出、转发）、目的地（本机或其它主机）以及它在前一个钩子处理后的状态（例如是否被接受）。</p><p>以下是 Linux 内核中定义的五个主要 IPv4 Netfilter 钩子点（定义在 <code>&lt;linux/netfilter_ipv4.h&gt;</code>）：</p><ul><li><strong>NF_IP_PRE_ROUTING:</strong> 这是数据包进入网络协议栈后遇到的第一个钩子。它在数据包刚刚通过基本的完整性检查（如 IP 头校验和、版本号验证）之后，但在进行任何路由决策之前触发。这是**执行目的地址转换（DNAT）**或进行早期包过滤&#x2F;检查的理想位置。</li><li><strong>NF_IP_LOCAL_IN:</strong> 当数据包经过路由决策，确定其最终目的地是本机时，在将数据包传递给上层协议（如 TCP&#x2F;UDP）之前，会触发此钩子。这是对访问本机服务的数据包进行**过滤（Filter 表的 INPUT 链）**的主要场所。</li><li><strong>NF_IP_FORWARD:</strong> 如果数据包经过路由决策，发现其目的地并非本机，而是需要<strong>转发到其他网络接口</strong>，那么在转发操作实际执行前会触发此钩子。这是实现防火墙转发规则（Filter 表的 FORWARD 链）的核心位置。</li><li><strong>NF_IP_LOCAL_OUT:</strong> 由本机应用程序产生、准备发送出去的数据包，在进入网络协议栈进行处理时，会立即触发此钩子。这发生在路由决策之前，是进行输出过滤（Filter 表的 OUTPUT 链）或早期修改（如标记）的地方。</li><li><strong>NF_IP_POST_ROUTING:</strong> 无论是本机产生的需要发送的数据包，还是需要转发的数据包，在经过最终的路由决策、即将被发送到网络接口之前，都会触发此钩子。这是**执行源地址转换（SNAT）或进行最后的数据包修改（Mangle）**的理想位置。</li></ul><p>内核模块在向 <code>Netfilter</code> 注册处理函数时，必须指定一个优先级（priority）。这使得当同一个钩子点有多个模块注册函数时，<code>Netfilter</code> 能够按照明确的顺序（优先级数值越小，越先执行）调用它们。每个处理函数执行完毕后，会返回一个状态码（如 <code>NF_ACCEPT</code>, <code>NF_DROP</code>, <code>NF_STOLEN</code>, <code>NF_QUEUE</code>, <code>NF_REPEAT</code>）给 <code>Netfilter</code> 框架，指示框架应该如何处理当前的数据包（接受、丢弃、模块已接管、送入用户空间队列、重新处理等）。</p><img src="/2025/04/10/kube-proxy/image-20250412130714279.png" class="" title="image-20250412130714279"><h2 id="Hooks、Tables-与-Chains：规则的组织结构"><a href="#Hooks、Tables-与-Chains：规则的组织结构" class="headerlink" title="Hooks、Tables 与 Chains：规则的组织结构"></a>Hooks、Tables 与 Chains：规则的组织结构</h2><p><code>iptables</code> 为了更好地组织和管理规则，引入了“表”（Table）和“链”（Chain）的概念。</p><p><strong>Tables</strong> 代表了不同类型的规则处理逻辑，主要有以下五种：</p><ul><li><strong>Filter Table (<code>filter</code>):</strong> 这是最常用、也是默认的表。其核心功能是进行数据包过滤，即决定是否允许一个数据包通过。它包含了 <code>INPUT</code>, <code>FORWARD</code>, <code>OUTPUT</code> 三个内建链。</li><li><strong>NAT Table (<code>nat</code>):</strong> 用于网络地址转换（Network Address Translation）。当数据包首次进入协议栈（<code>PREROUTING</code> 链，用于 DNAT）或即将离开时（<code>POSTROUTING</code> 链，用于 SNAT），以及某些特定场景下的输出包（<code>OUTPUT</code> 链，用于本地进程访问外部服务的 SNAT&#x2F;DNAT），此表中的规则会被触发，用于修改数据包的源或目的 IP 地址和端口，常用于实现内网访问外网、端口映射等。</li><li><strong>Mangle Table (<code>mangle</code>):</strong> 用于修改 IP 数据包的头部字段（如 TOS&#x2F;DSCP 服务质量标记、TTL 生存时间）或设置内核内部使用的标记（<code>MARK</code>）。这些修改可以影响后续的路由决策、流量控制或其他基于标记的处理。它可以在所有五个钩子点进行操作。</li><li><strong>Raw Table (<code>raw</code>):</strong> 这个表优先级非常高（在 <code>PREROUTING</code> 和 <code>OUTPUT</code> 钩子触发），其主要目的是提供一个机制，允许数据包“绕过” <code>Netfilter</code> 的连接跟踪（Connection Tracking）系统。通过在 <code>raw</code> 表中设置 <code>NOTRACK</code> 目标，可以显著降低某些场景下（如处理大量无状态短连接）的系统负载。</li><li><strong>Security Table (<code>security</code>):</strong> 主要用于与 Linux 安全模块（如 SELinux）集成。它允许基于安全策略为数据包或连接打上安全标记（<code>SECMARK</code>, <code>CONNSECMARK</code>），这些标记可以被 SELinux 或其他支持安全上下文的系统用于强制访问控制。它在 <code>filter</code> 表之后执行。</li></ul><p>在每个 Table 内部，规则被组织成<strong>Chains</strong>。Chain 是一系列按顺序排列的规则。<code>iptables</code> 有两种类型的 Chain：内建链（Built-in Chains）和自定义链（User-defined Chains）。内建链直接与 <code>Netfilter</code> 的钩子相关联，当相应的钩子被触发时，内核会遍历该链中的规则。</p><p>内建链与 Netfilter 钩子的对应关系，以及各 Table 在哪些链上注册，构成了数据包处理的完整路径：</p><ul><li><strong>PREROUTING Chain:</strong> 由 <code>NF_IP_PRE_ROUTING</code> 钩子触发。流经此链的 Table (按优先级顺序)：<code>raw</code>, <code>mangle</code>, <code>nat</code> (主要用于 DNAT)。</li><li><strong>INPUT Chain:</strong> 由 <code>NF_IP_LOCAL_IN</code> 钩子触发。流经此链的 Table：<code>mangle</code>, <code>filter</code>, <code>security</code>, <code>nat</code> (较少见，用于特定场景的源 NAT)。</li><li><strong>FORWARD Chain:</strong> 由 <code>NF_IP_FORWARD</code> 钩子触发。流经此链的 Table：<code>mangle</code>, <code>filter</code>, <code>security</code>。</li><li><strong>OUTPUT Chain:</strong> 由 <code>NF_IP_LOCAL_OUT</code> 钩子触发。流经此链的 Table：<code>raw</code>, <code>mangle</code>, <code>nat</code> (用于本地进程发起的连接的 DNAT&#x2F;SNAT), <code>filter</code>, <code>security</code>。</li><li><strong>POSTROUTING Chain:</strong> 由 <code>NF_IP_POST_ROUTING</code> 钩子触发。流经此链的 Table：<code>mangle</code>, <code>nat</code> (主要用于 SNAT)。</li></ul><p>这个结构使得管理员能够精确控制在数据包处理流程的哪个阶段应用何种类型的策略。例如，NAT 操作通常需要在路由决策之前（DNAT）或之后（SNAT）进行，而过滤操作则主要发生在路由决策之后的目的地判断点（INPUT、FORWARD）或本地发出时（OUTPUT）。</p><img src="/2025/04/10/kube-proxy/1.jpg" class="" title="image"><p><em>图片展示了数据包流经不同 Hook 点时，会依次经过哪些 Table 的哪些 Chain。</em></p><h2 id="从-Linux-IP-协议栈深入理解-Netfilter"><a href="#从-Linux-IP-协议栈深入理解-Netfilter" class="headerlink" title="从 Linux IP 协议栈深入理解 Netfilter"></a>从 Linux IP 协议栈深入理解 Netfilter</h2><p>要真正掌握 <code>Netfilter</code> 的工作原理，我们需要深入理解 Linux 内核处理 IP 数据包的流程。<code>Netfilter</code> 的钩子正是嵌入在这个流程中的。</p><img src="/2025/04/10/kube-proxy/2.jpg" class="" title="image"><p><em>简化的 Linux IP 协议栈数据包接收路径示意图</em></p><h3 id="数据包接收流程概述"><a href="#数据包接收流程概述" class="headerlink" title="数据包接收流程概述"></a>数据包接收流程概述</h3><ol><li><p><strong>硬件接收与中断:</strong> 当网卡（NIC）接收到一个目的 MAC 地址匹配本机或为广播&#x2F;多播地址的以太网帧时，它会将数据通过 DMA (Direct Memory Access) 传输到内存中的预分配缓冲区（Ring Buffer）。传输完成后，网卡会向 CPU 发出一个硬件中断信号。</p></li><li><p><strong>中断处理程序 (ISR - Interrupt Service Routine):</strong> CPU 响应该中断，暂停当前任务，跳转执行该网卡驱动注册的中断处理程序。ISR 的主要工作是快速响应硬件，通常会：</p><ul><li>禁用网卡中断（防止中断风暴）。</li><li>分配一个内核数据结构 <code>sk_buff</code> (Socket Buffer) 来表示这个数据包。<code>sk_buff</code> 是 Linux 网络栈中表示网络数据包的核心结构，包含了数据本身以及大量的元数据（如协议类型、接口信息、时间戳、路由结果等）。</li><li>调用网卡驱动的特定函数，将 DMA 缓冲区中的数据拷贝到 <code>sk_buff</code> 中，并更新 Ring Buffer 的状态。</li><li>调用与协议无关的网络设备接收函数 <code>netif_rx()</code> 或其变体（如 <code>napi_gro_receive()</code>）。</li></ul></li><li><p><strong><code>netif_rx()</code> 与 NAPI:</strong> <code>netif_rx()</code> 将 <code>sk_buff</code> 添加到 CPU 的 backlog 队列，并触发一个 <code>NET_RX_SOFTIRQ</code> 软中断。为了提高性能并避免中断风暴，现代驱动普遍使用 NAPI (New API)。在 NAPI 模式下，ISR 只需禁用中断并触发软中断，实际的数据包处理（分配 <code>sk_buff</code>、拷贝数据）被推迟到软中断上下文中，由 <code>napi_poll()</code> 函数批量处理。</p></li><li><p><strong>软中断处理 (<code>NET_RX_SOFTIRQ</code>):</strong> 内核调度器在适当的时候（通常是中断返回或内核线程调度时）会检查并执行挂起的软中断。<code>ksoftirqd</code> 内核线程也会在系统负载较高时帮助处理软中断。处理 <code>NET_RX_SOFTIRQ</code> 的核心函数是 <code>net_rx_action()</code>。它会从 backlog 队列或 NAPI 的 poll 列表中取出 <code>sk_buff</code>，然后根据 <code>sk_buff-&gt;protocol</code> 字段（由驱动根据以太网帧类型设置）将其分发给相应的 L3 协议处理函数。例如，IP 包会交给 <code>ip_rcv()</code> 处理，ARP 包交给 <code>arp_rcv()</code> 处理。</p></li></ol><h3 id="IPv4-数据包处理与-Netfilter-Hooks"><a href="#IPv4-数据包处理与-Netfilter-Hooks" class="headerlink" title="IPv4 数据包处理与 Netfilter Hooks"></a>IPv4 数据包处理与 Netfilter Hooks</h3><img src="/2025/04/10/kube-proxy/3.jpg" class="" title="image"><p><em>IP 层处理流程与 Netfilter Hooks 的嵌入点</em></p><ol><li><p><strong><code>ip_rcv()</code> - 初始处理与 <code>NF_IP_PRE_ROUTING</code>:</strong></p><ul><li><code>ip_rcv()</code> 函数是 IP 层处理接收到的数据包的入口。它首先会对 IP 头部进行基本的验证，如版本号、头部长度、总长度、校验和等。</li><li>如果验证通过，紧接着，数据包会经过 <strong><code>NF_IP_PRE_ROUTING</code></strong> 钩子。所有注册在此钩子上的 <code>Netfilter</code> 处理函数（来自 <code>raw</code>, <code>mangle</code>, <code>nat</code> 表）会依次执行。这是进行 DNAT 或早期过滤&#x2F;修改的关键点。</li><li>如果 <code>Netfilter</code> 函数返回 <code>NF_DROP</code>，数据包处理流程终止。如果返回 <code>NF_ACCEPT</code>，则继续。</li></ul></li><li><p><strong><code>ip_rcv_finish()</code> - 路由决策:</strong></p><ul><li>通过 <code>NF_IP_PRE_ROUTING</code> 钩子后，数据包进入 <code>ip_rcv_finish()</code>。此函数的核心任务是进行路由查找，决定数据包的下一跳。它会调用 <code>ip_route_input_slow()</code>（或其快速路径缓存）来查询路由表。</li><li>路由查找的结果会填充到 <code>skb-&gt;dst</code> (destination cache entry) 结构中，该结构包含了路由决策的全部信息，包括下一跳地址、输出设备、以及指向后续处理函数的指针（如 <code>dst-&gt;input</code> 和 <code>dst-&gt;output</code>）。</li></ul></li><li><p><strong>根据路由结果分发:</strong></p><ul><li><strong>目的为本机 (<code>dst-&gt;input == ip_local_deliver</code>):</strong> 如果路由查找确定数据包的目的 IP 是本机的某个地址，<code>dst_input(skb)</code> 最终会调用 <code>ip_local_deliver()</code>。<ul><li><strong><code>ip_local_deliver()</code> 与 <code>NF_IP_LOCAL_IN</code>:</strong> 在将数据包传递给更上层的协议（如 TCP 的 <code>tcp_v4_rcv</code> 或 UDP 的 <code>udp_rcv</code>）之前，<code>ip_local_deliver()</code> 会首先调用 <code>ip_local_deliver_finish()</code>，在这里会触发 <strong><code>NF_IP_LOCAL_IN</code></strong> 钩子。注册在此钩子上的 <code>Netfilter</code> 处理函数（来自 <code>mangle</code>, <code>filter</code>, <code>security</code>, <code>nat</code> 表）会被执行，主要用于对访问本机服务的数据包进行过滤。</li></ul></li><li><strong>需要转发 (<code>dst-&gt;input == ip_forward</code>):</strong> 如果路由查找确定数据包需要被转发到另一个网络接口，<code>dst_input(skb)</code> 最终会调用 <code>ip_forward()</code>。<ul><li><strong><code>ip_forward()</code> 与 <code>NF_IP_FORWARD</code>:</strong> <code>ip_forward()</code> 函数负责处理数据包的转发逻辑。在进行必要的检查（如 TTL 检查）之后，它会调用 <code>ip_forward_finish()</code>，在这里会触发 <strong><code>NF_IP_FORWARD</code></strong> 钩子。注册在此钩子上的 <code>Netfilter</code> 处理函数（来自 <code>mangle</code>, <code>filter</code>, <code>security</code> 表）会被执行，用于对转发的数据包进行过滤和修改。</li><li><strong>TTL 递减与 MTU 处理:</strong> 在 <code>ip_forward()</code> 过程中，IP 头部的 TTL 值会被减 1。如果 TTL 变为 0，数据包会被丢弃，并可能发送 ICMP Time Exceeded 消息。如果数据包大小超过了出口设备的 MTU 且允许分片，还会进行 IP 分片。</li></ul></li><li><strong>多播处理 (<code>dst-&gt;input == ip_mr_input</code>):</strong> 如果是多播数据包且本机配置了多播路由，会进入多播转发流程。</li></ul></li><li><p><strong>数据包发送路径与 <code>NF_IP_LOCAL_OUT</code> 和 <code>NF_IP_POST_ROUTING</code>:</strong></p><ul><li><strong>本地产生的数据包 (<code>ip_queue_xmit</code>):</strong> 当本地应用程序通过 Socket API 发送数据时，数据会逐层向下传递（例如 TCP -&gt; IP）。在 IP 层，<code>ip_queue_xmit()</code> 或类似函数负责构建 IP 头部并准备发送。<ul><li><strong><code>NF_IP_LOCAL_OUT</code>:</strong> 在 <code>ip_queue_xmit()</code> 内部，构建完 IP 头并进行初步路由查找（确定源地址和出口设备等）之后，会触发 <strong><code>NF_IP_LOCAL_OUT</code></strong> 钩子。注册在此钩子上的 <code>Netfilter</code> 处理函数（来自 <code>raw</code>, <code>mangle</code>, <code>nat</code>, <code>filter</code>, <code>security</code> 表）会被执行，用于对本地产生的数据包进行处理。</li></ul></li><li><strong>最终路由与 <code>NF_IP_POST_ROUTING</code>:</strong> 无论是本地产生的包还是需要转发的包，在最终确定所有 IP 头部字段（特别是经过了可能的 NAT 修改后）、选定出口网络设备，即将调用邻居子系统（ARP 或 NDP）解析下一跳 MAC 地址并将数据包传递给设备驱动程序之前，都会通过 <code>ip_output()</code>（单播）或 <code>ip_mc_output()</code>（多播）等函数，最终触发 <strong><code>NF_IP_POST_ROUTING</code></strong> 钩子。注册在此钩子上的 <code>Netfilter</code> 处理函数（来自 <code>mangle</code>, <code>nat</code> 表）会被执行。这是执行 SNAT 或进行最后修改的理想位置。</li><li><strong><code>dst_output()</code>:</strong> 最终，<code>dst_output(skb)</code> 函数会调用 <code>skb-&gt;dst-&gt;output</code> 指针指向的函数（如 <code>ip_output</code>），它会调用 <code>ip_finish_output()</code>，后者将 <code>sk_buff</code> 交给邻居子系统（<code>neigh_output</code>）和网络设备驱动进行 L2 封装和物理发送。</li></ul></li></ol><img src="/2025/04/10/kube-proxy/5.jpg" class="" title="kube"><p><em>TCP 层发送路径示意图，显示了数据包向下传递至 IP 层的过程，最终也会触发 Netfilter 的 OUT&#x2F;POSTROUTING 钩子。</em></p><h2 id="Netfilter-Hook-函数的注册与实现细节"><a href="#Netfilter-Hook-函数的注册与实现细节" class="headerlink" title="Netfilter Hook 函数的注册与实现细节"></a>Netfilter Hook 函数的注册与实现细节</h2><p><code>Netfilter</code> 框架的核心在于允许内核模块动态地注册和注销钩子处理函数。这使得内核的功能可以灵活扩展，而无需修改核心代码。</p><h3 id="注册和注销-Netfilter-Hook"><a href="#注册和注销-Netfilter-Hook" class="headerlink" title="注册和注销 Netfilter Hook"></a>注册和注销 Netfilter Hook</h3><p>注册一个钩子处理函数主要依赖于 <code>struct nf_hook_ops</code> 结构和 <code>nf_register_net_hook()</code> &#x2F; <code>nf_unregister_net_hook()</code> (或者针对特定网络命名空间的版本 <code>nf_register_hook</code> &#x2F; <code>nf_unregister_hook</code>) 函数。</p><p><code>struct nf_hook_ops</code> 结构定义在 <code>&lt;linux/netfilter.h&gt;</code> 中，其关键成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">list</span>;</span>       <span class="hljs-comment">// 用于将 ops 链入 Netfilter 内部链表，内核管理</span><br><br>    <span class="hljs-comment">/* User fills in from here down. */</span><br>    nf_hookfn           *hook;      <span class="hljs-comment">// 指向实际处理数据包的函数指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span>       *<span class="hljs-title">owner</span>;</span>     <span class="hljs-comment">// 指向拥有此 hook 的内核模块，用于引用计数</span><br>    <span class="hljs-type">u_int8_t</span>            pf;         <span class="hljs-comment">// 协议族 (Protocol Family)，如 PF_INET (IPv4), PF_INET6 (IPv6), PF_BRIDGE (桥接)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        hooknum;    <span class="hljs-comment">// 指定要挂载的钩子点，如 NF_IP_PRE_ROUTING</span><br>    <span class="hljs-comment">/* Hooks are ordered in ascending priority. */</span><br>    <span class="hljs-type">int</span>                 priority;   <span class="hljs-comment">// 钩子函数的优先级，数值越小越先执行。内核定义了一些标准优先级，如 NF_IP_PRI_FIRST, NF_IP_PRI_FILTER, NF_IP_PRI_NAT_DST, NF_IP_PRI_NAT_SRC, NF_IP_PRI_LAST 等。</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>list</code>：此成员由Netfilter框架内部管理，用于将注册的<code>nf_hook_ops</code>组织成链表。对于在同一协议族（<code>pf</code>）和同一挂接点（<code>hooknum</code>）注册的多个hook函数，内核正是通过遍历这个链表来依次调用它们的。模块开发者在注册时无需关心此字段。</li><li><code>hook</code>：这是一个函数指针，指向类型为<code>nf_hookfn</code>的函数。这正是你的模块提供的核心处理逻辑，当匹配的网络数据包经过指定的<code>hooknum</code>时，内核将调用此函数。<code>nf_hookfn</code>的函数原型我们稍后会详细解析。</li><li><code>owner</code>：通常设置为<code>THIS_MODULE</code>宏，用于内核的模块引用计数管理。当模块被卸载时，内核可以通过这个指针自动注销其注册的hooks，防止出现悬挂指针导致系统崩溃。虽然示例代码中设置为<code>NULL</code>，但在生产级代码中，正确设置<code>owner</code>是保证系统稳定性的重要实践。</li><li><code>pf</code>：指定此hook函数适用的协议族（Protocol Family）。常见的协议族定义在<code>linux/socket.h</code>中，例如<code>PF_INET</code>代表IPv4协议栈，<code>PF_INET6</code>代表IPv6，<code>PF_BRIDGE</code>用于网桥等。你的hook函数只会处理属于指定协议族的数据包。</li><li><code>hooknum</code>：这明确了你的hook函数要挂载到Netfilter处理流程中的哪个具体位置。对于IPv4 (<code>PF_INET</code>)，这些挂接点（如<code>NF_INET_PRE_ROUTING</code>, <code>NF_INET_LOCAL_IN</code>, <code>NF_INET_FORWARD</code>, <code>NF_INET_LOCAL_OUT</code>, <code>NF_INET_POST_ROUTING</code>）定义在<code>linux/netfilter_ipv4.h</code>中，它们对应了数据包在内核中处理的不同阶段。</li><li><code>priority</code>：定义了在同一挂接点（<code>hooknum</code>）上注册的多个hook函数之间的执行优先级。优先级是一个整数，数值越小，优先级越高，越先被执行。内核提供了一系列预定义的优先级常量，例如<code>NF_IP_PRI_FIRST</code>（最高优先级）、<code>NF_IP_PRI_CONNTRACK</code>、<code>NF_IP_PRI_NAT_DST</code>、<code>NF_IP_PRI_FILTER</code>、<code>NF_IP_PRI_NAT_SRC</code>、<code>NF_IP_PRI_LAST</code>（最低优先级）等，定义在<code>linux/netfilter_ipv4.h</code>的<code>nf_ip_hook_priorities</code>枚举中。选择合适的优先级对于确保你的hook函数在正确的时机（例如，在NAT转换之前或之后）执行至关重要。</li></ol><p>要将你定义的<code>nf_hook_ops</code>结构体实例注册到Netfilter框架中，你需要调用<code>nf_register_net_hook()</code>函数（或者在较新内核中推荐使用针对特定netns的<code>nf_register_net_hook()</code>，如果你的模块需要感知网络命名空间的话；对于简单的全局hook，<code>nf_register_hook()</code>是一个历史接口，现在通常封装了<code>nf_register_net_hook(&amp;init_net, ops)</code>）。此函数接受一个指向<code>nf_hook_ops</code>结构体的指针作为参数。注册成功，你的hook函数就会成为内核网络处理流程的一部分。相应地，当你的内核模块卸载时，必须调用<code>nf_unregister_net_hook()</code>（或<code>nf_unregister_hook()</code>）并传入相同的<code>nf_hook_ops</code>结构体指针，以将其从Netfilter框架中移除，释放资源并避免潜在的错误。</p><p>下面的示例代码演示了这一注册与注销过程。它注册了一个简单的hook函数，挂载在IPv4协议栈的<code>NF_INET_LOCAL_OUT</code>挂接点（即本机进程发出的数据包在路由决策之后、发送到网络接口之前的位置），并赋予其最高优先级(<code>NF_IP_PRI_FIRST</code>)。该hook函数的实现极为简单粗暴：直接返回<code>NF_DROP</code>，这意味着所有经由此挂接点的IPv4数据包都将被丢弃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/version.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/skbuff.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter_ipv4.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ip.h&gt;</span> <span class="hljs-comment">// Include for iphdr structure access if needed later</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;xsc&quot;</span>);<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nf_hook_ops</span> <span class="hljs-title">nfho</span>;</span><br><br><span class="hljs-comment">// The hook function itself</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hook_func</span><span class="hljs-params">(<span class="hljs-type">void</span> *priv, <span class="hljs-comment">// priv is unused in this simplified example, corresponds to nf_hook_ops</span></span><br><span class="hljs-params">                       <span class="hljs-keyword">struct</span> sk_buff *skb,</span><br><span class="hljs-params">                       <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> nf_hook_state *state)</span> <span class="hljs-comment">// Modern prototype uses nf_hook_state</span><br>&#123;<br>    <span class="hljs-comment">// In older kernels or simpler contexts, the prototype might be:</span><br>    <span class="hljs-comment">// unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb,</span><br>    <span class="hljs-comment">//                        const struct net_device *in, const struct net_device *out,</span><br>    <span class="hljs-comment">//                        int (*okfn)(struct sk_buff *))</span><br><br>    printk(KERN_INFO <span class="hljs-string">&quot;Packet dropped by example hook!\n&quot;</span>); <span class="hljs-comment">// Good practice to log actions</span><br>    <span class="hljs-keyword">return</span> NF_DROP; <span class="hljs-comment">// Discard the packet</span><br>    <span class="hljs-comment">// Other possible return values:</span><br>    <span class="hljs-comment">// NF_ACCEPT: Continue processing the packet normally.</span><br>    <span class="hljs-comment">// NF_STOLEN: The hook function has taken ownership of the packet (e.g., queued it for userspace),</span><br>    <span class="hljs-comment">//            Netfilter should stop processing it.</span><br>    <span class="hljs-comment">// NF_QUEUE: Queue the packet for userspace processing (used by tools like iptables -j QUEUE).</span><br>    <span class="hljs-comment">// NF_REPEAT: Call this hook function again (use with caution).</span><br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">kexec_test_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;kexec test module loading...\n&quot;</span>);<br><br>    nfho.hook = hook_func;<br>    <span class="hljs-comment">// nfho.owner = THIS_MODULE; // Recommended practice</span><br>    nfho.pf = PF_INET;                   <span class="hljs-comment">// Target IPv4 protocol family</span><br>    nfho.hooknum = NF_INET_LOCAL_OUT;    <span class="hljs-comment">// Hook at the local output stage</span><br>    nfho.priority = NF_IP_PRI_FIRST;     <span class="hljs-comment">// Execute with the highest priority</span><br><br>    <span class="hljs-comment">// Register the hook for the initial network namespace</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 13, 0)</span><br>    <span class="hljs-type">int</span> ret = nf_register_net_hook(&amp;init_net, &amp;nfho);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">int</span> ret = nf_register_hook(&amp;nfho); <span class="hljs-comment">// Older kernel registration</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to register Netfilter hook: %d\n&quot;</span>, ret);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;Netfilter hook registered successfully.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Success</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">kexec_test_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;kexec test module unloading...\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(4, 13, 0)</span><br>    nf_unregister_net_hook(&amp;init_net, &amp;nfho);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    nf_unregister_hook(&amp;nfho); <span class="hljs-comment">// Older kernel unregistration</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    printk(KERN_INFO <span class="hljs-string">&quot;Netfilter hook unregistered.\n&quot;</span>);<br>&#125;<br><br>module_init(kexec_test_init); <span class="hljs-comment">// Register the init function</span><br>module_exit(kexec_test_exit); <span class="hljs-comment">// Register the exit function</span><br><br></code></pre></td></tr></table></figure><p><em>(Note: The provided example code was slightly adjusted for better practice (logging, <code>THIS_MODULE</code>, modern registration API), but kept the core logic as requested. The original prototype of the hook function is also mentioned for context.)</em></p><h3 id="Hook函数的实现细节"><a href="#Hook函数的实现细节" class="headerlink" title="Hook函数的实现细节"></a>Hook函数的实现细节</h3><p>理解<code>nf_hookfn</code>的原型对于编写有效的Netfilter hook至关重要。虽然原型在不同内核版本中略有演变，但核心传递的信息保持一致。我们来看一个常见的（略旧但更易于解释基础概念的）原型，定义在<code>linux/netfilter.h</code>：</p><C><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nf_hookfn</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hooknum,<span class="hljs-keyword">struct</span> sk_buff *skb,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> net_device *in,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> net_device *out,<span class="hljs-type">int</span> (*okfn)(<span class="hljs-keyword">struct</span> sk_buff *))</span>;<br></code></pre></td></tr></table></figure><p><em>(较新内核倾向于使用 <code>nf_hookfn(void \*priv, struct sk_buff \*skb, const struct nf_hook_state \*state)</code>，其中<code>state</code>结构体封装了<code>hooknum</code>, <code>in</code>, <code>out</code>, <code>sk</code>等信息，<code>priv</code>通常指向注册时<code>nf_hook_ops</code>结构体本身)</em></p><p>让我们解析这个原型中的参数：</p><ul><li><code>hooknum</code>: 这个无符号整数明确告知hook函数当前是在哪个Netfilter挂接点被调用的（例如 <code>NF_INET_PRE_ROUTING</code>）。这使得一个函数可以服务于多个挂接点，并根据<code>hooknum</code>执行不同的逻辑。</li><li><code>skb</code>: 这是指向<code>struct sk_buff</code>的指针，是Linux内核中表示网络数据包的核心数据结构。<code>sk_buff</code>（Socket Buffer）不仅仅包含数据包的原始负载，还携带了大量的元数据，如协议头指针、路由信息、时间戳、关联的socket等。访问和操作<code>skb</code>是Netfilter hook函数进行包检查和修改的基础。</li><li><code>in</code>: 指向<code>struct net_device</code>的指针，代表数据包进入系统的网络接口。这个参数<strong>仅在数据包是接收路径上的特定挂接点</strong>（如<code>NF_INET_PRE_ROUTING</code>, <code>NF_INET_LOCAL_IN</code>）才有意义，此时它指向接收该数据包的物理或虚拟网络设备。在其他挂接点（如<code>NF_INET_LOCAL_OUT</code>, <code>NF_INET_POST_ROUTING</code>），<code>in</code>通常为<code>NULL</code>。</li><li><code>out</code>: 同样是指向<code>struct net_device</code>的指针，代表数据包计划离开系统的网络接口。这个参数<strong>仅在数据包是发送路径上的特定挂接点</strong>（如<code>NF_INET_LOCAL_OUT</code>, <code>NF_INET_POST_ROUTING</code>）才有意义，指向数据包将被发送出去的网络设备。在接收相关的挂接点，<code>out</code>通常为<code>NULL</code>。理解<code>in</code>和<code>out</code>的有效性取决于<code>hooknum</code>是至关重要的。</li><li><code>okfn</code>: 这是一个函数指针，原型为<code>int (*okfn)(struct sk_buff *)</code>。在某些复杂的Netfilter场景（尤其是在旧版本或特定子系统中），它指向下一个应该处理该数据包的函数或决策点。然而，在大多数现代的、简单的过滤场景下，hook函数的行为主要由其返回值（如 <code>NF_ACCEPT</code>, <code>NF_DROP</code>）决定，<code>okfn</code>的使用并不普遍，可以直接忽略。</li></ul><h3 id="Netfilter-报文过滤技术实现"><a href="#Netfilter-报文过滤技术实现" class="headerlink" title="Netfilter 报文过滤技术实现"></a>Netfilter 报文过滤技术实现</h3><p>Netfilter 构成了 Linux 内核网络栈的核心部分，它提供了一套强大的钩子（Hooks）机制，允许内核模块在数据包流经网络协议栈的关键路径点上注册回调函数，从而实现对数据包的检查、修改、丢弃或重新注入等操作。报文过滤是 Netfilter 最为经典和广泛的应用之一，诸如 iptables、nftables 等用户空间工具正是基于 Netfilter 框架来实现防火墙功能的。接下来，我们将深入探讨几种基于 Netfilter 实现报文过滤的具体技术途径。</p><h4 id="基于网络接口的过滤"><a href="#基于网络接口的过滤" class="headerlink" title="基于网络接口的过滤"></a>基于网络接口的过滤</h4><p>在网络数据包的处理流程中，识别数据包的来源或目的地网络接口是一项基本的过滤需求。Linux 内核中使用 <code>struct net_device</code> 结构来抽象表示一个网络接口（如 eth0, lo 等）。每个流经网络栈的数据包都由一个 <code>struct sk_buff</code> (skb) 结构体表示，该结构体内部包含了指向相关网络设备的指针，通常是 <code>skb-&gt;dev</code>，它指向数据包接收或即将发送的 <code>struct net_device</code>。因此，在 Netfilter 的钩子函数中（例如注册在 <code>NF_INET_PRE_ROUTING</code> 或 <code>NF_INET_LOCAL_IN</code> 钩子点），我们可以访问这个 <code>skb-&gt;dev</code> 指针，并进一步读取其 <code>name</code> 成员，这是一个包含了接口名称（如 “eth0”）的字符串。通过将此名称与我们预设的过滤规则中的接口名进行比较，就可以实现基于接口的过滤策略。例如，如果我们的策略是阻止所有进入 “eth0” 接口的数据包，那么在钩子函数中，当检测到 <code>skb-&gt;dev-&gt;name</code> 与 “eth0” 匹配时，函数直接返回 <code>NF_DROP</code> 即可。这个返回值会通知 Netfilter 框架立即丢弃该数据包，并释放相关的 <code>sk_buff</code> 资源，数据包将不再继续在网络栈中传递。</p><h4 id="基于-IP-地址的过滤"><a href="#基于-IP-地址的过滤" class="headerlink" title="基于 IP 地址的过滤"></a>基于 IP 地址的过滤</h4><p>基于源或目的 IP 地址进行过滤是防火墙最核心的功能之一。Netfilter 同样为此提供了便捷的实现方式。<code>sk_buff</code> 结构体中包含了指向各层协议头部的指针。网络层（IP层）的头部指针可以通过 <code>skb-&gt;network_header</code> 访问，或者更常用的方式是使用内核提供的辅助宏 <code>ip_hdr(skb)</code> 来获取指向 <code>struct iphdr</code>（定义于 <code>&lt;linux/ip.h&gt;</code>）的指针。这个结构体详细定义了 IPv4 报头的所有字段，包括源 IP 地址 (<code>saddr</code>) 和目的 IP 地址 (<code>daddr</code>)。需要注意的是，这些地址在内存中是以网络字节序（Big Endian）存储的。在 Netfilter 钩子函数中，我们可以提取出这些地址字段，并将其与过滤规则中定义的特定 IP 地址或地址范围进行比较（比较时通常需要使用 <code>ntohl()</code> 等函数将网络字节序转换为主机字节序，或者直接以网络字节序进行比较）。如果数据包的源地址或目的地址满足了我们设定的丢弃条件（例如，阻止来自某个特定恶意 IP 的所有连接请求），钩子函数便返回 <code>NF_DROP</code>，从而实现对该数据包的精确过滤。</p><h4 id="基于-TCP-端口的过滤"><a href="#基于-TCP-端口的过滤" class="headerlink" title="基于 TCP 端口的过滤"></a>基于 TCP 端口的过滤</h4><p>当需要进行更细粒度的控制，例如阻止对特定服务端口的访问时，就需要深入到传输层进行过滤。对于 TCP 协议而言，这意味着我们需要检查 TCP 头部中的源端口和目的端口。在 Netfilter 钩子函数中，这通常发生在确认了数据包是 IP 包（通过检查 <code>iphdr</code>）并且其协议字段 (<code>iph-&gt;protocol</code>) 指示为 <code>IPPROTO_TCP</code> 之后。要获取 TCP 头部的指针，我们需要知道 IP 头部的实际长度，因为 IP 头部可能包含选项，长度并非固定。<code>struct iphdr</code> 中的 <code>ihl</code> (Internet Header Length) 字段表示 IP 头部的长度，但其单位是 4 字节（32位字）。因此，TCP 头部的起始位置可以通过将 IP 头部指针（<code>iph</code>）加上 IP 头部的字节长度（<code>iph-&gt;ihl * 4</code>）来计算得到。获取到指向 <code>struct tcphdr</code>（定义于 <code>&lt;linux/tcp.h&gt;</code>）的指针后，我们就可以访问其成员，如源端口 (<code>source</code>) 和目的端口 (<code>dest</code>)。这些端口号同样是以网络字节序存储的。下面的代码片段展示了一个简单的示例，演示了如何在 Netfilter 钩子函数中检查 TCP 目的端口，并在端口号为 25 (SMTP 服务的默认端口) 时丢弃数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/netfilter_ipv4.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/skbuff.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">check_tcp_packet_hook</span><span class="hljs-params">(<span class="hljs-type">void</span> *priv,</span><br><span class="hljs-params">                                          <span class="hljs-keyword">struct</span> sk_buff *skb,</span><br><span class="hljs-params">                                          <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> nf_hook_state *state)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span> *<span class="hljs-title">tcph</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span> =</span> <span class="hljs-literal">NULL</span>;<br>    __be16 dport;<br><br>    <span class="hljs-comment">// skb 为空则直接接受，虽然理论上 Netfilter 不应传递空 skb</span><br>    <span class="hljs-keyword">if</span> (!skb) &#123;<br>        <span class="hljs-keyword">return</span> NF_ACCEPT;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取 IP 头部指针</span><br>    iph = ip_hdr(skb);<br>    <span class="hljs-comment">// 检查是否为 NULL 以及是否为 IPv4 包（通常在注册钩子时已指定协议族）</span><br>    <span class="hljs-keyword">if</span> (!iph) &#123;<br>        <span class="hljs-keyword">return</span> NF_ACCEPT;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查 IP 协议字段是否为 TCP</span><br>    <span class="hljs-keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP) &#123;<br>        <span class="hljs-comment">// 计算 TCP 头部的起始位置</span><br>        <span class="hljs-comment">// 注意：这里直接使用 iph 指针，因为 ip_hdr(skb) 返回的就是 skb-&gt;network_header</span><br>        <span class="hljs-comment">// (void *)iph + iph-&gt;ihl * 4 是计算 TCP 头地址的标准方式</span><br>        tcph = (<span class="hljs-keyword">struct</span> tcphdr *)((__u8 *)iph + (iph-&gt;ihl * <span class="hljs-number">4</span>));<br><br>        <span class="hljs-comment">// skb-&gt;transport_header 可能未被设置，或者我们需要处理 IP 选项等复杂情况，</span><br>        <span class="hljs-comment">// 直接计算偏移量是更可靠的方式。</span><br>        <span class="hljs-comment">// 还需要确保 skb 足够长，包含完整的 TCP 头，这里为简化省略了长度检查。</span><br><br>        <span class="hljs-comment">// 获取 TCP 目的端口 (网络字节序)</span><br>        dport = tcph-&gt;dest;<br><br>        <span class="hljs-comment">// 将目的端口从网络字节序转换为主机字节序进行比较</span><br>        <span class="hljs-keyword">if</span> (ntohs(dport) == <span class="hljs-number">25</span>) &#123;<br>            printk(KERN_INFO <span class="hljs-string">&quot;Dropping TCP packet to port 25\n&quot;</span>); <span class="hljs-comment">// 日志记录，便于调试</span><br>            <span class="hljs-keyword">return</span> NF_DROP; <span class="hljs-comment">// 丢弃目标端口为 25 的 TCP 包</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果端口不是 25，则接受该 TCP 包</span><br>            <span class="hljs-keyword">return</span> NF_ACCEPT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果不是 TCP 包，则接受（根据具体策略可能需要调整）</span><br>    <span class="hljs-keyword">return</span> NF_ACCEPT;<br>&#125;<br><br><span class="hljs-comment">// 注意：实际使用中需要将此函数注册到 Netfilter 钩子点，例如：</span><br><span class="hljs-comment">// static struct nf_hook_ops tcp_filter_hook_ops = &#123;</span><br><span class="hljs-comment">//     .hook     = check_tcp_packet_hook,</span><br><span class="hljs-comment">//     .pf       = NFPROTO_IPV4,</span><br><span class="hljs-comment">//     .hooknum  = NF_INET_PRE_ROUTING, // 或者其他合适的钩子点</span><br><span class="hljs-comment">//     .priority = NF_IP_PRI_FIRST,    // 优先级</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">// 在模块初始化时 nf_register_net_hook(&amp;init_net, &amp;tcp_filter_hook_ops);</span><br><span class="hljs-comment">// 在模块退出时 nf_unregister_net_hook(&amp;init_net, &amp;tcp_filter_hook_ops);</span><br></code></pre></td></tr></table></figure><p>在这个示例代码 <code>check_tcp_packet_hook</code>（调整了函数签名以匹配 Netfilter 钩子原型）中，我们首先通过 <code>ip_hdr(skb)</code> 获取 IP 头指针 <code>iph</code>。然后，检查 <code>iph-&gt;protocol</code> 是否等于 <code>IPPROTO_TCP</code>。如果是 TCP 包，就通过 IP 头长度 <code>iph-&gt;ihl * 4</code> 计算出 TCP 头 <code>tcphdr</code> 的地址。接着，提取目的端口 <code>tcph-&gt;dest</code>，并使用 <code>ntohs()</code> 将其从网络字节序转换为主机字节序。最后，将转换后的端口号与 25 进行比较，如果相等，则返回 <code>NF_DROP</code> 丢弃该包；否则，返回 <code>NF_ACCEPT</code> 允许该包继续传递。对于非 TCP 包或者不满足丢弃条件的 TCP 包，函数默认返回 <code>NF_ACCEPT</code>。这种基于传输层端口的过滤能力，使得我们可以对特定的网络服务进行精细化的访问控制。</p><h2 id="Kube-Proxy-工作原理"><a href="#Kube-Proxy-工作原理" class="headerlink" title="Kube-Proxy 工作原理"></a>Kube-Proxy 工作原理</h2><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2025/04/10/kube-proxy/image-20250412133507210.png" class="" title="image-20250412133507210"></h4><h3 id="kube-proxy-的核心职责与解决的问题"><a href="#kube-proxy-的核心职责与解决的问题" class="headerlink" title="kube-proxy 的核心职责与解决的问题"></a>kube-proxy 的核心职责与解决的问题</h3><p>在 Kubernetes 集群中，<strong>Pod 是短暂的，它们的 IP 地址会随着 Pod 的创建和销毁而改变</strong>。然而，应用程序（无论是集群内部的客户端还是外部的客户端）需要一个稳定的方式来访问这些可能不断变化的 Pod 集合提供的服务。这就是 Kubernetes <code>Service</code> 对象解决的问题，它提供了一个稳定的虚拟 IP（ClusterIP）和端口，作为访问后端 Pod 的入口。</p><p><code>kube-proxy</code> 正是实现 <code>Service</code> 概念的关键组件。它并不是传统意义上的用户空间代理（尽管它曾经有过 userspace 模式，但现在已不常用且效率低下），而是一个运行在每个 Node 上的网络代理和负载均衡器。它的核心职责是 <strong>监视（watch）<code>kube-apiserver</code> 上关于 <code>Service</code> 和 <code>Endpoints</code> (或更现代的 <code>EndpointSlice</code>) 对象的变化，并将这些变化转化为节点本地的网络规则</strong>，从而确保发送到 Service IP 的流量能够被正确地路由和负载均衡到后端健康的 Pod 上。简而言之，<code>kube-proxy</code> 让 Service 的虚拟 IP 地址真正“可用”。</p><h3 id="工作原理解析-iptables-模式"><a href="#工作原理解析-iptables-模式" class="headerlink" title="工作原理解析 (iptables 模式)"></a>工作原理解析 (iptables 模式)</h3><ol><li><p><strong>信息获取</strong>: <code>kube-proxy</code> 作为一个客户端，持续地通过 List-Watch 机制与 <code>kube-apiserver</code> 通信。它关注 <code>Service</code> 对象的创建、更新和删除，以及与之关联的 <code>Endpoints</code> 或 <code>EndpointSlice</code> 对象的变化。<code>Endpoints</code> 对象记录了构成一个 <code>Service</code> 的所有后端 Pod 的实际 IP 地址和端口。</p></li><li><p><strong>规则生成</strong>: 当 <code>kube-proxy</code> 检测到变化时（例如，一个新的 Service 被创建，或者一个 Pod 变成 Ready 状态并被添加到 Service 的 Endpoints 中），它会在其所在的 Node 上修改网络规则。在 <code>iptables</code> 模式下，它主要利用 Linux 内核的 <code>netfilter</code> 框架，通过操作 <code>iptables</code> 规则来实现 Service 的虚拟 IP 和端口到后端 Pod IP 和端口的转换。</p></li><li><p><strong>规则内容</strong>: 图中的 <code>IPtables</code> 云状图形内部标注了 <code>ServiceIP rule</code>, <code>NodePort rule</code>, <code>LB IP rule</code>，这代表了 <code>kube-proxy</code> 生成的主要规则类型：</p><ul><li><strong>ServiceIP rule</strong>: 这是针对 <code>ClusterIP</code> 类型 Service 的核心规则。当一个数据包的目的地址是某个 Service 的 ClusterIP 和端口时，<code>iptables</code> 规则（通常位于 <code>nat</code> 表的 <code>PREROUTING</code> 链用于处理节点外部流量，<code>OUTPUT</code> 链用于处理节点内部发起的流量）会执行 <strong>DNAT (Destination Network Address Translation)</strong>。它会从该 Service 对应的健康 Endpoints 列表中选择一个 Pod 的 IP 和端口，并将数据包的目标地址修改为选中的 Pod IP 和端口。同时，它会利用 <code>iptables</code> 的模块（如 <code>statistic</code> 模式的 <code>random</code> 或 <code>nth</code>）来实现简单的负载均衡（默认是随机选择）。</li><li><strong>NodePort rule</strong>: 对于 <code>NodePort</code> 类型的 Service，除了上述 ClusterIP 的规则外，<code>kube-proxy</code> 还会配置 <code>iptables</code> 规则来监听在所有节点（或指定节点）上的特定端口（NodePort）。当外部流量访问 <code>NodeIP:NodePort</code> 时，<code>iptables</code> 规则（同样在 <code>nat</code> 表的 <code>PREROUTING</code> 链）会进行 DNAT，将流量转发给一个后端 Pod。</li><li><strong>LB IP rule</strong>: 对于 <code>LoadBalancer</code> 类型的 Service，云服务商提供的外部负载均衡器（图中的 <code>Load Balancer</code>）通常会将流量导向集群中节点的 <code>NodePort</code>。因此，<code>kube-proxy</code> 产生的 <code>NodePort</code> 规则间接支持了 <code>LoadBalancer</code> 服务。此外，<code>kube-proxy</code> 也会处理直接发送到分配给 Service 的外部 IP (LoadBalancer Ingress IP) 的流量（如果这个 IP 的流量被路由到了节点上），同样通过 DNAT 转发到后端 Pod。</li></ul></li><li><p><strong>流量转发</strong>:</p><ul><li><strong>Internal Client</strong>: 集群内部的 Pod（图中的 <code>Internal client</code>）访问 Service 时，流量的目的地址是 Service 的 ClusterIP。如果该 Pod 与目标 Pod 在同一节点，流量可能经过 <code>OUTPUT</code> 链的 <code>iptables</code> 规则进行 DNAT；如果不在同一节点，流量发出后到达目标 Pod 所在节点，经过 <code>PREROUTING</code> 链的 <code>iptables</code> 规则进行 DNAT，最终被转发到选定的 <code>Backend pod</code>（如 Pod 1, Pod 2, Pod 3）。</li><li><strong>External Client</strong>: 外部客户端访问 <code>NodePort</code> 或 <code>LoadBalancer</code> IP 时，流量首先到达某个 Node。节点上的 <code>iptables</code> 规则（<code>PREROUTING</code> 链）捕获该流量，执行 DNAT，将其重定向到后端 Pod。</li></ul></li></ol><h2 id="Kube-proxy-与-iptables-模式概述"><a href="#Kube-proxy-与-iptables-模式概述" class="headerlink" title="Kube-proxy 与 iptables 模式概述"></a>Kube-proxy 与 iptables 模式概述</h2><p>在 Kubernetes 集群中，Service 提供了一个稳定的访问入口（虚拟 IP 地址 ClusterIP 和端口），用于访问后端一组动态变化的 Pod。<code>kube-proxy</code> 是运行在每个 Node 上的一个关键组件，它的核心职责之一就是实现 Service 的概念。当 <code>kube-proxy</code> 配置为 <code>iptables</code> 模式时（这是早期和广泛使用的一种模式），它会监听 Kubernetes API Server 关于 Service 和 Endpoint (Pod IP + Port) 的变化，并将这些信息转化为 Linux 内核 Netfilter 子系统中的 <code>iptables</code> 规则。这些规则共同作用，拦截发往 Service IP 的流量，并将其负载均衡地转发到后端健康的 Pod 上。其核心思想是利用 <code>iptables</code> 的 DNAT（Destination Network Address Translation）和 SNAT（Source Network Address Translation，通常通过 MASQUERADE 实现）功能，结合用户自定义的 chain 来管理复杂的转发逻辑。</p><h3 id="来自其他主机的请求：PREROUTING-链的处理"><a href="#来自其他主机的请求：PREROUTING-链的处理" class="headerlink" title="来自其他主机的请求：PREROUTING 链的处理"></a>来自其他主机的请求：PREROUTING 链的处理</h3><p>当一个网络数据包从集群外部或者集群内的另一个节点（“其他主机”）发送到当前节点，并且其目标是本节点上的某个 Service 时，这个数据包首先会经过 Linux 内核网络栈的 <code>PREROUTING</code> 链。这是 Netfilter 框架在进行路由决策 <em>之前</em> 处理数据包的第一个钩子点。<code>kube-proxy</code> 在 <code>nat</code> 表的 <code>PREROUTING</code> 链中插入了一条或多条规则。</p><p>这些规则会检查数据包的目标 IP 和端口。如果数据包的目标是某个 Service 的 ClusterIP 和端口，或者目标是本节点的 IP 加上某个 Service 暴露的 NodePort，那么这个数据包就会被匹配到。根据你图示的逻辑，入口通常会跳转（<code>JUMP</code>）到 <code>KUBE-SERVICES</code> 这个自定义链。<code>KUBE-SERVICES</code> 链是 <code>kube-proxy</code> 管理 Service 规则的总入口。</p><h3 id="KUBE-SERVICES-链：Service-的分发中心"><a href="#KUBE-SERVICES-链：Service-的分发中心" class="headerlink" title="KUBE-SERVICES 链：Service 的分发中心"></a>KUBE-SERVICES 链：Service 的分发中心</h3><p><code>KUBE-SERVICES</code> 链扮演着一个分发中心的角色。它包含了一系列的规则，每一条规则对应一个 Kubernetes Service。</p><ul><li>如果数据包的目标是某个 Service 的 ClusterIP (<code>-d clusterIP</code>)，<code>iptables</code> 规则会直接将这个数据包跳转到该 Service 对应的具体处理链，通常命名为 <code>KUBE-SVC-&lt;service_hash&gt;</code>。</li><li>如果数据包的目标是当前节点的 IP 且目标端口是某个 Service 暴露的 NodePort (<code>--dport nodePort</code>)，<code>iptables</code> 规则会先跳转到 <code>KUBE-NODEPORTS</code> 链。</li></ul><h3 id="KUBE-NODEPORTS-链：处理-NodePort-类型的-Service"><a href="#KUBE-NODEPORTS-链：处理-NodePort-类型的-Service" class="headerlink" title="KUBE-NODEPORTS 链：处理 NodePort 类型的 Service"></a>KUBE-NODEPORTS 链：处理 NodePort 类型的 Service</h3><p><code>KUBE-NODEPORTS</code> 链专门处理通过 NodePort 访问的流量。它内部也包含对应各个 NodePort Service 的规则。对于匹配到的 NodePort 流量，通常会执行两个关键动作：</p><ol><li>跳转到 <code>KUBE-MARK-MASQ</code> 链。这个链的作用是给数据包打上一个特殊的 Netfilter 标记（mark），通常是 <code>0x4000</code>。这个标记非常重要，它向后续的 <code>POSTROUTING</code> 链表明这个数据包需要进行源地址伪装（SNAT&#x2F;Masquerade）。这么做的原因是，当数据包经过 DNAT 转发给 Pod 后，如果不修改源 IP，Pod 回复数据包时会直接发给原始客户端 IP。如果客户端在集群外部，且 Pod IP 是私有地址，这个回复可能无法正确路由回去。通过 Masquerade 将源 IP 改为 Node 的 IP，可以确保回复流量能正确返回到 Node，Node 再根据连接跟踪记录转发给原始客户端。</li><li>跳转到该 NodePort Service 对应的 ClusterIP Service 处理链，即 <code>KUBE-SVC-&lt;service_hash&gt;</code>。这样，无论是通过 ClusterIP 还是 NodePort 访问，最终都会汇聚到同一个 Service 处理逻辑中。</li></ol><h3 id="KUBE-SVC-hash-链：实现负载均衡"><a href="#KUBE-SVC-hash-链：实现负载均衡" class="headerlink" title="KUBE-SVC-hash 链：实现负载均衡"></a>KUBE-SVC-hash 链：实现负载均衡</h3><p><code>KUBE-SVC-&lt;service_hash&gt;</code> 链负责将流量分发到 Service 后端的多个 Pod (Endpoints)。这里的 <code>&lt;service_hash&gt;</code> 是根据 Service 名称和命名空间等信息计算出的唯一标识。<br>在此链中，<code>kube-proxy</code> 会为每个健康的 Endpoint 创建一条对应的规则，并根据 Service 的配置（例如 <code>sessionAffinity</code>）以及 <code>kube-proxy</code> 的负载均衡策略（图中显示为 <code>--mode random</code>）来决定如何选择 Endpoint。<br>在 <code>random</code> 模式下，会使用 <code>statistic</code> 模块和概率（<code>--probability</code>）来实现随机负载均衡。如果有 N 个 Endpoints，每个 Endpoint 对应的规则会有大约 <code>1/N</code> 的概率被选中。选中的规则会跳转到该 Endpoint 对应的处理链，通常命名为 <code>KUBE-SEP-&lt;endpoint_hash&gt;</code>（SEP 代表 Service EndPoint）。</p><h3 id="KUBE-SEP-hash-链：执行-DNAT"><a href="#KUBE-SEP-hash-链：执行-DNAT" class="headerlink" title="KUBE-SEP-hash 链：执行 DNAT"></a>KUBE-SEP-hash 链：执行 DNAT</h3><p><code>KUBE-SEP-&lt;endpoint_hash&gt;</code> 链是最终执行地址转换的地方。这里的 <code>&lt;endpoint_hash&gt;</code> 是根据具体 Pod IP 和端口计算的哈希。<br>此链包含的关键规则是：</p><ol><li>（可选但常见）再次跳转到 <code>KUBE-MARK-MASQ</code> 链。这是为了确保即使流量是直接访问 ClusterIP（例如来自集群内部其他 Pod），如果这个 Service 配置了某些需要 SNAT 的策略（比如 <code>externalTrafficPolicy: Cluster</code> 时，来自外部的流量被转发到其他节点上的 Pod），或者某些 CNI 插件需要，也可能需要打上 Masquerade 标记。</li><li>执行 <code>DNAT</code> 操作。这条规则使用 <code>DNAT</code> target，将数据包的目标 IP 和端口修改为选定 Endpoint 的实际 Pod IP 和 <code>targetPort</code> (<code>--to-destination &lt;pod_ip&gt;:&lt;pod_port&gt;</code>)。</li></ol><p>完成 DNAT 后，数据包的目标地址就变成了具体的 Pod IP。内核会根据新的目标地址重新进行路由决策，并将数据包转发给目标 Pod。</p><h3 id="本地-Pod-发起的请求：OUTPUT-链的处理"><a href="#本地-Pod-发起的请求：OUTPUT-链的处理" class="headerlink" title="本地 Pod 发起的请求：OUTPUT 链的处理"></a>本地 Pod 发起的请求：OUTPUT 链的处理</h3><p>当集群内的一个 Pod（本地 Pod）尝试访问同一个节点上的或其他节点上的 Service 时，其发出的数据包会经过该节点内核网络栈的 <code>OUTPUT</code> 链。这是在路由决策之后，针对本地进程产生的数据包的钩子点。<code>kube-proxy</code> 同样在 <code>nat</code> 表的 <code>OUTPUT</code> 链中插入了规则。这些规则与 <code>PREROUTING</code> 中的类似，会检查数据包的目标是否为 Service 的 ClusterIP 和端口。如果匹配，数据包同样会被跳转到 <code>KUBE-SERVICES</code> 链，然后经历与外部请求类似的处理流程：<code>KUBE-SERVICES</code> -&gt; <code>KUBE-SVC-&lt;hash&gt;</code> -&gt; <code>KUBE-SEP-&lt;hash&gt;</code> -&gt; <code>DNAT</code>。</p><h3 id="POSTROUTING-链与-Masquerade：确保返回路径"><a href="#POSTROUTING-链与-Masquerade：确保返回路径" class="headerlink" title="POSTROUTING 链与 Masquerade：确保返回路径"></a>POSTROUTING 链与 Masquerade：确保返回路径</h3><p>当数据包经过路由决策，确定要从哪个网络接口发出时，它会经过 <code>POSTROUTING</code> 链。这是 Netfilter 在数据包即将离开本机前的最后一个钩子点。<code>kube-proxy</code> 在 <code>nat</code> 表的 <code>POSTROUTING</code> 链中插入规则，通常是跳转到 <code>KUBE-POSTROUTING</code> 链。<br><code>KUBE-POSTROUTING</code> 链的核心作用是处理之前被打上标记的数据包。它包含一条关键规则：</p><ul><li>匹配之前在 <code>KUBE-MARK-MASQ</code> 链中设置的标记 (<code>-m mark --mark 0x4000/0x4000</code>)。</li><li>对匹配的数据包执行 <code>MASQUERADE</code> target。<code>MASQUERADE</code> 是一种特殊的 SNAT，它会自动将数据包的源 IP 地址替换为数据包发出时选择的网络接口的 IP 地址。这对于源 IP 地址是动态分配（如 Node IP 可能变化）或者需要隐藏内部 Pod IP 的场景非常有用。</li></ul><p>这样，经过 DNAT 转发给 Pod 的数据包，在离开节点（无论是发往外部客户端还是集群内其他节点上的 Pod）之前，其源 IP 会被修改为节点的 IP。这确保了响应数据包能够正确地路由回该节点，节点再根据其连接跟踪（conntrack）表将响应转发给原始的请求者（无论是外部客户端还是集群内的 Pod）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kubernetes 利用 <code>iptables</code> 实现 Service 的机制，本质上是将 Linux 内核强大的 Netfilter&#x2F;iptables 功能自动化、规模化地应用于服务发现和负载均衡场景。通过在 <code>PREROUTING</code>、<code>OUTPUT</code>、<code>POSTROUTING</code> 等关键 Netfilter 钩子点注入精心设计的规则链 (<code>KUBE-SERVICES</code>, <code>KUBE-NODEPORTS</code>, <code>KUBE-SVC-*</code>, <code>KUBE-SEP-*</code>, <code>KUBE-MARK-MASQ</code>, <code>KUBE-POSTROUTING</code>)，<code>kube-proxy</code> 实现了将对稳定虚拟 Service IP 的请求，透明地、负载均衡地（例如随机）重定向（DNAT）到后端动态变化的 Pod IP，并通过标记（mark）和地址伪装（Masquerade&#x2F;SNAT）确保了网络连接在各种复杂场景下（如跨节点访问、NodePort 访问）的双向通信路径正确无误。这套机制虽然规则数量可能庞大，性能在超大规模集群下有挑战，但它稳定、可靠，并且不依赖任何特殊的网络硬件或协议，具有良好的兼容性。</p><h2 id="IPVS-模式"><a href="#IPVS-模式" class="headerlink" title="IPVS 模式"></a>IPVS 模式</h2><img src="/2025/04/10/kube-proxy/image-20250415103628349.png" class="" title="image-20250415103628349"><h3 id="服务发现与负载均衡的挑战"><a href="#服务发现与负载均衡的挑战" class="headerlink" title="服务发现与负载均衡的挑战"></a>服务发现与负载均衡的挑战</h3><p>在 Kubernetes 这样动态的环境中，Pod 的生命周期是短暂的，它们的 IP 地址会随着创建和销毁而改变。如果让客户端直接连接 Pod IP，那么当 Pod 发生变化时，客户端就需要感知并更新连接信息，这极大地增加了系统的复杂性。Service 的引入正是为了解决这个问题，它提供了一个稳定的访问点。<code>kube-proxy</code> 则需要将这个稳定的访问点（Service IP）动态地映射到当前提供服务的、健康的 Pod IP 列表上，并进行负载均衡。早期的 <code>userspace</code> 模式性能较差，后来广泛使用的 <code>iptables</code> 模式虽然功能稳定，但在集群规模（Service 数量、Endpoint 数量）非常大时，会因为 <code>iptables</code> 规则链的线性查找特性而遇到性能瓶颈。</p><h3 id="IPVS-模式：基于内核的-L4-负载均衡"><a href="#IPVS-模式：基于内核的-L4-负载均衡" class="headerlink" title="IPVS 模式：基于内核的 L4 负载均衡"></a>IPVS 模式：基于内核的 L4 负载均衡</h3><p>IPVS（IP Virtual Server）是 Linux 内核的一部分，属于 LVS（Linux Virtual Server）项目。它实现了一个高性能的、工作在 OSI 模型第四层（传输层）的负载均衡器。与 <code>iptables</code> 基于规则链匹配、逐条检查的方式不同，IPVS 使用哈希表（Hash Table）来存储和查找虚拟服务器（Virtual Server）和真实服务器（Real Server）的映射关系。当有数据包到达时，IPVS 可以通过高效的哈希查找（接近 O(1) 复杂度）快速确定目标真实服务器，这使得它在处理大量并发连接和规则时，性能远超 <code>iptables</code>（其复杂度可能接近 O(n)，n 为规则数量）。IPVS 被设计用来处理大规模的服务器负载均衡场景，因此非常适合用在大型 Kubernetes 集群中。</p><h3 id="kube-proxy-IPVS-模式工作原理"><a href="#kube-proxy-IPVS-模式工作原理" class="headerlink" title="kube-proxy IPVS 模式工作原理"></a>kube-proxy IPVS 模式工作原理</h3><img src="/2025/04/10/kube-proxy/image-20250415104221941.png" class="" title="image-20250415104221941"><p>当 <code>kube-proxy</code> 配置为 IPVS 模式时，它的工作流程大致如下：</p><ol><li><p><strong>监听 API Server:</strong> <code>kube-proxy</code> 通过 watch 机制持续监听 API Server 中 Service 和 Endpoints&#x2F;EndpointSlices 对象的创建、更新和删除事件。</p></li><li><p><strong>调用内核 IPVS 接口:</strong> 当检测到 Service 或 Endpoints 变化时，<code>kube-proxy</code> 不再是去生成大量的 <code>iptables</code> 规则，而是通过 <code>netlink</code> 接口与 Linux 内核的 IPVS 模块进行交互。<code>netlink</code> 是一种用于用户空间程序与内核空间模块之间进行通信的机制。</p></li><li><p><strong>创建 IPVS 规则:</strong></p><ul><li>对于每一个 Kubernetes Service（目前主要支持 ClusterIP 和 NodePort 类型的 Service），<code>kube-proxy</code> 会在宿主机内核中创建一个对应的 IPVS <em>虚拟服务器</em>（Virtual Server）。这个虚拟服务器的地址和端口就是 Service 的 ClusterIP 和 Port（或者 NodePort 的监听地址和端口）。</li><li>对于该 Service 关联的每一个健康的 Endpoint（即 Pod 的 IP 和 Port），<code>kube-proxy</code> 会为对应的 IPVS 虚拟服务器添加一个 <em>真实服务器</em>（Real Server）。</li><li><code>kube-proxy</code> 还会根据 Service 的配置（例如 <code>sessionAffinity</code>）和 <code>kube-proxy</code> 自身的启动参数，为这个 IPVS 虚拟服务器设置相应的负载均衡调度算法（如 Round Robin (rr), Least Connection (lc), Weighted Round Robin (wrr), Source Hashing (sh) 等）。IPVS 支持比 <code>iptables</code> 模式（通常是基于概率的随机或轮询）更丰富的调度算法。</li></ul></li><li><p><strong>流量转发:</strong> 当一个数据包到达宿主机，其目标地址和端口匹配某个 IPVS 虚拟服务器时，内核的 IPVS 模块会接管这个数据包。它会根据选定的调度算法，从该虚拟服务器关联的真实服务器列表中选择一个健康的 Pod。然后，IPVS 执行目标网络地址转换（DNAT），将数据包的目标 IP 和端口修改为选定 Pod 的 IP 和端口，并将数据包转发出去。</p></li><li><p><strong>网络接口与 IP 配置:</strong> 为了让 Service ClusterIP 在节点上可达，<code>kube-proxy</code> 通常会创建一个虚拟网络接口（如 <code>kube-ipvs0</code>），并将所有 Service ClusterIPs 配置在这个接口上。这样可以确保发送到 ClusterIP 的流量能够被节点正确地路由到 <code>INPUT</code> 链，进而被 IPVS 钩子捕获。</p></li><li><p><strong>SNAT 处理:</strong> 需要注意的是，虽然 IPVS 负责主要的负载均衡和 DNAT，但它通常不直接处理源网络地址转换（SNAT）。当 Pod 响应请求时，为了保证响应数据包能够正确返回给原始客户端（而不是直接返回，导致客户端收到一个来自 Pod IP 的非预期响应），通常还是需要进行 SNAT，将源 IP 地址改为节点的 IP 地址。这部分功能，<code>kube-proxy</code> 在 IPVS 模式下，仍然依赖 <code>iptables</code>（通常是 <code>MASQUERADE</code> 规则）来完成。<code>kube-proxy</code> 会配置相应的 <code>iptables</code> 规则来标记需要进行 SNAT 的数据包（例如，对从 IPVS 转发出去的、源 IP 是 Pod IP 但目标 IP 不在本地 Pod CIDR 范围内的包进行标记），然后在 <code>POSTROUTING</code> 链中对这些标记的包执行 <code>MASQUERADE</code>。</p></li></ol><h3 id="IPVS-模式的优势"><a href="#IPVS-模式的优势" class="headerlink" title="IPVS 模式的优势"></a>IPVS 模式的优势</h3><p>IPVS 模式相比 <code>iptables</code> 模式，主要优势在于：</p><ul><li><strong>性能和可扩展性:</strong> 如前所述，基于哈希表的查找机制使得 IPVS 在 Service 和 Endpoints 数量巨大时，依然能保持高性能和较低的 CPU 开销。这对于大规模集群至关重要，可以显著降低网络延迟，提高吞吐量。</li><li><strong>更丰富的负载均衡算法:</strong> IPVS 内核模块原生支持多种成熟的负载均衡算法，为 Service 流量分发提供了更多选择和优化空间，例如可以根据后端 Pod 的连接数进行负载均衡（Least Connection）。</li><li><strong>连接状态同步优化 (理论上):</strong> IPVS 本身有更完善的连接跟踪机制。在 <code>kube-proxy</code> 更新真实服务器列表时（例如 Pod 扩缩容或滚动更新），IPVS 处理现有连接（特别是长连接）通常比 <code>iptables</code> 更平滑，能更好地避免连接中断，但这具体也取决于 <code>kube-proxy</code> 的实现细节。</li></ul><h2 id="CoreDNS"><a href="#CoreDNS" class="headerlink" title="CoreDNS"></a>CoreDNS</h2><h3 id="Kubernetes-服务发现的挑战"><a href="#Kubernetes-服务发现的挑战" class="headerlink" title="Kubernetes 服务发现的挑战"></a>Kubernetes 服务发现的挑战</h3><p>在 Kubernetes 集群中，Service 提供了一种抽象，允许我们将一组运行相同应用的 Pod 暴露为一个网络服务。Kubernetes 会为类型为 <code>ClusterIP</code> 的 Service 分配一个虚拟 IP 地址（ClusterIP），为 <code>NodePort</code> 类型的 Service 在每个节点上开放一个静态端口，为 <code>LoadBalancer</code> 类型的 Service（在支持的云环境中）分配一个外部负载均衡器的 IP 地址。然而，正如你提到的，这些 IP 地址和端口（除了 NodePort 本身的端口号）本质上是动态的。当你删除并重新创建一个 Service 时，即使 Service 的名称和定义相同，其分配到的 ClusterIP 或 LoadBalancerIP 通常会发生变化。这种动态性使得直接使用 IP 地址作为服务的稳定访问入口变得不可靠，特别是对于服务间通信或者需要对外暴露的稳定端点而言。如果一个应用硬编码了另一个服务的 ClusterIP，那么当目标服务重建后，源应用就会连接失败。</p><h3 id="Kubernetes-DNS-的解决方案"><a href="#Kubernetes-DNS-的解决方案" class="headerlink" title="Kubernetes DNS 的解决方案"></a>Kubernetes DNS 的解决方案</h3><p>为了解决服务 IP 地址动态变化带来的问题，Kubernetes 引入了集群内部的 DNS 服务。这个 DNS 服务与 Kubernetes API Server 集成，能够自动为集群内的 Service 和 Pod 创建 DNS 记录。其核心思想是：<strong>用稳定的、人类可读的 DNS 名称来代替不稳定的 IP 地址</strong>。当一个 Service 被创建时，Kubernetes DNS 服务会为其自动生成一个形如 <code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.&lt;cluster-domain&gt;</code> 的完全限定域名（FQDN）。例如，一个名为 <code>my-app</code> 的 Service 在 <code>default</code> 命名空间下，其默认的集群域为 <code>cluster.local</code>，那么它的 FQDN 就是 <code>my-app.default.svc.cluster.local</code>。</p><p>这个 DNS 名称是稳定的。只要 Service 的名称 (<code>my-app</code>) 和其所在的命名空间 (<code>default</code>) 不变，即使这个 Service 被删除后重新创建，导致其 ClusterIP 发生变化，它的 DNS 名称始终保持不变。集群内的其他 Pod 可以通过这个 DNS 名称来访问该 Service。Pod 内的 DNS 解析器（通常由 Kubelet 根据 Pod 的 <code>dnsPolicy</code> 配置 <code>/etc/resolv.conf</code> 文件）会将这个 DNS 名称查询请求发送给集群的 DNS 服务，DNS 服务则会查询最新的 Service 信息，并将当前有效的 ClusterIP 返回给请求的 Pod。这样，应用代码中只需要使用服务名（或者 FQDN），就可以透明地连接到目标服务，无需关心其底层 IP 地址的变化。这极大地简化了服务发现和微服务间的通信。</p><h3 id="CoreDNS-是什么？"><a href="#CoreDNS-是什么？" class="headerlink" title="CoreDNS 是什么？"></a>CoreDNS 是什么？</h3><p>CoreDNS 是一个灵活、可扩展、插件化的 DNS 服务器，使用 Go 语言编写。自 Kubernetes v1.11 起，CoreDNS 成为了 Kubernetes 推荐且默认的集群 DNS 服务，逐渐取代了之前的 <code>kube-dns</code>（由 <code>dnsmasq</code>、<code>kube-dns</code> 和 <code>sidecar</code> 三个容器组成）解决方案。CoreDNS 的设计哲学是 “Do one thing and do it well”（通过插件链）。它的核心非常轻量，大部分功能，包括处理 DNS 查询、缓存、转发、监控指标暴露等，都是通过一系列可插拔的插件（Plugins）来实现的。这种架构使得 CoreDNS 非常容易定制和扩展，可以根据特定需求启用、禁用或配置不同的插件。</p><p>在 Kubernetes 中，CoreDNS 通常以 Deployment 的形式运行（例如，在 <code>kube-system</code> 命名空间下），并暴露为一个名为 <code>kube-dns</code> 的 Service（为了兼容性，Service 名称沿用了旧方案的名称）。这个 Service 的 ClusterIP 会被 Kubelet 配置到集群中每个 Pod 的 <code>/etc/resolv.conf</code> 文件中作为 <code>nameserver</code>，使得 Pod 内发起的 DNS 查询默认都流向 CoreDNS。</p><h3 id="CoreDNS-在-Kubernetes-中的工作原理"><a href="#CoreDNS-在-Kubernetes-中的工作原理" class="headerlink" title="CoreDNS 在 Kubernetes 中的工作原理"></a>CoreDNS 在 Kubernetes 中的工作原理</h3><img src="/2025/04/10/kube-proxy/image-20250415105305996.png" class="" title="image-20250415105305996"><p>CoreDNS 通过其 <code>kubernetes</code> 插件与 Kubernetes API Server 进行交互，实现了对集群内部服务和 Pod 的 DNS 解析。这个插件会 “watch”（监听）Kubernetes API Server 上的 Service 和 Endpoint (或 EndpointSlice，一种更高效的资源) 对象的变化。</p><p>当一个 Pod 发起对某个 Service FQDN（如 <code>my-service.my-ns.svc.cluster.local</code>）的 A 记录查询时：</p><ol><li>查询请求根据 Pod 的 <code>/etc/resolv.conf</code> 配置，被发送到 CoreDNS Pod 的 IP 地址和端口（通常是 <code>kube-dns</code> Service 的 ClusterIP 上的 53 端口）。</li><li>CoreDNS 接收到请求，根据其配置文件（Corefile）中的指令，将请求传递给 <code>kubernetes</code> 插件进行处理。</li><li><code>kubernetes</code> 插件检查查询的域名是否符合其配置的集群域（如 <code>cluster.local</code>）。</li><li>如果匹配，插件会解析出 Service 名称 (<code>my-service</code>) 和命名空间 (<code>my-ns</code>)。</li><li>插件在其内部维护的、从 API Server 同步来的缓存中查找对应的 Service 信息。</li><li>如果找到了 Service，它会返回该 Service 的 ClusterIP 作为 A 记录的响应。</li></ol><p>对于 Headless Service（定义了 <code>clusterIP: None</code> 的 Service），<code>kubernetes</code> 插件不会返回 ClusterIP，而是会返回该 Service 关联的所有 Ready状态 Pod 的 IP 地址作为多个 A 记录。这对于需要直接与 Pod 通信的场景（如 StatefulSet 的 Pod 间发现）非常有用。</p><p>除了 Service，<code>kubernetes</code> 插件还可以配置为解析 Pod 的 DNS 记录（通常格式为 <code>&lt;pod-ip-address&gt;.&lt;namespace-name&gt;.pod.&lt;cluster-domain&gt;</code>，其中 IP 地址中的点 <code>.</code> 被替换为短横线 <code>-</code>）。</p><p>如果查询的域名不属于集群内部域（例如 <code>www.google.com</code>），<code>kubernetes</code> 插件通常会配置 <code>fallthrough</code> 选项。这意味着它不会处理这个请求，而是让请求流转到插件链中的下一个插件，通常是 <code>forward</code> 插件。<code>forward</code> 插件会将请求转发给上游 DNS 服务器（例如，配置为 CoreDNS Pod 所在节点的 <code>/etc/resolv.conf</code> 中定义的 DNS 服务器，或者直接配置的公共 DNS 服务器如 8.8.8.8）。这样，CoreDNS 不仅能解析集群内部域名，也能代理外部域名的解析。</p><p>CoreDNS 还通过其他插件提供了重要功能：</p><ul><li><code>cache</code>: 缓存 DNS 记录，减少对 API Server 的查询压力和外部 DNS 查询的延迟。</li><li><code>forward</code>: 将无法在本地解析（非集群域或 <code>fallthrough</code> 的请求）的查询转发给上游 DNS 服务器。</li><li><code>prometheus</code>: 暴露 Prometheus 格式的监控指标，用于监控 CoreDNS 的性能和健康状况。</li><li><code>health</code>: 提供 HTTP 健康检查端点（<code>/health</code>），供 Kubelet 进行 Liveness Probe。</li><li><code>ready</code>: 提供 HTTP 就绪检查端点（<code>/ready</code>），供 Kubelet 进行 Readiness Probe，确保插件都已准备好服务。</li><li><code>reload</code>: 允许在不中断服务的情况下动态加载更新后的 Corefile 配置。</li><li><code>loop</code>: 检测并阻止 DNS 查询转发循环。</li><li><code>rewrite</code>: 在查询被处理之前或之后修改查询的名称。</li></ul><h3 id="CoreDNS-配置示例-Corefile"><a href="#CoreDNS-配置示例-Corefile" class="headerlink" title="CoreDNS 配置示例 (Corefile)"></a>CoreDNS 配置示例 (Corefile)</h3><p>CoreDNS 的配置通过一个名为 <code>Corefile</code> 的文件进行管理，这个文件通常存储在 Kubernetes 的 ConfigMap 对象（如 <code>coredns</code> ConfigMap in <code>kube-system</code>）中，并挂载到 CoreDNS Pod 里。<code>Corefile</code> 的语法是基于 Caddy 服务器的 Caddyfile 格式。它由一个或多个服务器块（Server Blocks）组成，每个块定义了 CoreDNS 监听的区域（Zone）、端口和使用的插件链。</p><p>以下是一个典型的 Kubernetes 环境下 CoreDNS 的 <code>Corefile</code> 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs coredns">.:53 &#123;                                                  # 定义一个服务器块，监听所有域 (.) 在 UDP/TCP 的 53 端口<br>    errors                                              # 启用错误日志记录插件<br>    health &#123;                                            # 启用健康检查插件<br>       lameduck 5s                                      # 在关闭前等待 5 秒，处理完现有请求<br>    &#125;<br>    ready                                               # 启用就绪检查插件，所有插件加载完毕后才报告 ready<br>    kubernetes cluster.local in-addr.arpa ip6.arpa &#123;    # 启用 Kubernetes 插件<br>       pods insecure                                    # 解析 Pod A 记录 (e.g., 1-2-3-4.default.pod.cluster.local)<br>       upstream                                         # 如果需要，从上游解析 headless service 的外部名称 CNAME 记录<br>       fallthrough in-addr.arpa ip6.arpa                # 如果查询不是 K8s 服务/Pod 或反向记录，则传递给下一个插件<br>    &#125;<br>    prometheus :9153                                    # 在 9153 端口暴露 Prometheus 指标<br>    forward . /etc/resolv.conf &#123;                        # 启用转发插件<br>       max_concurrent 1000                              # 设置最大并发转发查询数<br>    &#125;<br>    cache 30                                            # 启用缓存插件，缓存 TTL 为 30 秒<br>    loop                                                # 启用循环检测插件<br>    reload 5s                                           # 每 5 秒检查一次 Corefile 是否更新，并自动重新加载<br>    loadbalance                                         # 对返回的 A/AAAA/MX 记录进行轮询负载均衡<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>配置解读:</strong></p><ul><li><code>.:53 &#123; ... &#125;</code>: 定义了一个处理所有 DNS 查询（<code>.</code> 代表根区域）的核心块，监听标准 DNS 端口 53。</li><li><code>errors</code>: 捕获并记录处理过程中的错误。</li><li><code>health &#123; lameduck 5s &#125;</code>: 在 <code>:8080/health</code> (默认端口) 提供健康检查接口。<code>lameduck</code> 确保在 CoreDNS 准备关闭时，会先保持 5 秒的运行状态以完成正在处理的请求，然后才报告不健康。</li><li><code>ready</code>: 在 <code>:8181/ready</code> (默认端口) 提供就绪检查接口，只有当 CoreDNS 完全准备好处理请求时才返回成功。</li><li><code>kubernetes cluster.local in-addr.arpa ip6.arpa &#123; ... &#125;</code>: 这是核心。<ul><li><code>cluster.local</code>: 指定 CoreDNS 负责解析的 Kubernetes 集群域。所有 <code>*.cluster.local</code> 的查询将由这个插件处理。</li><li><code>in-addr.arpa</code> 和 <code>ip6.arpa</code>: 使插件能够处理 PTR 反向查询，将 IP 地址解析回对应的 Kubernetes 服务或 Pod 名称。</li><li><code>pods insecure</code>: 允许解析 Pod 的 IP 地址到 DNS 名称的 A 记录。<code>insecure</code> 表示即使 Pod 未处于 Ready 状态也可能被解析（通常还支持 <code>verified</code> 和 <code>disabled</code> 选项）。</li><li><code>upstream</code>: 对于指向外部名称 (ExternalName) 的 Service，如果需要解析，会使用上游解析器。</li><li><code>fallthrough in-addr.arpa ip6.arpa</code>: 如果查询的名称不匹配 <code>cluster.local</code> 域，或者不匹配反向查询域，则将请求传递给插件链中的下一个插件（在这里是 <code>forward</code>）。</li></ul></li><li><code>prometheus :9153</code>: 在 9153 端口暴露 <code>/metrics</code> 端点，供 Prometheus 抓取监控数据。</li><li><code>forward . /etc/resolv.conf</code>: 对于不由 <code>kubernetes</code> 插件处理的查询（由于 <code>fallthrough</code>），使用此插件转发。<code>.</code> 表示转发所有域。<code>/etc/resolv.conf</code> 表示使用 CoreDNS Pod 所在 Node 的 DNS 配置（通常来自宿主机或云提供商的 DHCP）作为上游解析器。也可以直接指定 IP 地址，如 <code>forward . 8.8.8.8 1.1.1.1</code>。</li><li><code>cache 30</code>: 对 DNS 记录进行缓存，默认缓存时间 30 秒。这能显著提高性能并减少对上游 DNS 的依赖。</li><li><code>loop</code>: 防止 DNS 查询在转发过程中形成循环。</li><li><code>reload 5s</code>: CoreDNS 会定期检查 <code>Corefile</code> 的修改时间。如果文件发生变化，它会在不中断服务的情况下平滑地重新加载配置。</li><li><code>loadbalance</code>: 对 DNS 响应中的多个 A&#x2F;AAAA&#x2F;MX 记录进行轮询分发，提供简单的客户端负载均衡。</li></ul><p>通过这套机制，CoreDNS 为 Kubernetes 集群提供了一个健壮、高效且可配置的内部 DNS 解析服务，完美解决了因 Service IP 动态变化而导致的服务发现难题，是构建稳定可靠微服务架构的关键基础设施之一。理解 CoreDNS 的工作原理和配置方式，对于深入掌握 Kubernetes 网络和服务发现至关重要。</p><h3 id="CoreDNS-的核心架构：内存态-DNS-与控制器模式"><a href="#CoreDNS-的核心架构：内存态-DNS-与控制器模式" class="headerlink" title="CoreDNS 的核心架构：内存态 DNS 与控制器模式"></a>CoreDNS 的核心架构：内存态 DNS 与控制器模式</h3><p>你提到的 “内存态 DNS” 和 “控制器” 是理解 CoreDNS 工作方式的关键。</p><p><strong>内存态 DNS</strong>：CoreDNS 本身可以配置为权威 DNS 服务器或转发器&#x2F;缓存。在 Kubernetes 环境中，通过其 <code>kubernetes</code> 插件，CoreDNS 能够动态地维护集群内部服务的 DNS 记录。这些记录主要存储在<strong>内存</strong>中，以便快速响应查询请求。这意味着 CoreDNS 不需要依赖传统的、基于文件的区域（Zone）文件来存储 K8s 服务的记录。这种内存态存储对于应对 K8s 中 Service 和 Pod 的频繁变化至关重要，可以提供低延迟的查询响应。当然，CoreDNS 也包含 <code>cache</code> 插件，用于缓存内部和外部查询结果，进一步提高性能并减少对上游 DNS 服务器的负载。</p><p><strong>控制器模式</strong>：这是 CoreDNS 与 Kubernetes 集成运作的核心机制。CoreDNS（通过其 <code>kubernetes</code> 插件）扮演着一个标准的 <strong>Kubernetes 控制器</strong>角色。它通过 Kubernetes API <strong>监听（Watch）</strong> <code>Service</code> 和 <code>EndpointSlice</code>（或者旧版本的 <code>Endpoints</code>）资源的变化。</p><ul><li>当一个新的 <code>Service</code> 被创建时，控制器会收到通知，并根据 Service 的类型和配置，在内存中生成相应的 DNS 记录（A、AAAA、SRV、PTR 等）。</li><li>当一个 <code>Service</code> 关联的 Pod 实例发生变化（例如，Pod 启动就绪、Pod 被删除、Pod IP 改变）时，对应的 <code>EndpointSlice</code> 会更新。控制器监听到 <code>EndpointSlice</code> 的变化，并相应地更新内存中的 DNS 记录（特别是对于 Headless Service 的 A&#x2F;AAAA 记录）。</li><li>当 <code>Service</code> 被删除时，控制器也会移除相关的 DNS 记录。</li></ul><p>这个过程是<strong>持续、自动</strong>的。CoreDNS 不需要手动配置每个服务的 DNS 条目，它通过与 Kubernetes API 的实时交互，动态地维护了一份准确反映集群当前状态的 DNS 视图。这种机制与其他的 Kubernetes 控制器（如 Deployment Controller、ReplicaSet Controller）的工作原理类似，都是通过 <strong>Watch API -&gt; 对比期望状态与实际状态 -&gt; 执行调整动作</strong> 的循环来确保系统达到期望的状态。</p><p>从 Linux 内核或网络角度看，当一个 Pod 内的进程发起 DNS 查询时（通常是调用 libc 的 <code>gethostbyname</code> 或 <code>getaddrinfo</code> 等函数），最终会根据 <code>/etc/resolv.conf</code> 的配置，将 UDP 或 TCP 请求发送到 CoreDNS Pod 的 IP 地址和 53 端口。CoreDNS Pod 接收到请求后，其内部的插件链开始处理。<code>kubernetes</code> 插件会检查请求的域名是否匹配集群内部的域（如 <code>cluster.local</code>），如果匹配，则在内存数据中查找相应的记录并返回；如果不匹配，则可能由 <code>forward</code> 或 <code>proxy</code> 插件将请求转发给上游 DNS 服务器（例如节点宿主机的 DNS 或公共 DNS）。</p><h3 id="不同类型服务的-DNS-记录详解"><a href="#不同类型服务的-DNS-记录详解" class="headerlink" title="不同类型服务的 DNS 记录详解"></a>不同类型服务的 DNS 记录详解</h3><p>CoreDNS 如何为不同类型的 Kubernetes Service 生成 DNS 记录是服务发现的核心细节。</p><h4 id="普通-Service-ClusterIP-NodePort-LoadBalancer"><a href="#普通-Service-ClusterIP-NodePort-LoadBalancer" class="headerlink" title="普通 Service (ClusterIP, NodePort, LoadBalancer)"></a>普通 Service (ClusterIP, NodePort, LoadBalancer)</h4><p>这类 Service 都有一个由 Kubernetes API Server 分配的、稳定的虚拟 IP，即 <strong>ClusterIP</strong>。这个 IP 并不是绑定在某个具体的网络设备上，而是由 kube-proxy（或等效的网络组件如 Cilium eBPF）在数据平面上实现负载均衡和转发。</p><ul><li><strong>A&#x2F;AAAA 记录</strong>：CoreDNS 会为这类 Service 创建一个 <strong>FQDN（完全限定域名）</strong>，格式通常是 <strong><code>&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></strong> (例如 <code>my-service.default.svc.cluster.local</code>)。这个 FQDN 解析为一个 A 记录（IPv4）或 AAAA 记录（IPv6），其值就是该 Service 的 <strong>ClusterIP</strong>。客户端 Pod 查询这个域名时，会得到 ClusterIP，然后发往这个 IP 的请求会被 kube-proxy 拦截并转发到该 Service 背后某个健康的 Pod IP 上。</li><li><strong>SRV 记录</strong>：如果 Service 定义了端口（Ports），CoreDNS 还会为每个命名端口（Named Port）创建 SRV 记录。格式通常是 <strong><code>_&lt;port-name&gt;._&lt;protocol&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></strong> (例如 <code>_http._tcp.my-service.default.svc.cluster.local</code>)。SRV 记录包含了端口号、优先级和权重，允许客户端发现服务提供的具体端口信息，而不仅仅是 IP 地址。这对于需要知道特定服务端口的应用（如 gRPC、LDAP）非常有用。</li><li><strong>PTR 记录</strong>：用于反向 DNS 查询，将 ClusterIP 解析回其对应的 FQDN。</li></ul><h4 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h4><p>当 Service 的 <code>.spec.clusterIP</code> 字段被显式设置为 <code>None</code> 时，就创建了一个 <strong>Headless Service</strong>。顾名思义，它<strong>没有 ClusterIP</strong>。API Server 不会为其分配虚拟 IP，kube-proxy 也不会处理到这个 Service 的流量。</p><ul><li><strong>A&#x2F;AAAA 记录 (多条)</strong>：对于 Headless Service，当查询其 FQDN <strong><code>&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></strong> 时，CoreDNS <strong>不会返回 ClusterIP</strong>（因为它不存在）。相反，它会返回多个 A&#x2F;AAAA 记录，每个记录对应一个**当前就绪（Ready）**状态的、属于该 Service 的 <strong>Pod 的 IP 地址</strong>。这意味着客户端直接解析到后端 Pod 的真实 IP 列表。这对于需要直接连接到特定 Pod 实例的应用（如数据库集群、StatefulSet 管理的有状态应用）或者希望自己实现客户端负载均衡策略的场景非常有用。</li><li><strong>Pod FQDN 记录</strong>：对于与 Headless Service 关联的每个 Pod（特别是那些由 StatefulSet 创建的、具有稳定网络标识符的 Pod），CoreDNS 还会创建一个特定的 FQDN，格式通常是 <strong><code>&lt;pod-hostname&gt;.&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></strong> (如果 Service 指定了 <code>subdomain</code> 字段，格式会是 <code>&lt;pod-hostname&gt;.&lt;subdomain&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code>) 或者对于普通 Pod 可能简化为类似 <strong><code>&lt;pod-ip-dashed&gt;.&lt;namespace&gt;.pod.&lt;cluster-domain&gt;</code></strong>。这个记录直接解析为该 <strong>Pod 的 IP 地址</strong>。这允许直接寻址到某个具体的 Pod 实例。</li></ul><h4 id="ExternalName-Service"><a href="#ExternalName-Service" class="headerlink" title="ExternalName Service"></a>ExternalName Service</h4><p>这种类型的 Service 比较特殊，它<strong>不涉及 Pod 选择器或 IP 地址分配</strong>。它的目的是在集群内部为<strong>外部的一个 DNS 域名</strong>创建一个别名。</p><ul><li><strong>CNAME 记录</strong>：CoreDNS 会为 ExternalName Service 的 FQDN <strong><code>&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></strong> 创建一个 <strong>CNAME 记录</strong>。这个 CNAME 记录的值是 Service 定义中 <code>.spec.externalName</code> 字段指定的外部域名。当集群内部的 Pod 查询这个 Service FQDN 时，CoreDNS 会返回 CNAME 记录，指示客户端应该去查询 <code>externalName</code> 指定的那个域名。这相当于在集群 DNS 内部做了一个“符号链接”或“别名”，将内部服务名映射到集群外部的某个实际服务上，而无需关心外部服务的 IP 是否变化。</li></ul><h3 id="Pod-的-DNS-配置-dnsPolicy-和-etc-resolv-conf"><a href="#Pod-的-DNS-配置-dnsPolicy-和-etc-resolv-conf" class="headerlink" title="Pod 的 DNS 配置 (dnsPolicy 和 /etc/resolv.conf)"></a>Pod 的 DNS 配置 (<code>dnsPolicy</code> 和 <code>/etc/resolv.conf</code>)</h3><p>Kubernetes 通过 <code>kubelet</code> 组件管理每个 Pod 的 DNS 配置，确保 Pod 能够正确地使用 CoreDNS 进行服务发现。</p><p><strong><code>dnsPolicy</code></strong> 属性定义了 Pod 的 DNS 解析行为。默认值是 <strong><code>ClusterFirst</code></strong>。这意味着：</p><ol><li>Pod 内发起的 DNS 查询，如果请求的域名<strong>不包含点（dots）或者包含的点数少于 <code>options ndots</code> 指定的值</strong>（通常默认为 5），并且<strong>配置了 <code>search</code> 域</strong>，那么系统会依次尝试将 <code>search</code> 域附加到查询域名后面进行解析。例如，查询 <code>my-service</code> 时，会依次尝试查询 <code>my-service.my-namespace.svc.cluster.local</code>，然后 <code>my-service.svc.cluster.local</code>，然后 <code>my-service.cluster.local</code>。</li><li>如果第一步没有找到，或者查询的域名本身就包含足够的点数（大于等于 <code>ndots</code>），系统会将其视为一个完全限定域名（FQDN）直接进行查询。</li><li>所有这些查询首先被发送到 <code>/etc/resolv.conf</code> 中 <code>nameserver</code> 指令指定的 DNS 服务器，也就是 <strong>CoreDNS 的 Service IP</strong>。</li><li>如果 CoreDNS 无法解析（例如，查询的是外部域名），并且 CoreDNS 配置了上游转发器（<code>forward</code> 插件），它会将查询转发给上游 DNS 服务器。</li></ol><p><strong><code>/etc/resolv.conf</code></strong> 文件在 Pod 启动时由 <code>kubelet</code> 根据 Pod 的 <code>dnsPolicy</code> 和集群配置动态生成并挂载到容器内部。一个典型的 <code>ClusterFirst</code> 策略下的 <code>/etc/resolv.conf</code> 文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 由 kubelet 生成</span><br>search &lt;namespace&gt;.svc.&lt;cluster-domain&gt; svc.&lt;cluster-domain&gt; &lt;cluster-domain&gt; [其他搜索域, 如宿主机配置的域]<br>nameserver &lt;coredns-cluster-ip&gt;<br>options ndots:5 <span class="hljs-built_in">timeout</span>:1 attempts:2<br></code></pre></td></tr></table></figure><ul><li><strong><code>search</code></strong>: 定义了 DNS 查询的搜索域列表。当查询一个不包含域名的短名称（如 <code>my-service</code>）时，系统会按列表顺序尝试将这些后缀附加到短名称后面进行解析。这使得在同一个 Namespace 内可以直接使用服务名（<code>my-service</code>），在不同 Namespace 可以使用 <code>&lt;service-name&gt;.&lt;namespace&gt;</code>。</li><li><strong><code>nameserver</code></strong>: 指定了 DNS 服务器的 IP 地址。在 K8s 中，这通常是 <strong>CoreDNS Service 的 ClusterIP</strong>。所有发往此 IP:53 的 DNS 请求都会被路由到某个 CoreDNS Pod 实例。</li><li><strong><code>options ndots:5</code></strong>: 这个选项非常关键。它告诉本地 DNS 解析器（通常是 glibc）：如果一个域名包含的点（dots）<strong>少于</strong> 5 个，那么在直接查询这个域名本身（视为绝对域名）之前，<strong>优先</strong>尝试将 <code>search</code> 列表中的后缀依次附加到该域名后面进行查询。如果域名包含的点数<strong>等于或多于</strong> 5 个，则解析器会认为它是一个 FQDN，直接查询它，不再尝试附加搜索后缀。这个默认值 5 是为了优化集群内部的服务发现（大部分内部服务 FQDN 包含 4 个点，如 <code>svc.cluster.local</code>），但有时可能导致对外部短域名（如 <code>www.google.com</code>，只有 2 个点）的解析变慢，因为它会先尝试附加搜索路径。</li><li><code>timeout</code> 和 <code>attempts</code> 控制 DNS 查询的超时时间和重试次数。</li></ul><p><strong>环境变量的影响</strong>：你提到了环境变量。确实，在 Kubernetes 的早期版本或者特定配置下，<code>kubelet</code> 会将<strong>当前 Namespace</strong> 中所有 Service 的信息（如 <code>SERVICE_HOST</code> 和 <code>SERVICE_PORT</code>）作为环境变量注入到新创建的 Pod 中。然而，这种方式有<strong>显著的缺点</strong>：</p><ol><li><strong>静态性</strong>：环境变量在 Pod 创建时注入，<strong>之后不会更新</strong>。如果 Service 的 ClusterIP 发生变化（虽然不常见，但可能发生），或者你希望 Pod 能够发现后来才创建的 Service，环境变量就无能为力了。</li><li><strong>污染环境变量空间</strong>：如果一个 Namespace 中有很多 Service，这会注入大量的环境变量，可能导致混乱或冲突。</li><li><strong>无法反映 Headless Service 的 Pod IP 列表</strong>。</li></ol><p>由于这些限制，<strong>基于 DNS 的服务发现（CoreDNS）是 Kubernetes 中推荐和主流的方式</strong>，它更加动态、灵活和标准。依赖环境变量的方式通常被认为是不推荐的做法。</p><h3 id="DNS-的落地实践：与企业-DNS-集成"><a href="#DNS-的落地实践：与企业-DNS-集成" class="headerlink" title="DNS 的落地实践：与企业 DNS 集成"></a>DNS 的落地实践：与企业 DNS 集成</h3><p>将 Kubernetes 集群的服务发现与企业现有的 DNS 基础架构集成是一个常见的需求，目的是让集群外部的用户或其他系统也能访问 Kubernetes 中部署的服务，并保持服务名称的一致性。</p><p><strong>挑战与需求</strong>：</p><ul><li>集群内部使用 CoreDNS 解析服务名到 ClusterIP 或 Pod IP。</li><li>集群外部（例如，用户的笔记本电脑、其他数据中心的服务器）需要通过企业内部的 DNS 服务器（如 BIND, Microsoft DNS, 或其他 DNS 服务）解析同一个服务名，但通常需要解析到服务的<strong>入口点 IP</strong>，比如 <strong>LoadBalancer Service 的外部 IP (VIP)</strong> 或 Ingress Controller 的外部 IP。</li><li>对于 Headless Service，如果其 Pod IP 在企业网络中是可路由的，并且需要从外部直接访问特定实例，可能也需要在企业 DNS 中创建相应的记录。</li></ul><p><strong>解决方案：定制 DNS 控制器 (如 ExternalDNS)</strong></p><p>为了自动化这个过程，社区开发了 <strong>ExternalDNS</strong> 这个项目。ExternalDNS 也是一个 Kubernetes 控制器，它的工作方式是：</p><ol><li><strong>监听</strong> Kubernetes 中的 <code>Service</code> 和&#x2F;或 <code>Ingress</code> 资源。</li><li>根据资源的**注解（Annotations）**或特定配置，判断哪些服务需要发布到外部 DNS。</li><li>读取需要发布的服务信息（例如，<code>LoadBalancer</code> Service 的 <code>status.loadBalancer.ingress[0].ip</code> 或 <code>hostname</code>，或者 <code>Ingress</code> 的主机名和 IP）。</li><li>使用相应的<strong>云服务商 API 或标准 DNS 更新协议 (RFC 2136)</strong>，在<strong>外部的企业 DNS 或公共 DNS</strong>（如 AWS Route 53, Google Cloud DNS, Azure DNS, BIND 等）中<strong>自动创建、更新或删除</strong>相应的 DNS 记录（通常是 A, AAAA, 或 CNAME 记录）。</li></ol><p><strong>配置示例 (ExternalDNS 部署片段 - 示意)</strong>：<br>部署 ExternalDNS 时，需要配置它连接到哪个 K8s 集群、监听哪些资源、使用哪个 DNS 提供商以及如何认证。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># deployment.yaml (部分)</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">external-dns</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span> <span class="hljs-comment"># 或者其他专用 namespace</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">external-dns</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">external-dns</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">external-dns</span> <span class="hljs-comment"># 需要配置 RBAC 权限访问 Service/Ingress</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">external-dns</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.k8s.io/external-dns/external-dns:v0.13.x</span> <span class="hljs-comment"># 使用合适的版本</span><br>        <span class="hljs-attr">args:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--source=service</span> <span class="hljs-comment"># 监听 Service 资源</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--source=ingress</span> <span class="hljs-comment"># 同时监听 Ingress 资源</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--domain-filter=my-company.com</span> <span class="hljs-comment"># 只管理这个域下的记录</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--provider=aws</span> <span class="hljs-comment"># 指定 DNS 提供商 (例如 AWS Route 53)</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--policy=upsert-only</span> <span class="hljs-comment"># DNS 记录管理策略 (安全起见，防止误删)</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--aws-zone-type=public</span> <span class="hljs-comment"># 指定 Route 53 Zone 类型</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--registry=txt</span> <span class="hljs-comment"># 使用 TXT 记录来跟踪所有权</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">--txt-owner-id=my-k8s-cluster-id</span> <span class="hljs-comment"># 唯一的 Owner ID 防止冲突</span><br>        <span class="hljs-comment"># 可能还需要配置 AWS 凭证，通常通过 Service Account + IAM Role (IRSA) 或挂载 Secret</span><br>      <span class="hljs-attr">securityContext:</span><br>        <span class="hljs-attr">fsGroup:</span> <span class="hljs-number">65534</span> <span class="hljs-comment"># 非 root 用户运行</span><br></code></pre></td></tr></table></figure><p><strong>处理 Headless Service 的注意事项</strong>：<br>如你所指出，将 Headless Service 的<strong>所有 Pod IP</strong> 都发布到企业 DNS 需要非常谨慎。</p><ul><li><strong>前提</strong>：这些 Pod IP 必须在企业网络中是<strong>可全局路由</strong>的，并且外部客户端有访问这些 IP 的网络策略许可。</li><li><strong>风险</strong>：如果 Pod 是动态扩缩容或频繁更新的，会导致大量的 DNS 记录频繁创建和删除，给企业 DNS 服务器带来<strong>巨大压力</strong>（冲击），也可能导致客户端 DNS 缓存失效和解析延迟。</li><li><strong>建议</strong>：<strong>按需创建 (On-demand creation)</strong>。通常只为那些需要稳定、可预测的外部访问的 Headless Service Pod（例如，StatefulSet 中的特定实例）创建 DNS 记录，并且可能需要更长的 TTL（Time-To-Live）来减少 DNS 流量。这通常通过在 Pod 或 Service 上添加特定的注解，让 ExternalDNS 知道要发布哪些记录。</li></ul><p><strong>最终目标</strong>：通过 CoreDNS（内部）和 ExternalDNS（外部）的协同工作，实现<strong>服务在集群内外拥有统一的标识</strong>（例如，<code>billing-api.my-company.com</code>）。内部 Pod 查询时，CoreDNS 可能返回 ClusterIP；外部用户查询时，企业 DNS 可能返回 LoadBalancer VIP。应用层使用统一的服务名，底层 DNS 负责解析到正确的、适合访问者位置的 IP 地址。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service对象</title>
    <link href="/2025/04/03/kubernetes-Service%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/04/03/kubernetes-Service%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Service-对象"><a href="#Service-对象" class="headerlink" title="Service 对象"></a>Service 对象</h2><img src="/2025/04/03/kubernetes-Service%E5%AF%B9%E8%B1%A1/image-20250410100845025.png" class="" title="image-20250410100845025"><p>Kubernetes Service 是集群内网络抽象的核心对象，其核心功能是通过稳定的虚拟 IP 和 DNS 名称对外暴露动态变化的 Pod 集合。我们从网络协议栈实现和控制器模式两个维度深入剖析其核心机制：</p><p><strong>1. Service Selector 的标签驱动机制</strong></p><ul><li>底层基于 Kubernetes API 的 List-Watch 机制，Service Controller 通过 Informer 持续监控 Endpoints 对象</li><li>标签选择器采用集合查询语义（equality-based selector），执行逻辑等价于 <code>kubectl get pods -l app=nginx</code></li><li>符合标签的 Pod 会被加入 Endpoints 对象，kube-proxy 据此动态维护 iptables&#x2F;IPVS 规则</li><li>选择器与 Pod 的标签匹配采用实时更新策略，任何 Pod 标签变更都会触发 Endpoints 的原子更新</li></ul><p><strong>2. Ports 的多层端口映射体系</strong></p><ul><li><code>port: 80</code> 定义 Service 的虚拟 IP 监听端口，对应 kube-proxy 在节点上开放的端口</li><li><code>targetPort: 80</code> 指向 Pod 内容器实际监听的端口，支持数字端口或命名端口（需与容器端口定义一致）</li><li>协议字段支持 TCP&#x2F;UDP&#x2F;SCTP，其中 TCP 默认开启 Nagle 算法，需注意与短连接服务的兼容性</li><li>端口映射本质是在 CNI 插件实现的 overlay 网络基础上构建的虚拟四层负载均衡</li></ul><p><strong>3. 示例配置的深度解析</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span>  <span class="hljs-comment"># 生成 DNS 记录 nginx-service.&lt;namespace&gt;.svc.cluster.local</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>  <span class="hljs-comment"># 与 Pod 的 metadata.labels 形成级联关系</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>    <span class="hljs-comment"># 传输层协议类型</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>         <span class="hljs-comment"># Service 暴露的虚拟端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span>   <span class="hljs-comment"># 容器实际监听端口，支持端口名称(如 web-port)</span><br></code></pre></td></tr></table></figure><p><strong>4. 底层流量转发机制</strong></p><ul><li>对于 ClusterIP 类型 Service，kube-proxy 通过 iptables 的 DNAT 规则实现流量转发</li><li>每个 Service 对应 iptables 链中的 KUBE-SVC-XXXXX 规则链，采用随机概率轮询算法</li><li>在 IPVS 模式下，会创建虚拟服务地址，采用更丰富的负载均衡算法（rr&#x2F;lc&#x2F;dh&#x2F;sh等）</li></ul><p><strong>5. 服务发现的双模机制</strong></p><ul><li>环境变量方式：Service 创建时，kubelet 向 Pod 注入形如 NGINX_SERVICE_SERVICE_HOST 的环境变量</li><li>DNS 方式：CoreDNS 创建 A&#x2F;AAAA 记录和 SRV 记录，支持全限定域名(FQDN)解析</li></ul><p>从系统设计视角看，Service 对象实现了关键的网络抽象层：</p><ul><li>解耦前端访问与后端实例的映射关系</li><li>提供跨节点、跨网络的透明通信能力</li><li>通过 Endpoints API 实现控制平面与数据平面的分离</li><li>与 kube-proxy 组件配合完成服务代理的声明式配置</li></ul><p>该设计使得应用可以无视底层基础设施的差异，获得一致的网络访问体验，是 Kubernetes 实现弹性伸缩和滚动升级的基础设施保障。</p><h3 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h3><p><code>Cluster IP: None</code></p><h3 id="External-Name"><a href="#External-Name" class="headerlink" title="External Name"></a>External Name</h3><p><code>externalName: example.com</code></p><h3 id="Service-Topology"><a href="#Service-Topology" class="headerlink" title="Service Topology"></a>Service Topology</h3><p>在 Kubernetes 集群跨多可用区（AZ）或多区域（Region）部署时，传统 Service 的流量分发存在以下问题：</p><ol><li><strong>非智能路由</strong>：默认的 <code>kube-proxy</code> 通过随机或轮询算法选择端点，可能导致跨 AZ 流量（如 Pod 在 AZ-A，请求来自 AZ-B 的节点）。</li><li><strong>高延迟与成本</strong>：跨区域通信涉及公网带宽或专线费用，延迟显著高于同区域通信（例如 AWS 同 AZ 延迟约 0.1ms，跨 AZ 约 1-5ms）。</li></ol><hr><p>Service Topology 的实现依赖 <strong>拓扑键（Topology Keys）</strong> 机制，其核心流程如下：</p><h4 id="1-节点标签定义"><a href="#1-节点标签定义" class="headerlink" title="1. 节点标签定义"></a><strong>1. 节点标签定义</strong></h4><ul><li>节点需标记拓扑标签（如 <code>topology.kubernetes.io/zone=us-east-1a</code>）。</li><li>典型拓扑层级：<code>kubernetes.io/hostname</code>（节点） → <code>topology.kubernetes.io/zone</code>（可用区） → <code>topology.kubernetes.io/region</code>（区域）。</li></ul><h4 id="2-Service-配置"><a href="#2-Service-配置" class="headerlink" title="2. Service 配置"></a><strong>2. Service 配置</strong></h4><p>在 Service Spec 中声明 <code>topologyKeys</code>，按优先级指定路由策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">my-app</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span><br>  <span class="hljs-attr">topologyKeys:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;topology.kubernetes.io/zone&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;topology.kubernetes.io/region&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*&quot;</span>  <span class="hljs-comment"># 全局回退（可选）</span><br><br></code></pre></td></tr></table></figure><p><strong>路由逻辑</strong>：</p><ol><li>优先选择与请求源节点<strong>同 Zone</strong> 的端点（Endpoints）。</li><li>若无同 Zone 端点，选择同 Region 的端点。</li><li>若仍无匹配，根据 <code>*</code> 回退到全局（需显式配置）。</li></ol><h2 id="Topology-Aware-Hints"><a href="#Topology-Aware-Hints" class="headerlink" title="Topology Aware Hints"></a>Topology Aware Hints</h2><table><thead><tr><th><strong>维度</strong></th><th><strong>Service Topology</strong></th><th><strong>Topology Aware Hints</strong></th></tr></thead><tbody><tr><td>配置方式</td><td>显式定义 <code>topologyKeys</code></td><td>自动识别 + 注解触发</td></tr><tr><td>流量分配</td><td>全有或全无（匹配层级）</td><td>按比例分配（权重化）</td></tr><tr><td>控制粒度</td><td>拓扑域级别</td><td>单个端点级别</td></tr><tr><td>会话保持</td><td>无</td><td>通过 iptables –recent 实现</td></tr><tr><td>回退机制</td><td>立即回退到下一层级</td><td>渐进式回退 + 比例控制</td></tr></tbody></table><h2 id="Endpoint-对象"><a href="#Endpoint-对象" class="headerlink" title="Endpoint 对象"></a>Endpoint 对象</h2><p>Endpoint 对象是 Kubernetes 服务发现机制的核心组件，其工作原理和细节可从以下四个维度深入理解：</p><img src="/2025/04/03/kubernetes-Service%E5%AF%B9%E8%B1%A1/image-20250410100946603.png" class="" title="image-20250410100946603"><h4 id="一、控制器协同机制"><a href="#一、控制器协同机制" class="headerlink" title="一、控制器协同机制"></a>一、控制器协同机制</h4><p>Endpoint Controller 通过监听 Service 和 Pod 的变更事件实现动态同步：</p><ol><li>采用 Informer 机制监听 API Server 事件（Watch 机制 + 增量队列）</li><li>事件处理逻辑：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// kubernetes/pkg/controller/endpoint/endpoints_controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Controller)</span></span> syncService(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    service, exists, err := e.serviceStore.GetByKey(key)<br>    <span class="hljs-comment">// 获取匹配的 Pod 列表</span><br>    pods, err := e.podLister.Pods(namespace).List(selector)<br>    <span class="hljs-comment">// 构建 subsets 数据结构</span><br>    subsets := []v1.EndpointSubset&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pod.Status.PodIP) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 就绪状态判断逻辑</span><br>        ready := podutil.IsPodReady(pod)<br>        <span class="hljs-keyword">if</span> !ready &amp;&amp; !service.Spec.PublishNotReadyAddresses &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 填充 endpoint 地址</span><br>        epAddress := v1.EndpointAddress&#123;<br>            IP:       pod.Status.PodIP,<br>            NodeName: &amp;pod.Spec.NodeName,<br>            TargetRef: &amp;v1.ObjectReference&#123;<br>                Kind:      <span class="hljs-string">&quot;Pod&quot;</span>,<br>                Namespace: pod.Namespace,<br>                Name:      pod.Name,<br>                UID:       pod.UID,<br>            &#125;,<br>        &#125;<br>        <span class="hljs-comment">// 端口映射处理</span><br>        <span class="hljs-keyword">for</span> _, svcPort := <span class="hljs-keyword">range</span> service.Spec.Ports &#123;<br>            <span class="hljs-comment">// 端口匹配逻辑...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二、就绪状态判定体系"><a href="#二、就绪状态判定体系" class="headerlink" title="二、就绪状态判定体系"></a>二、就绪状态判定体系</h4><ol><li>就绪探针深度集成：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Pod 定义示例</span><br><span class="hljs-attr">readinessProbe:</span><br>  <span class="hljs-attr">httpGet:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ol start="2"><li>状态机转换逻辑：</li></ol><ul><li>Pod 的 <code>status.conditions</code> 包含 <code>PodReady</code> 条件</li><li>kubelet 每 10 秒（默认）执行探针检测</li><li>连续成功次数达到阈值后标记为 Ready</li><li>失败时触发 endpoint 地址移除（默认配置下）</li></ul><h4 id="三、网络流量控制实现"><a href="#三、网络流量控制实现" class="headerlink" title="三、网络流量控制实现"></a>三、网络流量控制实现</h4><ol><li>kube-proxy 同步机制：</li></ol><ul><li>通过 EndpointSlice 控制器监听变更</li><li>实现 IPVS 规则动态更新：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># IPVS 规则示例</span><br>ipvsadm -Ln -t 10.96.0.10:80<br>Prot LocalAddress:Port Scheduler Flags<br>  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn<br>  -&gt; 10.244.1.2:9376              Masq    1      0          0<br>  -&gt; 10.244.1.3:9376              Masq    1      0          0<br></code></pre></td></tr></table></figure><ol start="2"><li>流量切换策略：</li></ol><ul><li>滚动更新时新旧 endpoint 共存</li><li>连接保持时间（默认 15s）影响长连接服务</li></ul><h4 id="四、生产环境最佳实践"><a href="#四、生产环境最佳实践" class="headerlink" title="四、生产环境最佳实践"></a>四、生产环境最佳实践</h4><ol><li>监控指标体系建设：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prometheus"># 关键监控指标<br>kube_endpoint_address_available<br>kube_endpoint_address_not_ready<br>kubeproxy_sync_proxy_rules_duration_seconds<br></code></pre></td></tr></table></figure><ol start="2"><li>异常场景处理：</li></ol><ul><li>僵尸 endpoint 检测（IP 冲突&#x2F;残留）</li><li>大规模集群 EndpointSlice 优化（默认每 EndpointSlice 包含 100 地址）</li></ul><ol start="3"><li>高级调度策略：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">topologyKeys:</span> [<span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span>]<br>  <span class="hljs-attr">externalTrafficPolicy:</span> <span class="hljs-string">Local</span><br></code></pre></td></tr></table></figure><h4 id="典型故障排查流程："><a href="#典型故障排查流程：" class="headerlink" title="典型故障排查流程："></a>典型故障排查流程：</h4><ol><li>检查 endpoint 状态：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get endpoints &lt;service-name&gt; -o yaml<br></code></pre></td></tr></table></figure><ol start="2"><li>验证 kube-proxy 日志：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">journalctl -u kube-proxy --since <span class="hljs-string">&quot;5 minutes ago&quot;</span> | grep SyncProxy<br></code></pre></td></tr></table></figure><ol start="3"><li>网络连通性测试：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -it test-pod -- curl -v http://service-ip:port<br></code></pre></td></tr></table></figure><p>理解 Endpoint 对象需要结合 Kubernetes 控制器模式、网络插件实现、探针机制等多个子系统。生产环境中需特别注意 endpoint 更新延迟（默认 30 秒同步周期）对服务发现的影响，大规模部署时应考虑启用 EndpointSlice 提升性能。</p><h2 id="EndpointSlice"><a href="#EndpointSlice" class="headerlink" title="EndpointSlice"></a><strong>EndpointSlice</strong></h2><h3 id="什么是-EndpointSlice-对象？"><a href="#什么是-EndpointSlice-对象？" class="headerlink" title="什么是 EndpointSlice 对象？"></a>什么是 <strong>EndpointSlice</strong> 对象？</h3><p><code>EndpointSlice</code> 是 Kubernetes 1.16 引入的一种 API 对象，旨在优化服务端点（Endpoints）的管理和扩展性问题。它是 <code>Endpoints</code> 的增强版本，用于解决服务规模变大时 <code>Endpoints</code> 对象所表现出的性能和可扩展性限制。</p><hr><h3 id="为什么需要-EndpointSlice？"><a href="#为什么需要-EndpointSlice？" class="headerlink" title="为什么需要 EndpointSlice？"></a>为什么需要 <strong>EndpointSlice</strong>？</h3><ol><li><p><strong>Endpoints 的膨胀问题</strong><br><code>Endpoints</code> 对象会存储某个 <code>Service</code> 所有后端 Pod 的地址信息。当后端 Pod 数量增多时，<code>Endpoints</code> 对象会变得异常庞大，从而导致：</p><ul><li>接近集群对象的天花板（例如 etcd 存储负载的增长）。</li><li><code>Endpoints</code> 的更新操作影响性能（所有节点需要重新 watch 它）。</li><li>集群网络带宽的浪费。</li></ul></li><li><p><strong>高频更新带来的开销</strong></p><ul><li>当 Pod 状态变化时，<code>Endpoints</code> 会更新所有服务相关的地址信息，并将这些变更分发给所有与集群相关的组件（如 kube-proxy）。</li><li>这可能会导致高容量的网络流量。</li></ul></li><li><p><strong>缺乏可扩展性</strong><br>大量的 <code>Endpoints</code> 数据会导致 kube-proxy、DNS 解析等组件性能下降，尤其是当服务规模达到上千个 Pod 时。</p></li></ol><hr><h3 id="EndpointSlice-的工作原理和设计"><a href="#EndpointSlice-的工作原理和设计" class="headerlink" title="EndpointSlice 的工作原理和设计"></a><strong>EndpointSlice</strong> 的工作原理和设计</h3><p><code>EndpointSlice</code> 提供了一种通过分片（Slice）方式存储服务端点的机制，它将服务的端点列表分割成更小的片段——每个 <code>EndpointSlice</code> 对象中可以存储一小段后端 Pod 的信息。这样实现了灵活性和扩展性的平衡。</p><ol><li><p><strong>分片存储</strong></p><ul><li>每个 <code>EndpointSlice</code> 对象内只维护部分服务端点。</li><li>默认情况下，Kubernetes 控制每个切片中包含 100 个端点（该值可以通过 <code>--max-endpoints-per-slice</code> 参数调整）。</li></ul></li><li><p><strong>高效的更新机制</strong></p><ul><li>只更新发生变更的 <code>EndpointSlice</code>，而不是整个 <code>Endpoints</code> 对象。</li><li>降低了更新的频率和数据量，从而减少了网络流量的开销。</li></ul></li><li><p><strong>更灵活的拓扑信息</strong></p><ul><li><code>EndpointSlice</code> 中引入了 <code>topology</code> 字段，可以用来标识这些端点的位置（例如节点名、可用区信息等）。</li><li>通过这种方式实现流量的智能调度，如跨区域分发或节点本地访问。</li></ul></li></ol><hr><h3 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h3><p>以下是 <code>EndpointSlice</code> 的 YAML 配置示例及关键字段说明：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">discovery.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">EndpointSlice</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-abc</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">kubernetes.io/service-name:</span> <span class="hljs-string">example</span>  <span class="hljs-comment"># 与 Service 绑定的名称</span><br><span class="hljs-attr">addressType:</span> <span class="hljs-string">IPv4</span>  <span class="hljs-comment"># 支持 IPv4、IPv6 和 FQDN（全限定域名）</span><br><span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">endpoints:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10.1.2.3&quot;</span>  <span class="hljs-comment"># 后端 Pod 的 IP 地址</span><br>    <span class="hljs-attr">conditions:</span><br>      <span class="hljs-attr">ready:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 标识 Pod 是否处于 Ready 状态</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">pod-1</span>  <span class="hljs-comment"># Pod 名称</span><br>    <span class="hljs-attr">topology:</span><br>      <span class="hljs-attr">kubernetes.io/hostname:</span> <span class="hljs-string">node-1</span>  <span class="hljs-comment"># 节点名</span><br>      <span class="hljs-attr">topology.kubernetes.io/zone:</span> <span class="hljs-string">us-west2-a</span>  <span class="hljs-comment"># 区域位置</span><br></code></pre></td></tr></table></figure><p><strong>重要字段：</strong></p><ul><li><code>addressType</code>：定义服务的通信地址类型，比如 IPv4。</li><li><code>ports</code>：服务所暴露的端口信息，包括协议和端口号。</li><li><code>endpoints</code>：具体到某组 Pod 的地址、状态等信息。</li><li><code>topology</code>：拓扑信息，可以用来做流量调度优化。</li></ul><hr><h3 id="解决了哪些问题？"><a href="#解决了哪些问题？" class="headerlink" title="解决了哪些问题？"></a>解决了哪些问题？</h3><ol><li><p><strong>降低资源消耗</strong></p><ul><li><code>EndpointSlice</code> 减少了随着服务规模增加而带来的 etcd 和网络负担。</li></ul></li><li><p><strong>增强可扩展性</strong></p><ul><li>通过对服务端点列表进行分片，解决了大规模服务中单个 <code>Endpoints</code> 对象过大的问题。</li><li>更快的更新和更小的更新负载适合超大规模的分布式系统。</li></ul></li><li><p><strong>改进网络流量管理</strong></p><ul><li>只通知变更的 Slice。</li><li>减少 kube-proxy 或 CoreDNS 等组件重新获取巨大端点列表的流量。</li></ul></li><li><p><strong>灵活的拓扑感知</strong></p><ul><li>允许用户进行区域或节点本地化流量路由。</li></ul></li></ol><hr><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p><strong>高可扩展性需求</strong><br>当一个 Service 的后端 Pod 数量达到数百甚至数千个时，<code>EndpointSlice</code> 的分片存储能够极大提高效率。</p></li><li><p><strong>分布式系统</strong><br>在跨区域、多节点的场景中，通过 <code>topology</code> 字段实现基于位置的流量优化。</p></li><li><p><strong>动态更新场景</strong><br>在高频率动态更新的场景中，<code>EndpointSlice</code> 减少网络更新的开销和对节点的广播负载。</p></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生命周期管理和服务发现</title>
    <link href="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <url>/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250329130114043.png" class="" title="image-20250329130114043"><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250329130138677.png" class="" title="image-20250329130138677"><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250329130149736.png" class="" title="image-20250329130149736"><h2 id="K8S-的-QoS-类分类"><a href="#K8S-的-QoS-类分类" class="headerlink" title="K8S 的 QoS 类分类"></a>K8S 的 QoS 类分类</h2><p>Kubernetes 定义了三种 QoS 类，分别是：</p><h4 id="1-Guaranteed"><a href="#1-Guaranteed" class="headerlink" title="1. Guaranteed"></a>1. <strong>Guaranteed</strong></h4><ul><li><p>一个 Pod <strong>所有容器</strong>的 <code>requests</code> 和 <code>limits</code> 必须完全相等。</p></li><li><p>特性：这类 Pod 通常被视为最高优先级资源请求，因此在资源争夺时被保留。</p></li><li><p>场景：适用于需要强资源保证的关键性应用。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">guaranteed-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Burstable"><a href="#2-Burstable" class="headerlink" title="2. Burstable"></a>2. <strong>Burstable</strong></h4><ul><li><p>如果 Pod 至少有一个容器的 <code>requests</code> 设置了，但 <code>requests</code> 和 <code>limits</code> 不完全相等，则 Pod 被归为 <code>Burstable</code>。</p></li><li><p>特性：该类 Pod 会优先获取至少等于 <code>requests</code> 的资源，其余资源可在容量溢出时被收回。</p></li><li><p>场景：适合对资源核心需求较低，但能够在负载高峰期动态扩展的场景。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">burstable-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.2&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-BestEffort"><a href="#3-BestEffort" class="headerlink" title="3. BestEffort"></a>3. <strong>BestEffort</strong></h4><ul><li><p>如果 Pod <strong>所有容器</strong>都没有配置 <code>requests</code> 或 <code>limits</code>，则它属于 <code>BestEffort</code>。</p></li><li><p>特性：属于最低优先级 Pod，仅在其他资源有剩余时可分配资源。</p></li><li><p>场景：适用于非核心、无资源保障需求的后备工作负载。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">besteffort-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="QoS-Class-在调度中的运作机制"><a href="#QoS-Class-在调度中的运作机制" class="headerlink" title="QoS Class 在调度中的运作机制"></a>QoS Class 在调度中的运作机制</h3><p>Kubernetes 的调度器主要通过以下几个相关逻辑处理 QoS 类：</p><h4 id="1-资源分配优先级"><a href="#1-资源分配优先级" class="headerlink" title="1. 资源分配优先级"></a>1. <strong>资源分配优先级</strong></h4><ul><li><code>Guaranteed &gt; Burstable &gt; BestEffort</code></li><li>Kubernetes Scheduler 在评估节点资源是否充足时，对于 Guaranteed 的 Pod 会尝试确保其分配请求的资源总量和上限。</li><li>Burstable 会优先与 Requests 值匹配，但 Limits 超出部分可能因抢占而被剥夺。</li><li>BestEffort Pod 通常在资源充足时才被调度，但在资源紧张时可能完全无法运行。</li></ul><h4 id="2-Node-Eviction（节点逐出机制）"><a href="#2-Node-Eviction（节点逐出机制）" class="headerlink" title="2. Node Eviction（节点逐出机制）"></a>2. <strong>Node Eviction（节点逐出机制）</strong></h4><p>   当节点资源耗尽或压力过高（例如内存压力<code>MemoryPressure</code>），Kubernetes 使用 QoS 类来决定驱逐的优先级：</p><ul><li><strong>BestEffort</strong>：首当其冲被驱逐，适合非关键性负载。</li><li><strong>Burstable</strong>：在满足请求的基础上，超出的部分会被挤占或驱逐。</li><li><strong>Guaranteed</strong>：保证级别最高，最后才会被驱逐。</li></ul><h4 id="3-调度优先级"><a href="#3-调度优先级" class="headerlink" title="3. 调度优先级"></a>3. <strong>调度优先级</strong></h4><ul><li>调度器会根据节点的资源可用性优先分配高 QoS 的 Pod。</li><li>考虑结合 <code>Taints</code> 和 <code>Tolerations</code>、资源亲和性等规则提高具体调度的确定性。</li></ul><h4 id="举例：调度阶段中的-QoS-Decision"><a href="#举例：调度阶段中的-QoS-Decision" class="headerlink" title="举例：调度阶段中的 QoS Decision"></a>举例：调度阶段中的 QoS Decision</h4><p>当新的 Pod 到来时，Kubernetes Scheduler 会依次检查以下项：</p><ul><li>是否满足 Pod 的 <code>requests</code>（按 QoS 优先顺序检查）；</li><li>节点剩余容量能否满足 Pod 的 <code>limits</code>；</li><li>Resource Fit Filter（调度器中的 Fit 规则）根据 QoS 级别动态评估节点状态和适合性。</li></ul><hr><h3 id="调度-QoS-类的实际操作与优化"><a href="#调度-QoS-类的实际操作与优化" class="headerlink" title="调度 QoS 类的实际操作与优化"></a>调度 QoS 类的实际操作与优化</h3><p>为了更好地调度不同 QoS 的 Pod，我们可以采取以下策略：</p><h4 id="1-调整资源分配规则"><a href="#1-调整资源分配规则" class="headerlink" title="1. 调整资源分配规则"></a>1. <strong>调整资源分配规则</strong></h4><p>   为关键性的应用分配 QoS <code>Guaranteed</code>，明确资源上下界，保证资源独占或排他性。</p><h4 id="2-Taints-和-Tolerations"><a href="#2-Taints-和-Tolerations" class="headerlink" title="2. Taints 和 Tolerations"></a>2. <strong>Taints 和 Tolerations</strong></h4><p>   配合使用 Taints 和 Tolerations，将高 QoS 的应用调度到专用节点。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">taints:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">critical</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br></code></pre></td></tr></table></figure><h4 id="3-预留关键性资源节点"><a href="#3-预留关键性资源节点" class="headerlink" title="3. 预留关键性资源节点"></a>3. <strong>预留关键性资源节点</strong></h4><p>   Kubernetes 支持通过 <code>kube-reserved</code>、<code>system-reserved</code> 等方式预留关键性资源，保证平台本身稳定运行。</p><h4 id="4-配额管理"><a href="#4-配额管理" class="headerlink" title="4. 配额管理"></a>4. <strong>配额管理</strong></h4><p>   使用 ResourceQuotas 限制低 QoS 的资源消耗，如限制 <code>BestEffort</code> Pod 数量，确保资源可为高 QoS 的 Pod 使用。</p><h2 id="健康探针"><a href="#健康探针" class="headerlink" title="健康探针"></a>健康探针</h2><p>Kubernetes 中的三种健康检查探针（Liveness、Readiness、Startup）是保障容器化应用稳定性的核心机制，其设计深度融入了分布式系统的容错理念。</p><ol><li><p><strong>Liveness Probe（存活探针）</strong></p><ul><li><strong>核心作用</strong>：通过持续检测容器进程状态，实现故障自愈（Self-healing）机制</li><li><strong>实现原理</strong>：<ul><li>基于 Linux cgroups 的进程监控，当探测连续失败超过阈值时，kubelet 通过 CRI（Container Runtime Interface）触发容器重建</li><li>底层使用 Linux 的 <code>kill()</code> 系统调用发送 SIGTERM，等待优雅终止期后发送 SIGKILL</li></ul></li><li><strong>典型场景</strong>：<ul><li>检测死锁状态（如 Golang 的 runtime.Stack 可获取 goroutine 堆栈）</li><li>内存泄漏导致 OOM 前的主动回收（需配合 memory limits 使用）</li><li>文件系统损坏等不可恢复错误</li></ul></li><li><strong>高级配置</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">livenessProbe:</span><br>  <span class="hljs-attr">exec:</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;pgrep -x myapp || exit 1&quot;</span>]<br>  <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># 避免过早触发（考虑 JVM 类加载时间）</span><br>  <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">5</span><br>  <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>        <span class="hljs-comment"># 基于业务 RT 设置</span><br>  <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span>      <span class="hljs-comment"># 根据 SLA 调整</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Readiness Probe（就绪探针）</strong></p><ul><li><strong>流量治理本质</strong>：实现 Kubernetes Service 的最终一致性负载均衡</li><li><strong>网络层机制</strong>：<ul><li>通过修改 iptables&#x2F;ipvs 规则，将 Endpoint 从 Service 的 endpoints 对象中剔除</li><li>kube-proxy 监听 API Server 的 Endpoints 变化，动态更新节点转发规则</li></ul></li><li><strong>关键应用</strong>：<ul><li>预热阶段（如 JIT 编译、缓存加载）</li><li>依赖服务连接检查（数据库、Redis 连接池健康状态）</li><li>流量熔断（基于 QPS&#x2F;Latency 的动态降级）</li></ul></li><li><strong>Go 语言实现示例</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readinessHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> db.Ping() != <span class="hljs-literal">nil</span> || cache.Connected() == <span class="hljs-literal">false</span> &#123;<br>        w.WriteHeader(http.StatusServiceUnavailable)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    w.WriteHeader(http.StatusOK)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Startup Probe（启动探针）</strong></p><ul><li><strong>设计哲学</strong>：解决 CAP 理论中一致性（Consistency）与可用性（Availability）的权衡问题</li><li><strong>内核级机制</strong>：<ul><li>通过 Linux 的 inotify 机制监控进程的 &#x2F;proc 文件系统状态</li><li>结合 cgroup 的 freezer subsystem 实现进程状态管理</li></ul></li><li><strong>特殊场景</strong>：<ul><li>Legacy 系统迁移（如传统 Java EE 应用的长时间启动）</li><li>大数据处理容器的初始化阶段（TensorFlow&#x2F;PyTorch 模型加载）</li><li>需要与 initContainer 配合使用的复杂启动流程</li></ul></li><li><strong>性能优化配置</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">startupProbe:</span><br>  <span class="hljs-attr">httpGet:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># 总等待时间 = failureThreshold * periodSeconds</span><br>  <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><table><thead><tr><th>维度</th><th>Liveness Probe</th><th>Readiness Probe</th><th>Startup Probe</th></tr></thead><tbody><tr><td><strong>核心使命</strong></td><td>故障自愈（Fail-Fast）</td><td>流量管控（Graceful Degradation）</td><td>启动隔离（Cold Start Shield）</td></tr><tr><td><strong>K8s 响应动作</strong></td><td>重启容器（Recreate）</td><td>移除 Service Endpoints</td><td>暂停其他探针检测</td></tr><tr><td><strong>失败影响域</strong></td><td>节点级（Pod 重建）</td><td>集群级（流量路径变更）</td><td>Pod 启动阶段锁定</td></tr></tbody></table><h3 id="三种探针的执行顺序"><a href="#三种探针的执行顺序" class="headerlink" title="三种探针的执行顺序"></a>三种探针的执行顺序</h3><p>Kubernetes 允许在同一个 Pod 中同时配置三种探针（StartupProbe&#x2F;LivenessProbe&#x2F;ReadinessProbe），且它们的执行顺序和交互机制具有明确的逻辑层次。以下从内核调度和 Kubernetes 控制面角度进行深度解析：</p><ol><li><p><strong>探针执行顺序机制</strong>：</p><ul><li><strong>启动阶段</strong>：容器启动时首先激活 StartupProbe，此时 LivenessProbe 和 ReadinessProbe 会被暂时挂起</li><li><strong>状态转换</strong>：只有当 StartupProbe 首次成功后，kubelet 才会创建两个独立的 goroutine 分别执行 LivenessProbe 和 ReadinessProbe</li><li><strong>资源隔离</strong>：三种探针在 runtime 层面通过不同的 http.Client&#x2F;time.Ticker 实现，避免相互阻塞（代码见 kubernetes&#x2F;pkg&#x2F;kubelet&#x2F;prober&#x2F;prober.go）</li></ul></li><li><p><strong>内核级调度细节</strong>：</p><ul><li>探针检查本质是 kubelet 通过 CRI 接口调用容器运行时执行命令</li><li>对于 HTTP&#x2F;TCP 探针，kubelet 会创建独立的 socket 连接（Linux 内核通过 epoll 实现非阻塞 IO）</li><li>Exec 探针会通过 fork&#x2F;execve 系统调用创建子进程执行命令</li></ul></li><li><p><strong>参数设计的工程实践</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">startupProbe:</span><br>  <span class="hljs-attr">httpGet:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># 充分考虑冷启动时间</span><br>  <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">5</span>      <span class="hljs-comment"># 30*5=150秒超时窗口</span><br><br><span class="hljs-attr">livenessProbe:</span><br>  <span class="hljs-attr">exec:</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;check_running&quot;</span>]<br>  <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">60</span>  <span class="hljs-comment"># 等待业务初始化</span><br>  <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">readinessProbe:</span><br>  <span class="hljs-attr">tcpSocket:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span>       <span class="hljs-comment"># 快速失败避免雪崩</span><br></code></pre></td></tr></table></figure></li><li><p><strong>控制面状态机转换</strong>（源码级分析）：</p><ul><li>kubelet 维护的 ProbeWorker 状态机包含 <code>ProbeNotInitialized</code>、<code>ProbeCompleted</code> 等状态</li><li>就绪状态变更会触发 endpoints controller 的 watch 机制（client-go 的 informer 实现）</li><li>存活检查失败会触发 killContainer 操作（通过 containerd 的 TaskService API）</li></ul></li><li><p><strong>生产环境最佳实践</strong>：</p><ul><li>为 Java 应用设置 JVM 预热等待期（特别是 JIT 编译场景）</li><li>对 GPU 加速服务增加 CUDA 驱动检查逻辑</li><li>在 readinessProbe 成功前配置 preStop hook 引流</li><li>通过 eBPF 监控探针执行路径的性能损耗</li></ul></li></ol><p>补充一个典型错误配置案例：某 AI 推理服务因未合理设置 startupProbe，导致 Kubernetes 在模型加载期间误判存活检查失败，触发频繁重启。通过将 startupProbe 的 failureThreshold 从默认 3 调整为 30（对应 150 秒加载时间），问题得到解决。这印证了深入理解探针机制对稳定性保障的重要性。</p><h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><hr><h3 id="1-基础检测控制参数"><a href="#1-基础检测控制参数" class="headerlink" title="1. 基础检测控制参数"></a><strong>1. 基础检测控制参数</strong></h3><h4 id="1-initialDelaySeconds"><a href="#1-initialDelaySeconds" class="headerlink" title="(1) initialDelaySeconds"></a>(1) <code>initialDelaySeconds</code></h4><ul><li><strong>内核级作用</strong>：规避容器启动时 PID 1 进程初始化阶段的竞态条件</li><li><strong>默认值</strong>：0（生产环境必须显式设置）</li><li><strong>调优原则</strong>：<ul><li>JVM 应用：需超过 <code>-XX:MaxRAMPercentage</code> 参数后的堆内存初始化时间</li><li>Golang 服务：考虑 <code>init()</code> 函数中 sync.Once 初始化逻辑耗时</li></ul></li><li><strong>特殊案例</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 大数据服务典型配置</span><br><span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">120</span>  <span class="hljs-comment"># 考虑 Spark Executor 的 JVM 元空间加载</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-periodSeconds"><a href="#2-periodSeconds" class="headerlink" title="(2) periodSeconds"></a>(2) <code>periodSeconds</code></h4><ul><li><strong>调度机制</strong>：基于 kubelet 的 syncLoop 实现定时触发（精度约 ±10%）</li><li><strong>推荐值</strong>：<ul><li>Liveness：5-10s（避免过度频繁触发 OOM）</li><li>Readiness：2-5s（快速响应服务状态变化）</li></ul></li><li><strong>底层约束</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Kubernetes 源码 pkg/kubelet/prober/worker.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *worker)</span></span> run() &#123;<br>    ticker := time.NewTicker(period) <br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ticker.C:<br>            w.probe()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="2-故障容错参数"><a href="#2-故障容错参数" class="headerlink" title="2. 故障容错参数"></a><strong>2. 故障容错参数</strong></h3><h4 id="1-failureThreshold"><a href="#1-failureThreshold" class="headerlink" title="(1) failureThreshold"></a>(1) <code>failureThreshold</code></h4><ul><li><strong>算法本质</strong>：滑动窗口计数器实现的状态判断</li><li><strong>计算公式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">总检测时间 = failureThreshold × periodSeconds<br></code></pre></td></tr></table></figure></li><li><strong>典型配置</strong>：<ul><li>Liveness：3（快速故障恢复）</li><li>Startup：30（兼容慢启动应用）</li></ul></li><li><strong>特殊场景</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 金融级高可用要求</span><br><span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 配合 periodSeconds: 1 实现秒级故障检测</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-successThreshold"><a href="#2-successThreshold" class="headerlink" title="(2) successThreshold"></a>(2) <code>successThreshold</code></h4><ul><li><strong>状态恢复策略</strong>：防止网络抖动造成的状态翻转（Flapping）</li><li><strong>默认值</strong>：<ul><li>Liveness：1</li><li>Readiness：1 </li><li>Startup：1</li></ul></li><li><strong>生产实践</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">readinessProbe:</span><br>  <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">3</span>  <span class="hljs-comment"># 连续3次成功才标记 Ready</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="3-探针执行控制"><a href="#3-探针执行控制" class="headerlink" title="3. 探针执行控制"></a><strong>3. 探针执行控制</strong></h3><h4 id="1-timeoutSeconds"><a href="#1-timeoutSeconds" class="headerlink" title="(1) timeoutSeconds"></a>(1) <code>timeoutSeconds</code></h4><ul><li><strong>网络层影响</strong>：底层使用 Linux 的 TCP_USER_TIMEOUT 选项</li><li><strong>推荐值</strong>：小于 Kubernetes API Server 的默认 15s 超时</li><li><strong>Go 实现参考</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doHTTPProbe</span><span class="hljs-params">()</span></span> &#123;<br>    client := http.Client&#123;<br>        Timeout: timeoutSeconds * time.Second,<br>    &#125;<br>    resp, err := client.Get(url)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-terminationGracePeriodSeconds"><a href="#2-terminationGracePeriodSeconds" class="headerlink" title="(2) terminationGracePeriodSeconds"></a>(2) <code>terminationGracePeriodSeconds</code></h4><ul><li><strong>进程终止流程</strong>：<ol><li>发送 SIGTERM</li><li>等待 terminationGracePeriodSeconds</li><li>发送 SIGKILL</li></ol></li><li><strong>关键配置</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span>  <span class="hljs-comment"># 必须大于业务优雅关闭时间</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="4-探针类型专属参数"><a href="#4-探针类型专属参数" class="headerlink" title="4. 探针类型专属参数"></a><strong>4. 探针类型专属参数</strong></h3><h4 id="1-HTTP-GET-探针"><a href="#1-HTTP-GET-探针" class="headerlink" title="(1) HTTP GET 探针"></a>(1) HTTP GET 探针</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">httpGet:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <span class="hljs-comment"># 避免使用 Service IP（绕过 kube-proxy）</span><br>  <span class="hljs-attr">httpHeaders:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">X-Edge-Token</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;secret&quot;</span><br>  <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTPS</span>     <span class="hljs-comment"># 需要容器内配置 CA 证书</span><br></code></pre></td></tr></table></figure><h4 id="2-TCP-Socket-探针"><a href="#2-TCP-Socket-探针" class="headerlink" title="(2) TCP Socket 探针"></a>(2) TCP Socket 探针</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tcpSocket:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <span class="hljs-comment"># 防止检测外网依赖服务</span><br><span class="hljs-comment"># 底层使用 net.DialTimeout 实现</span><br></code></pre></td></tr></table></figure><h4 id="3-Exec-探针"><a href="#3-Exec-探针" class="headerlink" title="(3) Exec 探针"></a>(3) Exec 探针</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">exec:</span><br>  <span class="hljs-attr">command:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;[ $(curl -s http://localhost:8080/ready | jq .status) = &quot;OK&quot; ]&#x27;</span><br><span class="hljs-comment"># 注意：命令执行消耗的 CPU/Memory 会计入容器资源配额</span><br></code></pre></td></tr></table></figure><hr><h3 id="典型故障模式分析"><a href="#典型故障模式分析" class="headerlink" title="典型故障模式分析"></a><strong>典型故障模式分析</strong></h3><table><thead><tr><th>故障现象</th><th>根本原因</th><th>解决方案</th></tr></thead><tbody><tr><td>容器无限重启循环</td><td>livenessTimeout &lt; 服务冷启动时间</td><td>增加 initialDelaySeconds + failureThreshold</td></tr><tr><td>Service 流量丢失</td><td>readinessProbe 检测路径未排除健康检查自身</td><td>单独设置检测端点</td></tr><tr><td>节点 CPU 飙升</td><td>exec 探针脚本复杂度过高</td><td>改用轻量级 HTTP 检测</td></tr><tr><td>集群控制平面压力大</td><td>过多容器的高频探针检测</td><td>合并检测端点 + 调整 periodSeconds</td></tr></tbody></table><p>通过精准控制这些属性参数，可以实现：</p><ul><li>99.99% 的故障检测准确率（需配合 NRMSE 算法）</li><li>容器重启耗时优化至 200ms 以内（基于 CRI-O 的快速路径）</li><li>零误杀（False Positive）的服务保障</li></ul><h2 id="readinessGates"><a href="#readinessGates" class="headerlink" title="readinessGates"></a>readinessGates</h2><p>在 Kubernetes 中，<code>readinessGates</code> 是一种高级就绪状态控制机制，它扩展了传统 readinessProbe 的能力，允许将 Pod 的就绪状态与集群级或外部系统的条件绑定。以下是其技术实现原理与深度解析：</p><hr><h3 id="1-核心设计原理"><a href="#1-核心设计原理" class="headerlink" title="1. 核心设计原理"></a><strong>1. 核心设计原理</strong></h3><h4 id="1-扩展式状态判定"><a href="#1-扩展式状态判定" class="headerlink" title="(1) 扩展式状态判定"></a>(1) 扩展式状态判定</h4><ul><li><strong>传统模型缺陷</strong>：readinessProbe 只能检测 Pod 内部状态，无法感知外部依赖（如服务注册完成、配置同步等）</li><li><strong>Gates 机制</strong>：引入布尔逻辑门控概念，只有当所有门控条件满足时，Pod 才标记为 Ready</li><li><strong>条件表达式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">PodReady = (readinessProbe OK) ∧ (Gate1 OK) ∧ (Gate2 OK) ∧ ... ∧ (GateN OK)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-控制器架构"><a href="#2-控制器架构" class="headerlink" title="(2) 控制器架构"></a>(2) 控制器架构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Kubernetes 源码 pkg/kubelet/status/status_manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *manager)</span></span> SetPodReadiness(pod *v1.Pod, readiness v1.PodCondition) &#123;<br>    <span class="hljs-keyword">for</span> _, gate := <span class="hljs-keyword">range</span> pod.Spec.ReadinessGates &#123;<br>        condition := getCondition(pod.Status.Conditions, gate.ConditionType)<br>        <span class="hljs-keyword">if</span> condition == <span class="hljs-literal">nil</span> || condition.Status != v1.ConditionTrue &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">// 存在未满足的门控条件</span><br>        &#125;<br>    &#125;<br>    updatePodReadyCondition(pod, v1.ConditionTrue)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-关键技术特性"><a href="#2-关键技术特性" class="headerlink" title="2. 关键技术特性"></a><strong>2. 关键技术特性</strong></h3><h4 id="1-条件类型注册"><a href="#1-条件类型注册" class="headerlink" title="(1) 条件类型注册"></a>(1) 条件类型注册</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Pod 定义示例</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">readinessGates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">conditionType:</span> <span class="hljs-string">&quot;www.example.com/ExternalServiceRegistered&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">conditionType:</span> <span class="hljs-string">&quot;storage.example.com/DiskAttached&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-条件状态注入"><a href="#2-条件状态注入" class="headerlink" title="(2) 条件状态注入"></a>(2) 条件状态注入</h4><ul><li><strong>注入方式</strong>：<ul><li>自定义控制器通过 Kubernetes API 更新 Pod status</li><li>外部系统通过 Admission Webhook 修改</li></ul></li><li><strong>状态结构</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;www.example.com/ExternalServiceRegistered&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;True&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;lastProbeTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2023-07-20T08:00:00Z&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;reason&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ServiceRegistered&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Successfully registered with external service&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="3-底层通信机制"><a href="#3-底层通信机制" class="headerlink" title="3. 底层通信机制"></a><strong>3. 底层通信机制</strong></h3><p><img src="https://example.com/readiness-gates-arch.png" alt="readinessGates 架构图">（注：实际应用需替换真实图示）</p><ol><li><strong>条件监听器</strong>（如自定义 Operator）监控外部系统状态</li><li>通过 <code>kubectl patch</code> 或 Kubernetes Client 更新 Pod 状态</li><li>kubelet 的 statusManager 周期性同步 Pod 状态</li><li>kube-proxy 根据最终 Ready 状态更新负载均衡规则</li></ol><hr><h3 id="4-生产环境典型场景"><a href="#4-生产环境典型场景" class="headerlink" title="4. 生产环境典型场景"></a><strong>4. 生产环境典型场景</strong></h3><h4 id="场景-1：服务网格集成"><a href="#场景-1：服务网格集成" class="headerlink" title="场景 1：服务网格集成"></a>场景 1：服务网格集成</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">readinessGates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">conditionType:</span> <span class="hljs-string">&quot;servicemesh.istio.io/sidecarReady&quot;</span><br><span class="hljs-comment"># Istio 自动注入该条件，确保业务容器与 sidecar 同步就绪</span><br></code></pre></td></tr></table></figure><h4 id="场景-2：存储系统验证"><a href="#场景-2：存储系统验证" class="headerlink" title="场景 2：存储系统验证"></a>场景 2：存储系统验证</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">readinessGates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">conditionType:</span> <span class="hljs-string">&quot;csi.storage.k8s.io/volume-ready&quot;</span><br><span class="hljs-comment"># CSI 驱动程序在完成卷挂载后设置条件状态</span><br></code></pre></td></tr></table></figure><h4 id="场景-3：多云部署验证"><a href="#场景-3：多云部署验证" class="headerlink" title="场景 3：多云部署验证"></a>场景 3：多云部署验证</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">readinessGates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">conditionType:</span> <span class="hljs-string">&quot;multicloud.acme.com/CrossRegionReplicationComplete&quot;</span><br><span class="hljs-comment"># 自定义控制器验证跨云数据同步状态</span><br></code></pre></td></tr></table></figure><hr><h3 id="5-性能优化策略"><a href="#5-性能优化策略" class="headerlink" title="5. 性能优化策略"></a><strong>5. 性能优化策略</strong></h3><h4 id="1-条件更新批处理"><a href="#1-条件更新批处理" class="headerlink" title="(1) 条件更新批处理"></a>(1) 条件更新批处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 批量更新条件状态的示例代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BatchUpdateConditions</span><span class="hljs-params">(pods []*v1.Pod)</span></span> &#123;<br>    patchOps := <span class="hljs-built_in">make</span>([]PatchOperation, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        op := PatchOperation&#123;<br>            Op:    <span class="hljs-string">&quot;add&quot;</span>,<br>            Path:  <span class="hljs-string">&quot;/status/conditions/-&quot;</span>,<br>            Value: newCondition,<br>        &#125;<br>        patchOps = <span class="hljs-built_in">append</span>(patchOps, op)<br>    &#125;<br>    k8sClient.Patch(pod, patchOps)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-条件状态缓存"><a href="#2-条件状态缓存" class="headerlink" title="(2) 条件状态缓存"></a>(2) 条件状态缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 etcd watch 机制监听条件变更</span><br>kubectl get pods --watch -o jsonpath=<span class="hljs-string">&#x27;&#123;.status.conditions[?(@.type==&quot;www.example.com/ExternalServiceRegistered&quot;)]&#125;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h3 id="6-高级调试技巧"><a href="#6-高级调试技巧" class="headerlink" title="6. 高级调试技巧"></a><strong>6. 高级调试技巧</strong></h3><h4 id="1-状态追踪"><a href="#1-状态追踪" class="headerlink" title="(1) 状态追踪"></a>(1) 状态追踪</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看门控条件详情</span><br>kubectl get pod myapp -o jsonpath=<span class="hljs-string">&#x27;&#123;.status.conditions[?(@.type==&quot;www.example.com/ExternalServiceRegistered&quot;)]&#125;&#x27;</span><br><br><span class="hljs-comment"># 事件流分析</span><br>kubectl events --<span class="hljs-keyword">for</span> Pod/myapp --field-selector involvedObject.kind=Pod<br></code></pre></td></tr></table></figure><h4 id="2-延迟分析"><a href="#2-延迟分析" class="headerlink" title="(2) 延迟分析"></a>(2) 延迟分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测量条件更新延迟</span><br>ts-condition=$(kubectl get pod myapp -o jsonpath=<span class="hljs-string">&#x27;&#123;.status.conditions[?(@.type==&quot;example&quot;)].lastUpdateTime&#125;&#x27;</span>)<br>ts-patch=$(<span class="hljs-built_in">date</span> -d <span class="hljs-string">&quot;<span class="hljs-subst">$(kubectl get pod myapp -o jsonpath=&#x27;&#123;.metadata.managedFields[?(@.operation==<span class="hljs-string">&quot;Update&quot;</span>)</span>].time&#125;&#x27;)&quot;</span> +%s)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Condition propagation delay: <span class="hljs-subst">$((ts-patch - ts-condition)</span>) seconds&quot;</span><br></code></pre></td></tr></table></figure><hr><h3 id="7-安全管控机制"><a href="#7-安全管控机制" class="headerlink" title="7. 安全管控机制"></a><strong>7. 安全管控机制</strong></h3><h4 id="1-RBAC-权限控制"><a href="#1-RBAC-权限控制" class="headerlink" title="(1) RBAC 权限控制"></a>(1) RBAC 权限控制</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 自定义控制器的 ClusterRole 配置</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods/status&quot;</span>]<br>  <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;patch&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="2-准入验证"><a href="#2-准入验证" class="headerlink" title="(2) 准入验证"></a>(2) 准入验证</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 验证条件类型的 Webhook 示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateConditionType</span><span class="hljs-params">(conditionType <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> !strings.Contains(conditionType, <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;condition type must be domain-prefixed&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="8-与传统方案的对比"><a href="#8-与传统方案的对比" class="headerlink" title="8. 与传统方案的对比"></a><strong>8. 与传统方案的对比</strong></h3><table><thead><tr><th>维度</th><th>readinessProbe</th><th>readinessGates</th></tr></thead><tbody><tr><td><strong>检测触发源</strong></td><td>kubelet 主动探测</td><td>外部系统被动通知</td></tr><tr><td><strong>检测范围</strong></td><td>容器内部状态</td><td>集群级&#x2F;外部系统状态</td></tr><tr><td><strong>更新延迟</strong></td><td>秒级（依赖探测间隔）</td><td>毫秒级（基于事件驱动）</td></tr><tr><td><strong>资源消耗</strong></td><td>周期性 CPU&#x2F;网络消耗</td><td>事件驱动型低消耗</td></tr><tr><td><strong>适用场景</strong></td><td>单 Pod 内部健康检查</td><td>跨组件协同状态管理</td></tr><tr><td><strong>故障定位</strong></td><td>通过容器日志排查</td><td>需要追踪条件更新链路</td></tr></tbody></table><hr><h3 id="9-生产环境最佳实践"><a href="#9-生产环境最佳实践" class="headerlink" title="9. 生产环境最佳实践"></a><strong>9. 生产环境最佳实践</strong></h3><ol><li><strong>命名规范</strong>：条件类型采用域名反转格式（如 <code>com.example.middleware/Ready</code>）</li><li><strong>状态监控</strong>：对每个门控条件设置 Prometheus 告警规则<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">ReadinessGateStale</span><br>  <span class="hljs-attr">expr:</span> <span class="hljs-string">time()</span> <span class="hljs-bullet">-</span> <span class="hljs-string">kube_pod_status_condition_timestamp_seconds&#123;condition=~&quot;your_gate_condition&quot;&#125;</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">300</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br></code></pre></td></tr></table></figure></li><li><strong>条件回收</strong>：实现 Finalizer 机制自动清理废弃条件</li><li><strong>性能压测</strong>：在 10k Pod 规模下验证条件更新吞吐量</li></ol><hr><p>通过 readinessGates 机制，可以实现：</p><ul><li>跨集群资源的状态协同（如等待跨区存储卷准备就绪）</li><li>与 CI&#x2F;CD 流水线的深度集成（如金丝雀发布的人工审批门控）</li><li>复杂中间件系统的启动顺序控制（如数据库主从同步完成）</li></ul><h2 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a>Lifecycle Hooks</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250329143150630.png" class="" title="image-20250329143150630"><h3 id="TerminationGracePeriodSeconds"><a href="#TerminationGracePeriodSeconds" class="headerlink" title="TerminationGracePeriodSeconds"></a>TerminationGracePeriodSeconds</h3><p><code>TerminationGracePeriodSeconds</code> 是 Kubernetes 中一个非常重要的概念，它用于控制 Pod 在被删除时的优雅终止行为。具体来说，它定义了在 Pod 被删除后，Kubernetes 会等待多长时间才强制终止 Pod 中的容器。这个参数的主要目的是确保应用程序有足够的时间完成清理工作，比如关闭数据库连接、保存状态、处理未完成的请求等。</p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><p><strong>Pod 删除流程</strong>：</p><ul><li>当用户或控制器（如 Deployment、StatefulSet）请求删除一个 Pod 时，Kubernetes 会首先向 Pod 中的每个容器发送 <code>SIGTERM</code> 信号，通知它们即将被终止。</li><li>容器在接收到 <code>SIGTERM</code> 信号后，可以执行一些清理操作，比如关闭连接、保存数据等。</li><li>如果容器在 <code>TerminationGracePeriodSeconds</code> 指定的时间内没有自行退出，Kubernetes 会发送 <code>SIGKILL</code> 信号，强制终止容器。</li></ul></li><li><p><strong>默认值</strong>：</p><ul><li>如果未显式设置 <code>TerminationGracePeriodSeconds</code>，Kubernetes 会使用默认值 30 秒。这意味着 Kubernetes 会等待 30 秒，如果容器在这段时间内没有退出，就会强制终止它。</li></ul></li><li><p><strong>自定义值</strong>：</p><ul><li>你可以通过设置 <code>TerminationGracePeriodSeconds</code> 来调整这个等待时间。例如，如果你的应用程序需要更多时间来完成清理工作，可以将这个值设置为 60 秒或更长。</li><li>如果你希望立即终止 Pod，可以将这个值设置为 0 或 1 秒。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li><strong>长时间运行的清理任务</strong>：如果你的应用程序在关闭时需要执行一些耗时的操作（如数据持久化、日志上传等），可以增加 <code>TerminationGracePeriodSeconds</code> 的值。</li><li><strong>快速终止</strong>：对于一些无状态或不需要清理的应用程序，可以减小这个值，以加快 Pod 的终止速度。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">60</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">my-image</span><br></code></pre></td></tr></table></figure><p>在这个示例中，Kubernetes 会在删除 Pod 时等待 60 秒，如果容器在这段时间内没有退出，才会强制终止它。</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250401111633442.png" class="" title="image-20250401111633442"><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250401111817481.png" class="" title="image-20250401111817481"><hr><p>在 Kubernetes 和容器化场景中，postStart 和 postStop 属于容器生命周期钩子（Lifecycle Hooks），它们为开发者提供了介入容器关键生命周期的能力。以下从 Linux 进程管理、Kubernetes 实现机制和 Golang 实践三个维度进行深度解析：</p><hr><h3 id="一、底层机制与执行时机"><a href="#一、底层机制与执行时机" class="headerlink" title="一、底层机制与执行时机"></a>一、底层机制与执行时机</h3><ol><li><p><strong>postStart Hook</strong></p><ul><li><strong>触发时机</strong>：在容器创建后但主进程（ENTRYPOINT）启动前执行</li><li><strong>实现原理</strong>：通过 Linux cgroups 和命名空间隔离环境，由 kubelet 调用容器运行时接口（CRI）触发</li><li><strong>执行方式</strong>：<ul><li><code>ExecAction</code>：在容器内执行命令（通过 <code>nsenter</code> 进入容器命名空间）</li><li><code>HTTPGetAction</code>：向容器 IP 发起 HTTP 请求</li></ul></li></ul></li><li><p><strong>postStop Hook</strong> </p><ul><li><strong>触发时机</strong>：在容器终止信号（SIGTERM）发送后，但容器完全终止前执行</li><li><strong>同步特性</strong>：必须等待 postStop 完成才会发送 SIGKILL（最长等待时间由 terminationGracePeriodSeconds 控制）</li><li><strong>典型应用</strong>：数据库连接池的优雅关闭、服务注册中心的注销操作</li></ul></li></ol><hr><h3 id="二、Kubernetes-实现细节"><a href="#二、Kubernetes-实现细节" class="headerlink" title="二、Kubernetes 实现细节"></a>二、Kubernetes 实现细节</h3><p>通过分析 Kubernetes 1.27 源码（pkg&#x2F;kubelet&#x2F;kuberuntime&#x2F;lifecycle.go）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *kubeGenericRuntimeManager)</span></span> runHook(ctx context.Context, containerID kubecontainer.ContainerID, hook *v1.LifecycleHook, pod *v1.Pod, handler <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> hook.Exec != <span class="hljs-literal">nil</span>:<br>        <span class="hljs-keyword">return</span> m.runExecHook(ctx, containerID, hook.Exec.Command, pod, handler)<br>    <span class="hljs-keyword">case</span> hook.HTTPGet != <span class="hljs-literal">nil</span>:<br>        <span class="hljs-keyword">return</span> m.runHTTPHook(ctx, hook.HTTPGet, pod, handler)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>钩子执行过程会：</p><ol><li>通过 CRI 接口获取容器文件系统访问权限</li><li>在独立的临时进程空间执行命令</li><li>设置 2 秒的连接超时和 1 秒的等待头部超时（HTTP 模式）</li></ol><hr><h3 id="三、Golang-实践建议"><a href="#三、Golang-实践建议" class="headerlink" title="三、Golang 实践建议"></a>三、Golang 实践建议</h3><h4 id="1-postStart-典型场景"><a href="#1-postStart-典型场景" class="headerlink" title="1. postStart 典型场景"></a>1. postStart 典型场景</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 配合 readinessProbe 实现服务预热</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initCache</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := cache.Preload(); err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatal(<span class="hljs-string">&quot;Cache preload failed&quot;</span>)<br>        &#125;<br>        healthz.Ready() <span class="hljs-comment">// 更新健康检查状态</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>需注意：</p><ul><li>钩子执行时间不计入 Pod 的 readiness 状态</li><li>建议与 startupProbe 配合使用控制超时</li></ul><h4 id="2-postStop-优雅关闭模式"><a href="#2-postStop-优雅关闭模式" class="headerlink" title="2. postStop 优雅关闭模式"></a>2. postStop 优雅关闭模式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>    signal.Notify(stopCh, syscall.SIGTERM)<br>  <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        &lt;-stopCh<br>        grpcServer.GracefulStop()  <span class="hljs-comment">// 优雅关闭 gRPC</span><br>        db.CloseIdleConnections()  <span class="hljs-comment">// 关闭数据库连接</span><br>        os.Exit(<span class="hljs-number">0</span>)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>需配合：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><hr><h3 id="四、生产环境注意事项"><a href="#四、生产环境注意事项" class="headerlink" title="四、生产环境注意事项"></a>四、生产环境注意事项</h3><ol><li><p><strong>执行顺序陷阱</strong>：</p><ul><li>postStart 不保证在 ENTRYPOINT 之前完成</li><li>需通过启动脚本实现顺序控制：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/post-init.sh &amp;&amp; <span class="hljs-built_in">exec</span> /main-process<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>信号处理冲突</strong>：</p><ul><li>主进程需正确处理 SIGTERM 和 SIGKILL</li><li>避免在 postStop 中执行长时操作（超过 terminationGracePeriodSeconds）</li></ul></li><li><p><strong>调试技巧</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl debug pod/[pod-name] -it --image=nicolaka/netshoot<br>nsenter -t $(pgrep -o main-process) -n tcpdump -i eth0<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="五、架构设计启示"><a href="#五、架构设计启示" class="headerlink" title="五、架构设计启示"></a>五、架构设计启示</h3><ol><li><strong>服务网格集成</strong>：Istio 等 sidecar 注入场景下，需确保 postStop 完成服务网格的注销</li><li><strong>有状态服务</strong>：数据库类应用应在 postStop 中完成检查点持久化</li><li><strong>分布式锁管理</strong>：结合 etcd 实现租约机制，确保 postStop 能可靠释放资源</li></ol><p>这些钩子的合理使用需要结合 Linux 信号机制、Kubernetes 调度原理和应用程序的业务特性进行综合设计，建议通过 eBPF 工具观察实际执行过程来验证生命周期时序。</p><hr><h2 id="容器应用可能面临的进程中断"><a href="#容器应用可能面临的进程中断" class="headerlink" title="容器应用可能面临的进程中断"></a>容器应用可能面临的进程中断</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250401114121396.png" class="" title="image-20250401114121396"><p>这张表格展示了 Kubernetes 管理环境中，节点（Node）或者运行时操作可能对容器化应用带来的“进程中断”问题分类，并提供了一些建议以最小化对业务的影响。这些问题通常来源于节点的状态变更，如升级、重启、下线维护、甚至崩溃等。以下是对表格内容的进一步解释和解析：</p><hr><h3 id="1-Kubelet-升级"><a href="#1-Kubelet-升级" class="headerlink" title="1. Kubelet 升级"></a>1. <strong>Kubelet 升级</strong></h3><p><strong>影响：</strong></p><ul><li>Kubelet 是 Kubernetes 工作节点中负责与容器运行时通信并管理 Pod 生命周期的组件。</li><li>升级 Kubelet 时，通常不需要重建容器，但如果升级过程中导致 Kubelet崩溃或短暂不可用，可能会导致用户 Pod 暂时失去调度能力。</li><li>如果出现 Kubelet 设置异常（例如计算 hash 的方式改变），也可能触发容器进程的重新启动，进而影响应用的正常运行。</li></ul><p><strong>建议：</strong></p><ul><li><strong>冗余部署：</strong> 增加多副本的 Pod，确保某一节点异常时，不会导致服务不可用。</li><li><strong>跨故障域部署：</strong> 将应用部署在不同节点或不同可用区内（如果是公有云环境），降低单节点问题对应用的影响。</li></ul><hr><h3 id="2-主机操作系统升级-节点手工重启"><a href="#2-主机操作系统升级-节点手工重启" class="headerlink" title="2. 主机操作系统升级 &#x2F; 节点手工重启"></a>2. <strong>主机操作系统升级 &#x2F; 节点手工重启</strong></h3><p><strong>影响：</strong></p><ul><li>重启整个主机（可能是因为操作系统升级、内核补丁安装等），节点会短暂不可用，这会导致：<ul><li>Pod 被标记为不可调度（NotReady 状态）。</li><li>节点上的 Pod 会终止，可能需要数分钟时间（约 10 分钟）才能重新调度到健康节点上。</li></ul></li></ul><p><strong>建议：</strong></p><ul><li><strong>跨故障域部署：</strong> 同样，确保应用有冗余。</li><li><strong>探针配置：</strong> 增加应用的 Liveness 和 Readiness 探针，用于快速定义容器运行时是否健康，以保证当 Pod 被迁移时，新调度的实例能马上被应用访问。</li><li><strong>合理设置 Toleration：</strong> 对于临时性的节点不可用问题，可以通过为 Pod 配置合理的 “NotReady node” 容忍时间（<code>tolerationSeconds</code>），避免 Pod 过早被调度到其他节点。</li></ul><hr><h3 id="3-节点下架-送修"><a href="#3-节点下架-送修" class="headerlink" title="3. 节点下架 &#x2F; 送修"></a>3. <strong>节点下架 &#x2F; 送修</strong></h3><p><strong>影响：</strong></p><ul><li>如果需要下架节点（例如硬件维护），通常会先对节点执行 <code>kubectl drain</code>，即：<ul><li>将节点标记为不可调度。</li><li>驱逐（Evict）节点上运行的 Pod，迁移到其他节点。</li><li>重启节点或者从集群中移除节点。</li></ul></li><li>这一过程中会导致：<ul><li>驱逐操作可能对服务造成秒级到分钟级中断。</li><li>如果是状态副本（如有状态应用 StatefulSet）未正确处理迁移，可能引发数据丢失。</li></ul></li></ul><p><strong>建议：</strong></p><ul><li><strong>Pod Disruption Budget（PDB）：</strong> 利用 PDB 控制驱逐过程中的并发限制，确保节点上的 Pod 不被过度驱逐，影响到业务整体的健康状态。</li><li><strong>PreStop 处理：</strong> 配置 Pod 的 <code>preStop</code> 钩子，在 Pod 被终止前执行关键操作，比如数据同步、日志备份等。</li><li><strong>跨故障域部署：</strong> 避免所有实例跑在同一节点上。需要注意，某些节点亲和场景（如 GPU）下可能需要特殊调整。</li></ul><hr><h3 id="4-节点崩溃"><a href="#4-节点崩溃" class="headerlink" title="4. 节点崩溃"></a>4. <strong>节点崩溃</strong></h3><p><strong>影响：</strong></p><ul><li>如果发生硬件故障或者节点程序奔溃导致节点不可用，结果是：<ul><li>节点上的 Pod 也会被中断（约 15 分钟）。</li><li>如果没有自动迁移机制，服务可能会长时间中断。</li><li>在极端情况下，可能会遗失正在运行中的数据。</li></ul></li></ul><p><strong>建议：</strong></p><ul><li><strong>跨故障域部署：</strong> 保持所有应用实例分布在不同节点，以及关键服务使用多副本架构。</li><li><strong>合理配置 Toleration：</strong> 设置 Pod 的 Toleration，让 Kubernetes 为网络异常、短暂的硬件故障（如网络抖动）做缓冲而不是直接驱逐 Pod。</li></ul><h2 id="高可用部署方式"><a href="#高可用部署方式" class="headerlink" title="高可用部署方式"></a>高可用部署方式</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250401114632259.png" class="" title="image-20250401114632259"><p>这张图的内容涉及 Kubernetes 的 <strong>高可用部署设计</strong>，尤其是在<strong>部署过程中的更新策略</strong>设计，以及如何满足容器化应用在高可用场景中的需求。</p><h3 id="1-部署实例的数量"><a href="#1-部署实例的数量" class="headerlink" title="1. 部署实例的数量"></a>1. <strong>部署实例的数量</strong></h3><p>高可用系统中的实例数量需要根据业务需求和服务负载设计，以确保服务的可用性和可靠性。</p><ul><li><p><strong>实例数量的重要性</strong>:<br>多副本部署是实现高可用的基础，Kubernetes 的 Pod 数量是通过 <code>ReplicaSet</code> 或 <code>Deployment</code> 的 <code>replicas</code> 参数来控制。如果某个实例（Pod）故障，K8S 会自动通过 <code>ReplicaSet</code> 确保重建到指定数量。</p><p><strong>设计考量</strong>：</p><ul><li>服务的 SLA 要求（如 99.99% 可用时间）；</li><li>节点能力，如硬件资源是否足够支持拟定的副本数量；</li><li>负载均衡器是否能在流量高峰时正常分配请求；</li><li>单个区域中的实例分布 versus 多区域（跨数据中心）的分布。</li></ul></li></ul><h3 id="2-更新策略"><a href="#2-更新策略" class="headerlink" title="2. 更新策略"></a>2. <strong>更新策略</strong></h3><p>更新Pod时需要遵循高可用性原则，以最小化更新带来的风险。Kubernetes 提供了蓝绿部署（Blue-Green）、滚动更新（RollingUpdate）等策略，其中滚动更新是最常用的方式，而 <code>maxSurge</code> 和 <code>maxUnavailable</code> 是影响滚动更新行为的两个关键参数。</p><h4 id="maxSurge"><a href="#maxSurge" class="headerlink" title="maxSurge"></a><strong>maxSurge</strong></h4><ul><li><strong>定义</strong>：<code>maxSurge</code> 决定了更新时，允许的最大额外副本数量（即 Pod 的临时增加数量）。</li><li><strong>意义</strong>：对于一个 Deployment，在更新时可能需要新增几个临时 Pod 来替代旧版本 Pod，这个参数控制新增 Pod 的数量，确保更新时不会中断现有服务。</li><li><strong>配置格式</strong>：支持整数值（具体数量）或百分比（相对于 <code>replicas</code> 的比例）。</li><li><strong>使用场景</strong>：<br>假设 <code>replicas=5</code>，如果设置 <code>maxSurge=1</code>，在更新过程中最多可以有 6 个 Pod 并存。</li></ul><h4 id="maxUnavailable"><a href="#maxUnavailable" class="headerlink" title="maxUnavailable"></a><strong>maxUnavailable</strong></h4><ul><li><strong>定义</strong>: <code>maxUnavailable</code> 决定了更新时允许的最大不可用 Pod 的数量，表示在滚动更新时可以容忍多少个 Pod 被终止。</li><li><strong>意义</strong>：控制了同时不可用的 Pod 数量，从而确保服务的可用性。</li><li><strong>配置格式</strong>：类似 <code>maxSurge</code>，支持整数值或百分比。</li><li><strong>考虑 ResourceQuota 的限制</strong>：<ul><li><strong>ResourceQuota</strong> 是 Kubernetes 的配额机制，用来限制命名空间内资源的使用量。在设置 <code>maxSurge</code> 时，可能会导致新的 Pod 数量超出配额，从而影响部署成功。</li><li>需要综合考虑 <code>maxSurge</code> 和 <code>maxUnavailable</code> 的配置，以避免超出资源限制，同时满足更新策略的高效性。</li></ul></li></ul><h3 id="示例组合"><a href="#示例组合" class="headerlink" title="示例组合"></a>示例组合</h3><p>假设 <code>replicas=5</code>:</p><ul><li><strong>配置 A（maxSurge&#x3D;2, maxUnavailable&#x3D;1）</strong>：最多同时运行 7 个 Pod（5 常规 Pod ＋ 2 surge Pod），同时最多允许 1 个 Pod 不可用。</li><li><strong>配置 B（maxSurge&#x3D;0, maxUnavailable&#x3D;2）</strong>：不创建额外的 Pod，同时允许最多 2 个 Pod 不可用，适用于资源受限环境。</li></ul><h3 id="3-PodTemplateHash-的影响"><a href="#3-PodTemplateHash-的影响" class="headerlink" title="3. PodTemplateHash 的影响"></a>3. <strong>PodTemplateHash 的影响</strong></h3><p><code>PodTemplateHash</code> 是 Kubernetes Deployment 中自动生成的标识，用于区分不同的 Deployment 版本。</p><ul><li><strong>导致的应用易变性</strong>：在滚动更新中，每次改变 Deployment 级别的关联属性（比如镜像版本、环境变量等），都会生成新的 <code>PodTemplateHash</code>，并以此为基础生成新的 ReplicaSet。</li><li><strong>影响</strong>：<ul><li>对于外部系统（如监控）来说，Pod 名称和标签发生变化，可能会导致短暂的不可观测性；</li><li>如果更新频繁，会导致 Pod 的快速替换，增加资源负担。</li></ul></li></ul><h4 id="深度理解和实际案例"><a href="#深度理解和实际案例" class="headerlink" title="深度理解和实际案例"></a><strong>深度理解和实际案例</strong></h4><ul><li>当更新频繁时，可以通过 <code>revisionHistoryLimit</code> 参数限制历史版本的保留数量，从而避免过多未清理资源。</li><li>在 CI&#x2F;CD 流水线中，应特别注意更新后 <code>PodTemplateHash</code> 的变化可能引发的负载均衡抖动，以及新旧版本间的兼容性问题。</li></ul><hr><p>这一流程设计的核心是，通过合理的副本数量、更新策略及与 <code>PodTemplateHash</code> 相关的配置，保证实现<strong>在线更新无中断服务</strong>，达到最佳的高可用性。</p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h3 id="1-服务发布方式"><a href="#1-服务发布方式" class="headerlink" title="1. 服务发布方式"></a>1. 服务发布方式</h3><p>云原生通过 <strong>Service</strong> 抽象定义，可以把工作负载从内部或外部暴露出去。Kubernetes 提供了多种服务发布的策略，适用于不同场景：</p><ul><li><strong>ClusterIP</strong>（默认类型，支持 Headless 模式）：用于集群内部通信，服务绑定一个虚拟 IP。</li><li><strong>NodePort</strong>：将服务暴露在每个节点的指定端口上，允许从外部访问集群。</li><li><strong>LoadBalancer</strong>：通过云提供商实现自动注册的负载均衡器（如 AWS ELB、GCP LB），用于外部流量。</li><li><strong>ExternalName</strong>：仅通过 DNS 别名将请求转发到外部地址。</li></ul><p>要注意的是，服务发布还涉及其他附加要求：</p><ul><li><strong>证书管理和负载均衡</strong>：需要保护流量的安全性，并分发请求。</li><li><strong>DNS 请求支持</strong>：如 Headless 服务，要依赖 DNS 实现 Pod 级别的粒度访问。</li><li><strong>与上下游服务的关系</strong>：服务的消费方（下游）与被消费方（上游）之间需要保持解耦和高可用。</li></ul><hr><h3 id="2-服务发现的挑战"><a href="#2-服务发现的挑战" class="headerlink" title="2. 服务发现的挑战"></a>2. 服务发现的挑战</h3><p>云原生环境中，节点、Pod 和服务都可能动态变化，这种动态性带来了以下挑战：</p><h4 id="服务层挑战："><a href="#服务层挑战：" class="headerlink" title="服务层挑战："></a>服务层挑战：</h4><ol><li><p><strong>DNS 方面</strong>：</p><ul><li><strong>DNS TTL 问题</strong>：DNS 的 TTL 设置和缓存可能导致服务 IP 变更不能被及时感知。</li><li>服务多次重启会引发客户端 DNS 查找的不一致。</li></ul></li><li><p><strong>Kubernetes Service 层：</strong></p><ul><li><strong>ClusterIP 仅限内部</strong>：默认 ClusterIP 只能用于集群内，不能直接对外。</li><li><strong>性能问题</strong>：kube-proxy 支持的 iptables 和 IPVS 有性能瓶颈和扩展性限制。</li><li><strong>Pod 动态变动问题</strong>：频繁的 Pod 动态事件（如 CrashLoop 或重启）会导致服务 Endpoint 不断变化，引发流量中断。</li><li><strong>gRPC 支持问题</strong>：不支持 gRPC 等七层协议级定位（如 resolver），可能增加开发复杂性。</li><li><strong>定制化不足</strong>：Service 不支持自定义 DNS 记录或高级路由功能。</li></ul></li><li><p><strong>对外服务问题</strong>：</p><ul><li>对外发布服务依赖云厂商的负载均衡器（如 AWS ELB），灵活性受限，费用较高。</li></ul></li></ol><h4 id="Ingress-控制器的挑战："><a href="#Ingress-控制器的挑战：" class="headerlink" title="Ingress 控制器的挑战："></a>Ingress 控制器的挑战：</h4><ul><li><strong>Spec 成熟度</strong>：Ingress 依赖标准化 Spec，但目前在复杂路由、负载均衡的配置灵活性上可能不够完善。</li><li><strong>路由高级能力不足</strong>：有限支持深度路由控制（例如路径、权重）。</li></ul><h4 id="跨地域、多集群："><a href="#跨地域、多集群：" class="headerlink" title="跨地域、多集群："></a>跨地域、多集群：</h4><p>服务发现如果跨越地域、可用区（AZ）或集群部署，则需要解决以下问题：</p><ul><li><strong>跨集群 DNS 映射</strong>：如何让集群间的 DNS 可以互相解析。</li><li><strong>流量控制和优先分配</strong>：通过流量分配策略保证区域间负载均衡。</li><li><strong>顺序更新</strong>：如何控制跨集群流量逐步切换以减少中断。</li></ul><hr><h3 id="3-解决服务发现的方法"><a href="#3-解决服务发现的方法" class="headerlink" title="3. 解决服务发现的方法"></a>3. 解决服务发现的方法</h3><h4 id="a-kube-dns和CoreDNS"><a href="#a-kube-dns和CoreDNS" class="headerlink" title="a. kube-dns和CoreDNS"></a>a. kube-dns和CoreDNS</h4><ul><li>Kubernetes 默认使用 CoreDNS 来解决动态服务的 DNS 发现，但需要注意 DNS TTL 和缓存的调优。</li><li>建议使用 Headless Service+StatefulSet 模式，让服务发现更细粒度。</li></ul><h4 id="b-Service-Mesh（如-Istio、Linkerd）"><a href="#b-Service-Mesh（如-Istio、Linkerd）" class="headerlink" title="b. Service Mesh（如 Istio、Linkerd）"></a>b. Service Mesh（如 Istio、Linkerd）</h4><ul><li><strong>高级服务发现</strong>：通过 Sidecar 代理平滑处理 gRPC、七层协议等服务注册和发现。</li><li><strong>动态路由和细粒度控制</strong>：增加流量分配、故障注入等功能。</li></ul><h4 id="c-Consul-etcd-等第三方"><a href="#c-Consul-etcd-等第三方" class="headerlink" title="c. Consul &#x2F; etcd 等第三方"></a>c. Consul &#x2F; etcd 等第三方</h4><ul><li>对于需要自定义注册的服务场景，可以引入 Consul（通过 HTTP+DNS 支持的服务发现）或 etcd （存储 IP 和元数据）等，弥补 Kubernetes 自带服务的不足。</li></ul><h4 id="d-基于-Ingress-的增强"><a href="#d-基于-Ingress-的增强" class="headerlink" title="d. 基于 Ingress 的增强"></a>d. 基于 Ingress 的增强</h4><ul><li>使用 NGINX、Traefik 等作为 Ingress 实现更复杂的负载均衡和路由策略。</li></ul><h4 id="e-跨集群服务发现"><a href="#e-跨集群服务发现" class="headerlink" title="e. 跨集群服务发现"></a>e. 跨集群服务发现</h4><ul><li>配置 DNS 代理或 Route 53 等支持跨集群的域名解析。</li><li>使用 Federation（联邦式多集群）或者服务网格来统一服务治理。</li></ul><h1 id="微服务架构下的服务治理"><a href="#微服务架构下的服务治理" class="headerlink" title="微服务架构下的服务治理"></a>微服务架构下的服务治理</h1><ul><li>微服务架构是由一系列职责单一的细粒度服务构成的分布式网状结构，服务之间通过轻量机制进行通信，这时候必然引入一个服务注册发现问题，也就是说服务提供方要注册通告服务地址，服务的调用方要能发现目标服务。</li><li>同时服务提供方一般以集群方式提供服务，也就引入了负载均衡和健康检查问题。</li></ul><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403151308553.png" class="" title="image-20250403151308553"><h2 id="网络包格式"><a href="#网络包格式" class="headerlink" title="网络包格式"></a>网络包格式</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403151336191.png" class="" title="image-20250403151336191"><h4 id="1-网络包结构概述"><a href="#1-网络包结构概述" class="headerlink" title="1. 网络包结构概述"></a>1. 网络包结构概述</h4><p>如图所示，通信数据在网络中传输时被层层封装，按照 <strong>OSI 七层模型</strong> 或 <strong>TCP&#x2F;IP 四层模型</strong>的规则格式化。这种封装逐层添加协议头，直到被传输到目的地，然后在接收端反向解析，逐层解包。以下是主要的封装结构：</p><ol><li><p><strong>应用层数据</strong>（HTTP Header 和 User Data）：</p><ul><li>位于 OSI 第 7 层，接近用户。</li><li>包含业务相关的协议，如 HTTP、DNS。</li><li>数据是最终应用所处理的内容。</li></ul></li><li><p><strong>传输层数据</strong>（TCP Header + Application Data）：</p><ul><li>位于 OSI 第 4 层。</li><li><strong>TCP Header</strong> 用于提供可靠的连接（包括分段、确认和重传）。主要字段包括：<ul><li><strong>Source Port &#x2F; Destination Port</strong>：确定源和目的应用（HTTP 通常是 80 或 443）。</li><li><strong>Sequence Number &#x2F; Acknowledgment Number</strong>：保证包的顺序和完整性。</li><li><strong>Flags (e.g., SYN, ACK, FIN)</strong>：用于连接建立和关闭。</li></ul></li></ul></li><li><p><strong>网络层数据</strong>（IP Header + TCP Segment）：</p><ul><li>位于 OSI 第 3 层。</li><li><strong>IP Header</strong> 是网络间传输的核心部分：<ul><li><strong>Source IP &#x2F; Destination IP</strong>：标识源主机和目标主机。</li><li><strong>TTL (Time to Live)</strong>：用于限制数据包的生命周期，避免网络环路。</li><li><strong>Protocol</strong>：指明承载的是哪种传输层协议（TCP 或 UDP）。</li></ul></li></ul></li><li><p><strong>链路层数据</strong>（Ethernet Header + IP Datagram）：</p><ul><li>位于 OSI 第 2 层。</li><li><strong>Ethernet Header</strong> 包含源和目的的 MAC 地址等信息，用于局域网内的传输。</li><li><strong>Frame Size</strong>：单个以太网帧的大小为 46~1500 字节（需考虑 MTU 限制）。</li></ul></li></ol><h4 id="2-负载均衡的原理与关联"><a href="#2-负载均衡的原理与关联" class="headerlink" title="2. 负载均衡的原理与关联"></a>2. 负载均衡的原理与关联</h4><p>负载均衡器位于网络传输路径中，作用是将用户请求分发到后端多个服务器来分担流量。了解网络包格式有助于理解 <strong>负载均衡器如何选择目标服务器</strong> 和 <strong>处理流量</strong>。</p><h5 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a><strong>关键点</strong>：</h5><ul><li><p><strong>网络层负载均衡（L3，IP 层）</strong>：</p><ul><li>基于 IP 报文头中的 <strong>Source IP</strong> 和 <strong>Destination IP</strong> 实现流量分发。</li><li>示例：一个用户请求到达负载均衡器，基于源 IP 哈希，将请求分配给不同的后端服务器。</li></ul></li><li><p><strong>传输层负载均衡（L4，TCP&#x2F;UDP 层）</strong>：</p><ul><li>利用 TCP&#x2F;UDP Header 中的 <strong>Source Port</strong> 和 <strong>Destination Port</strong>，**四元组（源 IP、目的 IP、源端口、目的端口）**唯一标识一个会话。</li><li>负载均衡器可以通过四元组选择后端服务器，支持粘性会话（如永久绑定到某个服务器）。</li></ul></li><li><p><strong>应用层负载均衡（L7，HTTP 层）</strong>：</p><ul><li>深入到用户 HTTP 请求内容，包括 URL 路径、请求头等。</li><li>假设用户访问不同的路径（如 <code>/api/service1</code> 和 <code>/api/service2</code>），负载均衡器可以通过路径判断并路由到不同的服务。例如 Nginx 的 <code>location</code> 配置基于路径规则分发。</li><li>通常需要解包到应用层，且影响性能（比 L4 慢）。</li></ul></li></ul><h4 id="3-实例解析：负载均衡器的处理流程"><a href="#3-实例解析：负载均衡器的处理流程" class="headerlink" title="3. 实例解析：负载均衡器的处理流程"></a>3. 实例解析：负载均衡器的处理流程</h4><p>假设一个 HTTP 请求从客户端发向服务器：</p><ul><li><p>客户端的请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/product</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure><p>在传输过程中，HTTP 数据被封装成 TCP 段（添加 TCP Header），然后附加 IP Header 和 Ethernet Header。</p></li><li><p>流程（L7 负载均衡的例子）：</p><ol><li>请求到达负载均衡器后。</li><li>负载均衡器解包，查看 IP Header，确定目的 IP 是否本机。</li><li>检查 TCP Header，维护会话表。</li><li>执行深度解析（查看 HTTP 请求路径 <code>/api/product</code>）。</li><li>根据配置规则，将流量转发到后端优先进行处理的服务器（比如 <code>/api/product</code> 的请求分发到服务 A）。</li></ol></li><li><p>对于 L4 负载均衡，负载均衡器无需解包到 HTTP 层，仅基于 TCP 四元组即可实现转发，性能更高。</p></li></ul><h2 id="集中式-LB-服务发现"><a href="#集中式-LB-服务发现" class="headerlink" title="集中式 LB 服务发现"></a>集中式 LB 服务发现</h2><p>集中式负载均衡（Load Balancer, LB）服务发现是当前后端系统中一种广泛应用的架构模式。在讨论它的具体实现和特点之前，我们先从它的原理和工作流开始逐步拆解。</p><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403190538802.png" class="" title="image-20250403190538802"><hr><h3 id="1-集中式LB的工作原理"><a href="#1-集中式LB的工作原理" class="headerlink" title="1. 集中式LB的工作原理"></a>1. 集中式LB的工作原理</h3><ol><li><p><strong>核心组件：</strong></p><ul><li><strong>服务消费者（Consumer）：</strong> 例如一个客户端应用或微服务，它需要调用另一个服务（服务提供者）以完成某些业务逻辑。</li><li><strong>服务提供者（Service Provider）：</strong> 被调用的服务，通常是后端服务的实例，运行在不同的主机或容器中。</li><li><strong>负载均衡器（Load Balancer, LB）：</strong> 这是集中式LB架构的核心组件，它作为服务消费者和服务提供者之间的中介。</li><li><strong>DNS：</strong> 用于给负载均衡器提供域名解析，方便服务消费者找到LB。</li></ul></li><li><p><strong>关键工作流程：</strong></p><ul><li><strong>地址注册与暴露：</strong> 所有服务提供者的实例地址通常由运维或服务发现机制注册在负载均衡器中。例如，LB可能会维护一个包含所有服务实例的列表，类似于：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">service-a:<br>  - 10.0.0.1:8080<br>  - 10.0.0.2:8080<br>  - 10.0.0.3:8080<br></code></pre></td></tr></table></figure></li><li><strong>服务消费者调用：</strong> 服务消费者通过DNS获取负载均衡器的地址。例如，一个域名<code>service.a.com</code>会被DNS解析到负载均衡器的IP地址。</li><li><strong>服务分发与负载：</strong> 当服务消费者发起请求时，负载均衡器根据流量分配策略（比如轮询、最小连接数等），将请求转发到某个具体的服务提供者实例。</li><li><strong>健康检查：</strong> 负载均衡器会定期探测服务提供者的健康状态，确保只把流量分发到可用的服务实例上。</li></ul></li><li><p><strong>服务发现的集中化：</strong></p><ul><li>集中式LB本身包含所有服务的实例元信息，服务消费者无需直接感知或了解服务提供者的具体地址，因为这一切由LB“隐藏”。</li><li>LB的地址是相对固定的，通过DNS指向并被硬编码到消费者配置中，从而提高了系统的统一性。</li></ul></li></ol><hr><h3 id="2-集中式LB的优点与应用场景"><a href="#2-集中式LB的优点与应用场景" class="headerlink" title="2. 集中式LB的优点与应用场景"></a>2. 集中式LB的优点与应用场景</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><p><strong>实现简单：</strong></p><ul><li>服务消费者只需要关心负载均衡器的固定地址（如DNS域名），无需直接管理和感知服务的动态变化，简化了消费者开发的复杂性。</li><li>大多数成熟的LB解决方案（例如Nginx、HAProxy、AWS ALB）都支持这种模式，工具链完善。</li></ul></li><li><p><strong>可集中化控制：</strong></p><ul><li>集中式架构使得运维可以统一配置负载均衡策略，例如限流、熔断等流量控制机制。</li><li>在这一点上，集中式LB对于传统企业和微服务初期阶段的部署非常适用。</li></ul></li><li><p><strong>健康检查：</strong></p><ul><li>负载均衡器通常内置健康检查机制，可以主动剔除不健康的服务实例，确保请求的可靠性。</li></ul></li><li><p><strong>网络抽象：</strong></p><ul><li>服务消费者无需直接感知服务实例的 IP 或端口动态变化，这种网络抽象提高了应用的可移植性。</li></ul></li></ol><h4 id="典型应用场景："><a href="#典型应用场景：" class="headerlink" title="典型应用场景："></a>典型应用场景：</h4><ul><li><strong>互联网企业的WEB层负载：</strong><br>一些互联网企业的用户访问，通常通过DNS绑定到一个集中式负载均衡器，它再将流量分配到后端服务器。</li><li><strong>企业微服务项目中的初期探索：</strong><br>在微服务初阶段，引入复杂的服务发现机制可能会加大开发和运维难度，因此集中式LB是一个较好的折中方案。</li></ul><hr><h3 id="3-集中式LB存在的不足"><a href="#3-集中式LB存在的不足" class="headerlink" title="3. 集中式LB存在的不足"></a>3. 集中式LB存在的不足</h3><h4 id="单点问题："><a href="#单点问题：" class="headerlink" title="单点问题："></a><strong>单点问题：</strong></h4><ul><li>集中式LB本身成为了整个架构的单点：<ol><li>如果LB崩溃，所有对服务提供者的请求都会中断。</li><li>尤其是在高访问量场景下，LB的吞吐瓶颈可能会导致全局性能下降。</li></ol></li></ul><h4 id="性能开销："><a href="#性能开销：" class="headerlink" title="性能开销："></a><strong>性能开销：</strong></h4><ul><li>服务消费者和服务提供者之间增加了一跳（hop），这一额外的网络转发开销在高性能场景下可能是显著的，尤其是微服务体系中频繁的跨服务调用。</li><li>LB也可能引入盲区，例如由于LB的缓存机制，可能会掩盖部分服务实例在动态变化时的信息更新。</li></ul><h4 id="动态性差："><a href="#动态性差：" class="headerlink" title="动态性差："></a><strong>动态性差：</strong></h4><ul><li>在实例数量频繁变化的情况下，集中式LB需要不断更新实例列表，如果更新不及时，可能会导致流量路由不一致，出现流量黑洞。</li></ul><hr><h3 id="4-集中式LB实现的关键技术点"><a href="#4-集中式LB实现的关键技术点" class="headerlink" title="4. 集中式LB实现的关键技术点"></a>4. 集中式LB实现的关键技术点</h3><p>在实际实现一个集中式负载均衡架构时，需要重点考虑以下几个核心技术点：</p><h4 id="1-流量分发策略："><a href="#1-流量分发策略：" class="headerlink" title="1. 流量分发策略："></a><strong>1. 流量分发策略：</strong></h4><ul><li><strong>轮询（Round-Robin）：</strong> 按顺序把流量依次分发给后端实例。其优点简单直接，但是可能无法平衡实例间的负载。</li><li><strong>最小连接数（Least Connections）：</strong> 根据后端实例当前的连接数状态选择最空闲的实例。</li><li><strong>权重分发（Weighted Round-Robin）：</strong> 给后端实例配置不同的权重，用于建模实际中实例性能的差异。</li><li><strong>一致性哈希（Consistent Hashing）：</strong> 用于确保特定消费者请求总是路由到同一个实例，在状态会话或分布式缓存中常用。</li></ul><h4 id="2-健康检查机制："><a href="#2-健康检查机制：" class="headerlink" title="2. 健康检查机制："></a><strong>2. 健康检查机制：</strong></h4><p>负载均衡器需要定期检查后端服务实例的健康状态，典型的健康检查方式包括：</p><ol><li><strong>主动检查：</strong> LB定期向服务实例发起健康检查请求（如 HTTP Ping 或 TCP连接）。</li><li><strong>被动检查：</strong> LB通过监控实例的响应状态（如状态码或超时时间）判断实例是否健康。</li></ol><h4 id="3-注册与配置管理："><a href="#3-注册与配置管理：" class="headerlink" title="3. 注册与配置管理："></a><strong>3. 注册与配置管理：</strong></h4><p>后端服务的注册通常由运维或者自动化机制完成。这可以通过静态配置文件，也可以通过动态服务发现工具（如Consul、Zookeeper、Eureka）与负载均衡器对接。</p><hr><h3 id="5-集中式LB负载均衡示例（基于简单的Go实现）"><a href="#5-集中式LB负载均衡示例（基于简单的Go实现）" class="headerlink" title="5. 集中式LB负载均衡示例（基于简单的Go实现）"></a>5. 集中式LB负载均衡示例（基于简单的Go实现）</h3><p>假设我们要实现一个基本的负载均衡器，可以用以下Go代码模拟：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-comment">// 服务提供者实例</span><br><span class="hljs-keyword">type</span> Backend <span class="hljs-keyword">struct</span> &#123;<br>URL    <span class="hljs-type">string</span><br>Healthy <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// 负载均衡器结构</span><br><span class="hljs-keyword">type</span> LoadBalancer <span class="hljs-keyword">struct</span> &#123;<br>backends []*Backend<br>curr     <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个新的负载均衡器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLoadBalancer</span><span class="hljs-params">(backends []*Backend)</span></span> *LoadBalancer &#123;<br><span class="hljs-keyword">return</span> &amp;LoadBalancer&#123;<br>backends: backends,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 简单轮询策略</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lb *LoadBalancer)</span></span> getNextBackend() *Backend &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 使用原子递增获取当前实例索引</span><br>next := atomic.AddUint32(&amp;lb.curr, <span class="hljs-number">1</span>) % <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(lb.backends))<br>backend := lb.backends[next]<br><span class="hljs-keyword">if</span> backend.Healthy &#123;<br><span class="hljs-keyword">return</span> backend<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 转发流量到服务实例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lb *LoadBalancer)</span></span> HandleRequest(w http.ResponseWriter, r *http.Request) &#123;<br>backend := lb.getNextBackend()<br>fmt.Printf(<span class="hljs-string">&quot;Routing request to: %s\n&quot;</span>, backend.URL)<br>http.Redirect(w, r, backend.URL, http.StatusTemporaryRedirect)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>backends := []*Backend&#123;<br>&#123;URL: <span class="hljs-string">&quot;http://localhost:8081&quot;</span>, Healthy: <span class="hljs-literal">true</span>&#125;,<br>&#123;URL: <span class="hljs-string">&quot;http://localhost:8082&quot;</span>, Healthy: <span class="hljs-literal">true</span>&#125;,<br>&#123;URL: <span class="hljs-string">&quot;http://localhost:8083&quot;</span>, Healthy: <span class="hljs-literal">true</span>&#125;,<br>&#125;<br><br>lb := NewLoadBalancer(backends)<br><br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, lb.HandleRequest)<br>fmt.Println(<span class="hljs-string">&quot;Load Balancer started at :8080&quot;</span>)<br>http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这段代码后，流量会被轮询后端实例，如<code>http://localhost:8081</code>等。</p><hr><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h3><p>集中式LB是构建后端架构的重要技术手段，具有实现简单和集中化管理的优点，但需要谨慎考虑其性能瓶颈、单点问题和动态适配能力。在实际生产环境中，可以通过多层LB架构和自动化工具加强其可靠性，同时结合服务健康检查机制确保高可用性。</p><h2 id="进程内-LB-服务发现"><a href="#进程内-LB-服务发现" class="headerlink" title="进程内 LB 服务发现"></a>进程内 LB 服务发现</h2><p>进程内负载均衡（LB）和服务发现是一种非常常见的微服务设计模式，它将客户端 LB 的能力和服务发现的逻辑集成到客户端进程中，而不依赖外部的 LB 服务。例如在 Kubernetes 中，虽然很多情况下使用的是 Service+ClusterIP 的网络模型，但对于服务通信细颗粒化和低延迟要求较高的场景，这种进程内的 LB 模式更为灵活和高效。以下是该模式的详细解析：</p><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403191049947.png" class="" title="image-20250403191049947"><hr><h3 id="核心概念与架构"><a href="#核心概念与架构" class="headerlink" title="核心概念与架构"></a><strong>核心概念与架构</strong></h3><ol><li><p><strong>服务注册发现机制</strong></p><ul><li>服务提供者（Service Provider）启动时，可以通过服务注册中心（Service Registry，例如 Consul、ZooKeeper、etcd）上报自身的状态（包括服务地址和心跳信息）。</li><li>服务消费者（Consumer）进程内的 LB 客户端从注册中心拉取或订阅这些服务列表，并基于服务列表完成负载均衡请求。</li></ul></li><li><p><strong>进程内 LB 的结构</strong></p><ul><li>客户端实现了一个 “服务发现客户端库”（Client Library），它同时负责：<ul><li>服务发现：定期查询或监听服务注册中心的变更，更新可用节点地址列表。</li><li>本地缓存：对节点地址进行高效的本地缓存，减少查询延迟。</li><li>负载均衡：按照预设的负载均衡策略，从服务列表中选择目标服务地址。</li></ul></li></ul></li><li><p><strong>架构优点</strong></p><ul><li>本地实现负载均衡，无需额外的中间负载均衡服务，减少了网络跳数，性能非常高。</li><li>服务发现、负载均衡和调用几乎全部由客户端处理，避免对外部网络服务的直接高度依赖（避免 SPOF 问题）。</li></ul></li><li><p><strong>架构要求</strong></p><ul><li>服务注册表的高可用性和可靠性要求非常高（例如 ZooKeeper、Consul 需要有 3 节点或 5 节点分布式集群部署）。</li><li>客户端库必须设计良好，能够处理网络波动、服务发现数据变化等问题。</li></ul></li></ol><hr><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ol><li><p><strong>性能和延迟</strong></p><ul><li>由于将负载均衡能力从服务端（例如 Nginx、Ingress）转移到了客户端进程中，可以减少一次网络跳转，从而提升性能并显著减少延迟。</li></ul></li><li><p><strong>解耦服务端和客户端</strong></p><ul><li>服务消费者不需要直接依赖外部 LB 服务组件（如 Nginx、F5、Envoy），所有的服务端与客户端交互通过服务注册中心+客户端库来实现。</li></ul></li><li><p><strong>动态负载均衡策略</strong></p><ul><li>客户端内置了负载均衡策略（如轮询策略、权重策略、随机策略等），可以根据业务需求动态选择。</li></ul></li><li><p><strong>灵活性</strong></p><ul><li>针对跨语言、多语言场景，这种架构非常灵活，可以设计多套语言定制化的客户端库。</li></ul></li></ol><hr><h3 id="缺点与挑战"><a href="#缺点与挑战" class="headerlink" title="缺点与挑战"></a><strong>缺点与挑战</strong></h3><ol><li><p><strong>客户端库的开发与维护成本</strong></p><ul><li>对于多语言的环境，每种语言都需要一套独立实现的客户端库（如 Java 的 Ribbon 或 Spring Cloud LoadBalancer，Go 的 etcd 发现在 gRPC 中实现等），费时费力且增加研发&#x2F;维护成本。</li></ul></li><li><p><strong>客户端升级困难</strong></p><ul><li>因为负载均衡和服务发现逻辑都集成到了每一个消费者进程中，一旦要修改 LB 策略或引入新的服务发现逻辑，可能需要对所有客户端重新构建和升级发布，存在巨大的升级阻力。</li></ul></li><li><p><strong>服务发现的集中依赖</strong></p><ul><li>服务注册中心（如 ZooKeeper、Consul 或 etcd）的高可用性是整个架构的关键依赖，一旦注册中心宕机或者负载压力过大，可能导致服务发现失败或者延迟更新。</li></ul></li><li><p><strong>负载均衡的局部可见性</strong></p><ul><li>因为每个客户端实例都独立运行一个 LB，因此负载均衡策略仅在客户端进程内生效，这可能导致全局负载均衡效果不佳（例如一个实例可能比其他实例承担更大压力）。</li></ul></li></ol><hr><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li><strong>高性能要求:</strong> 服务调用链延迟非常敏感，需要尽量减少跳跃次数。</li><li><strong>高频内部服务调用:</strong> 内部微服务之间调用非常频繁，且调用数量远大于对外部服务的调用。</li><li><strong>注册中心可靠:</strong> 服务注册中心具有高可靠性，能够快速更新全量&#x2F;增量服务列表。</li><li><strong>单语言项目:</strong> 项目采用单一主流语言开发，方便共用同一套 LB 客户端库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>进程内 LB 将负载均衡和服务发现逻辑前移到了客户端，使微服务间的调用更加高效。但是，它需要客户端库的强力支持，且对服务注册中心的可靠性有较高的要求。从架构角度来看，它非常适合延迟敏感以及对外部中间件依赖最低的纯后端服务，同时它也是 Spring Cloud、Dubbo 等框架内天然支持的模式。如果你对这个模式感兴趣，可以进一步深入学习客户端实现（如 Consul SDK、etcd 的 gRPC Resolver）或者 DIY 一个轻量级的 Client Library 来理解其底层原理。</p><h2 id="独立-LB-进程服务发现"><a href="#独立-LB-进程服务发现" class="headerlink" title="独立 LB 进程服务发现"></a>独立 LB 进程服务发现</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403191518441.png" class="" title="image-20250403191518441"><h3 id="1-什么是独立-LB-进程服务发现？"><a href="#1-什么是独立-LB-进程服务发现？" class="headerlink" title="1. 什么是独立 LB 进程服务发现？"></a>1. 什么是独立 LB 进程服务发现？</h3><p>独立 LB（Load Balancer）进程服务发现是一种介于客户端负载均衡（Client-side Load Balancing）和传统服务网关（API Gateway）之间的折中方案。它将负载均衡逻辑从应用程序进程中独立出来，运行在一个单独的进程中，与服务调用者和服务注册中心进行交互，并提供软负载均衡（Soft Load Balancing）的能力。</p><p>相比于客户端负载均衡将负载均衡逻辑嵌入到每个调用者的代码中，独立 LB 进程可以作为一种被复用的服务进程，为主机上的多个调用者提供统一的负载均衡和服务发现功能。</p><hr><h3 id="2-核心原理及架构分析"><a href="#2-核心原理及架构分析" class="headerlink" title="2. 核心原理及架构分析"></a>2. 核心原理及架构分析</h3><h4 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h4><ol><li><p><strong>服务注册与健康检查</strong>：</p><ul><li>服务提供者（Service Provider）定期向服务注册中心（Service Registry）注册自己的状态信息，包括服务地址、端口、健康状态等。</li><li>独立 LB 进程会从注册中心订阅服务信息，保持一个本地缓存，并且周期性地更新。</li></ul></li><li><p><strong>服务调用</strong>：</p><ul><li>当服务调用者（Consumer）需要访问某个服务时，会将请求发送给独立 LB 进程。</li><li>独立 LB 基于缓存的服务列表和健康状态进行负载均衡，选取最佳的服务实例地址。</li><li>最终由独立 LB 将实际的请求路由到选定的服务实例。</li></ul></li></ol><h4 id="组成模块详解"><a href="#组成模块详解" class="headerlink" title="组成模块详解"></a>组成模块详解</h4><ul><li><p><strong>Service Registry（服务注册中心）</strong>:<br>提供服务发现和动态注册功能，通常使用像 etcd、Consul 或 Zookeeper 等组件。</p></li><li><p><strong>独立 LB 进程</strong>:</p><ul><li>高效处理请求路由, 包含的功能包括服务发现、负载均衡策略实现（如轮询、最小连接数、加权轮询等）。</li><li>作为一个独立的进程运行在 Consumer 所在的主机上。</li></ul></li><li><p><strong>Consumer 和 Service Provider</strong>:<br>Service Consumer 发起服务请求，Service Provider 提供具体的业务服务。</p></li></ul><h4 id="架构优点"><a href="#架构优点" class="headerlink" title="架构优点"></a>架构优点</h4><ul><li><p><strong>独立 LB 进程与 Consumer 分离，提高开发体验</strong>：<br>由于负载均衡的逻辑不与 Consumer 代码耦合，升级 LB 或者更改负载均衡策略不需要修改和发布调用者代码。这样还能更好地支持多种语言的客户端，而不需要为每个语言客户端实现一套负载均衡逻辑。</p></li><li><p><strong>本地负载均衡，性能高</strong>：<br>服务的调用通过本地进程通信，避免了跨主机调用的额外网络开销，延迟较低。</p></li><li><p><strong>松耦合设计，提升灵活性</strong>：<br>LB 和调用逻辑之间解耦，客户端只需要与 LB 通信即可, 无需感知服务定位的复杂性。</p></li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>增加了独立 LB 进程的开发、部署和维护复杂性。</li><li>如果某台主机上的 LB 进程出现问题，会影响该主机上所有服务调用者的正常工作。</li><li>调试成本较高，尤其当多层负载均衡发生问题时（例如服务注册中心与服务实例之间的健康检查和同步出错）。</li></ul><hr><h3 id="3-为什么称之为软负载均衡？"><a href="#3-为什么称之为软负载均衡？" class="headerlink" title="3. 为什么称之为软负载均衡？"></a>3. 为什么称之为软负载均衡？</h3><p>软负载均衡的概念区别于传统的硬件负载均衡器（例如 F5、A10 设备）。独立 LB 进程通过主机上的单独实例实现负载均衡逻辑，通常只在本机网络（Loopback 或 Host-local）范围内操作，采用的软件方式处理网络流量，而无需依赖专用硬件设备，因此被称为“软负载均衡”。</p><hr><h3 id="4-与其他服务发现模式的对比"><a href="#4-与其他服务发现模式的对比" class="headerlink" title="4. 与其他服务发现模式的对比"></a>4. 与其他服务发现模式的对比</h3><table><thead><tr><th></th><th><strong>客户端负载均衡</strong></th><th><strong>独立 LB 进程模式</strong></th><th><strong>服务端负载均衡（API Gateway）</strong></th></tr></thead><tbody><tr><td><strong>复杂度</strong></td><td>高，客户端需要内置负载均衡逻辑</td><td>中等，LB 程序需要维护和部署</td><td>高，由较重的网关统一代理所有请求</td></tr><tr><td><strong>开发语言兼容性</strong></td><td>库实现和语言强绑定，不易多语言共用</td><td>语言无关，对 Consumer 是透明的</td><td>语言无关，对 Consumer 是透明的</td></tr><tr><td><strong>性能</strong></td><td>高，直接服务实例通讯</td><td>高，本地主机进程间通讯</td><td>中，涉及额外的网关代理跳转</td></tr><tr><td><strong>灵活性</strong></td><td>差，升级负载均衡策略需要改动客户端代码</td><td>高，负载均衡逻辑可单独升级</td><td>高，负载均衡逻辑可单独升级</td></tr><tr><td><strong>部署和调试难度</strong></td><td>简单，客户端即负载均衡逻辑的最终点</td><td>中等，需要增加独立 LB 部署复杂度</td><td>高，涉及分布式网关部署、多点监控和调试</td></tr></tbody></table><hr><h3 id="5-典型应用场景"><a href="#5-典型应用场景" class="headerlink" title="5. 典型应用场景"></a>5. 典型应用场景</h3><ul><li><p><strong>中小规模微服务集群</strong>:<br>在那些服务数量相对有限、主机资源充足的环境下，独立 LB 进程可以高效运行，避免过度复杂性。</p></li><li><p><strong>异构服务生态</strong>:<br>需要支持多种语言和技术栈的服务调用，比如 Python 调用 Java 服务、Golang 服务调用 Node.js 服务。</p></li><li><p><strong>需要快速升级负载均衡策略</strong>:<br>如果服务发现逻辑需要频繁调整或升级，使用独立进程的 LB 可以较快部署扩展，而不需要逐一更新客户端组件。</p></li></ul><hr><h3 id="6-实现思路（结合-Golang-演示）"><a href="#6-实现思路（结合-Golang-演示）" class="headerlink" title="6. 实现思路（结合 Golang 演示）"></a>6. 实现思路（结合 Golang 演示）</h3><p>以下是独立 LB 进程服务发现的基本实现步骤，简单代码实现举例：</p><h4 id="注册中心模拟"><a href="#注册中心模拟" class="headerlink" title="注册中心模拟"></a>注册中心模拟</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ServiceRegistry <span class="hljs-keyword">struct</span> &#123;<br>    mu      sync.RWMutex<br>    services <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span> <span class="hljs-comment">// 服务：实例地址列表</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sr *ServiceRegistry)</span></span> Register(serviceName <span class="hljs-type">string</span>, instanceAddr <span class="hljs-type">string</span>) &#123;<br>    sr.mu.Lock()<br>    <span class="hljs-keyword">defer</span> sr.mu.Unlock()<br>    sr.services[serviceName] = <span class="hljs-built_in">append</span>(sr.services[serviceName], instanceAddr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sr *ServiceRegistry)</span></span> Discover(serviceName <span class="hljs-type">string</span>) []<span class="hljs-type">string</span> &#123;<br>    sr.mu.RLock()<br>    <span class="hljs-keyword">defer</span> sr.mu.RUnlock()<br>    <span class="hljs-keyword">return</span> sr.services[serviceName]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="独立-LB-逻辑"><a href="#独立-LB-逻辑" class="headerlink" title="独立 LB 逻辑"></a>独立 LB 逻辑</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LoadBalancer <span class="hljs-keyword">struct</span> &#123;<br>    registry *ServiceRegistry<br>    cache    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span> <span class="hljs-comment">// 缓存服务列表</span><br>    mu       sync.RWMutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lb *LoadBalancer)</span></span> UpdateCache(serviceName <span class="hljs-type">string</span>) &#123;<br>    instances := lb.registry.Discover(serviceName)<br>    lb.mu.Lock()<br>    lb.cache[serviceName] = instances<br>    lb.mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lb *LoadBalancer)</span></span> GetInstance(serviceName <span class="hljs-type">string</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    lb.mu.RLock()<br>    instances, ok := lb.cache[serviceName]<br>    lb.mu.RUnlock()<br>    <span class="hljs-keyword">if</span> !ok || <span class="hljs-built_in">len</span>(instances) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;No instances available for service %s&quot;</span>, serviceName)<br>    &#125;<br>    <span class="hljs-comment">// 简单轮询策略</span><br>    selected := instances[rand.Intn(<span class="hljs-built_in">len</span>(instances))]<br>    <span class="hljs-keyword">return</span> selected, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过结合定期刷新服务注册信息以及简单的负载均衡策略，这可以成为一个轻量的服务发现与负载均衡模型。</p><hr><p>独立 LB 模式是一种折中方案，相比客户端模式简化了逻辑维护，相比服务端模式减轻了网关服务器的压力。对于中型规模的微服务架构，它提供了一种高效且兼顾灵活性的微服务调用策略。</p><hr><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li>系统的扩展可分为<strong>纵向（垂直）扩展和横向（水平）扩展</strong>。<ul><li>纵向扩展，是从单机的角度通过<strong>增加硬件处理能力</strong>，比如CPU处理能力，内存容量，磁盘等方面，实现<br>服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题；</li><li>横向扩展，通过<strong>添加机器</strong>来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者<br>  多台机器，共同承担访问压力，这就是典型的集群和负载均衡架构。</li></ul></li><li>负载均衡的作用（解决的问题）：</li><li>解决并发压力，提高应用处理性能，增加吞吐量，加强网络处理能力；</li><li>提供故障转移，实现高可用；</li><li>通过添加或减少服务器数量，提供网站<strong>伸缩性，扩展性</strong>；</li><li>安全防护，负载均衡设备上做一些过滤，黑白名单等处理。</li></ul><h2 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h2><p>最早的负载均衡技术，利用域名解析实现负载均衡，在DNS服务器，配置<strong>多个A记录</strong>，<strong>这些A记录对应的服务器构成集群</strong>。<img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403192211117.png" class="" title="image-20250403192211117"></p><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403192325067.png" class="" title="image-20250403192325067"><h2 id="技术概览"><a href="#技术概览" class="headerlink" title="技术概览"></a>技术概览</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403192400424.png" class="" title="image-20250403192400424"><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403192525332.png" class="" title="image-20250403192525332"><h2 id="新建-TCP-连接"><a href="#新建-TCP-连接" class="headerlink" title="新建 TCP 连接"></a>新建 TCP 连接</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403193045714.png" class="" title="image-20250403193045714"><h2 id="链路层负载均衡"><a href="#链路层负载均衡" class="headerlink" title="链路层负载均衡"></a>链路层负载均衡</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403193034643.png" class="" title="image-20250403193034643"><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><img src="/2025/03/29/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/image-20250403193100289.png" class="" title="image-20250403193100289">]]></content>
    
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_CSI</title>
    <link href="/2025/03/28/kubernetes-CSI/"/>
    <url>/2025/03/28/kubernetes-CSI/</url>
    
    <content type="html"><![CDATA[<p>Kubernetes CSI（Container Storage Interface）是 Kubernetes 存储生态中实现存储插件标准化的核心机制，其设计深度结合了 Kubernetes 的存储架构和 Linux 内核特性。以下从原理到实践的详细解析：</p><hr><h3 id="一、CSI-架构原理"><a href="#一、CSI-架构原理" class="headerlink" title="一、CSI 架构原理"></a>一、CSI 架构原理</h3><p>CSI 采用三层架构设计，解耦 Kubernetes 核心组件与存储实现：</p><ol><li><p><strong>Kubernetes 核心组件</strong>（控制平面）：</p><ul><li><code>PersistentVolume</code>&#x2F;<code>PersistentVolumeClaim</code> 资源对象</li><li><code>VolumeAttachment</code> 对象跟踪卷挂载状态</li><li>外置控制器（External Provisioner&#x2F;Attacher）通过 Watch 机制监听 API 变更</li></ul></li><li><p><strong>CSI Node Plugin</strong>（数据平面）：</p><ul><li>以 DaemonSet 形式部署到每个节点</li><li>通过 Unix Domain Socket 暴露 gRPC 服务（默认路径 <code>/var/lib/kubelet/plugins_registry/&lt;driver-name&gt;.sock</code>）</li><li>直接调用节点级存储操作（如 <code>mount</code>&#x2F;<code>umount</code> 系统调用）</li></ul></li><li><p><strong>CSI Controller Plugin</strong>（控制平面）：</p><ul><li>以 StatefulSet 或 Deployment 形式部署</li><li>实现 CreateVolume&#x2F;DeleteVolume 等控制面接口</li><li>与云存储 API（如 AWS EBS、GCE PD）或存储阵列交互</li></ul></li></ol><p>关键源码实现可见 Kubernetes 的 <code>pkg/volume/csi</code> 包，核心逻辑通过 <code>csiPlugin</code> 结构体实现 <code>VolumePlugin</code> 接口。</p><hr><h3 id="二、EmptyDir"><a href="#二、EmptyDir" class="headerlink" title="二、EmptyDir"></a>二、EmptyDir</h3><p>EmptyDir 是 Kubernetes 中一种特殊类型的卷（Volume），它为 Pod 中的容器提供临时存储空间。其设计体现了 Linux 文件系统和容器编排系统的深度结合，下面从技术实现角度进行详细解析：</p><ol><li><strong>生命周期与存储机制</strong></li></ol><ul><li>创建时机：当 Pod 被调度到节点时，kubelet 会在宿主机的 <code>/var/lib/kubelet/pods/&lt;pod-uid&gt;/volumes/kubernetes.io~empty-dir/</code> 目录下创建实际存储目录</li><li>销毁机制：Pod 删除时，kubelet 的垃圾回收器（通过 kube-controller-manager 的 PV 控制器）会触发目录删除操作</li><li>数据持久性：节点重启时，若使用磁盘存储（默认），数据可保留；若使用内存（tmpfs），数据会丢失</li></ul><ol start="2"><li><strong>底层存储实现</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 典型配置示例（内存模式）：</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache-volume</span><br>  <span class="hljs-attr">emptyDir:</span><br>    <span class="hljs-attr">medium:</span> <span class="hljs-string">Memory</span><br>    <span class="hljs-attr">sizeLimit:</span> <span class="hljs-string">256Mi</span><br></code></pre></td></tr></table></figure><ul><li>默认使用宿主机的文件系统存储（ext4&#x2F;xfs等），通过 Linux mount namespace 实现容器间共享</li><li>当设置 <code>medium: Memory</code> 时，实际使用 Linux tmpfs 实现（内存文件系统），可通过 <code>df -T</code> 在容器内验证</li></ul><ol start="3"><li><strong>内核级隔离机制</strong></li></ol><ul><li>通过 Linux 的 mount namespace 实现卷挂载隔离</li><li>使用 cgroups v2 的 memory controller 限制内存型 emptyDir 的使用量（sizeLimit 参数）</li><li>文件系统隔离通过 Linux 的 pivot_root&#x2F;chroot 机制实现</li></ul><ol start="4"><li><strong>性能特征</strong></li></ol><ul><li>磁盘模式：受底层存储介质性能影响（HDD&#x2F;SSD&#x2F;NVMe）</li><li>内存模式：读写性能可达 DDR4 内存的 80-90%（约 30GB&#x2F;s 读取，20GB&#x2F;s 写入）</li><li>适合高频次小文件操作的场景（如 unix domain socket 通信）</li></ul><ol start="5"><li><strong>典型应用场景</strong></li></ol><ul><li><strong>Sidecar 模式</strong>：主容器与 sidecar 容器通过 emptyDir 共享 unix socket</li><li><strong>批处理工作流</strong>：多个 init 容器通过 emptyDir 传递处理中间结果</li><li><strong>内存数据库缓存</strong>：Redis&#x2F;Memcached 等使用内存型 emptyDir 实现快速缓存</li><li><strong>CI&#x2F;CD 流水线</strong>：构建过程中临时存储制品（配合 sizeLimit 防止磁盘溢出）</li></ul><ol start="6"><li><strong>安全注意事项</strong></li></ol><ul><li>敏感数据存储：建议配合 volumeMode: Memory 和加密方案（如 LUKS）</li><li>资源限制：必须设置 sizeLimit 防止 DoS 攻击（特别是内存模式）</li><li>访问控制：通过 securityContext.fsGroup 设置正确的文件权限</li></ul><ol start="7"><li><strong>与 hostPath 的对比</strong><table><thead><tr><th>特性</th><th>emptyDir</th><th>hostPath</th></tr></thead><tbody><tr><td>生命周期</td><td>Pod 级别</td><td>节点级别</td></tr><tr><td>存储位置</td><td>kubelet 管理目录</td><td>任意宿主目录</td></tr><tr><td>安全隔离</td><td>命名空间隔离</td><td>直接暴露宿主文件系统</td></tr><tr><td>调度约束</td><td>自动跟随 Pod</td><td>需手动处理节点亲和性</td></tr></tbody></table></li></ol><p>从 Golang 的 client-go 实现来看，emptyDir 的处理逻辑主要在 kubelet 的 volume manager 模块（pkg&#x2F;kubelet&#x2F;volumemanager）。当 Pod 调度到节点时，会调用 volumePlugin 的 NewMounter 方法创建具体 volume 实例。</p><p>对于需要更高性能的场景，可考虑将 emptyDir 与 CSI ephemeral volume 结合使用，利用本地临时存储设备（如 Intel Optane）获得更好的 IOPS 表现。这在 AI 训练等需要高速暂存数据的场景中尤为重要。</p><h3 id="三、HostPath"><a href="#三、HostPath" class="headerlink" title="三、HostPath"></a>三、HostPath</h3><p>HostPath 是 Kubernetes 中直接将宿主机文件系统路径映射到 Pod 的卷类型，其设计与 Linux 文件系统、内核命名空间深度耦合。以下从技术实现角度进行深度解析：</p><hr><h4 id="1-核心特性与内核交互"><a href="#1-核心特性与内核交互" class="headerlink" title="1. 核心特性与内核交互"></a><strong>1. 核心特性与内核交互</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 典型配置示例</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">host-log-volume</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br></code></pre></td></tr></table></figure><ul><li><strong>路径透传机制</strong>：<ul><li>通过 Linux mount namespace 将宿主机路径挂载到容器的 mount 命名空间</li><li>实际调用 <code>mount --bind /host/path /container/path</code> 实现绑定挂载</li></ul></li><li><strong>文件系统隔离</strong>：<ul><li>依赖 Linux 的 VFS（Virtual File System）层实现跨命名空间访问</li><li>容器内看到的 inode 与宿主机完全一致（可通过 <code>ls -i</code> 验证）</li></ul></li></ul><hr><h4 id="2-存储生命周期与调度约束"><a href="#2-存储生命周期与调度约束" class="headerlink" title="2. 存储生命周期与调度约束"></a><strong>2. 存储生命周期与调度约束</strong></h4><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>生命周期</strong></td><td>与宿主机节点生命周期一致（Pod 删除不影响宿主机数据）</td></tr><tr><td><strong>调度亲和性</strong></td><td>需配合 <code>nodeSelector</code> 确保 Pod 始终调度到同一节点</td></tr><tr><td><strong>数据持久性</strong></td><td>依赖底层存储介质（HDD&#x2F;SSD 持久化，tmpfs 内存存储会丢失）</td></tr><tr><td><strong>跨节点同步</strong></td><td>无自动同步机制，需自行处理分布式存储（如使用 rsync 等工具）</td></tr></tbody></table><hr><h4 id="3-安全风险与防护机制"><a href="#3-安全风险与防护机制" class="headerlink" title="3. 安全风险与防护机制"></a><strong>3. 安全风险与防护机制</strong></h4><ul><li><strong>高危操作示例</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 危险配置：挂载宿主机根目录</span><br><span class="hljs-attr">hostPath:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br></code></pre></td></tr></table></figure></li><li><strong>防护策略</strong>：<ul><li><strong>PodSecurityPolicy</strong>（已弃用）：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">allowedHostPaths:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">pathPrefix:</span> <span class="hljs-string">&quot;/var/log&quot;</span><br>  <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><strong>Admission Webhook</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 示例校验逻辑（使用 client-go）</span><br><span class="hljs-keyword">if</span> strings.HasPrefix(hostPath, <span class="hljs-string">&quot;/etc/kubernetes/pki&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> admission.Denied(<span class="hljs-string">&quot;Prohibited hostPath&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>SELinux&#x2F;AppArmor</strong>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">AppArmor 规则示例：禁止写入 /etc 目录</span><br>deny /etc/** w,<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="4-性能特征与优化"><a href="#4-性能特征与优化" class="headerlink" title="4. 性能特征与优化"></a><strong>4. 性能特征与优化</strong></h4><ul><li><p><strong>IO 路径分析</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Container → OverlayFS → HostPath → 宿主机文件系统（ext4/xfs等）<br></code></pre></td></tr></table></figure></li><li><p><strong>性能对比测试</strong>（fio 4k随机写）：</p><table><thead><tr><th>存储类型</th><th>IOPS</th><th>Latency (μs)</th><th>吞吐量 (MB&#x2F;s)</th></tr></thead><tbody><tr><td>HostPath</td><td>80k</td><td>60</td><td>313</td></tr><tr><td>EmptyDir</td><td>120k</td><td>40</td><td>469</td></tr><tr><td>CSI LocalPV</td><td>150k</td><td>30</td><td>586</td></tr></tbody></table></li><li><p><strong>优化建议</strong>：</p><ul><li>使用 <code>volumeMounts.readOnly: true</code> 避免写操作开销</li><li>对高频访问目录使用内存盘挂载：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hostPath:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">/mnt/tmpfs</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span>  <span class="hljs-comment"># 需预先在节点创建 tmpfs 挂载</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="5-典型应用场景与实现模式"><a href="#5-典型应用场景与实现模式" class="headerlink" title="5. 典型应用场景与实现模式"></a><strong>5. 典型应用场景与实现模式</strong></h4><ul><li><strong>节点监控代理</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 收集宿主机指标</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">proc</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/proc</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">sys</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/sys</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br></code></pre></td></tr></table></figure></li><li><strong>设备直通场景</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># GPU 设备透传</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nvidia-driver</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/usr/local/nvidia</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">dev-char</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/dev/nvidiactl</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">CharDevice</span><br></code></pre></td></tr></table></figure></li><li><strong>分布式存储客户端</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Ceph 客户端配置</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ceph-conf</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/ceph</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ceph-sockets</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/var/run/ceph</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="6-内核级问题排查"><a href="#6-内核级问题排查" class="headerlink" title="6. 内核级问题排查"></a><strong>6. 内核级问题排查</strong></h4><ul><li><strong>挂载点检查</strong>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器内查看挂载信息</span><br>cat /proc/self/mountinfo | grep host-log-volume<br></code></pre></td></tr></table></figure></li><li><strong>权限问题调试</strong>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查 SELinux 上下文</span><br>ls -Z /var/log/containers<br><span class="hljs-meta prompt_"># </span><span class="language-bash">临时禁用 SELinux</span><br>setenforce 0<br></code></pre></td></tr></table></figure></li><li><strong>文件描述符泄漏</strong>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查找容器进程对宿主机文件的占用</span><br>lsof +D /host/path | grep &lt;container-pid&gt;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="7-与-EmptyDir-的架构对比"><a href="#7-与-EmptyDir-的架构对比" class="headerlink" title="7. 与 EmptyDir 的架构对比"></a><strong>7. 与 EmptyDir 的架构对比</strong></h4><table><thead><tr><th><strong>维度</strong></th><th><strong>HostPath</strong></th><th><strong>EmptyDir</strong></th></tr></thead><tbody><tr><td>数据可见性</td><td>节点上所有 Pod 可见</td><td>仅限同一 Pod 内的容器</td></tr><tr><td>存储位置</td><td>任意宿主机路径</td><td>kubelet 管理的临时目录</td></tr><tr><td>安全风险</td><td>可能暴露敏感系统文件</td><td>受命名空间隔离保护</td></tr><tr><td>典型使用场景</td><td>节点级监控、设备透传</td><td>容器间临时数据共享</td></tr><tr><td>性能影响</td><td>受宿主机存储性能限制</td><td>可配置内存模式获得更高性能</td></tr></tbody></table><hr><h4 id="8-演进趋势与替代方案"><a href="#8-演进趋势与替代方案" class="headerlink" title="8. 演进趋势与替代方案"></a><strong>8. 演进趋势与替代方案</strong></h4><ul><li><strong>CSI Ephemeral Volumes</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 替代 HostPath 的临时卷方案</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">inline-volume</span><br>  <span class="hljs-attr">csi:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">ephemeral.csi.k8s.io</span><br>    <span class="hljs-attr">volumeAttributes:</span><br>      <span class="hljs-attr">size:</span> <span class="hljs-string">&quot;5Gi&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>Projected Volumes</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 安全替代方案：将敏感文件注入容器</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">merged-secrets</span><br>  <span class="hljs-attr">projected:</span><br>    <span class="hljs-attr">sources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">db-cred</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">downwardAPI:</span><br>        <span class="hljs-attr">items:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;labels&quot;</span><br>          <span class="hljs-attr">fieldRef:</span><br>            <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.labels</span><br></code></pre></td></tr></table></figure></li></ul><p>HostPath 的核心价值在于其直接对接宿主机基础设施的能力，但在生产环境中需严格配合安全策略使用。对于需要持久化存储的场景，建议优先考虑 CSI 驱动的存储方案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_CNI</title>
    <link href="/2025/03/25/kubernetes-CNI/"/>
    <url>/2025/03/25/kubernetes-CNI/</url>
    
    <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a><strong>CNI</strong></h1><p>CNI 是 Kubernetes 中一个至关重要的组件，它定义了一套标准接口，用于配置和管理容器的网络连接。CNI 将 Kubernetes 与底层网络实现解耦，允许用户选择不同的网络方案，从而提高了 Kubernetes 的灵活性和可扩展性。理解 CNI 的工作原理对于深入理解 Kubernetes 网络至关重要。</p><span id="more"></span><h2 id="Kubernetes-网络模型的核心原则"><a href="#Kubernetes-网络模型的核心原则" class="headerlink" title="Kubernetes 网络模型的核心原则"></a><strong>Kubernetes 网络模型的核心原则</strong></h2><p>Kubernetes 网络模型的设计目标是提供一个扁平的、易于理解和使用的网络环境，让应用程序可以像在传统虚拟机环境中一样运行，而无需关心底层网络的复杂性。为此，Kubernetes 确立了以下三个核心原则：</p><ol><li><p><strong>所有 Pod 能够不通过 NAT 就能相互访问</strong></p><ul><li><p><strong>含义：</strong> 这意味着集群内的任何 Pod 都可以直接使用彼此的 IP 地址进行通信，无需进行网络地址转换（NAT）。这简化了应用程序的开发和调试，因为应用程序可以使用标准的 IP 地址和端口进行通信，而无需担心 NAT 带来的问题。</p></li><li><p>实现方式：</p><p>为了实现这一目标，Kubernetes 需要提供一种机制，使得集群内的所有 Pod 都能被分配到唯一的 IP 地址，并且这些 IP 地址在集群内都是可路由的。这通常通过以下方式实现：</p><ul><li><strong>容器网络接口（CNI）：</strong> Kubernetes 使用 CNI 插件来配置 Pod 的网络。CNI 插件负责为 Pod 分配 IP 地址、配置路由规则和创建必要的网络设备。</li><li><strong>网络插件：</strong> CNI 插件通常会依赖于底层的网络插件来实现具体的网络功能。常见的网络插件包括 Flannel、Calico、Weave Net 等。这些网络插件会使用不同的技术来实现 Pod 之间的网络连通性，例如 VXLAN、IPIP、BGP 等。</li><li><strong>路由配置：</strong> Kubernetes 会自动配置集群内的路由规则，使得所有 Pod 都能通过彼此的 IP 地址进行通信。这通常通过在每个节点上配置路由表来实现。</li></ul></li></ul></li><li><p><strong>所有节点能够不通过 NAT 就能相互访问</strong></p><ul><li><strong>含义：</strong> 这意味着集群内的任何节点都可以直接使用彼此的 IP 地址进行通信，无需进行 NAT。这对于 Kubernetes 的控制平面组件（例如 kube-apiserver、kube-scheduler、kube-controller-manager）之间的通信至关重要。</li><li><strong>实现方式：</strong> 为了实现这一目标，Kubernetes 通常会要求集群内的所有节点都位于同一个网络中，或者通过 VPN 等技术实现节点之间的网络连通性。</li></ul></li><li><p><strong>容器内看见的 IP 地址和外部组件看到的容器 IP 是一样的</strong></p><ul><li><strong>含义：</strong> 这意味着 Pod 内的容器看到的 IP 地址与 Kubernetes 集群内其他组件（例如其他 Pod、Service）看到的 IP 地址是相同的。这消除了应用程序的歧义，简化了网络配置。</li><li><strong>实现方式：</strong> 这主要通过 CNI 插件来实现。CNI 插件会为 Pod 创建一个网络命名空间，并将容器连接到该命名空间。容器在该命名空间中看到的 IP 地址就是 Pod 的 IP 地址。</li></ul></li></ol><h2 id="CNI插件分类"><a href="#CNI插件分类" class="headerlink" title="CNI插件分类"></a><strong>CNI插件分类</strong></h2><ul><li>IPAM: IP 地址分配</li><li>主插件：网卡设置<ul><li>bridge：创建一个网桥，并把主机端口和容器端口插入网桥</li><li>ipvlan：为容器添加 vlan 网口</li><li>loopback：设置 loopback 网口</li></ul></li><li>Meta：附加功能<ul><li>portmap：主机和容器的端口映射</li><li>bandwidth：利用 Linux Traffic Control 进行限流</li><li>firewall： 通过 iptables 或firewalld 为容器设置防火墙规则</li></ul></li></ul><h2 id="CNI-插件运行机制"><a href="#CNI-插件运行机制" class="headerlink" title="CNI 插件运行机制"></a><strong>CNI 插件运行机制</strong></h2><ol><li><p><strong>配置文件读取：</strong> 容器运行时（例如，kubelet）在启动时，会从 CNI 的配置目录中读取 JSON 格式的配置文件。这些配置文件的后缀可以是 <code>.conf</code>、<code>.conflist</code> 或 <code>.json</code>。</p></li><li><p><strong>配置文件选择：</strong> 如果配置目录中包含多个配置文件，通常情况下，会以文件名<strong>字母顺序</strong>排序，选择第一个文件作为默认的网络配置。然后，加载并获取其中指定的 CNI 插件名称和配置参数。</p><ul><li><code>.conflist</code> 文件：<code>.conflist</code> 文件允许定义一个 CNI 插件列表，容器运行时会按照列表中插件的顺序依次调用。这允许你配置更复杂的网络功能，例如，先创建一个虚拟网络接口，然后配置防火墙规则。</li></ul></li><li><p><strong>CNI 操作 (ADD&#x2F;DEL)：</strong>  容器运行时根据容器的生命周期，调用 CNI 插件执行网络配置操作。主要有两种操作：</p><ul><li><strong>ADD：</strong> 当容器创建时，CNI 插件被调用，负责为容器创建网络接口（例如 <code>veth pair</code>），配置 IP 地址、路由规则，并将容器连接到指定的网络。</li><li><strong>DEL：</strong> 当容器删除时，CNI 插件被调用，负责清理容器的网络配置，例如删除虚拟网络接口，移除路由规则等。</li></ul></li><li><p><strong>网络插件类型：</strong> CNI 插件有很多种，常见的包括：</p><ul><li><code>loopback</code>：创建 loopback 接口 (lo)。</li><li><code>bridge</code>：创建网桥，并将容器连接到该网桥。这是最常用的 CNI 插件之一。</li><li><code>ipvlan</code>：创建 <code>ipvlan</code> 接口，允许容器直接连接到主机网络接口。</li><li><code>macvlan</code>：创建 <code>macvlan</code> 接口，为容器分配一个独立的 MAC 地址。</li></ul></li></ol><h2 id="CNI-的运行机制"><a href="#CNI-的运行机制" class="headerlink" title="CNI 的运行机制"></a><strong>CNI 的运行机制</strong></h2><ol><li><p><strong>参数配置：</strong> 为了使容器能够正确地配置网络，通常需要配置两个关键参数：</p><ul><li><code>--cni-bin-dir</code>： 指定 CNI 插件可执行文件所在的目录。默认情况下，是 <code>/opt/cni/bin</code>。容器运行时会在此目录下查找可执行的 CNI 插件。</li><li><code>--cni-conf-dir</code>：指定 CNI 配置文件的目录。默认情况下，是 <code>/etc/cni/net.d</code>。容器运行时会在此目录下查找网络配置文件。</li></ul></li><li><p><strong>Kubelet 与 CNI：</strong> 在 Kubernetes 中，<code>kubelet</code> 负责管理节点上的容器。当 <code>kubelet</code> 使用内置的 Docker 作为容器运行时，它会负责查找 CNI 插件，并调用这些插件来为容器设置网络。</p></li></ol><p><strong>简而言之， CNI 定义了一套接口规范，允许容器运行时（如 kubelet）通过调用不同的插件来配置容器的网络。</strong> 你可以理解为，CNI 就像一个“驱动程序”，使得 Kubernetes 可以支持各种不同的网络方案。</p><p><strong>示例配置（&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;mycni.conflist）：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;cniVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.3.1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mycni&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;bridge&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cni0&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isGateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;ipMasq&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;ipam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;host-local&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10.244.0.0/16&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;routes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;dst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.0.0.0/0&quot;</span> <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;portmap&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;capabilities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;portMappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这个配置文件定义了一个名为 “mycni” 的 CNI 配置，它使用 <code>bridge</code> 插件创建网桥，并使用 <code>host-local</code> IPAM 插件为容器分配 IP 地址。<code>portmap</code> 插件则用于端口映射。</p><h2 id="CNI-插件设计考量"><a href="#CNI-插件设计考量" class="headerlink" title="CNI 插件设计考量"></a><strong>CNI 插件设计考量</strong></h2><ol><li><p><strong>“容器运行时必须在调用任何插件之前为容器创建一个新的网络命名空间。”</strong></p><ul><li><strong>深度解析：</strong> 这是容器网络隔离的基础。在 Linux 中，网络命名空间（Network Namespace）是内核提供的一种资源隔离机制。每个网络命名空间都拥有独立的网络栈，包括网络接口（如 lo, eth0）、路由表、iptables 规则、套接字等。容器运行时（如 containerd）在启动容器进程之前，会调用 <code>clone()</code> 或 <code>unshare()</code> 系统调用，并带上 <code>CLONE_NEWNET</code> 标志，为即将运行的容器进程创建一个全新的、隔离的网络环境。这个空的网络命名空间只有 <code>lo</code> 回环设备，并且处于 <code>down</code> 状态。CNI 插件的职责就是在这个已经创建好的命名空间内配置网络。运行时会将这个命名空间的路径（例如 <code>/proc/&lt;pid&gt;/ns/net</code>）传递给 CNI 插件，以便插件可以进入该命名空间进行操作（通常通过 <code>setns()</code> 系统调用）。</li></ul></li><li><p><strong>“容器运行时必须决定这个容器属于哪些网络，针对每个网络，哪些插件必须要执行。”</strong></p><ul><li><strong>深度解析：</strong> 这涉及到配置的发现和解析。容器的网络需求可能很复杂，比如一个 Pod 在 Kubernetes 中可能需要连接到默认的 Pod 网络，还可能通过 Multus CNI 连接到其他如 SR-IOV 或 Macvlan 网络。运行时需要读取相应的配置（在 Kubernetes 中，这通常由 Kubelet 根据 Pod 定义和 CNI 配置文件 <code>/etc/cni/net.d/</code> 下的内容来决定）。配置文件（<code>.conf</code> 或 <code>.conflist</code>）定义了网络的名称、类型（即要调用的 CNI 插件二进制文件）以及其他参数（如 IPAM 类型）。运行时负责根据这些配置，确定需要为当前容器调用哪个或哪些 CNI 插件的二进制文件。</li></ul></li><li><p><strong>“容器运行时必须加载配置文件，并确定设置网络时哪些插件必须被执行。”</strong></p><ul><li><strong>深度解析：</strong> 这是对上一点的补充和具体化。CNI 的配置通常放在主机的特定目录（默认为 <code>/etc/cni/net.d/</code>）。配置文件可以是单个网络配置 (<code>.conf</code>)，也可以是一个网络配置列表 (<code>.conflist</code>)，后者支持插件链（Chaining）。例如，一个 <code>.conflist</code> 文件可能先调用一个 IPAM 插件（如 <code>host-local</code>）来分配 IP 地址，然后调用一个主插件（如 <code>bridge</code> 或 <code>calico</code>）来创建网络设备并连接到网络，最后可能还会调用一个策略插件（如 <code>portmap</code>）来设置端口映射。运行时需要解析这个 JSON 配置，理解插件的类型和顺序，并将正确的配置信息传递给每个插件。</li></ul></li><li><p><strong>“网络配置采用 JSON 格式，可以很容易地存储在文件中。”</strong></p><ul><li><strong>深度解析：</strong> 选择 JSON 作为配置格式是基于其广泛的接受度、易于人类阅读和编写，以及极其方便的机器解析性。几乎所有的现代编程语言（包括 Golang）都有成熟的库来处理 JSON。CNI 规范严格定义了配置的 JSON 结构，包括 <code>cniVersion</code>, <code>name</code>, <code>type</code>, <code>ipam</code>, <code>dns</code>, <code>args</code> 等字段。这使得不同开发者编写的运行时和插件能够无缝协作。在 Golang 中，<code>encoding/json</code> 标准库使得 CNI 插件或运行时可以轻松地将 JSON 数据 unmarshal 到结构体中，或将结构体 marshal 成 JSON 字符串。</li></ul></li><li><p><strong>“容器运行时必须按顺序执行配置文件里相应的插件。”</strong></p><ul><li><strong>深度解析：</strong> 这特指 CNI 插件链（Plugin Chaining）的执行顺序。当使用 <code>.conflist</code> 配置文件时，<code>plugins</code> 数组中的插件必须按照它们在数组中出现的顺序被依次调用。前一个插件执行成功后，其输出的 CNI Result（通常包含分配的 IP 地址、DNS 信息等）会作为下一个插件的输入配置（通过 <code>prevResult</code> 字段）。这种机制允许将复杂的网络功能分解为一系列可组合的、单一职责的插件。例如，IP 分配、网络设备创建、路由设置、端口映射、带宽限制等可以由不同的插件按顺序完成。运行时需要确保这种严格的顺序执行和结果传递。</li></ul></li><li><p><strong>“在完成容器生命周期后，容器运行时必须按照与执行添加容器相反的顺序执行插件，以便将容器与网络断开连接。”</strong></p><ul><li><strong>深度解析：</strong> 这是资源清理的关键。当容器被删除时，运行时需要调用 CNI 插件的 <code>DEL</code> 命令来清理网络资源。对于插件链，清理操作必须按照添加操作（<code>ADD</code>）的<strong>相反顺序</strong>执行。这是因为后执行的 <code>ADD</code> 操作可能依赖于先执行的 <code>ADD</code> 操作创建的资源。例如，<code>portmap</code> 插件设置的 iptables 规则可能依赖于 <code>bridge</code> 插件创建的 veth 设备。因此，必须先调用 <code>portmap</code> 的 <code>DEL</code> 来删除规则，然后才能调用 <code>bridge</code> 的 <code>DEL</code> 来删除设备。这种反向顺序确保了依赖关系的正确解除和资源的干净回收。</li></ul></li><li><p><strong>“容器运行时被同一容器调用时不能并行操作，但被不同的容器调用时，允许并行操作。”</strong></p><ul><li><strong>深度解析：</strong> 这是为了保证单个容器网络配置的一致性。对同一个容器的网络进行并发的 <code>ADD</code> 或 <code>DEL</code> 操作可能会导致竞态条件（Race Condition）和不可预测的网络状态。例如，两个进程同时尝试为同一个容器配置 IP 地址，可能会导致配置冲突或状态不一致。因此，运行时必须确保对特定容器（由 <code>ContainerID</code> 标识）的所有 CNI 操作（针对同一网络或不同网络）是串行执行的，通常通过加锁（如基于 ContainerID 的锁）来实现。然而，为 <em>不同</em> 的容器配置网络通常是互不影响的，运行时应该允许这些操作并行执行，以提高效率，尤其是在节点上需要同时启动或销毁大量容器时。</li></ul></li><li><p><strong>“容器运行时针对一个容器必须按顺序执行 ADD 和 DEL 操作，ADD 后面总是跟着相应的 DEL。DEL 可能跟着额外的 DEL，插件应该允许处理多个 DEL。”</strong></p><ul><li><strong>深度解析：</strong> 这定义了基本的 <code>ADD</code>&#x2F;<code>DEL</code> 调用模式，并强调了 <code>DEL</code> 操作的幂等性（Idempotency）。一个成功的 <code>ADD</code> 操作最终应该对应一个 <code>DEL</code> 操作来清理资源。但是，由于运行时或节点可能发生故障、重启或用户强制清理，同一个容器的同一个网络接口可能会收到多次 <code>DEL</code> 命令。因此，CNI 插件在实现 <code>DEL</code> 逻辑时，必须设计成幂等的。也就是说，即使 <code>DEL</code> 被调用多次，也应该能正确处理（例如，第一次删除资源，后续调用发现资源已不存在，则直接返回成功，而不是报错）。这保证了清理操作的健壮性。</li></ul></li><li><p><strong>“容器必须由 ContainerID 来唯一标识，需要存储状态的插件需要使用网络名称、容器 ID 和网络接口组成的主 key 用于索引。”</strong></p><ul><li><strong>深度解析：</strong> <code>ContainerID</code> 是运行时（如 containerd）生成的唯一标识符，用于区分节点上的不同容器。对于需要持久化状态的 CNI 插件（最典型的例子是 IPAM 插件，需要记录哪个 IP 地址分配给了哪个容器），<code>ContainerID</code> 是必不可少的。然而，仅有 <code>ContainerID</code> 可能不够，因为一个容器可能连接到多个网络，或者同一个网络在配置中可能有不同的实例（虽然不常见）。CNI 规范建议（虽然没有强制要求所有插件都这样做），使用一个组合键，通常是 <code>(网络名称, ContainerID, 网络接口名称)</code>，来唯一地标识一个特定的网络连接实例。这个组合键可以用来在持久化存储（如本地文件、etcd、数据库）中查找或存储与该连接相关的状态（如分配的 IP 地址）。例如，<code>host-local</code> IPAM 插件默认就在本地磁盘上使用包含这些信息的文件路径或内容来存储 IP 分配记录。</li></ul></li><li><p><strong>“容器运行时针对同一个网络、同一个容器、同一个网络接口，不能连续调用两次 ADD 命令。”</strong><br>*   <strong>深度解析：</strong> 这是对运行时行为的约束，旨在防止意外的重复配置。如果运行时已经成功为某个容器的特定接口（如 <code>eth0</code>）在特定网络上执行了 <code>ADD</code> 操作，那么在没有执行相应的 <code>DEL</code> 操作之前，不应该再次对完全相同的目标（相同网络名、相同 ContainerID、相同接口名）发起 <code>ADD</code> 请求。这简化了插件的逻辑，插件通常可以假设收到的 <code>ADD</code> 请求是针对一个尚未配置或已被清理的接口。如果运行时违反了此规则，插件的行为是未定义的，可能会失败或导致状态混乱。</p></li></ol><h2 id="打通主机层插件"><a href="#打通主机层插件" class="headerlink" title="打通主机层插件"></a>打通主机层插件</h2><ol><li><p><strong>基础要求：CNI <code>lo</code> 插件</strong></p><ul><li><code>Kubernetes 还需要标准的 CNI 插件 lo, 最低版本为 0.2.0 版本。</code></li><li><strong>解析：</strong> 每个 Pod 都有自己独立的网络命名空间（Network Namespace）。在这个命名空间里，必须有一个 <code>lo</code> (loopback) 网络接口，IP 地址通常是 <code>127.0.0.1</code>。这是网络栈正常工作的基础，允许 Pod 内的进程通过 <code>localhost</code> 互相通信，或者访问绑定在 <code>localhost</code> 上的服务。CNI <code>lo</code> 插件的职责就是在创建 Pod 的网络命名空间后，执行 <code>ip link set lo up</code> 之类的操作，确保这个最基本的接口是启动和可用的。虽然简单，但它是所有 Pod 网络功能的前提。</li></ul></li><li><p><strong>CNI 插件与 Kube-proxy (Iptables 模式) 的协同</strong></p><ul><li><code>网络插件除支持设置和清理 Pod 网络接口外，该插件还需要支持 Iptables。如果 Kube-proxy 工作在 Iptables 模式，网络插件需要确保容器流量能使用 Iptables 转发。</code></li><li><strong>解析：</strong> CNI 插件的主要职责是为 Pod 创建网络接口（例如 veth pair 中的一端），分配 IP 地址，并将其连接到主机网络或某种覆盖网络。然而，仅仅设置好接口和 IP 是不够的。Kubernetes 中的 <code>Service</code> 对象提供了一个稳定的访问入口，其背后由 <code>Kube-proxy</code> 组件实现负载均衡和转发。</li><li><code>Kube-proxy</code> 有多种工作模式，其中 <code>iptables</code> 模式是最经典也曾经是默认的模式。在这种模式下，<code>Kube-proxy</code> 会在宿主机上创建大量的 Iptables 规则（主要在 <code>nat</code> 表的 <code>PREROUTING</code>、<code>OUTPUT</code>、<code>KUBE-SERVICES</code>、<code>KUBE-SVC-*</code>、<code>KUBE-SEP-*</code> 等链中）。这些规则的作用是：当有数据包访问 Service 的 ClusterIP 时，将其目标地址（DNAT）修改为后端某个具体 Pod 的 IP 地址和端口。</li><li><strong>关键点：</strong> 为了让 <code>Kube-proxy</code> 的 Iptables 规则生效，从 Pod 发出、目标是 Service ClusterIP 的流量，或者从外部进入、目标是 NodePort&#x2F;LoadBalancer IP 并最终需要转发给 Pod 的流量，都<strong>必须</strong>经过宿主机上设置了这些 Iptables 规则的 Netfilter 处理点。CNI 插件的设计和配置<strong>必须保证</strong>这一点。如果 CNI 插件创建的网络路径绕过了宿主机的 Iptables 处理，那么 Service 就会失效。</li></ul></li><li><p><strong>Linux 网桥场景：<code>bridge-nf-call-iptables</code> 的重要性</strong></p><ul><li><code>例如，如果网络插件将容器连接到 Linux 网桥，必须将 net/bridge/bridge-nf-call-iptables 参数 sysctl 设置为 1，网桥上数据包将遍历 Iptables 规则。</code></li><li><strong>解析：</strong> 一种非常常见的 CNI 实现方式（例如 Flannel 的 <code>host-gw</code> 或 <code>vxlan</code> 模式的部分配置，以及早期的 Docker 网络）是在宿主机上创建一个 Linux 网桥（如 <code>cni0</code> 或 <code>docker0</code>），然后将每个 Pod 的 veth pair 的宿主机端接入这个网桥。</li><li><strong>Linux 内核行为：</strong> 默认情况下，Linux 网桥工作在 OSI 模型的第二层（数据链路层）。当数据包从一个连接到网桥的接口（比如 Pod 的 veth）进入，网桥会根据目标 MAC 地址决定将其从哪个接口转发出去（如果目标 MAC 在本地，则转发；如果未知，则广播）。这个二层转发过程<strong>通常不会</strong>经过宿主机的三层（IP 层）处理，也就是<strong>不会</strong>经过 Netfilter&#x2F;Iptables 的钩子（Hooks）。</li><li><strong>问题：</strong> 如果 Pod A（IP: 10.1.1.2）访问一个 Service（ClusterIP: 10.96.0.10），数据包从 Pod A 的 veth 进入宿主机的网桥。如果目标 Pod B（IP: 10.1.1.3）也在同一个网桥上，并且网桥已经学习了 Pod B veth 的 MAC 地址，那么数据包可能会被直接二层转发给 Pod B 的 veth，完全绕过了宿主机的 Iptables <code>nat</code> 表，导致 DNAT 规则无法匹配和执行，Service 访问失败。</li><li><strong>解决方案：<code>net.bridge.bridge-nf-call-iptables = 1</code></strong><ul><li>这个 <code>sysctl</code> 参数位于 <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code>。当它被设置为 <code>1</code> 时，会启用 <code>br_netfilter</code> 内核模块的功能。</li><li><code>br_netfilter</code> 模块会在 Linux 网桥处理数据包的路径上增加 Netfilter 钩子。具体来说，它使得即使是<strong>二层桥接</strong>的数据包，也会被提交到 Iptables 的 <code>PREROUTING</code>、<code>FORWARD</code> 和 <code>POSTROUTING</code> 链（以及相关的 <code>filter</code>、<code>nat</code>、<code>mangle</code> 表）进行处理。</li><li>这样一来，即使 Pod A 和目标 Service 的后端 Pod B 在同一个网桥上，从 Pod A 发往 Service ClusterIP 的数据包在进入网桥后，也会被强制送入 Iptables <code>nat</code> 表的 <code>PREROUTING</code> 或 <code>OUTPUT</code> 链（取决于流量发起点），从而被 <code>Kube-proxy</code> 设置的 DNAT 规则正确匹配和修改，最终转发给 Pod B。</li><li><strong>注意：</strong> 相关的还有 <code>bridge-nf-call-ip6tables</code> (用于 IPv6) 和 <code>bridge-nf-call-arptables</code> (用于 ARP)。通常都需要一并检查或设置。</li></ul></li></ul></li><li><p><strong>非 Linux 网桥场景：路由是关键</strong></p><ul><li><code>如果插件不使用 Linux 桥接器（而是类似 Open vSwitch 或其他某种机制的插件），则应确保容器流量被正确设置了路由。</code></li><li><strong>解析：</strong> 有些 CNI 插件（如 Calico 的 BGP 模式，或者一些基于 OVS 的实现）不依赖 Linux 内核原生的网桥。<ul><li><strong>Calico BGP 模式示例：</strong> Calico 通常为每个 Pod 的 veth 接口配置一个 <code>/32</code> 的路由，并在宿主机上维护到各个 Pod IP 的路由信息（通过 BGP 协议交换或直接写入路由表）。当 Pod A 访问 Service ClusterIP 时，数据包离开 Pod A 的网络命名空间，进入宿主机。宿主机的路由表会将目标为 ClusterIP 的数据包导向正确的处理路径（通常是本地处理，触发 <code>OUTPUT</code> 链或 <code>PREROUTING</code> 链的 Iptables 规则）。或者，如果 Pod A 访问 Pod B，路由表会直接将数据包导向 Pod B 所在的节点或其本地 veth 接口。由于这种方式天然依赖宿主机的 IP 层路由，流量自然会经过 Netfilter&#x2F;Iptables 处理点，因此不需要 <code>bridge-nf-call-iptables</code>。关键在于 CNI 插件必须正确配置宿主机的路由表。</li><li><strong>Open vSwitch (OVS) 示例：</strong> 基于 OVS 的插件（如 OVN-Kubernetes）使用 OVS 作为虚拟交换机。OVS 有自己复杂的流表处理逻辑。这类插件需要配置 OVS 的流表规则，确保 Pod 发出的流量在 OVS 内部被正确处理后，能够到达宿主机的网络栈（如果需要 Iptables 处理 Service），或者直接被 OVS 转发到目标 Pod 或下一跳。配置的细节取决于具体的 OVS 实现，但核心目标一致：确保流量能被 Kube-proxy 的机制（无论是 Iptables 还是 IPVS）拦截和处理。</li></ul></li></ul></li></ol><img src="/2025/03/25/kubernetes-CNI/image-20250328201253599.png" class="" title="image-20250328201253599"><img src="/2025/03/25/kubernetes-CNI/image-20250328201905840.png" class="" title="image-20250328201905840">]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_CRI</title>
    <link href="/2025/03/22/kubernetes-CRI/"/>
    <url>/2025/03/22/kubernetes-CRI/</url>
    
    <content type="html"><![CDATA[<p>CRI 是 Kubernetes 定义的一组 gRPC 接口。它允许 kubelet（Kubernetes 的节点代理）与容器运行时（例如 Docker, containerd, CRI-O 等）进行通信。</p><span id="more"></span><h1 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CRI 是 Kubernetes 定义的一组 gRPC 接口。它允许 <strong>kubelet</strong>与<strong>容器运行时</strong>（例如 Docker, containerd, CRI-O 等）进行通信。这种接口的设计目的是为了<strong>解耦 Kubernetes 和特定的容器运行时实现</strong>，使得 Kubernetes 可以支持多种容器运行时，而无需修改 Kubernetes 的核心代码。</p><img src="/2025/03/22/kubernetes-CRI/image-20250324125824154.png" class="" title="image-20250324125824154"><h2 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a><strong>容器运行时</strong></h2><p>容器运行时通常被分为两个主要层级：高级运行时（High-level Runtime）和低级运行时（Low-level Runtime）。 这种分层架构有助于解耦容器管理的各个方面，提高了灵活性和可维护性。</p><ol><li><p><strong>高级运行时 (High-level Runtime)</strong></p><ul><li><p><strong>功能</strong>：高级运行时主要负责容器镜像的管理、容器生命周期的管理以及与容器编排系统（如 Kubernetes）的交互。它们提供了一个更友好的接口，简化了容器的创建、启动、停止和删除等操作。</p></li><li><p><strong>代表</strong>：<code>Docker shim</code>、<code>containerd</code>和<code>CRI-O</code></p></li><li><p><strong>流程</strong>：</p><ul><li>接收来自容器编排系统的指令（例如，创建容器）。</li><li>从镜像仓库下载容器镜像。</li><li>将镜像解压成 OCI 运行时文件系统包（filesystem bundle）。</li><li>调用低级运行时来实际创建和运行容器。</li><li>监控容器的生命周期，并向容器编排系统报告状态。</li></ul></li><li><p><strong>例如</strong>，当你使用 <code>docker run</code> 命令时，Docker 守护进程（dockerd）会调用 containerd，然后 containerd 负责拉取镜像、创建容器的元数据，并最终调用 runC 来启动容器。</p></li></ul></li><li><p><strong>低级运行时 (Low-level Runtime)</strong></p><ul><li><p><strong>功能</strong>：低级运行时直接与操作系统内核交互，负责创建和管理容器的隔离环境，包括命名空间（namespaces）、控制组（cgroups）以及文件系统的挂载等。</p></li><li><p><strong>标准</strong>：遵循 OCI（Open Container Initiative）运行时规范（Runtime Specification），该规范定义了如何从 OCI 运行时文件系统包运行容器进程，并定义了容器的配置、运行环境和生命周期。</p></li><li><p><strong>代表</strong>：<code>runC</code>、<code>kata-runtime</code>等。</p></li><li><p><strong>流程</strong>：</p><ul><li>接收来自高级运行时的指令和配置信息。</li><li>使用 Linux 内核的特性（如 namespaces 和 cgroups）来创建容器的隔离环境。</li><li>执行容器内的进程。</li><li>管理容器的资源限制。</li></ul></li><li><p><strong>深入理解 runC</strong>：</p><ul><li><code>runC</code> 是一个轻量级的、可移植的容器运行时工具，它是 Docker 的核心组件之一。它直接调用 Linux 内核的 API 来创建容器。</li><li><code>runC</code> 的主要功能包括：<ul><li><strong>命名空间（Namespaces）</strong>：为容器提供隔离的运行环境，包括 PID、网络、IPC、Mount、UTS 和 User namespaces。</li><li><strong>控制组（Cgroups）</strong>：限制容器可以使用的资源，如 CPU、内存、磁盘 I&#x2F;O 等。</li><li><strong>文件系统隔离</strong>：通过 chroot 或 pivot_root 将容器的文件系统与主机隔离。</li><li><strong>能力（Capabilities）</strong>：控制容器内进程可以执行的特权操作。</li></ul></li></ul></li></ul></li></ol><h2 id="OCI（Open-Container-Initiative）"><a href="#OCI（Open-Container-Initiative）" class="headerlink" title="OCI（Open Container Initiative）"></a><strong>OCI（Open Container Initiative）</strong></h2><p>OCI 是一个开源项目，旨在制定容器格式和运行时的开放标准。OCI 定义了两个主要的规范：</p><ul><li><strong>镜像规范（Image Specification）</strong>：定义了容器镜像的格式。</li><li><strong>运行时规范（Runtime Specification）</strong>：定义了如何运行容器。</li></ul><p>通过遵循 OCI 标准，不同的容器运行时可以互操作，从而避免了厂商锁定。</p><h2 id="开源运行时的比较"><a href="#开源运行时的比较" class="headerlink" title="开源运行时的比较"></a>开源运行时的比较</h2><p><strong>1. 整体架构</strong></p><ul><li><strong>Docker:</strong> 从图中可以看出，Docker 的架构相对复杂，涉及多个组件，包括 dockershim, docker, containerd。这使得 Docker 在 Kubernetes 中的集成略显笨重，维护和调试也相对复杂。</li><li><strong>Containerd:</strong> Containerd 的架构更为简洁，直接通过 <code>cri-containerd</code> 与 Kubernetes 集成，减少了中间环节，提高了效率和稳定性。Containerd 通过 <code>containerd-shim</code> 与底层的 OCI 运行时交互，负责容器的生命周期管理。</li><li><strong>CRI-O:</strong> CRI-O 的设计目标是成为 Kubernetes 的专用容器运行时。它直接实现了 Kubernetes CRI (Container Runtime Interface)，通过 <code>conmon</code> 监控容器进程，并使用 OCI 运行时 (如 runc) 创建和管理容器。</li></ul><p><strong>2. 关键组件</strong></p><ul><li><strong>dockershim:</strong>  dockershim 是 Kubernetes 为了兼容 Docker 而引入的组件，它充当了 Docker 和 Kubernetes 之间的适配器。但 dockershim 的引入增加了维护成本，也限制了 Kubernetes 对其他容器运行时的支持。在 Kubernetes 1.24 版本中，dockershim 已被移除。</li><li><strong>containerd:</strong> Containerd 是一个 CNCF (Cloud Native Computing Foundation) 项目，它提供了一个工业标准的容器运行时。Containerd 专注于容器的生命周期管理、镜像分发和存储等核心功能。</li><li><strong>CRI-O:</strong> CRI-O 是一个轻量级的容器运行时，专门为 Kubernetes 设计。它只关注 Kubernetes 需要的功能，例如镜像拉取、容器创建、启动、停止和删除等。</li><li><strong>OCI Runtime:</strong> OCI (Open Container Initiative) 运行时，如 runc，是真正创建和运行容器的组件。它们负责与操作系统内核交互，完成容器的隔离、资源限制等操作。</li></ul><p><strong>3. 与 Kubernetes 的集成</strong></p><ul><li><strong>Docker:</strong> 通过 dockershim 集成，已被 Kubernetes 废弃。</li><li><strong>Containerd:</strong> 通过 <code>cri-containerd</code> 插件直接集成，是 Kubernetes 推荐的容器运行时。</li><li><strong>CRI-O:</strong> 原生支持 Kubernetes CRI，无需额外的适配层。</li></ul><img src="/2025/03/22/kubernetes-CRI/image-20250325124303637.png" class="" title="image-20250325124303637"><ol start="4"><li><strong>性能比较</strong></li></ol><img src="/2025/03/22/kubernetes-CRI/image-20250325124452967.png" class="" title="image-20250325124452967">]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_kubelet</title>
    <link href="/2025/03/21/kubernetes-kubelet/"/>
    <url>/2025/03/21/kubernetes-kubelet/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h1><p>kubelet 是 Kubernetes 节点（Node）上的核心组件，负责管理节点上的 Pod 和容器生命周期，是 Kubernetes 控制平面（Control Plane）与节点层之间的桥梁。</p><span id="more"></span><hr><img src="/2025/03/21/kubernetes-kubelet/image-20250321224007971.png" class="" title="image-20250321224007971"><hr><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><h3 id="1-Kubelet-API"><a href="#1-Kubelet-API" class="headerlink" title="1. Kubelet API"></a><strong>1. Kubelet API</strong></h3><p>Kubelet 提供了一系列 HTTP API 服务，用于与外部或 Kubernetes 控制平面通信。关键的端口与服务如下：</p><ul><li><strong>:10250 API</strong>：接受 Master 节点发来的指令，管理 Pod 和 Pod 中的容器，每个 Kubelet 在 API Server 上注册自身节点信息，定期向 Master 发送节点使用情况，并通过 cAdvisor 监控节点和容器的资源。</li><li><strong>:10255 只读 API</strong> - 提供一个无需认证的只读接口，通常用于外部系统（如监控系统）获取 Pod 和节点的状态信息。（此端口已逐渐不推荐使用）</li><li><strong>:10248 &#x2F;healthz</strong> - 用于 Kubelet 自身的健康检查。主要提供 <code>/healthz</code> 接口，以供其他组件监控 Kubelet 运行状况。</li></ul><p>这些接口是外界与 Kubelet 交互的重要入口。</p><hr><h3 id="2-核心组件"><a href="#2-核心组件" class="headerlink" title="2. 核心组件"></a><strong>2. 核心组件</strong></h3><h4 id="1-syncLoop"><a href="#1-syncLoop" class="headerlink" title="(1) syncLoop"></a><strong>(1) syncLoop</strong></h4><p><code>syncLoop</code> 是 Kubelet 的核心主循环，负责持续同步节点的状态和调度的 Pod 期望状态。</p><ul><li>通过 Kubernetes API Server <strong>Watch</strong> 机制获取调度到该节点的 Pod 信息（期望状态）。</li><li>对比节点上实际运行的 Pod 状态（实际状态）。</li><li>调用其他模块（如 <code>PodWorker</code>）完成实际状态与期望状态的对齐。</li></ul><h4 id="2-PodWorker"><a href="#2-PodWorker" class="headerlink" title="(2) PodWorker"></a><strong>(2) PodWorker</strong></h4><p><code>PodWorker</code> 是每个 Pod 的具体操作执行模块。它是一个并发协程池，用于处理 Pod 的创建、更新、删除等任务。与 <code>syncLoop</code> 配合，<code>PodWorker</code> 实现了节点状态与调度期望状态的最终一致性。</p><h4 id="3-ProbeManager"><a href="#3-ProbeManager" class="headerlink" title="(3) ProbeManager"></a><strong>(3) ProbeManager</strong></h4><p><code>ProbeManager</code> 负责 Pod 的健康检查。</p><ul><li><strong>Liveness Probe</strong>：判断容器是否健康，不健康时触发重启。</li><li><strong>Readiness Probe</strong>：判断容器是否准备就绪，用于流量负载分发。</li><li><strong>Startup Probe</strong>：当容器启动较慢时，避免被误判为不健康。</li></ul><p>ProbeManager 会根据 Pod 的探针配置，周期性调用相关检查逻辑，确保应用运行状态。</p><h4 id="4-OOMWatcher"><a href="#4-OOMWatcher" class="headerlink" title="(4) OOMWatcher"></a><strong>(4) OOMWatcher</strong></h4><p><code>OOMWatcher</code> 监听容器是否因内存不足（OOM）被系统杀死，并触发回调通知其他模块进行后续处理。</p><h4 id="5-GPUManager"><a href="#5-GPUManager" class="headerlink" title="(5) GPUManager"></a><strong>(5) GPUManager</strong></h4><p><code>GPUManager</code> 专为需要显卡支持的容器（如深度学习模型或 GPU 加速的应用）服务，确保请求 GPU 资源的 Pod 能够成功调度并正常初始化设备。</p><h4 id="6-cAdvisor"><a href="#6-cAdvisor" class="headerlink" title="(6) cAdvisor"></a><strong>(6) cAdvisor</strong></h4><p>cAdvisor 是 Google 开源的资源监控工具，被内置为 Kubelet 的一部分，负责收集节点和容器的资源消耗（CPU、内存、网络、磁盘 IO 等）。这些数据被用于：</p><ul><li>提供给 Kubernetes 控制平面的资源调度。</li><li>在节点上触发资源回收或补救机制。</li></ul><h4 id="7-DiskSpaceManager-Image-GC"><a href="#7-DiskSpaceManager-Image-GC" class="headerlink" title="(7) DiskSpaceManager &amp; Image GC"></a><strong>(7) DiskSpaceManager &amp; Image GC</strong></h4><ul><li><code>DiskSpaceManager</code> 负责监控节点磁盘空间，并协作执行相应的垃圾回收。</li><li><code>Image GC</code> 用于定期回收未使用的镜像资源，避免磁盘因持久化镜像而耗尽。</li></ul><h4 id="8-StatusManager"><a href="#8-StatusManager" class="headerlink" title="(8) StatusManager"></a><strong>(8) StatusManager</strong></h4><p><code>StatusManager</code> 负责汇报节点和 Pod 的状态信息。具体工作包括：</p><ul><li>将本地运行中 Pod 的状态（如 Ready、运行时间、网络状态）上传到 API Server。</li><li>将状态数据同步到 <code>syncLoop</code>，用于进一步决策。</li></ul><h4 id="9-EvictionManager"><a href="#9-EvictionManager" class="headerlink" title="(9) EvictionManager"></a><strong>(9) EvictionManager</strong></h4><p><code>EvictionManager</code> 负责节点资源压力下的 Pod 驱逐。它监控节点整体资源状况，当内存、磁盘、inode 等资源低于预设阈值时，会主动驱逐“非关键”Pod 以释放资源。</p><h4 id="10-VolumeManager"><a href="#10-VolumeManager" class="headerlink" title="(10) VolumeManager"></a><strong>(10) VolumeManager</strong></h4><p><code>VolumeManager</code> 负责处理 Pod 的存储卷挂载和卸载，例如支持 <code>PersistentVolume</code> (PV) 的分配与管理。在 Pod 创建过程中，确保所需存储卷按请求挂载到容器。</p><h4 id="11-CertificateManager"><a href="#11-CertificateManager" class="headerlink" title="(11) CertificateManager"></a><strong>(11) CertificateManager</strong></h4><p><code>CertificateManager</code> 负责管理 Kubelet 所需的证书和密钥文件，用于与 API Server 安全通信的 TLS 握手。</p><hr><h2 id="kubelet-管理-Pod-的流程"><a href="#kubelet-管理-Pod-的流程" class="headerlink" title="kubelet 管理 Pod 的流程"></a>kubelet 管理 Pod 的流程</h2><img src="/2025/03/21/kubernetes-kubelet/image-20250321232354306.png" class="" title="image-20250321232354306"><ol><li><p><strong>Pod 清单的生产与获取</strong>：</p><ul><li><strong>API Server</strong>：Kubelet 从 API Server 获取需要运行的 Pod 信息。</li><li><strong>Manifest 目录</strong>：通过启动参数 <code>--config</code> 指定目录（如 <code>/etc/kubernetes/manifests/</code>），周期性扫描文件获取 Pod 定义（默认间隔 20 秒，可配置）。</li><li><strong>HTTP Server</strong>：通过启动参数 <code>--manifest-url</code> 设置 URL 来周期性拉取 Pod 清单。</li><li><strong>HTTP 接口调用</strong>：通过 kubelet 自身暴露的 HTTP 服务接口，允许动态提交新的 Pod 清单。</li></ul></li><li><p><strong>syncLoop - 消费者流程</strong>：</p><ul><li>Kubelet 的核心事件循环（syncLoop）持续监听 Pod 变更事件（如新建、更新或删除）。</li><li><strong>Worker 处理逻辑</strong>：<ul><li>调用 <code>syncPod</code> 函数处理每个 Pod。</li><li>在 <code>syncPod</code> 中，调用 <code>computePodActions</code> 比对清单中的 Pod（期望状态）和当前节点运行中的实际 Pod（实际状态）。</li><li>根据比对结果，计算需要新增、修改或删除的 Pod，并通过容器运行时接口（CRI：Container Runtime Interface）执行相应的操作。</li></ul></li></ul></li><li><p><strong>容器运行时接口 (CRI)</strong>：</p><ul><li>Kubelet 并不会直接操作容器，而是通过 CRI 进行抽象的容器操作。</li><li>CRI 执行 Pod 和容器的新增、更新、删除操作，屏蔽物理容器运行时（如 Docker、containerd）之间的实现差异。</li></ul></li></ol><hr><h2 id="Pod-生命周期管理-PLEG"><a href="#Pod-生命周期管理-PLEG" class="headerlink" title="Pod 生命周期管理 (PLEG)"></a><strong>Pod 生命周期管理 (PLEG)</strong></h2><p><strong>PLEG (Pod Lifecycle Event Generator)</strong> 是 Kubelet 的一个关键模块，用于监听和维护容器的实际状态。</p><ol><li><p><strong>功能</strong>： </p><ul><li>收集当前节点上所有 Pod 的运行状态，例如容器是否已启动、运行中、退出等。</li><li>定期通过 <strong>relist 操作</strong>，从容器运行时（CRI）中获取实际 Pod 的状态清单。</li><li>将这些状态事件发送到 Kubelet，帮助它同步期望状态与实际状态。</li></ul></li><li><p><strong>状态报告</strong>：</p><ul><li>PLEG 的状态信息会周期性地上传到 Kubernetes 控制平面（API Server），并最终存储到 etcd 中。</li><li>如果 PLEG 中出现问题（如 relist 被阻塞或超时），Kubernetes 控制平面可能会错误地认为节点状态异常（Node Not Ready）。</li></ul></li><li><p><strong>性能限制</strong>：</p><ul><li>Kubernetes 会对每个节点上的 Pod 数量设定上限，原因包括：<ul><li><strong>时间开销</strong>：PLEG 每秒 relist 一次节点上的 Pod，如果 Pod 数过多，会使 relist 操作消耗大量时间。</li><li><strong>节点状态异常</strong>：如 CRI 卡住、无法及时上报状态时，就可能导致控制平面认为节点处于 <code>NotReady</code> 状态。</li></ul></li><li>这种限制保障了分布式系统的稳定性。</li></ul></li></ol><hr><h2 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a><strong>节点管理</strong></h2><p>Kubernetes 中的节点由 Kubelet 注册、监控并周期性汇报状态。以下是节点管理的主要流程：</p><ol><li><p><strong>Kubelet 的节点自注册</strong>：</p><ul><li>通过启动参数 <code>--register-node</code> 决定是否自动向 API Server 注册节点。</li><li>若启用，Kubelet 会在启动时通过与 API Server 通信，注册节点自身的信息（如容量、配置）。</li></ul></li><li><p><strong>手动注册节点</strong>：</p><ul><li>假如未开启节点自注册模式，用户需手动创建节点资源，并将节点的相关信息配置到 API Server。</li><li>同时，需要手动配置 Kubelet 的启动参数，告知其 API Server 的地址。</li></ul></li><li><p><strong>节点状态更新</strong>：</p><ul><li>Kubelet 会定期向控制平面（API Server）发送心跳、节点资源使用情况、节点运行状态等信息。</li><li>API Server 在收到这些信息后，将其写入 etcd，供调度器和控制器使用。</li></ul></li></ol><hr><h2 id="Pod-启动流程"><a href="#Pod-启动流程" class="headerlink" title="Pod 启动流程"></a><strong>Pod 启动流程</strong></h2><img src="/2025/03/21/kubernetes-kubelet/image-20250321234138744.png" class="" title="image-20250321234138744"><h3 id="1-用户提交-Pod-创建请求"><a href="#1-用户提交-Pod-创建请求" class="headerlink" title="1. 用户提交 Pod 创建请求"></a><strong>1. 用户提交 Pod 创建请求</strong></h3><p>用户通过 <code>kubectl</code> 命令或 Kubernetes API 客户端将 Pod 的定义（如 YAML 或 JSON 格式）发送到 API Server。 </p><ol><li><p><strong>流程细节</strong>：</p><ul><li>用户运行命令：<code>kubectl apply -f pod.yaml</code> 或直接调用 REST API。</li><li>API Server 会对收到的 Pod 对象执行一系列验证、权限检查和默认值填充等逻辑：<ul><li><strong>权限校验</strong>：通过 RBAC（Role-Based Access Control）验证用户对资源类型的权限。</li><li><strong>Admission Webhook</strong>：触发一系列 Admission Controllers，用于资源约束、默认值注入或自定义逻辑的执行。</li><li><strong>Schema 验证</strong>：验证 Pod 定义是否符合 Kubernetes 的 API 规范。</li></ul></li></ul></li><li><p><strong>写入 etcd</strong>：</p><ul><li>验证成功后，API Server 将 Pod 信息写入 etcd，与此同时，返回状态 <code>201 CREATED</code> 给用户，表示资源创建成功。</li><li>etcd 是 Kubernetes 的分布式一致性存储组件，所有的集群状态变更最终都会存储在 etcd 中。</li></ul></li></ol><hr><h3 id="2-调度器-Scheduler-分配节点"><a href="#2-调度器-Scheduler-分配节点" class="headerlink" title="2. 调度器 (Scheduler) 分配节点"></a><strong>2. 调度器 (Scheduler) 分配节点</strong></h3><p>调度器负责决定每个 Pod 应该在哪个 Node（工作节点）运行，这是 Kubernetes 中资源调度的重要阶段。</p><h3 id="流程细节："><a href="#流程细节：" class="headerlink" title="流程细节："></a>流程细节：</h3><ol><li><p><strong>Scheduler 监听未绑定的 Pod</strong>：</p><ul><li>调度器通过 Watch 机制监听 API Server，寻找 <code>spec.nodeName</code> 字段为空的 Pod（即尚未绑定到具体节点的 Pod）。</li></ul></li><li><p><strong>调度决策过程</strong>:</p><ul><li>调度器会根据 <strong>调度算法</strong> 对集群中的可用节点进行评估。主要包括：<ul><li><strong>Predicate - 过滤节点</strong>：<ul><li>基本过滤条件（如节点健康状态、资源容量是否足够等）会筛选出一组候选节点。</li><li>网络、存储条件等插件可能也会影响过滤结果。</li></ul></li><li><strong>Priority - 节点评分</strong>：<ul><li>为每个候选节点根据调度优先级打分，例如节点剩余资源多的分数更高，或使 Pod 与本地数据亲和的节点优先。</li><li>最终选择得分最高的一个节点。</li></ul></li></ul></li></ul></li><li><p><strong>绑定节点</strong>：</p><ul><li>调度器决定节点后，会通过调用 API Server 的 <code>Bind</code> 接口，将 Pod 的 <code>spec.nodeName</code> 字段设置为目标节点，建立 Pod 与节点的绑定关系。</li><li>Pod 的最新状态信息会被写入到 etcd 中，由 API Server 同步到其他组件。</li></ul></li></ol><hr><h3 id="3-Kubelet-开始管理-Pod"><a href="#3-Kubelet-开始管理-Pod" class="headerlink" title="3. Kubelet 开始管理 Pod"></a><strong>3. Kubelet 开始管理 Pod</strong></h3><p>调度完成后，Pod 被分配到具体的工作节点，此时 Kubelet（运行在该节点上的组件）开始接管 Pod 的创建和管理。</p><h4 id="Kubelet-的处理流程："><a href="#Kubelet-的处理流程：" class="headerlink" title="Kubelet 的处理流程："></a><strong>Kubelet 的处理流程</strong>：</h4><ol><li><p><strong>监听 API Server</strong>：</p><ul><li>Kubelet 通过 Watch 机制监听 API Server 上的 Pod 定义变更（绑定到本节点的 Pod）。</li><li>Pod 的元数据（如容器镜像名、CPU&#x2F;内存资源需求等）会被获取到本地。</li></ul></li><li><p><strong>创建 Pod 的 sandbox 容器</strong>：</p><ul><li>Kubelet 调用 CRI（Container Runtime Interface）接口，运行一个 Sandbox 容器（如 <code>pause</code> 容器）。具体流程：<ul><li><strong>Pause 容器作用：</strong><ul><li><code>pause</code> 是 Pod 的第一个容器，负责承载网络、PID 和 IPC 等共享的 Linux Namespace。</li><li>它是一个极为轻量级的容器（通常仅几百 KB 且几乎不占用 CPU），为 Pod 提供基础的隔离环境。</li></ul></li><li><strong>网络配置：</strong><ul><li>Sandbox 容器启动后，CNI（Container Network Interface） Plugin 会为 Pod 配置网络（如分配 IP 和设置网络路由）。</li><li>若 Pod 需要挂载存储卷，Kubelet 也会在这个阶段通过 CSI（Container Storage Interface）完成卷的挂载。</li></ul></li></ul></li></ul></li><li><p><strong>构建 Pod 的运行环境</strong>：</p><ul><li>Sandbox 容器运行成功后，容器运行时（如 containerd 或 Docker）会等待 Kubelet 的进一步指令来准备用户定义的应用容器。</li></ul></li><li><p><strong>容器生命周期管理</strong>：</p><ul><li>Kubelet 根据 Pod 定义中描述的容器逐一执行以下操作：<ul><li><strong>PullImage</strong>：拉取容器镜像（若镜像已存在，则跳过）。</li><li><strong>CreateContainer</strong>：创建容器。</li><li><strong>StartContainer</strong>：启动容器。</li></ul></li><li>当所有容器都创建并正常启动后，Pod 进入 “Running” 状态。</li></ul></li></ol><hr><h3 id="4-状态反馈与同步"><a href="#4-状态反馈与同步" class="headerlink" title="4. 状态反馈与同步"></a><strong>4. 状态反馈与同步</strong></h3><ol><li><p><strong>状态更新</strong>：</p><ul><li>Kubelet 会周期性地获取 Pod 的实际运行状态（通过 CRI 和 PLEG）：<ul><li>检查容器是否正常运行；</li><li>如果存在失败，则可能记录事件（Event）并尝试重启容器。</li></ul></li><li>这些状态信息会被汇报到 API Server，API Server 将其写入 etcd。</li></ul></li><li><p><strong>状态查询结果</strong>：</p><ul><li>用户通过 <code>kubectl get pod &lt;pod-name&gt; -o wide</code> 或其他方式查询 Pod 状态时，会从 etcd 中读取最新状态。</li><li>当所有容器成功运行，且健康检查通过时，Pod 会被标记为 <strong>Ready</strong>。</li></ul></li></ol><img src="/2025/03/21/kubernetes-kubelet/image-20250322110715382.png" class="" title="image-20250322110715382">]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang并发编程</title>
    <link href="/2025/03/18/golang-concurrency/"/>
    <url>/2025/03/18/golang-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="GO并发编程（Concurrency）"><a href="#GO并发编程（Concurrency）" class="headerlink" title="GO并发编程（Concurrency）"></a>GO并发编程（Concurrency）</h1><h4 id="通过通信共享内存（Share-by-communicating）"><a href="#通过通信共享内存（Share-by-communicating）" class="headerlink" title="通过通信共享内存（Share by communicating）"></a>通过通信共享内存（Share by communicating）</h4><p>并发编程是一个广泛的话题，这里只讨论一些与 Go 语言相关的重点。</p><p>在许多环境中，并发编程的难点在于如何正确访问共享变量。Go 语言鼓励一种不同的方法：</p><p><strong>通过通道（channel）传递共享值，而不是让多个执行线程主动共享内存。</strong></p><p>在任何给定时间，只有一个 goroutine 可以访问该值。通过设计，数据竞争不会发生。为了鼓励这种思维方式，我们将其简化为一个口号：</p><p><strong>不要通过共享内存来通信；相反，通过通信来共享内存。</strong></p><p>这种方法有时可能被过度使用。例如，引用计数可能最好通过在一个整数变量周围加锁来实现。但作为一种高级方法，使用通道来控制访问可以更容易编写清晰、正确的程序。</p><p>这种模型的一个思考方式是考虑一个在单个 CPU 上运行的典型单线程程序。它不需要同步原语。</p><p>现在运行另一个这样的实例；它也不需要同步。现在让这两个实例进行通信；如果通信本身就是同步器，那么仍然不需要其他同步。例如，Unix 管道完美地符合这种模型。尽管 Go 的并发方法源自 Hoare 的通信顺序进程（CSP），但它也可以被视为 Unix 管道的一种类型安全的泛化。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>它们被称为 goroutines，因为现有的术语（线程、协程、进程等）传达了不准确的含义。Goroutine 有一个简单的模型：它是一个与同一地址空间中的其他 goroutine 并发执行的函数。它是轻量级的，成本几乎只比分配栈空间多一点。而且栈一开始很小，所以它们很便宜，并且根据需要分配（和释放）堆存储来增长。</p><p>Goroutines 被多路复用到多个操作系统线程上，因此如果一个 goroutine 阻塞（例如等待 I&#x2F;O），其他 goroutine 可以继续运行。它们的设计隐藏了许多线程创建和管理的复杂性。</p><p>在函数或方法调用前加上 <code>go</code> 关键字，可以在一个新的 goroutine 中运行该调用。当调用完成时，goroutine 会静默退出。（效果类似于 Unix shell 的 <code>&amp;</code> 符号，用于在后台运行命令。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> list.Sort()  <span class="hljs-comment">// 并发运行 list.Sort；不等待它完成。</span><br></code></pre></td></tr></table></figure><p>在 goroutine 调用中，函数字面量（匿名函数）非常方便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Announce</span><span class="hljs-params">(message <span class="hljs-type">string</span>, delay time.Duration)</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(delay)<br>        fmt.Println(message)<br>    &#125;()  <span class="hljs-comment">// 注意括号 - 必须调用函数。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，函数字面量是闭包：实现确保函数引用的变量在它们活跃时一直存在。</p><p>这些例子不太实用，因为函数没有办法通知完成。为此，我们需要通道。</p><h4 id="通道（Channels）"><a href="#通道（Channels）" class="headerlink" title="通道（Channels）"></a>通道（Channels）</h4><p>与映射（map）一样，通道是用 <code>make</code> 分配的，结果值是对底层数据结构的引用。如果提供了一个可选的整数参数，它会设置通道的缓冲区大小。默认值为零，表示无缓冲或同步通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ci := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)            <span class="hljs-comment">// 无缓冲的整数通道</span><br>cj := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>)         <span class="hljs-comment">// 无缓冲的整数通道</span><br>cs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *os.File, <span class="hljs-number">100</span>)  <span class="hljs-comment">// 缓冲的文件指针通道</span><br></code></pre></td></tr></table></figure><p>无缓冲通道将通信（值的交换）与同步（保证两个计算（goroutine）处于已知状态）结合在一起。</p><p>使用通道有很多好的习惯用法。这里有一个例子。在上一节中，我们在后台启动了一个排序。通道可以让启动的 goroutine 等待排序完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <span class="hljs-comment">// 分配一个通道。</span><br><span class="hljs-comment">// 在 goroutine 中启动排序；完成后，通过通道发送信号。</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    list.Sort()<br>    c &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">// 发送信号；值不重要。</span><br>&#125;()<br>doSomethingForAWhile()<br>&lt;-c   <span class="hljs-comment">// 等待排序完成；丢弃发送的值。</span><br></code></pre></td></tr></table></figure><p>接收者总是阻塞，直到有数据可以接收。如果通道是无缓冲的，发送者会阻塞，直到接收者接收到值。如果通道有缓冲区，发送者只会在值被复制到缓冲区之前阻塞；如果缓冲区已满，这意味着等待某个接收者检索一个值。</p><p>缓冲通道可以像信号量一样使用，例如限制吞吐量。在这个例子中，传入的请求被传递给 <code>handle</code>，它向通道发送一个值，处理请求，然后从通道接收一个值，以便为下一个消费者准备好“信号量”。通道缓冲区的容量限制了同时调用 <code>process</code> 的数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, MaxOutstanding)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(r *Request)</span></span> &#123;<br>    sem &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 等待活动队列排空。</span><br>    process(r)  <span class="hljs-comment">// 可能需要很长时间。</span><br>    &lt;-sem       <span class="hljs-comment">// 完成；启用下一个请求运行。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        req := &lt;-queue<br>        <span class="hljs-keyword">go</span> handle(req)  <span class="hljs-comment">// 不要等待 handle 完成。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦 <code>MaxOutstanding</code> 个处理程序正在执行 <code>process</code>，任何更多的处理程序都会阻塞，尝试向已满的通道缓冲区发送数据，直到现有的处理程序之一完成并从缓冲区接收数据。</p><p>不过，这个设计有一个问题：<code>Serve</code> 为每个传入的请求创建一个新的 goroutine，即使在任何时刻只有 <code>MaxOutstanding</code> 个 goroutine 可以运行。因此，如果请求来得太快，程序可能会消耗无限的资源。我们可以通过修改 <code>Serve</code> 来限制 goroutine 的创建来解决这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue &#123;<br>        sem &lt;- <span class="hljs-number">1</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            process(req)<br>            &lt;-sem<br>        &#125;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（注意，在 Go 1.22 之前的版本中，这段代码有一个 bug：循环变量在所有 goroutine 之间共享。详情请参阅 Go wiki。）</p><p>另一种管理资源的方法是启动固定数量的 <code>handle</code> goroutine，它们都从请求通道中读取。goroutine 的数量限制了同时调用 <code>process</code> 的数量。这个 <code>Serve</code> 函数还接受一个通道，用于通知它退出；在启动 goroutine 后，它会阻塞接收该通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> r := <span class="hljs-keyword">range</span> queue &#123;<br>        process(r)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">(clientRequests <span class="hljs-keyword">chan</span> *Request, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 启动处理程序</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; MaxOutstanding; i++ &#123;<br>        <span class="hljs-keyword">go</span> handle(clientRequests)<br>    &#125;<br>    &lt;-quit  <span class="hljs-comment">// 等待被告知退出。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通道的通道（Channels-of-channels）"><a href="#通道的通道（Channels-of-channels）" class="headerlink" title="通道的通道（Channels of channels）"></a>通道的通道（Channels of channels）</h4><p>Go 最重要的特性之一是通道是一等值，可以像其他值一样分配和传递。这个特性的一个常见用途是实现安全的并行多路分解。</p><p>在上一节的例子中，<code>handle</code> 是一个理想化的请求处理程序，但我们没有定义它处理的类型。如果该类型包含一个用于回复的通道，每个客户端都可以提供自己的答案路径。以下是 <code>Request</code> 类型的示意定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>    args        []<span class="hljs-type">int</span><br>    f           <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>    resultChan  <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>客户端提供一个函数及其参数，以及请求对象中的一个通道，用于接收答案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br>request := &amp;Request&#123;[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, sum, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)&#125;<br><span class="hljs-comment">// 发送请求</span><br>clientRequests &lt;- request<br><span class="hljs-comment">// 等待响应。</span><br>fmt.Printf(<span class="hljs-string">&quot;answer: %d\n&quot;</span>, &lt;-request.resultChan)<br></code></pre></td></tr></table></figure><p>在服务器端，处理函数是唯一改变的部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">(queue <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> queue &#123;<br>        req.resultChan &lt;- req.f(req.args)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，要使它更现实，还有很多工作要做，但这段代码是一个限速、并行、非阻塞 RPC 系统的框架，而且没有使用任何互斥锁。</p><h4 id="并行化（Parallelization）"><a href="#并行化（Parallelization）" class="headerlink" title="并行化（Parallelization）"></a>并行化（Parallelization）</h4><p>这些思想的另一个应用是在多个 CPU 核心上并行化计算。如果计算可以分解为可以独立执行的单独部分，那么它可以并行化，并使用通道来通知每个部分何时完成。</p><p>假设我们有一个对向量中的项目执行昂贵操作的需求，并且每个项目的操作值是独立的，如这个理想化的例子所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vector []<span class="hljs-type">float64</span><br><br><span class="hljs-comment">// 对 v[i], v[i+1] ... 直到 v[n-1] 应用操作。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vector)</span></span> DoSome(i, n <span class="hljs-type">int</span>, u Vector, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">for</span> ; i &lt; n; i++ &#123;<br>        v[i] += u.Op(v[i])<br>    &#125;<br>    c &lt;- <span class="hljs-number">1</span>    <span class="hljs-comment">// 发送信号表示这部分已完成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在循环中独立启动这些部分，每个 CPU 一个。它们可以以任何顺序完成，但这并不重要；我们只需在启动所有 goroutine 后通过排空通道来计算完成信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> numCPU = <span class="hljs-number">4</span> <span class="hljs-comment">// CPU 核心数</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vector)</span></span> DoAll(u Vector) &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, numCPU)  <span class="hljs-comment">// 缓冲是可选的，但明智的。</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCPU; i++ &#123;<br>        <span class="hljs-keyword">go</span> v.DoSome(i*<span class="hljs-built_in">len</span>(v)/numCPU, (i+<span class="hljs-number">1</span>)*<span class="hljs-built_in">len</span>(v)/numCPU, u, c)<br>    &#125;<br>    <span class="hljs-comment">// 排空通道。</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCPU; i++ &#123;<br>        &lt;-c    <span class="hljs-comment">// 等待一个任务完成</span><br>    &#125;<br>    <span class="hljs-comment">// 全部完成。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与其为 <code>numCPU</code> 创建一个常量值，我们可以询问运行时什么值是合适的。函数 <code>runtime.NumCPU</code> 返回机器中的硬件 CPU 核心数，因此我们可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numCPU = runtime.NumCPU()<br></code></pre></td></tr></table></figure><p>还有一个函数 <code>runtime.GOMAXPROCS</code>，它报告（或设置）用户指定的 Go 程序可以同时运行的 CPU 核心数。它默认为 <code>runtime.NumCPU</code> 的值，但可以通过设置同名的 shell 环境变量或调用该函数并传递一个正数来覆盖。传递零只是查询该值。因此，如果我们想尊重用户的资源请求，我们应该这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numCPU = runtime.GOMAXPROCS(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>确保不要混淆并发（将程序结构化为独立执行的组件）和并行（在多个 CPU 上并行执行计算以提高效率）的概念。尽管 Go 的并发特性可以使一些问题容易结构化为并行计算，但 Go 是一种并发语言，而不是并行语言，并非所有并行化问题都适合 Go 的模型。有关区别的讨论，请参阅此博客文章中引用的演讲。</p><h4 id="漏桶（Leaky-buffer）"><a href="#漏桶（Leaky-buffer）" class="headerlink" title="漏桶（Leaky buffer）"></a>漏桶（Leaky buffer）</h4><p>并发编程的工具甚至可以使非并发的思想更容易表达。这里有一个从 RPC 包中抽象出来的例子。客户端 goroutine 循环从某个源（可能是网络）接收数据。为了避免分配和释放缓冲区，它保留一个空闲列表，并使用一个缓冲通道来表示它。如果通道为空，则分配一个新的缓冲区。一旦消息缓冲区准备好，它就会被发送到 <code>serverChan</code> 上的服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> freeList = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">var</span> serverChan = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">client</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">var</span> b *Buffer<br>        <span class="hljs-comment">// 如果有可用的缓冲区，则获取；否则分配一个新的。</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> b = &lt;-freeList:<br>            <span class="hljs-comment">// 获取一个；无需做更多操作。</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 没有空闲的，所以分配一个新的。</span><br>            b = <span class="hljs-built_in">new</span>(Buffer)<br>        &#125;<br>        load(b)              <span class="hljs-comment">// 从网络读取下一条消息。</span><br>        serverChan &lt;- b      <span class="hljs-comment">// 发送到服务器。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器循环接收来自客户端的每条消息，处理它，并将缓冲区返回到空闲列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        b := &lt;-serverChan    <span class="hljs-comment">// 等待工作。</span><br>        process(b)<br>        <span class="hljs-comment">// 如果有空间，则重用缓冲区。</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> freeList &lt;- b:<br>            <span class="hljs-comment">// 缓冲区在空闲列表上；无需做更多操作。</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// 空闲列表已满，继续执行。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端尝试从 <code>freeList</code> 中检索一个缓冲区；如果没有可用的，则分配一个新的。服务器的发送到 <code>freeList</code> 将 <code>b</code> 放回空闲列表，除非列表已满，在这种情况下，缓冲区会被丢弃，由垃圾回收器回收。（<code>select</code> 语句中的 <code>default</code> 子句在没有其他 case 准备就绪时执行，这意味着 <code>select</code> 永远不会阻塞。）这个实现在几行代码中构建了一个漏桶空闲列表，依赖于缓冲通道和垃圾回收器进行簿记。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang错误处理</title>
    <link href="/2025/03/18/golang-error/"/>
    <url>/2025/03/18/golang-error/</url>
    
    <content type="html"><![CDATA[<h2 id="Golang-的错误处理（Error-Handling）"><a href="#Golang-的错误处理（Error-Handling）" class="headerlink" title="Golang 的错误处理（Error Handling）"></a>Golang 的错误处理（Error Handling）</h2><hr><h3 id="1-Errors-包"><a href="#1-Errors-包" class="headerlink" title="1. Errors 包"></a>1. Errors 包</h3><p>Error 是一个<code>interface</code>，只要实现了<code>Error() string</code>接口的结构体都是一个 Error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>最简单的 error 示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;division by zero is not allowed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result, err := divide(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-Sentinel-Error（预定义的-Error）"><a href="#2-Sentinel-Error（预定义的-Error）" class="headerlink" title="2. Sentinel Error（预定义的 Error）"></a>2. Sentinel Error（预定义的 Error）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// ErrNotFound 定义 Sentinel Error</span><br><span class="hljs-keyword">var</span> ErrNotFound = errors.New(<span class="hljs-string">&quot;item not found&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findItem</span><span class="hljs-params">(items []<span class="hljs-type">string</span>, target <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> item == target &#123;<br><span class="hljs-keyword">return</span> item, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, ErrNotFound<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>items := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;<br>_, err := findItem(items, <span class="hljs-string">&quot;grape&quot;</span>)<br><br><span class="hljs-keyword">if</span> errors.Is(err, ErrNotFound) &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error: Item not found in the list&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Unexpected error:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Item found&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-自定义错误类型"><a href="#3-自定义错误类型" class="headerlink" title="3. 自定义错误类型"></a>3. 自定义错误类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// MyError 自定义错误类型</span><br><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>Operation <span class="hljs-type">string</span><br>Err       <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;operation %s failed: %v&quot;</span>, e.Operation, e.Err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> e.Err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 模拟一个底层错误</span><br><span class="hljs-keyword">return</span> &amp;MyError&#123;<br>Operation: <span class="hljs-string">&quot;file_read&quot;</span>,<br>Err:       fmt.Errorf(<span class="hljs-string">&quot;file not found&quot;</span>),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := doSomething()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-Wrap-Error"><a href="#4-Wrap-Error" class="headerlink" title="4. Wrap Error"></a>4. Wrap Error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 模拟底层错误</span><br><span class="hljs-keyword">return</span> os.ErrNotExist<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := readFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 包装底层错误</span><br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;processFile failed: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := processFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> errors.Is(err, os.ErrNotExist) &#123;<br>fmt.Println(<span class="hljs-string">&quot;File does not exist&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Unexpected error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Is 的源代码如下：</p><p><code>is</code>中会去<code>unwrap</code>最后确定这两个 <code>err</code> 的最底层是否一致。ß</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> || target == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err == target<br>&#125;<br><br>isComparable := reflectlite.TypeOf(target).Comparable()<br><span class="hljs-keyword">return</span> is(err, target, isComparable)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>, targetComparable <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> targetComparable &amp;&amp; err == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x, ok := err.(<span class="hljs-keyword">interface</span>&#123; Is(<span class="hljs-type">error</span>) <span class="hljs-type">bool</span> &#125;); ok &amp;&amp; x.Is(target) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">switch</span> x := err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123; Unwrap() <span class="hljs-type">error</span> &#125;:<br>err = x.Unwrap()<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123; Unwrap() []<span class="hljs-type">error</span> &#125;:<br><span class="hljs-keyword">for</span> _, err := <span class="hljs-keyword">range</span> x.Unwrap() &#123;<br><span class="hljs-keyword">if</span> is(err, target, targetComparable) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-As-提取指定错误"><a href="#5-As-提取指定错误" class="headerlink" title="5. As 提取指定错误"></a>5. As 提取指定错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 模拟底层错误</span><br><span class="hljs-keyword">return</span> &amp;os.PathError&#123;<br>Op:   <span class="hljs-string">&quot;open&quot;</span>,<br>Path: <span class="hljs-string">&quot;/nonexistent/file&quot;</span>,<br>Err:  os.ErrNotExist,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := readFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> pathErr *os.PathError<br><span class="hljs-keyword">if</span> errors.As(err, &amp;pathErr) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;File operation failed: %v (path: %s)\n&quot;</span>, pathErr.Err, pathErr.Path)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Unexpected error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-整合日志记录与错误处理"><a href="#6-整合日志记录与错误处理" class="headerlink" title="6. 整合日志记录与错误处理"></a>6. <strong>整合日志记录与错误处理</strong></h3><p>在 Goroutine 的顶层统一记录日志并打印堆栈信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;something went wrong&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := process()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 顶层记录错误日志</span><br>fmt.Printf(<span class="hljs-string">&quot;Error occurred: %+v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Process completed successfully&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-模拟-DAO-错误处理"><a href="#7-模拟-DAO-错误处理" class="headerlink" title="7. 模拟 DAO 错误处理"></a>7. 模拟 DAO 错误处理</h3><p>数据库操作中的错误处理示例，注重上下文信息的传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 模拟 DAO 层查询</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">queryUserByID</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> id == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, sql.ErrNoRows<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;John Doe&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findUserByID</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>user, err := queryUserByID(id)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> errors.Is(err, sql.ErrNoRows) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;user with ID %d not found: %w&quot;</span>, id, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected database error: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_, err := findUserByID(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="8-pkg-errors"><a href="#8-pkg-errors" class="headerlink" title="8. pkg&#x2F;errors"></a>8. pkg&#x2F;errors</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;file not found&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processFile</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := readFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;failed to process file&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := processFile()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// %+v 会打印堆栈信息</span><br>fmt.Printf(<span class="hljs-string">&quot;Error: %+v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wrap returns an error annotating err with a stack trace</span><br><span class="hljs-comment">// at the point Wrap is called, and the supplied message.</span><br><span class="hljs-comment">// If err is nil, Wrap returns nil.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>, message <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>err = &amp;withMessage&#123;<br>cause: err,<br>msg:   message,<br>&#125;<br><span class="hljs-keyword">return</span> &amp;withStack&#123;<br>err,<br>callers(),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Warp 会追踪栈的调用链。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_controller_manager</title>
    <link href="/2025/03/18/kubernetes-controller-manager/"/>
    <url>/2025/03/18/kubernetes-controller-manager/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-Controller-Manager"><a href="#k8s-Controller-Manager" class="headerlink" title="k8s-Controller-Manager"></a>k8s-Controller-Manager</h1><p><code>Controller Manager</code> 是 Kubernetes（K8S）中的一个核心组件，负责管理和运行各种控制器（Controllers）。控制器是 Kubernetes 的自动化机制之一，Controller Manager 通过与 API Server 的交互来获取和更新集群的状态信息。它使用 Kubernetes 的 <code>watch</code> API 来实时监控资源的变化，并根据这些变化执行相应的操作。</p><!--more---><h2 id="控制器的工作流程"><a href="#控制器的工作流程" class="headerlink" title="控制器的工作流程"></a>控制器的工作流程</h2><img src="/2025/03/18/kubernetes-controller-manager/image-20250319131225932.png" class=""><h3 id="Informer-和-Lister-的关系"><a href="#Informer-和-Lister-的关系" class="headerlink" title="Informer 和 Lister 的关系"></a>Informer 和 Lister 的关系</h3><p>Informer内部通过<code>Store</code>（基于<code>cache.FIFO</code>或<code>cache.RateLimiter</code>）存储资源对象数据，而Lister的接口实现（如<code>GridLister</code>）<strong>直接读取Informer的Store</strong>，因此Lister是Informer数据的<strong>查询接口</strong>。</p><p>Informer负责<strong>实时监听API Server变更</strong>（通过ListAndWatch机制），将资源变化事件（Add&#x2F;Update&#x2F;Delete）写入Store并触发处理链。</p><p>Lister提供<strong>快照式查询能力</strong>（如<code>List()</code>、<code>Get()</code>），通过直接访问Informer的Store实现低延迟查询，避免每次直接调用API Server。</p><h4 id="1-核心组件与流程"><a href="#1-核心组件与流程" class="headerlink" title="1. 核心组件与流程"></a>1. <strong>核心组件与流程</strong></h4><ul><li><p><strong>Lister</strong></p><ul><li>提供 <code>List()</code> 接口获取资源对象的全量快照（如 <code>ListPods()</code>）。</li><li>通过 <code>Informer</code> 的 <code>Lister()</code> 方法获取，确保与缓存数据同步。</li><li><strong>实现</strong>：基于 <code>Reflector</code> 的初始 List 操作，结合 Informer 缓存。</li></ul></li><li><p><strong>Informer</strong></p><ul><li>核心：<code>SharedIndexInformer</code>（实现 <code>Informers</code> 接口）。</li><li><strong>机制</strong>：<ol><li><strong>List+Watch</strong>：通过 API Server 获取资源初始列表（List）并建立 Watch 长连接（Watch）。</li><li><strong>缓存</strong>：本地缓存资源对象（线程安全，通过 <code>DeltaFIFO</code> 或 <code>Store</code> 实现）。</li><li><strong>事件分发</strong>：将 Watch 到的事件（Add&#x2F;Update&#x2F;Delete）传递给 <code>ResourceEventHandler</code>。</li></ol></li></ul></li><li><p><strong>EventHandler</strong></p><ul><li>定义事件处理逻辑：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourceEventHandler <span class="hljs-keyword">interface</span> &#123;<br>    OnAdd(obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    OnUpdate(oldObj, newObj <span class="hljs-keyword">interface</span>&#123;&#125;)<br>    OnDelete(obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>关键点</strong>：<ul><li>Update 事件需通过 <code>obj.DeepCopy()</code> 避免直接操作缓存对象。</li><li>Delete 事件可能携带 <code>gracePeriod</code>，需处理最终状态。</li></ul></li></ul></li><li><p><strong>Enqueue 到 WorkQueue</strong></p><ul><li><strong>KeyFunc</strong>：生成队列键（如 <code>controller.KeyFunc</code> 默认使用 <code>&lt;namespace&gt;/&lt;name&gt;</code>）。</li><li><strong>Enqueue</strong>：将键加入 <code>workqueue.RateLimitingInterface</code>（如 <code>NewRateLimitingQueue</code>）。</li><li><strong>RateLimiter</strong>：<ul><li>配置指数退避算法（如 <code>ExponentialBackoff</code>），失败任务重试间隔随失败次数指数增长。</li><li>通过 <code>workqueue.NewMaxHeapRateLimiter</code> 设置最大&#x2F;最小重试间隔。</li></ul></li></ul></li></ul><h4 id="2-Worker-处理流程"><a href="#2-Worker-处理流程" class="headerlink" title="2. Worker 处理流程"></a>2. <strong>Worker 处理流程</strong></h4><ul><li><strong>Goroutine</strong>：<ul><li>启动多个 worker 从队列中 <code>Dequeue()</code> 任务。</li><li><strong>关键逻辑</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        key := queue.Get()<br>        obj, exists := store.GetByKey(key)<br>        <span class="hljs-keyword">if</span> !exists &#123; <span class="hljs-comment">// 对象已删除</span><br>            queue.Forget(key)<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> err := process(obj) &#123;<br>            <span class="hljs-keyword">if</span> err == ErrTooEarly &#123; <span class="hljs-comment">// 需重试</span><br>                queue.AddRateLimited(key)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                queue.Forget(key)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queue.Forget(key)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>指数退避</strong>：<ul><li><code>AddRateLimited</code> 触发 RateLimiter 计算延迟，失败次数越多，重试间隔越长。</li><li>通过 <code>workqueue.AddAfter</code> 或 <code>workqueue.Forget</code> 控制重试逻辑。</li></ul></li></ul></li></ul><h4 id="3-关键机制补充"><a href="#3-关键机制补充" class="headerlink" title="3. 关键机制补充"></a>3. <strong>关键机制补充</strong></h4><ul><li><p><strong>ReSync 机制</strong>：</p><ul><li>通过 <code>ResyncPeriod</code> 定期强制刷新缓存（如每 30 分钟 List 一次资源）。</li><li>作用：避免 Watch 断连导致的缓存不一致。</li></ul></li><li><p><strong>并发安全</strong>：</p><ul><li><code>SharedIndexInformer</code> 的缓存是线程安全的，但 <code>worker</code> 处理需自行保证业务逻辑的原子性。</li><li><code>workqueue</code> 的 <code>Add</code>&#x2F;<code>Get</code> 操作已原子化，但需通过 <code>Forget</code>&#x2F;<code>Done</code> 管理键状态。</li></ul></li><li><p><strong>错误处理策略</strong>：</p><ul><li><strong>永久错误</strong>（如无效配置）：直接 <code>queue.Forget</code>，避免无限重试。</li><li><strong>临时错误</strong>（如 API 限流）：通过 <code>queue.AddRateLimited</code> 触发指数退避。</li></ul></li></ul><h2 id="Informer-详解"><a href="#Informer-详解" class="headerlink" title="Informer 详解"></a>Informer 详解</h2><img src="/2025/03/18/kubernetes-controller-manager/image-20250319132531577.png" class="" title="image-20250319132531577"><hr><p>通用 Controller</p><img src="/2025/03/18/kubernetes-controller-manager/image-20250321170252430.png" class="" title="image-20250321170252430"><img src="/2025/03/18/kubernetes-controller-manager/image-20250321170234148.png" class="" title="image-20250321170213798"><h2 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h2><h3 id="Leader-Election-的工作原理"><a href="#Leader-Election-的工作原理" class="headerlink" title="Leader Election 的工作原理"></a>Leader Election 的工作原理</h3><p>Kubernetes 使用 <strong>分布式锁</strong> 来实现 Leader Election。具体来说，它利用了 Kubernetes 的 API Server 作为分布式锁的存储后端，通过 <code>Lease</code> 资源来实现选举。</p><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h4><ol><li><strong>Lease 资源</strong>：<ul><li>Lease 是 Kubernetes 中的一种资源类型，用于表示某个组件对 Leader 角色的持有权。</li><li>Lease 资源包含以下关键字段：<ul><li><code>holderIdentity</code>：当前持有锁的实例标识。</li><li><code>leaseDurationSeconds</code>：锁的持有时间。</li><li><code>renewTime</code>：最近一次续约的时间。</li></ul></li></ul></li><li><strong>选举流程</strong>：<ul><li>每个候选实例（Controller Manager 或 Scheduler）会尝试创建一个 Lease 资源或更新现有的 Lease 资源。</li><li>如果某个实例成功创建或更新 Lease 资源，它将成为 Leader。</li><li>Leader 会定期更新 Lease 资源的 <code>renewTime</code>，以表明它仍然活跃。</li><li>如果 Leader 在指定时间内未更新 Lease 资源，其他实例会认为 Leader 已失效，并尝试竞选新的 Leader。</li></ul></li></ol><p><strong>Leader Election 的作用</strong>：</p><ul><li>在 HA 环境中确保只有一个实例执行任务，避免冲突。</li><li>提高系统的可靠性和容错能力。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_scheduler</title>
    <link href="/2025/03/18/kubernetes-scheduler/"/>
    <url>/2025/03/18/kubernetes-scheduler/</url>
    
    <content type="html"><![CDATA[<h1 id="Kube-Schedular"><a href="#Kube-Schedular" class="headerlink" title="Kube-Schedular"></a>Kube-Schedular</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>kube-scheduler</code> 是 Kubernetes 核心组件之一，负责 Pod 的调度（Scheduling）。简而言之，它的主要职责是决定一个未绑定到节点的 Pod 应该被分配到哪个节点上运行。调度器在 Kubernetes 中起到“任务分派员”的作用，其调度的核心目标是满足工作负载的资源需求（如 CPU、内存等），并同时遵循用户定义的调度策略和约束（如 Pod 配置的 <code>nodeSelector</code>、<code>affinity</code> 等）。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="一、Pod-监听："><a href="#一、Pod-监听：" class="headerlink" title="一、Pod 监听："></a><strong>一、Pod 监听：</strong></h3><ol><li><p><strong>初始化 Informer</strong>：</p><ul><li><p><code>kube-scheduler</code> 在启动时，会创建一个 <code>Pod Informer</code>，用于监听和缓存 Pod 的变化（包括新增、修改、删除事件）。</p></li><li><p>只监听那些未绑定到节点（<code>spec.nodeName</code> 为空）的 Pod。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewScheduler</span><span class="hljs-params">(...)</span></span> (*Scheduler, <span class="hljs-type">error</span>) &#123;<br>    ...<br>    <span class="hljs-comment">// 创建 Pod Informer</span><br>    podInformer := informerFactory.Core().V1().Pods()<br>    <br>    <span class="hljs-comment">// 初始化调度器</span><br>    sched := &amp;Scheduler&#123;<br>        podQueue:         queue,                <span class="hljs-comment">// 调度队列</span><br>        podInformer:      podInformer,         <span class="hljs-comment">// Pod Informer</span><br>        podLister:        podInformer.Lister() <span class="hljs-comment">// 用于从缓存中获取 Pod 列表</span><br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过 List 和 Watch 获取数据</strong>：</p><ul><li><strong>List</strong>：在调度器启动时，通过 API Server 全量获取当前所有未被绑定的 Pod。</li><li><strong>Watch</strong>：之后通过 Watch API，订阅 Pod 的增量更新事件（新增、修改、删除）。</li></ul></li></ol><h3 id="二、接收调度请求："><a href="#二、接收调度请求：" class="headerlink" title="二、接收调度请求："></a>二、接收调度请求：</h3><ul><li><p>当用户创建一个 Pod 时，Pod <strong>没有绑定到特定的节点</strong>（<strong>即 <code>.spec.nodeName</code> 为空</strong>），此时 kube-scheduler 会将其视为候选调度对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在 Informer 的初始化过程中，设置了过滤器</span><br>podInformer := informerFactory.Core().V1().Pods().Informer()<br><br><span class="hljs-comment">// 过滤只监听未绑定到节点的 Pod</span><br>podInformer.AddEventHandler(cache.ResourceEventHandlerFuncs&#123;<br>    AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        pod := obj.(*v1.Pod)<br>        <span class="hljs-keyword">if</span> pod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// Pod 未被绑定，加入调度队列</span><br>            sched.AddPodToQueue(pod)<br>        &#125;<br>    &#125;,<br>  <br>    UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(oldObj, newObj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        oldPod := oldObj.(*v1.Pod)<br>        newPod := newObj.(*v1.Pod)<br>        <span class="hljs-keyword">if</span> oldPod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; newPod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// Pod 更新了但仍未绑定</span><br>            sched.AddPodToQueue(newPod)<br>        &#125;<br>    &#125;,<br>    DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>        pod := obj.(*v1.Pod)<br>        <span class="hljs-keyword">if</span> pod.Spec.NodeName == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// Pod 被删除</span><br>            sched.DeletePodFromQueue(pod)<br>        &#125;<br>    &#125;,<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="三、可调度候选节点筛选（Predicate-Filter-Phase）："><a href="#三、可调度候选节点筛选（Predicate-Filter-Phase）：" class="headerlink" title="三、可调度候选节点筛选（Predicate&#x2F;Filter Phase）："></a>三、可调度候选节点筛选（Predicate&#x2F;Filter Phase）：</h3><p>kube-scheduler 会根据一系列过滤规则（称为 “Predicates”，目前叫 Filter Plugins），筛选出所有满足 Pod 调度需求的候选节点。例如：</p><img src="/2025/03/18/kubernetes-scheduler/image-20250318141606770.png" class="" title="image-20250318141606770"><h4 id="1-PodFitsHostPorts"><a href="#1-PodFitsHostPorts" class="headerlink" title="1. PodFitsHostPorts"></a>1. <strong>PodFitsHostPorts</strong></h4><ul><li><h5 id="含义：验证目标节点上是否有-Pod-使用了相同的-hostPort，避免端口冲突。"><a href="#含义：验证目标节点上是否有-Pod-使用了相同的-hostPort，避免端口冲突。" class="headerlink" title="含义：验证目标节点上是否有 Pod 使用了相同的 hostPort，避免端口冲突。"></a><strong>含义</strong>：验证目标节点上是否有 Pod 使用了相同的 <code>hostPort</code>，避免端口冲突。</h5></li><li><p><strong>场景</strong>：当 Pod 定义了容器的 <code>hostPort</code> 时，调度器会检查该端口在目标节点上是否已经被占用。</p></li></ul><h4 id="2-PodFitsResources"><a href="#2-PodFitsResources" class="headerlink" title="2. PodFitsResources"></a>2. <strong>PodFitsResources</strong></h4><ul><li><strong>含义</strong>：检查目标节点的资源是否足够，包括：<ul><li><code>CPU</code>、<code>内存</code>、GPU（通过 <code>OpaqueIntResources</code> 定义）。</li></ul></li><li><strong>实现逻辑</strong>：对比 Pod 的资源请求（<code>requests</code>）与节点的可用资源（考虑已分配和未分配资源）。如果资源不足，则调度失败。</li></ul><h4 id="3-HostName"><a href="#3-HostName" class="headerlink" title="3. HostName"></a>3. <strong>HostName</strong></h4><ul><li><strong>含义</strong>：检查 Pod 的 <code>spec.nodeName</code> 是否与候选节点的名称一致。</li><li><strong>场景</strong>：当 Pod 明确指定了运行的节点（通过 <code>spec.nodeName</code> 字段），调度器会检查是否匹配。</li></ul><h4 id="4-MatchNodeSelector"><a href="#4-MatchNodeSelector" class="headerlink" title="4. MatchNodeSelector"></a><strong>4. MatchNodeSelector</strong></h4><ul><li><strong>含义</strong>：检查候选节点是否满足 Pod 的 <code>nodeSelector</code> 条件。</li><li><strong>场景</strong>：当 Pod 使用 <code>nodeSelector</code> 指定了需要运行的节点特性（通常是节点的标签），调度器会验证候选节点是否满足这些条件。</li></ul><h4 id="5-NoVolumeZoneConflict"><a href="#5-NoVolumeZoneConflict" class="headerlink" title="5. NoVolumeZoneConflict"></a>5. <strong>NoVolumeZoneConflict</strong></h4><ul><li><strong>含义</strong>：验证 Pod 引用的 Volume（例如云存储卷）是否可以在目标节点所在的地域（Zone）使用。</li><li><strong>场景</strong>：某些存储类型（如 GCE PD、AWS EBS 等）具有区域限制，调度器需要检查节点的 Zone 是否匹配。</li></ul><h4 id="6-MatchInterPodAffinity"><a href="#6-MatchInterPodAffinity" class="headerlink" title="6. MatchInterPodAffinity"></a>6. <strong>MatchInterPodAffinity</strong></h4><ul><li><strong>含义</strong>：检查 Pod 是否匹配其他 Pod 的亲和性（Affinity）或反亲和性（Anti-Affinity）规则。</li><li><strong>场景</strong>：用于实现将相关的 Pod 放置在相同或不同节点上的需求。</li></ul><h4 id="7-NoDiskConflict"><a href="#7-NoDiskConflict" class="headerlink" title="7. NoDiskConflict"></a>7. <strong>NoDiskConflict</strong></h4><ul><li><strong>含义</strong>：验证目标节点上是否存在 Pod 的 Volume 冲突。</li><li><strong>支持的存储类型</strong>：仅限 GCE PD、AWS EBS、Ceph RBD、iSCSI 等。</li></ul><h4 id="8-PodToleratesNodeTaints"><a href="#8-PodToleratesNodeTaints" class="headerlink" title="8. PodToleratesNodeTaints"></a>8. <strong>PodToleratesNodeTaints</strong></h4><ul><li><strong>含义</strong>：检查 Pod 是否能容忍（Toleration）目标节点的污点（Taint）。</li><li><strong>场景</strong>：用于过滤那些不能容忍节点特殊属性（通过 Taints 表达）的 Pod。</li></ul><h4 id="9-CheckNodeMemoryPressure"><a href="#9-CheckNodeMemoryPressure" class="headerlink" title="9. CheckNodeMemoryPressure"></a>9. <strong>CheckNodeMemoryPressure</strong></h4><ul><li><strong>含义</strong>：验证目标节点是否处于内存压力（MemoryPressure）状态。</li><li><strong>场景</strong>：当节点内存使用接近或达到阈值，Pod 不应该调度到该节点。</li></ul><h4 id="10-CheckNodeDiskPressure"><a href="#10-CheckNodeDiskPressure" class="headerlink" title="10. CheckNodeDiskPressure"></a>10. <strong>CheckNodeDiskPressure</strong></h4><ul><li><strong>含义</strong>：验证目标节点是否处于磁盘压力（DiskPressure）状态。</li><li><strong>场景</strong>：当节点磁盘空间不足时，调度器会避免将新的 Pod 调度到该节点。</li></ul><h4 id="11-NoVolumeNodeConflict"><a href="#11-NoVolumeNodeConflict" class="headerlink" title="11. NoVolumeNodeConflict"></a>11. <strong>NoVolumeNodeConflict</strong></h4><ul><li><strong>含义</strong>：验证目标节点是否满足 Pod 所需 Volume 的条件，例如是否存在挂载冲突。</li><li><strong>场景</strong>：在某些存储驱动中，一个 Volume 可能只能挂载到一个节点上，因此需要检查是否有冲突。</li></ul><h3 id="四、候选节点评分（Priority-Scoring-Phase）："><a href="#四、候选节点评分（Priority-Scoring-Phase）：" class="headerlink" title="四、候选节点评分（Priority&#x2F;Scoring Phase）："></a><strong>四、候选节点评分（Priority&#x2F;Scoring Phase）</strong>：</h3><ul><li>对于通过过滤的候选节点，调度器会根据一系列优先级规则（称为 “Priorities”，现在叫 Scoring Plugins）为每个节点打分。</li><li>评分的目标是从所有可用节点中选择一个最优节点。例如：<ul><li>尽量将 Pod 调度到负载较低的节点。</li><li>尽量将 Pod 调度到与其数据存储位置较近的节点。</li><li>避免过多 Pod 调度到同一个节点，导致资源热点。</li></ul></li></ul><p>在 Kubernetes 中，<code>kube-scheduler</code> 是负责将 Pod 调度到合适的 Node 上的组件。调度过程分为两步：<strong>过滤（Filter）</strong> 和 <strong>打分（Score）</strong>。其中，<code>Priorities</code> 策略是调度器在打分阶段使用的规则，用于评估每个 Node 的优先级，通过分配得分来选择最优的候选节点。</p><p>下面详细介绍常见的 <code>Priorities</code> 策略：</p><hr><h4 id="1-SelectorSpreadPriority"><a href="#1-SelectorSpreadPriority" class="headerlink" title="1. SelectorSpreadPriority"></a><strong>1. SelectorSpreadPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先将 Pod 分布到不同的 Node 上，减少某个 Node 上同一个 Service 或 Replication Controller 的 Pod 数量。</li></ul></li><li><strong>目的：</strong><ul><li>达到负载均衡，避免将同一类型的 Pod 全部调度到一个 Node 上。</li></ul></li><li><strong>典型场景：</strong><ul><li>应用高可用性，提高服务容错能力（例如分布式系统）。</li></ul></li></ul><hr><h4 id="2-InterPodAffinityPriority"><a href="#2-InterPodAffinityPriority" class="headerlink" title="2. InterPodAffinityPriority"></a><strong>2. InterPodAffinityPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先将 Pod 调度到具有相同拓扑（如同一个节点、Rack、Zone 等）的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>符合 Pod 的亲和性要求，例如让 Pod 与相同组件的其他 Pod 部署在同一个区域中。</li></ul></li><li><strong>典型场景：</strong><ul><li>有数据本地性需求的应用或需要紧密协同的组件。</li></ul></li></ul><hr><h4 id="3-LeastRequestedPriority"><a href="#3-LeastRequestedPriority" class="headerlink" title="3. LeastRequestedPriority"></a><strong>3. LeastRequestedPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到资源请求最少的 Node 上。</li></ul></li><li><strong>目的：</strong><ul><li>避免资源紧张，提高资源利用率。</li></ul></li><li><strong>典型场景：</strong><ul><li>集群中存在部分节点资源接近饱和时，优先调度到空闲较多的节点。</li></ul></li></ul><hr><h4 id="4-BalancedResourceAllocation"><a href="#4-BalancedResourceAllocation" class="headerlink" title="4. BalancedResourceAllocation"></a><strong>4. BalancedResourceAllocation</strong></h4><ul><li><strong>作用：</strong><ul><li>优先选择 CPU 和内存使用率相对均衡的节点。</li></ul></li><li><strong>目的：</strong><ul><li>避免单一维度资源（如 CPU 或内存）成为瓶颈，优化集群资源利用。</li></ul></li><li><strong>典型场景：</strong><ul><li>资源分布不均的集群环境下，适合有高资源利用需求的场景。</li></ul></li></ul><hr><h4 id="5-NodePreferAvoidPodsPriority"><a href="#5-NodePreferAvoidPodsPriority" class="headerlink" title="5. NodePreferAvoidPodsPriority"></a><strong>5. NodePreferAvoidPodsPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先避开有 <code>preferAvoidPods</code> 字段标记的节点。</li></ul></li><li><strong>目的：</strong><ul><li>避免对某些节点施加额外负载。</li></ul></li><li><strong>典型场景：</strong><ul><li>某些节点需要保留资源或需要减少干扰。</li></ul></li></ul><hr><h4 id="6-NodeAffinityPriority"><a href="#6-NodeAffinityPriority" class="headerlink" title="6. NodeAffinityPriority"></a><strong>6. NodeAffinityPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到匹配 NodeAffinity 的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>符合节点亲和性规则，满足用户的调度要求。</li></ul></li><li><strong>典型场景：</strong><ul><li>应用对特定的硬件、标签等有明确需求。</li></ul></li></ul><hr><h4 id="7-TaintTolerationPriority"><a href="#7-TaintTolerationPriority" class="headerlink" title="7. TaintTolerationPriority"></a><strong>7. TaintTolerationPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到能容忍特定 Taint 的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>解决 Taint 和 Toleration 机制下的调度问题。</li></ul></li><li><strong>典型场景：</strong><ul><li>使用节点隔离机制时。</li></ul></li></ul><hr><h4 id="8-ServiceSpreadingPriority（已被替代）"><a href="#8-ServiceSpreadingPriority（已被替代）" class="headerlink" title="8. ServiceSpreadingPriority（已被替代）"></a><strong>8. ServiceSpreadingPriority</strong>（已被替代）</h4><ul><li><strong>作用：</strong><ul><li>将同一个 Service 的 Pod 分布到不同的 Node 上。</li></ul></li><li><strong>替代：</strong><ul><li>该策略已被 <code>SelectorSpreadPriority</code> 替代。</li></ul></li></ul><hr><h4 id="9-EqualPriority"><a href="#9-EqualPriority" class="headerlink" title="9. EqualPriority"></a><strong>9. EqualPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>为所有节点分配相同的优先级，优先级值为 1。</li></ul></li><li><strong>目的：</strong><ul><li>用于测试或没有特殊调度需求的场景。</li></ul></li></ul><hr><h4 id="10-ImageLocalityPriority"><a href="#10-ImageLocalityPriority" class="headerlink" title="10. ImageLocalityPriority"></a><strong>10. ImageLocalityPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到已经缓存了容器镜像的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>减少镜像拉取时间，提高调度效率。</li></ul></li><li><strong>典型场景：</strong><ul><li>集群节点镜像拉取速度较慢时。</li></ul></li></ul><hr><h4 id="11-MostRequestedPriority"><a href="#11-MostRequestedPriority" class="headerlink" title="11. MostRequestedPriority"></a><strong>11. MostRequestedPriority</strong></h4><ul><li><strong>作用：</strong><ul><li>优先调度到已经使用过资源的节点上。</li></ul></li><li><strong>目的：</strong><ul><li>尤其适用于 <code>cluster-autoscaler</code>，提高已有节点的资源利用率。</li></ul></li><li><strong>典型场景：</strong><ul><li>自动扩容场景，避免浪费新的节点资源。</li></ul></li></ul><p><code>kube-scheduler</code> 的 Priorities 实现位于 <code>pkg/scheduler/framework/plugins</code> 中。例如，<code>BalancedResourceAllocation</code> 的代码实现可以参考该插件下的具体实现方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BalancedAllocation)</span></span> Score(ctx context.Context, state *framework.CycleState, pod *v1.Pod, nodeName <span class="hljs-type">string</span>) (<span class="hljs-type">int64</span>, *framework.Status) &#123;<br>    nodeInfo, err := b.nodeInfoLister.Get(nodeName)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, framework.NewStatus(framework.Error, err.Error())<br>    &#125;<br>    <span class="hljs-keyword">return</span> b.score(pod, nodeInfo.Node())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *BalancedAllocation)</span></span> score(pod *v1.Pod, node *v1.Node) <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-comment">// 计算 CPU 和内存的使用率</span><br>    cpuFraction := node.UsedCPU() / node.TotalCPU()<br>    memoryFraction := node.UsedMemory() / node.TotalMemory()<br>    <span class="hljs-comment">// 计算得分</span><br>    score := <span class="hljs-number">100</span> - <span class="hljs-type">int64</span>(math.Abs(cpuFraction-memoryFraction)*<span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">return</span> score<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、决策和绑定（Bind-Phase）："><a href="#五、决策和绑定（Bind-Phase）：" class="headerlink" title="五、决策和绑定（Bind Phase）："></a><strong>五、决策和绑定（Bind Phase）</strong>：</h3><ul><li>从评分最高的节点中挑选一个节点，作为该 Pod 的最终调度目标。</li><li>调度器将调度结果写入到 <code>etcd</code> 中，将 Pod 绑定到目标节点。</li></ul><p>整体来说，调度过程可以概括为：<strong>过滤（Filter） -&gt; 评分（Score） -&gt; 绑定（Bind）</strong>。</p><p>在 Kubernetes（K8S）中，不同的 <code>QoS（Quality of Service）</code> 类表示 Pod 的服务质量保障级别，这对调度、资源管理和优先级管理起到重要作用。Kubernetes 基于 Pod 的资源请求和限制自动确定它的 QoS 类，因此理解 QoS 类以及它们如何影响调度至关重要。本文将系统介绍 QoS 类的划分及其调度行为。</p><hr><h2 id="K8S-的-QoS-类分类"><a href="#K8S-的-QoS-类分类" class="headerlink" title="K8S 的 QoS 类分类"></a>K8S 的 QoS 类分类</h2><p>Kubernetes 定义了三种 QoS 类，分别是：</p><h4 id="1-Guaranteed"><a href="#1-Guaranteed" class="headerlink" title="1. Guaranteed"></a>1. <strong>Guaranteed</strong></h4><ul><li><p>一个 Pod <strong>所有容器</strong>的 <code>requests</code> 和 <code>limits</code> 必须完全相等。</p></li><li><p>特性：这类 Pod 通常被视为最高优先级资源请求，因此在资源争夺时被保留。</p></li><li><p>场景：适用于需要强资源保证的关键性应用。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">guaranteed-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Burstable"><a href="#2-Burstable" class="headerlink" title="2. Burstable"></a>2. <strong>Burstable</strong></h4><ul><li><p>如果 Pod 至少有一个容器的 <code>requests</code> 设置了，但 <code>requests</code> 和 <code>limits</code> 不完全相等，则 Pod 被归为 <code>Burstable</code>。</p></li><li><p>特性：该类 Pod 会优先获取至少等于 <code>requests</code> 的资源，其余资源可在容量溢出时被收回。</p></li><li><p>场景：适合对资源核心需求较低，但能够在负载高峰期动态扩展的场景。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">burstable-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.2&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-BestEffort"><a href="#3-BestEffort" class="headerlink" title="3. BestEffort"></a>3. <strong>BestEffort</strong></h4><ul><li><p>如果 Pod <strong>所有容器</strong>都没有配置 <code>requests</code> 或 <code>limits</code>，则它属于 <code>BestEffort</code>。</p></li><li><p>特性：属于最低优先级 Pod，仅在其他资源有剩余时可分配资源。</p></li><li><p>场景：适用于非核心、无资源保障需求的后备工作负载。</p></li><li><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">besteffort-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="QoS-Class-在调度中的运作机制"><a href="#QoS-Class-在调度中的运作机制" class="headerlink" title="QoS Class 在调度中的运作机制"></a>QoS Class 在调度中的运作机制</h3><p>Kubernetes 的调度器主要通过以下几个相关逻辑处理 QoS 类：</p><h4 id="1-资源分配优先级"><a href="#1-资源分配优先级" class="headerlink" title="1. 资源分配优先级"></a>1. <strong>资源分配优先级</strong></h4><ul><li><code>Guaranteed &gt; Burstable &gt; BestEffort</code></li><li>Kubernetes Scheduler 在评估节点资源是否充足时，对于 Guaranteed 的 Pod 会尝试确保其分配请求的资源总量和上限。</li><li>Burstable 会优先与 Requests 值匹配，但 Limits 超出部分可能因抢占而被剥夺。</li><li>BestEffort Pod 通常在资源充足时才被调度，但在资源紧张时可能完全无法运行。</li></ul><h4 id="2-Node-Eviction（节点逐出机制）"><a href="#2-Node-Eviction（节点逐出机制）" class="headerlink" title="2. Node Eviction（节点逐出机制）"></a>2. <strong>Node Eviction（节点逐出机制）</strong></h4><p>   当节点资源耗尽或压力过高（例如内存压力<code>MemoryPressure</code>），Kubernetes 使用 QoS 类来决定驱逐的优先级：</p><ul><li><strong>BestEffort</strong>：首当其冲被驱逐，适合非关键性负载。</li><li><strong>Burstable</strong>：在满足请求的基础上，超出的部分会被挤占或驱逐。</li><li><strong>Guaranteed</strong>：保证级别最高，最后才会被驱逐。</li></ul><h4 id="3-调度优先级"><a href="#3-调度优先级" class="headerlink" title="3. 调度优先级"></a>3. <strong>调度优先级</strong></h4><ul><li>调度器会根据节点的资源可用性优先分配高 QoS 的 Pod。</li><li>考虑结合 <code>Taints</code> 和 <code>Tolerations</code>、资源亲和性等规则提高具体调度的确定性。</li></ul><h4 id="举例：调度阶段中的-QoS-Decision"><a href="#举例：调度阶段中的-QoS-Decision" class="headerlink" title="举例：调度阶段中的 QoS Decision"></a>举例：调度阶段中的 QoS Decision</h4><p>当新的 Pod 到来时，Kubernetes Scheduler 会依次检查以下项：</p><ul><li>是否满足 Pod 的 <code>requests</code>（按 QoS 优先顺序检查）；</li><li>节点剩余容量能否满足 Pod 的 <code>limits</code>；</li><li>Resource Fit Filter（调度器中的 Fit 规则）根据 QoS 级别动态评估节点状态和适合性。</li></ul><hr><h3 id="调度-QoS-类的实际操作与优化"><a href="#调度-QoS-类的实际操作与优化" class="headerlink" title="调度 QoS 类的实际操作与优化"></a>调度 QoS 类的实际操作与优化</h3><p>为了更好地调度不同 QoS 的 Pod，我们可以采取以下策略：</p><h4 id="1-调整资源分配规则"><a href="#1-调整资源分配规则" class="headerlink" title="1. 调整资源分配规则"></a>1. <strong>调整资源分配规则</strong></h4><p>   为关键性的应用分配 QoS <code>Guaranteed</code>，明确资源上下界，保证资源独占或排他性。</p><h4 id="2-Taints-和-Tolerations"><a href="#2-Taints-和-Tolerations" class="headerlink" title="2. Taints 和 Tolerations"></a>2. <strong>Taints 和 Tolerations</strong></h4><p>   配合使用 Taints 和 Tolerations，将高 QoS 的应用调度到专用节点。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">taints:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">critical</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br></code></pre></td></tr></table></figure><h4 id="3-预留关键性资源节点"><a href="#3-预留关键性资源节点" class="headerlink" title="3. 预留关键性资源节点"></a>3. <strong>预留关键性资源节点</strong></h4><p>   Kubernetes 支持通过 <code>kube-reserved</code>、<code>system-reserved</code> 等方式预留关键性资源，保证平台本身稳定运行。</p><h4 id="4-配额管理"><a href="#4-配额管理" class="headerlink" title="4. 配额管理"></a>4. <strong>配额管理</strong></h4><p>   使用 ResourceQuotas 限制低 QoS 的资源消耗，如限制 <code>BestEffort</code> Pod 数量，确保资源可为高 QoS 的 Pod 使用。</p><h2 id="API-对象：requests-limits"><a href="#API-对象：requests-limits" class="headerlink" title="API 对象：requests limits"></a>API 对象：requests limits</h2><p>在 Kubernetes 中，<code>requests</code> 和 <code>limits</code> 是 Pod 或容器级别的资源管理功能，用于定义对 CPU 和内存等资源的需求和限制。这两个参数是 Kubernetes 调度器和 Kubelet 的关键配置，它们分别用于调度和运行时资源管理。</p><hr><h3 id="1-什么是-requests-和-limits"><a href="#1-什么是-requests-和-limits" class="headerlink" title="1. 什么是 requests 和 limits"></a>1. 什么是 <code>requests</code> 和 <code>limits</code></h3><h4 id="1-1-requests"><a href="#1-1-requests" class="headerlink" title="1.1 requests"></a>1.1 <code>requests</code></h4><ul><li><strong>定义</strong>: 容器运行时的<strong>最低资源需求</strong>。Kubernetes 调度器在调度 Pod 时会使用 <code>requests</code> 的值来决定是否有足够的资源可用。</li><li><strong>作用</strong>: <ul><li>决定 Pod 是否能被调度到某个 Node。</li><li>一旦 Pod 被调度到某个 Node，Node 上必须预留至少 <code>requests</code> 定义的资源量。</li></ul></li></ul><h4 id="1-2-limits"><a href="#1-2-limits" class="headerlink" title="1.2 limits"></a>1.2 <code>limits</code></h4><ul><li><strong>定义</strong>: 容器运行时的<strong>资源上限</strong>。Kubelet 和容器运行时会根据 <code>limits</code> 限制容器使用的资源量，超过此限制可能会被杀死或降速。</li><li><strong>作用</strong>:<ul><li>防止容器使用的资源超出指定的上限，从而保护其他容器的稳定性。</li></ul></li></ul><h4 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h4><p>以一个简单的 Pod 配置为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>requests.memory: 64Mi</code>: 容器至少需要 64Mi 内存才能正常运行。</li><li><code>limits.memory: 128Mi</code>: 容器最多只能使用 128Mi 内存，超过时可能会被 OOM（Out of Memory）杀死。</li><li><code>requests.cpu: 250m</code>: 容器需要 250 毫核的 CPU，调度器会确保目标节点能够提供这部分资源。</li><li><code>limits.cpu: 500m</code>: 容器最多只能使用 500 毫核的 CPU。</li></ul><hr><h3 id="2-Kubernetes-调度器如何使用-requests"><a href="#2-Kubernetes-调度器如何使用-requests" class="headerlink" title="2. Kubernetes 调度器如何使用 requests"></a>2. Kubernetes 调度器如何使用 <code>requests</code></h3><p>调度器是 Kubernetes 的核心组件之一，负责将待调度的 Pod 分配到合适的节点上。调度器通过以下步骤使用 <code>requests</code> 值来进行资源调度：</p><h4 id="2-1-节点资源过滤"><a href="#2-1-节点资源过滤" class="headerlink" title="2.1 节点资源过滤"></a>2.1 节点资源过滤</h4><p>调度器首先会根据 Pod 的 <code>requests</code> 值过滤掉不满足资源需求的节点：</p><ul><li>对比节点的 <strong>可用资源</strong> 和 Pod 的 <code>requests</code>。</li><li>如果节点的可用资源小于 Pod 的 <code>requests</code>，则该节点会被过滤掉。</li></ul><p><strong>节点可用资源计算公式</strong>:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">节点可用资源 = 节点总资源 - <span class="hljs-function"><span class="hljs-title">sum</span>(所有已分配 <span class="hljs-variable">Pod</span> 的 <span class="hljs-variable">requests</span>)</span><br></code></pre></td></tr></table></figure><p>示例：</p><ul><li>假设一个节点有 4 核 CPU 和 8 Gi 内存。</li><li>已经运行了 2 个 Pod，分别请求了以下资源：<ul><li>Pod1: <code>requests.cpu=1</code> 和 <code>requests.memory=2Gi</code></li><li>Pod2: <code>requests.cpu=1</code> 和 <code>requests.memory=2Gi</code></li></ul></li><li>节点剩余资源：<ul><li>剩余 CPU: <code>4 - (1 + 1) = 2</code></li><li>剩余内存：<code>8Gi - (2Gi + 2Gi) = 4Gi</code></li></ul></li><li>如果新创建一个 Pod 需要 <code>requests.cpu=3</code>，调度器会过滤掉这个节点，因为剩余 CPU 不足。</li></ul><h4 id="2-2-优化节点选择"><a href="#2-2-优化节点选择" class="headerlink" title="2.2 优化节点选择"></a>2.2 优化节点选择</h4><p>在过滤掉不满足 <code>requests</code> 的节点后，调度器会根据调度策略（例如：<strong>最少资源利用策略</strong> 或 <strong>均衡策略</strong>）选择最佳节点。例如：</p><ul><li>找出当前负载最小的节点。</li><li>确保资源分配均匀，避免资源热点。</li></ul><hr><h3 id="3-Kubelet-和容器运行时如何使用-limits"><a href="#3-Kubelet-和容器运行时如何使用-limits" class="headerlink" title="3. Kubelet 和容器运行时如何使用 limits"></a>3. Kubelet 和容器运行时如何使用 <code>limits</code></h3><p>在 Pod 被调度到节点上之后，Kubelet 和容器运行时会使用 <code>limits</code> 来限制容器运行时的资源使用：</p><h4 id="3-1-CPU-限制"><a href="#3-1-CPU-限制" class="headerlink" title="3.1 CPU 限制"></a>3.1 CPU 限制</h4><ul><li><code>limits.cpu</code> 通过 Cgroup 的 <strong>CPU Shares</strong> 和 <strong>CPU Quota</strong> 实现：<ul><li><strong>CPU Shares</strong>: 控制 CPU 调度的优先级。例如，<code>requests.cpu=500m</code> 会分配较低优先级，但如果节点空闲，容器可以使用更多 CPU。</li><li><strong>CPU Quota</strong>: 硬性限制 CPU 使用总量。例如，<code>limits.cpu=500m</code> 意味着容器最多只能使用 50% 的 CPU 核心时间。</li></ul></li></ul><p>相关 cgroup 配置路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/cpu/kubepods/&lt;pod_id&gt;/&lt;container_id&gt;/cpu.shares<br>/sys/fs/cgroup/cpu/kubepods/&lt;pod_id&gt;/&lt;container_id&gt;/cpu.cfs_quota_us<br></code></pre></td></tr></table></figure><h4 id="3-2-内存限制"><a href="#3-2-内存限制" class="headerlink" title="3.2 内存限制"></a>3.2 内存限制</h4><ul><li><code>limits.memory</code> 是一个硬限制，通过 Cgroup 的 <strong>memory limit</strong> 配置。</li><li>如果容器超出 <code>limits.memory</code> 的值，会触发 OOM（Out of Memory）杀死容器。</li></ul><p>相关 cgroup 配置路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/memory/kubepods/&lt;pod_id&gt;/&lt;container_id&gt;/memory.limit_in_bytes<br></code></pre></td></tr></table></figure><hr><h3 id="4-使用-requests-和-limits-的最佳实践"><a href="#4-使用-requests-和-limits-的最佳实践" class="headerlink" title="4. 使用 requests 和 limits 的最佳实践"></a>4. 使用 <code>requests</code> 和 <code>limits</code> 的最佳实践</h3><ul><li><p><strong>合理分配 <code>requests</code> 和 <code>limits</code></strong>:</p><ul><li><code>requests</code> 应根据容器的最低需求来设置，避免调度失败。</li><li><code>limits</code> 应根据容器的最大允许使用量来设置，避免资源抢占。</li></ul></li><li><p><strong>避免 <code>requests</code> 和 <code>limits</code> 间差距过大</strong>:</p><ul><li>如果 <code>limits</code> 远大于 <code>requests</code>，容易导致节点资源超分配，运行时引发不稳定。</li><li>如果 <code>requests</code> 远大于实际需求，可能导致资源浪费，降低集群整体利用率。</li></ul></li><li><p><strong>结合资源配额（Resource Quotas）和限制（Limit Ranges）</strong>:</p><ul><li>使用 Resource Quotas 在命名空间层面限制资源总量。</li><li>使用 Limit Ranges 强制为 Pod 配置合理的 <code>requests</code> 和 <code>limits</code>。</li></ul></li></ul><hr><h2 id="将-Pod-调度到指定的-Node-上"><a href="#将-Pod-调度到指定的-Node-上" class="headerlink" title="将 Pod 调度到指定的 Node 上"></a>将 Pod 调度到指定的 Node 上</h2><p><code>NodeSelector</code> 是 Kubernetes 中用来将 Pod 调度到特定的 Node 上的一种机制。它本质上是一种调度约束，让你可以通过为 Pod 定义一个条件来指定只允许它运行在满足该条件的节点上。</p><p>在 Kubernetes 中，Node 通常会有一组标签（labels），比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br>    <span class="hljs-attr">region:</span> <span class="hljs-string">us-west</span><br></code></pre></td></tr></table></figure><p>而 <code>NodeSelector</code> 是 Pod 的 <code>spec</code> 部分中的一个字段，允许你通过指定这些标签来选择目标节点。</p><hr><h3 id="NodeSelector-的工作原理"><a href="#NodeSelector-的工作原理" class="headerlink" title="NodeSelector 的工作原理"></a><code>NodeSelector</code> 的工作原理</h3><p><code>NodeSelector</code> 的核心是通过键值对匹配来选择 Node。Kubernetes 的调度器会检查集群中所有可用的节点，只有满足 <code>NodeSelector</code> 条件的节点才会被作为候选节点来运行该 Pod。</p><hr><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="1-定义节点标签"><a href="#1-定义节点标签" class="headerlink" title="1. 定义节点标签"></a>1. 定义节点标签</h4><p>给一个节点打上标签。假设我们有一个节点名为 <code>node1</code>，我们通过以下命令给它加上一个标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl label nodes node1 disktype=ssd<br></code></pre></td></tr></table></figure><h4 id="2-配置-Pod-的-NodeSelector"><a href="#2-配置-Pod-的-NodeSelector" class="headerlink" title="2. 配置 Pod 的 NodeSelector"></a>2. 配置 Pod 的 <code>NodeSelector</code></h4><p>定义一个 Pod，并使用 <code>nodeSelector</code> 来选择节点：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">nodeSelector:</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>nodeSelector</code> 指定了 <code>disktype: ssd</code>，所以 Kubernetes 只会尝试将该 Pod 调度到具有标签 <code>disktype=ssd</code> 的节点上。</p><hr><h3 id="多个条件的-NodeSelector"><a href="#多个条件的-NodeSelector" class="headerlink" title="多个条件的 NodeSelector"></a>多个条件的 <code>NodeSelector</code></h3><p><code>NodeSelector</code> 可以指定多个键值对条件，所有条件必须同时满足。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nodeSelector:</span><br>  <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br>  <span class="hljs-attr">region:</span> <span class="hljs-string">us-west</span><br></code></pre></td></tr></table></figure><p>这种情况下，目标节点必须同时满足以下条件：</p><ul><li>标签 <code>disktype=ssd</code></li><li>标签 <code>region=us-west</code></li></ul><p><strong>注意：</strong> <code>NodeSelector</code> 的匹配条件是 AND 逻辑，所有条件都必须满足，不能用 OR 逻辑。</p><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>性能优化：</strong> 你可以将特定的工作负载调度到具有高性能硬件的节点上，比如 SSD 存储或高 CPU 内核的节点。</li><li><strong>地理分布：</strong> 通过标签标识区域（region）和可用区（zone），你可以将工作负载调度到离用户更近的节点上。</li><li><strong>隔离性：</strong> 可以使用一些特殊标签将敏感的工作负载调度到专门的隔离节点上。</li></ol><hr><h3 id="为什么只用-NodeSelector-是不够的？"><a href="#为什么只用-NodeSelector-是不够的？" class="headerlink" title="为什么只用 NodeSelector 是不够的？"></a>为什么只用 <code>NodeSelector</code> 是不够的？</h3><p><code>NodeSelector</code> 是 Kubernetes 中最简单的调度约束工具，但它有以下局限性：</p><ol><li><p><strong>无法表达复杂条件：</strong> <code>NodeSelector</code> 只支持简单的键值对，并且只能用 AND 逻辑，无法表达更复杂的调度规则（例如 OR 或 NOT）。</p></li><li><p><strong>不够灵活：</strong> 如果节点标签被更改，Pod 不会自动重新调度到符合新条件的节点。</p></li><li><p>替代方案：</p><p>更强大的调度工具包括：</p><ul><li><strong>Node Affinity</strong>：支持更复杂的调度规则，并允许使用 OR&#x2F;NOT 等逻辑。</li><li><strong>Taints and Tolerations</strong>：允许特定 Pod 避免或容忍某些节点的特殊污点条件。</li><li><strong>Custom Schedulers</strong>：你可以实现自己的调度器来处理更复杂的需求。</li></ul></li></ol><p>在 Kubernetes 中，<code>NodeAffinity</code> (节点亲和性) 是一种调度约束，用于决定某些 Pod 应该运行在哪些节点上。它是 Pod 调度器的重要配置之一，可以帮助用户控制 Pod 在集群中的分布。通过 <code>NodeAffinity</code>，用户可以定义 Pod 如何选择合适的节点。它是 Kubernetes 中 “亲和性和反亲和性” 特性的一部分。</p><p>下面我们详细讲解一下 <code>NodeAffinity</code> 的概念、工作原理和使用方法：</p><hr><h2 id="NodeAffinity"><a href="#NodeAffinity" class="headerlink" title="NodeAffinity"></a>NodeAffinity</h2><h3 id="1-什么是-NodeAffinity？"><a href="#1-什么是-NodeAffinity？" class="headerlink" title="1. 什么是 NodeAffinity？"></a>1. 什么是 <code>NodeAffinity</code>？</h3><p><code>NodeAffinity</code> 是一个与节点标签匹配的调度策略。它允许你基于节点的标签设置调度规则，从而指定：</p><ul><li><strong>Pod 更倾向于调度到哪些节点上（软约束）</strong>。</li><li><strong>Pod 必须调度到哪些节点上（硬约束）</strong>。</li></ul><p><code>NodeAffinity</code> 是 Pod 的属性，定义在 Pod 的 Spec 中。调度器会根据 <code>NodeAffinity</code> 的规则，在集群中选择合适的节点来运行 Pod。</p><hr><h3 id="2-NodeAffinity-的分类"><a href="#2-NodeAffinity-的分类" class="headerlink" title="2. NodeAffinity 的分类"></a>2. <code>NodeAffinity</code> 的分类</h3><p><code>NodeAffinity</code> 有两种主要类型：</p><ol><li><p><strong>硬约束</strong> (<code>requiredDuringSchedulingIgnoredDuringExecution</code>)</p><ul><li>Pod 必须调度到符合条件的节点上。</li><li>如果没有符合条件的节点，Pod 会一直待在 Pending 状态，直到有满足条件的节点出现。</li><li>等价于硬性规则。</li></ul></li><li><p><strong>软约束</strong> (<code>preferredDuringSchedulingIgnoredDuringExecution</code>)</p><ul><li>Pod 优先调度到符合条件的节点，但如果没有符合条件的节点，也可以调度到其他节点。</li><li>等价于建议性规则。</li></ul></li></ol><h4 id="键名解释："><a href="#键名解释：" class="headerlink" title="键名解释："></a>键名解释：</h4><ul><li><strong><code>DuringScheduling</code></strong>：调度时检查规则是否满足。</li><li><strong><code>IgnoredDuringExecution</code></strong>：调度完成后，不再检查规则是否持续满足。</li></ul><hr><h3 id="3-NodeAffinity-的语法"><a href="#3-NodeAffinity-的语法" class="headerlink" title="3. NodeAffinity 的语法"></a>3. <code>NodeAffinity</code> 的语法</h3><p><code>NodeAffinity</code> 的定义在 Pod Spec 的 <code>affinity.nodeAffinity</code> 字段下，采用 <code>MatchExpressions</code> 或 <code>MatchFields</code> 的形式。以下是一个典型的 YAML 配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">node-affinity-example</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">demo-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">nodeAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬约束</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node2</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软约束</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">disktype</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><ol><li><p><strong>硬约束：<code>requiredDuringSchedulingIgnoredDuringExecution</code></strong></p><ul><li>定义了 Pod 只允许调度到 <code>kubernetes.io/hostname</code> 为 <code>node1</code> 或 <code>node2</code> 的节点。</li><li>如果没有满足条件的节点，Pod 不会调度。</li></ul></li><li><p><strong>软约束：<code>preferredDuringSchedulingIgnoredDuringExecution</code></strong></p><ul><li>定义了 Pod 优先调度到 <code>disktype</code> 为 <code>ssd</code> 的节点。</li><li>如果没有满足条件的节点，Pod 仍然可以调度到其他节点。</li></ul></li></ol><hr><h3 id="4-NodeAffinity-的高级配置"><a href="#4-NodeAffinity-的高级配置" class="headerlink" title="4. NodeAffinity 的高级配置"></a>4. <code>NodeAffinity</code> 的高级配置</h3><h4 id="4-1-matchExpressions-的语法"><a href="#4-1-matchExpressions-的语法" class="headerlink" title="4.1 matchExpressions 的语法"></a>4.1 <code>matchExpressions</code> 的语法</h4><p><code>matchExpressions</code> 是常见的表达式，用来定义约束规则。它支持以下操作符：</p><ul><li><strong><code>In</code></strong>：匹配标签的值在指定的值列表中。</li><li><strong><code>NotIn</code></strong>：匹配标签的值不在指定的值列表中。</li><li><strong><code>Exists</code></strong>：匹配节点是否具有某个标签（不用指定值）。</li><li><strong><code>DoesNotExist</code></strong>：匹配节点是否没有某个标签。</li><li><strong><code>Gt</code></strong>：匹配标签的值大于指定值。</li><li><strong><code>Lt</code></strong>：匹配标签的值小于指定值。</li></ul><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">matchExpressions:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">environment</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>  <span class="hljs-attr">values:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">production</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">staging</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">disktype</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br></code></pre></td></tr></table></figure><h4 id="4-2-多标签规则"><a href="#4-2-多标签规则" class="headerlink" title="4.2 多标签规则"></a>4.2 多标签规则</h4><p><code>NodeAffinity</code> 支持多标签条件的组合。一个 <code>nodeSelectorTerms</code> 的条件是 <strong>“或”</strong> 的关系（满足任意一个条件即可）。而 <code>matchExpressions</code> 中的多个表达式是 <strong>“且”</strong> 的关系（需要同时满足）。</p><hr><h2 id="PodAffinity"><a href="#PodAffinity" class="headerlink" title="PodAffinity"></a>PodAffinity</h2><p>在 Kubernetes 中，<code>PodAffinity</code> 是调度器中一种高级的调度约束，用于控制 Pod 在集群中的调度位置。它允许用户定义一个 Pod 应该尽量调度在哪些节点上，基于与其他 Pod 的亲和性规则。通过 <code>PodAffinity</code>，用户可以确保某些服务之间的 Pod 被调度到更接近的位置，优化性能、减少网络延迟或者提高数据访问效率。</p><p>Kubernetes 为 <code>PodAffinity</code> 提供了以下两个类型的亲和性：</p><ul><li><strong>Pod Affinity (亲和性)</strong>：指示 Pod 应该调度到与特定 Pod 接近的节点。</li><li><strong>Pod Anti-Affinity (反亲和性)</strong>：指示 Pod 应该调度到远离特定 Pod 的节点。</li></ul><h3 id="PodAffinity-的应用场景"><a href="#PodAffinity-的应用场景" class="headerlink" title="PodAffinity 的应用场景"></a>PodAffinity 的应用场景</h3><p>通过 <code>PodAffinity</code>，可以实现以下常见需求：</p><ol><li>加强服务间的局部性。例如，某些微服务需要与缓存服务位于同一个节点或同一个拓扑域（区域、可用区）以提高性能。</li><li>数据密集型应用需要靠近数据所在的节点。</li><li>降低集群内的网络延迟。</li><li>节约跨节点流量的带宽开销。</li></ol><p>而通过 <code>PodAntiAffinity</code>，可以实现以下需求：</p><ol><li>增强高可用性，确保副本分散在不同的节点上，避免单点故障。</li><li>降低资源争用的可能性，避免同类型 Pod 集中在一个节点上。</li></ol><hr><h3 id="PodAffinity-的核心字段"><a href="#PodAffinity-的核心字段" class="headerlink" title="PodAffinity 的核心字段"></a><code>PodAffinity</code> 的核心字段</h3><p><code>PodAffinity</code> 是 Pod 的调度策略的一部分，它位于 Pod 的 <code>spec.affinity</code> 字段下。主要相关的字段如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">affinity:</span><br>  <span class="hljs-attr">podAffinity:</span><br>    <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬性亲和性规则</span><br>    <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软性亲和性规则</span><br></code></pre></td></tr></table></figure><p>类似的结构也适用于 <code>PodAntiAffinity</code>。</p><h4 id="1-requiredDuringSchedulingIgnoredDuringExecution"><a href="#1-requiredDuringSchedulingIgnoredDuringExecution" class="headerlink" title="1. requiredDuringSchedulingIgnoredDuringExecution"></a>1. <code>requiredDuringSchedulingIgnoredDuringExecution</code></h4><p>表示强制规则（硬性约束），如果规则无法被满足，Pod 将不会被调度到某个节点上。<br>这个字段适合用在要求非常严格的场景，比如某些关键服务之间的紧密绑定。</p><h4 id="2-preferredDuringSchedulingIgnoredDuringExecution"><a href="#2-preferredDuringSchedulingIgnoredDuringExecution" class="headerlink" title="2. preferredDuringSchedulingIgnoredDuringExecution"></a>2. <code>preferredDuringSchedulingIgnoredDuringExecution</code></h4><p>表示偏好规则（软性约束），如果规则能够满足，调度器会优先选择满足条件的节点；但如果无法满足，Pod 仍然可以被调度到其他节点上。<br>这个字段适合用在需要优化但不强制的场景。</p><hr><h3 id="PodAffinity-的使用示例"><a href="#PodAffinity-的使用示例" class="headerlink" title="PodAffinity 的使用示例"></a>PodAffinity 的使用示例</h3><h4 id="1-配置-Pod-Affinity（亲和性）"><a href="#1-配置-Pod-Affinity（亲和性）" class="headerlink" title="1. 配置 Pod Affinity（亲和性）"></a>1. 配置 Pod Affinity（亲和性）</h4><p>假如你希望一个应用的 Pod 调度到与指定标签 <code>app=webserver</code> 的 Pod 所在的节点上，可以使用以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchLabels:</span><br>            <span class="hljs-attr">app:</span> <span class="hljs-string">webserver</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p><strong>字段解释：</strong></p><ul><li><code>labelSelector</code>: 指定需要与哪些 Pod 匹配，这里是所有具备 <code>app=webserver</code> 标签的 Pod。</li><li><code>topologyKey</code>: 指定亲和性的拓扑域。在这个例子中，它是 <code>kubernetes.io/hostname</code>，表示 Pod 会被调度到与目标 Pod 位于相同主机的节点上。</li></ul><h4 id="2-配置-Pod-Anti-Affinity（反亲和性）"><a href="#2-配置-Pod-Anti-Affinity（反亲和性）" class="headerlink" title="2. 配置 Pod Anti-Affinity（反亲和性）"></a>2. 配置 Pod Anti-Affinity（反亲和性）</h4><p>如果你希望 Pod 避开与指定标签 <code>app=webserver</code> 的 Pod 所在的节点，可以使用如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">podAntiAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchLabels:</span><br>            <span class="hljs-attr">app:</span> <span class="hljs-string">webserver</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>这会确保 Pod 避开任何有 <code>app=webserver</code> 的节点。</p><hr><h3 id="结合-TopologyKey-的使用"><a href="#结合-TopologyKey-的使用" class="headerlink" title="结合 TopologyKey 的使用"></a>结合 TopologyKey 的使用</h3><p>Kubernetes 中的 <code>topologyKey</code> 是一个关键字段，它指定亲和性或反亲和性规则所应用的拓扑域。常见的值包括：</p><ol><li><code>kubernetes.io/hostname</code> - 节点级别的亲和性。</li><li><code>failure-domain.beta.kubernetes.io/zone</code> - 可用区级别的亲和性。</li><li><code>failure-domain.beta.kubernetes.io/region</code> - 区域级别的亲和性。</li></ol><p>假设你希望 Pod 调度到与目标 Pod 位于相同的可用区，而不是完全相同的节点，你可以将 <code>topologyKey</code> 设置为 <code>failure-domain.beta.kubernetes.io/zone</code>s</p><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><strong>性能开销：</strong></p><ul><li>使用复杂的亲和性规则可能会显著增加调度器的计算负担，因为调度器需要检查每个节点是否满足约束。</li><li>如果集群规模较大、规则复杂，可能会对调度器性能产生负面影响。</li></ul></li><li><p><strong>节点资源竞争：</strong></p><ul><li>当 PodAffinity 被强制使用为硬性约束时，可能导致 Pod 在资源不足时无法调度。</li></ul></li><li><p><strong>与节点亲和性（NodeAffinity）的对比：</strong></p><ul><li><code>NodeAffinity</code> 是基于节点标签的调度规则，而 <code>PodAffinity</code> 是基于 Pod 标签的调度规则。</li><li>两者可以结合使用，形成更灵活的调度策略。</li></ul></li></ol><p>在 Kubernetes 中，<code>Taints</code> 和 <code>Tolerations</code> 是用来控制 Pod 调度的机制。通过它们，集群管理员可以实现更细粒度的调度控制，确保工作负载被调度到最合适的节点上执行。</p><h2 id="Taints-和-Tolerations"><a href="#Taints-和-Tolerations" class="headerlink" title="Taints 和 Tolerations"></a>Taints 和 Tolerations</h2><h3 id="1-Taints-和-Tolerations-概念"><a href="#1-Taints-和-Tolerations-概念" class="headerlink" title="1. Taints 和 Tolerations 概念"></a>1. Taints 和 Tolerations 概念</h3><h4 id="Taints（污点）"><a href="#Taints（污点）" class="headerlink" title="Taints（污点）"></a>Taints（污点）</h4><p><code>Taints</code> 是对节点（Node）设置的一种标记，用来表示该节点存在某种“特殊性”，不能随便调度任意的 Pod。只有那些显式声明“能够容忍”这些污点的 Pod 才能调度到这些节点上。</p><p>每个 Taint 由以下三部分组成：</p><ul><li><strong>Key</strong>：一个字符串，表示污点的键。</li><li><strong>Value</strong>：一个字符串，表示污点的值。（可选）</li><li><strong>Effect</strong>：污点的影响，表示不满足某些条件的 Pod 会被如何处理。</li></ul><p><code>Effect</code> 的取值有以下三种：</p><ul><li><strong><code>NoSchedule</code>: 不允许 Pod 被调度到这个节点上。</strong></li><li><strong><code>PreferNoSchedule</code>: 尽量不要调度 Pod 到这个节点上，但不是强制的。</strong></li><li><strong><code>NoExecute</code>: 如果 Pod 已经运行在这个节点上，也会驱逐它，同时阻止新的 Pod 被调度到这个节点上。</strong></li></ul><p>创建一个 <code>Taint</code> 的语法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes &lt;node-name&gt; &lt;key&gt;=&lt;value&gt;:&lt;effect&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes node1 dedicated=special-workload:NoSchedule<br></code></pre></td></tr></table></figure><p>这表示节点 <code>node1</code> 上有一个污点 <code>dedicated=special-workload</code>，任何没有适当 <code>Toleration</code> 的 Pod 都不能调度到该节点。</p><h4 id="Tolerations（容忍）"><a href="#Tolerations（容忍）" class="headerlink" title="Tolerations（容忍）"></a>Tolerations（容忍）</h4><p><code>Tolerations</code> 是对 Pod 的配置，用于声明该 Pod 可以“容忍”哪些节点上的污点，从而允许自己被调度到这些节点上。</p><p>每个 Toleration 的结构如下：</p><ul><li><strong>Key</strong>: 和节点的 Taints 的 Key 对应。</li><li><strong>Operator</strong>: 表示如何匹配 Key，可能的值有 <code>Equal</code> 和 <code>Exists</code>。<ul><li><code>Equal</code>: Key 和 Value 必须完全相等。</li><li><code>Exists</code>: Key 必须存在，而不要求 Value。</li></ul></li><li><strong>Value</strong>: 和节点的 Taints 的 Value 对应。（可选）</li><li><strong>Effect</strong>: 与节点上的污点的 Effect 对应。</li><li><strong>TolerationSeconds</strong>: 仅对 <code>NoExecute</code> 生效。如果指定了该字段，表示 Pod 在被驱逐前可以容忍这个污点的时间。</li></ul><p>一个 Toleration 的 YAML 配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;dedicated&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;special-workload&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-Taints-和-Tolerations-的工作机制"><a href="#2-Taints-和-Tolerations-的工作机制" class="headerlink" title="2. Taints 和 Tolerations 的工作机制"></a>2. Taints 和 Tolerations 的工作机制</h3><ul><li>当一个节点上有污点（Taint）时，Kubernetes 调度器会检查所有待调度的 Pod，只有那些有匹配的 Toleration 的 Pod 才会被调度到该节点。</li><li>如果 Pod 没有匹配的 Toleration，则调度器会跳过这个节点，继续寻找其他合适的节点。</li></ul><p>需要注意的是：</p><ul><li><strong>Taints 是主动的</strong>：节点上有污点时，会对不满足条件的 Pod 施加限制。</li><li><strong>Tolerations 是被动的</strong>：Pod 上有 Toleration 时，表明它可以容忍某种污点，但它不会主动要求调度到有特定污点的节点上。</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><h4 id="3-1-在特定节点上添加-Taint"><a href="#3-1-在特定节点上添加-Taint" class="headerlink" title="3.1 在特定节点上添加 Taint"></a>3.1 在特定节点上添加 Taint</h4><p>假设我们希望将节点 <code>node1</code> 设为专用节点，用于跑某些特定工作负载（如后台任务）。我们可以给这个节点添加如下 Taint：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes node1 dedicated=background-tasks:NoSchedule<br></code></pre></td></tr></table></figure><h4 id="3-2-配置-Pod-的-Toleration"><a href="#3-2-配置-Pod-的-Toleration" class="headerlink" title="3.2 配置 Pod 的 Toleration"></a>3.2 配置 Pod 的 Toleration</h4><p>假设我们有一个 Pod 专门用于后台任务，我们希望它能够调度到 <code>node1</code> 上。可以在 Pod 的 YAML 文件中添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-background-task</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;dedicated&quot;</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;background-tasks&quot;</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;3600&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="3-3-添加-NoExecute-的场景"><a href="#3-3-添加-NoExecute-的场景" class="headerlink" title="3.3 添加 NoExecute 的场景"></a>3.3 添加 <code>NoExecute</code> 的场景</h4><p>假设我们希望标记一个节点为不可用（例如硬件维护时），并且希望正在运行的 Pod 能够在 60 秒内迁移到其他节点。可以这样设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes node1 maintenance=<span class="hljs-literal">true</span>:NoExecute<br></code></pre></td></tr></table></figure><p>然后，在 Pod 的 Toleration 中，我们可以指定容忍时间：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;maintenance&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>  <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>  <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>此时，Pod 会在 60 秒内迁移到其他节点。</p><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h3><h4 id="场景-1：专用节点调度"><a href="#场景-1：专用节点调度" class="headerlink" title="场景 1：专用节点调度"></a>场景 1：专用节点调度</h4><p>通过设置 <code>Taints</code> 和 <code>Tolerations</code>，可以实现节点专用于某些特殊工作负载（如 GPU 工作负载、日志收集等）。</p><h4 id="场景-2：节点维护"><a href="#场景-2：节点维护" class="headerlink" title="场景 2：节点维护"></a>场景 2：节点维护</h4><p>当节点需要下线维护时，可以添加 <code>NoExecute</code> 类型的 Taint，将该节点上的所有 Pod 驱逐，同时阻止新 Pod 调度到该节点。</p><h4 id="场景-3：负载隔离"><a href="#场景-3：负载隔离" class="headerlink" title="场景 3：负载隔离"></a>场景 3：负载隔离</h4><p>通过对节点添加 <code>PreferNoSchedule</code> 类型的 Taint，可以降低调度到该节点的优先级，但仍然允许在特殊情况下将 Pod 调度到该节点。</p><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ol><li><strong>Taints 和 Tolerations 并不主动分配工作负载到特定节点</strong>：它们只是限制哪些节点可以运行哪些 Pod。如果需要主动分配，可以结合 <code>nodeSelector</code> 或 <code>nodeAffinity</code>。</li><li><strong>Tolerations 只允许调度，不强制调度</strong>：即使 Pod 有符合条件的 Toleration，也可能因为资源不足等原因无法调度到对应节点。</li><li><strong>TolerationSeconds 仅适用于 <code>NoExecute</code></strong>：当节点添加 <code>NoExecute</code> 类型的 Taint 时，容忍时间才会生效。</li></ol><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>Kubernetes 通过 <code>Taints</code> 和 <code>Tolerations</code> 配合来实现节点的故障转移（Failover），当某些节点出现故障（如离线或不可用）时，<code>Taints</code> 可以标记这些节点不适合继续运行 Pod，而调度器（Scheduler）会将受影响的 Pod 迁移到其他可用节点，从而实现故障转移。</p><h3 id="故障转移的核心机制"><a href="#故障转移的核心机制" class="headerlink" title="故障转移的核心机制"></a>故障转移的核心机制</h3><p>在 Kubernetes 中，故障转移通常依赖以下几个机制：</p><ol><li><p><strong>节点不可用的检测</strong>：<br>Kubernetes 使用 <code>kubelet</code> 和 <code>Node Controller</code> 来监控节点的可用性。如果节点未在指定时间内报告心跳（默认 40 秒内未响应），Node Controller 会将该节点标记为不可用，进而触发相应的处理。</p></li><li><p><strong>节点的 <code>NoExecute</code> Taint</strong>：<br>当节点被标记为不可用时，Kubernetes 会自动为该节点添加一个特殊的 Taint：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">node.kubernetes.io/unreachable:NoExecute<br></code></pre></td></tr></table></figure><p>这是一个系统级的 Taint，表示该节点已不可达。</p></li><li><p><strong>Pod 的 Tolerations</strong>：<br>如果部署的 Pod 没有显式声明可以容忍这个 Taint，它们会被驱逐（Evicted）并重新调度到其他健康的节点上。</p></li><li><p><strong>驱逐与重新调度</strong>：<br>调度器检测到 Pod 因为 Taints 被驱逐后，会在其他节点上重新调度这些 Pod（前提是集群中有其他符合条件的健康节点）。</p></li></ol><hr><h3 id="故障转移中的-Tolerations-作用"><a href="#故障转移中的-Tolerations-作用" class="headerlink" title="故障转移中的 Tolerations 作用"></a>故障转移中的 <code>Tolerations</code> 作用</h3><p><code>Tolerations</code> 是用来定义 Pod 能够容忍哪些类型的 Taints 的。如果一个 Pod 声明了能够容忍 <code>NoExecute</code> 类型的 Taint，会影响 Pod 的行为：</p><ol><li><p><strong>没有 Tolerations</strong>：</p><ul><li>当节点被标记为不可用（添加 <code>NoExecute</code> Taint）时，Pod 会立即被驱逐，并重新调度到其他健康节点。</li></ul></li><li><p><strong>有 Toleration，但没有 <code>tolerationSeconds</code></strong>：</p><ul><li>如果 Pod 声明了可以容忍 <code>node.kubernetes.io/unreachable:NoExecute</code> 的 Taint，但没有指定 <code>tolerationSeconds</code>，它会无限期地留在该节点上，即使节点不可达也不会被驱逐。</li></ul></li><li><p><strong>有 Toleration，且指定了 <code>tolerationSeconds</code></strong>：</p><ul><li>如果 Pod 声明了可以容忍 <code>node.kubernetes.io/unreachable:NoExecute</code> 的 Taint，并设置了 <code>tolerationSeconds</code>，Pod 会在节点不可达的指定时间后被驱逐。例如：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node.kubernetes.io/unreachable&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>  <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>这表示该 Pod 当节点不可达时，可以容忍 60 秒，超过这个时间后会被驱逐。</li></ul></li></ol><hr><h3 id="故障转移示例"><a href="#故障转移示例" class="headerlink" title="故障转移示例"></a>故障转移示例</h3><h4 id="1-模拟节点故障"><a href="#1-模拟节点故障" class="headerlink" title="1. 模拟节点故障"></a>1. 模拟节点故障</h4><p>假设有一个 Pod 被调度到了节点 <code>node1</code>，我们可以通过以下命令模拟该节点的不可用状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 标记节点为不可用</span><br>kubectl taint nodes node1 node.kubernetes.io/unreachable:NoExecute<br></code></pre></td></tr></table></figure><p>这和节点因为健康检查失败被自动添加 <code>NoExecute</code> Taint 的情况等价。</p><h4 id="2-Pod-的行为"><a href="#2-Pod-的行为" class="headerlink" title="2. Pod 的行为"></a>2. Pod 的行为</h4><ul><li><p>如果 Pod 没有定义任何 Toleration：</p><ul><li>Pod 会被立即驱逐并重新调度到其他健康节点（如果有可用节点）。</li></ul></li><li><p>如果 Pod 有定义以下 Toleration：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node.kubernetes.io/unreachable&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>  <span class="hljs-attr">tolerationSeconds:</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><ul><li>Pod 在 <code>node1</code> 上可以继续运行，但最多容忍 30 秒。如果在 30 秒内节点状态恢复，Pod 不会被驱逐；如果超过 30 秒节点仍不可用，Pod 会被驱逐并重新调度。</li></ul></li></ul><hr><h3 id="故障转移的工作流程"><a href="#故障转移的工作流程" class="headerlink" title="故障转移的工作流程"></a>故障转移的工作流程</h3><p>以下是 Kubernetes 故障转移的完整工作流程：</p><ol><li><p><strong>节点检测与标记</strong>：</p><ul><li><code>kubelet</code> 定期向 <code>kube-apiserver</code> 发送心跳。如果节点的心跳在 40 秒内没有响应（通过 <code>node-status-update-frequency</code> 和 <code>node-monitor-grace-period</code> 参数控制），Node Controller 会将节点标记为 <code>NotReady</code> 并添加一个 <code>NoExecute</code> Taint：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">node.kubernetes.io/unreachable:NoExecute<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Pod 驱逐逻辑</strong>：</p><ul><li>对于运行在该节点上的 Pod，调度器会检查它们是否有 <code>Toleration</code> 能容忍 <code>NoExecute</code> Taint：<ul><li>没有 Tolerations 的 Pod 会被立刻驱逐。</li><li>有 <code>tolerationSeconds</code> 的 Pod 会在指定时间后被驱逐。</li><li>有 Tolerations 且无限期容忍的 Pod 会继续保留在节点上（即使节点不可用）。</li></ul></li></ul></li><li><p><strong>重新调度</strong>：</p><ul><li>被驱逐的 Pod 状态会变为 <code>Pending</code>，调度器会尝试将 Pod 分配到其他符合条件的健康节点。</li><li>如果集群中没有足够的资源，Pod 会一直处于 <code>Pending</code> 状态，直到有可用资源。</li></ul></li><li><p><strong>节点恢复</strong>：</p><ul><li>如果节点恢复（心跳正常），Taint 会被自动移除，新的 Pod 可以调度到该节点。</li></ul></li></ol><hr><h3 id="实际使用场景"><a href="#实际使用场景" class="headerlink" title="实际使用场景"></a>实际使用场景</h3><ol><li><p><strong>无状态应用（Stateless Applications）</strong>：</p><ul><li>对于无状态应用（如 Web 服务器），通常不会定义 <code>NoExecute</code> Taint 的 Tolerations。当节点不可用时，这些 Pod 会被快速驱逐并重新调度到其他节点。</li></ul></li><li><p><strong>有状态应用（Stateful Applications）</strong>：</p><ul><li>对于有状态应用（如数据库），可以使用 <code>tolerationSeconds</code> 为 Pod 设置一个宽限期，以允许节点临时不可用的情况下减少不必要的驱逐。例如，数据库可能会因为网络抖动而短时间失联，此时无需立即驱逐 Pod。</li></ul></li><li><p><strong>关键任务负载（Critical Workloads）</strong>：</p><ul><li>如果某些 Pod 是关键任务，且对节点的不可用有更高的容忍度，可以为其设置无限期容忍：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tolerations:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;node.kubernetes.io/unreachable&quot;</span><br>  <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>  <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="调优建议"><a href="#调优建议" class="headerlink" title="调优建议"></a>调优建议</h3><ol><li><p><strong>合理设置心跳间隔</strong>：</p><ul><li>如果节点的不可用只是暂时的（例如网络抖动），可以通过调整 <code>node-monitor-grace-period</code> 参数来避免误判。</li></ul></li><li><p><strong>为不同类型的应用设置不同的 <code>tolerationSeconds</code></strong>：</p><ul><li>无状态应用可以设置较短的容忍时间（甚至不容忍）。</li><li>有状态应用可以设置较长的容忍时间，避免频繁驱逐。</li></ul></li><li><p><strong>结合 Pod 的 Liveness Probe 和 Readiness Probe</strong>：</p><ul><li>确保 Pod 本身的健康状态，避免将调度问题与 Pod 内部问题混淆。</li></ul></li></ol><p>在 Kubernetes 中，调度器是负责将 Pod 分配到集群中的合适节点上的组件。对于复杂的生产环境，可能会遇到调度效率、资源竞争和容灾等挑战，Kubernetes 提供了多种功能来优化调度策略，其中包括 <strong>PriorityClass（优先级调度）</strong> 和 <strong>多调度器（Multiple Schedulers）</strong>。</p><hr><h2 id="PriorityClass"><a href="#PriorityClass" class="headerlink" title="PriorityClass"></a>PriorityClass</h2><h3 id="1-优先级调度（PriorityClass）"><a href="#1-优先级调度（PriorityClass）" class="headerlink" title="1. 优先级调度（PriorityClass）"></a>1. <strong>优先级调度（PriorityClass）</strong></h3><p><strong>PriorityClass</strong> 是 Kubernetes 提供的一种机制，用于给不同 Pod 设置调度优先级。它允许用户指定某些工作负载的重要性，从而确保高优先级的工作负载能够获得优先调度。</p><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a><strong>关键概念</strong></h4><ul><li><strong>PriorityClass 对象</strong>: 定义了优先级名称和其对应的整数字段（<code>value</code>），<code>value</code> 越大，优先级越高。</li><li><strong>系统优先级范围</strong>: <ul><li><code>system-cluster-critical</code> 和 <code>system-node-critical</code> 是 Kubernetes 预定义的最高优先级，通常用于核心组件（如 <code>coredns</code>、<code>kube-proxy</code>）。</li><li>自定义的优先级值取值范围为正整数，通常由管理员定义。</li></ul></li><li><strong>抢占（Preemption）</strong>:<ul><li>如果没有足够的资源调度高优先级 Pod，会触发抢占机制，驱逐低优先级的 Pod 为高优先级的 Pod 腾出资源。</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><p>定义一个 PriorityClass:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">high-priority</span><br><span class="hljs-attr">value:</span> <span class="hljs-number">1000</span><br><span class="hljs-attr">globalDefault:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&quot;This priority class is for high-priority workloads.&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>value</code>: 优先级值。</li><li><code>globalDefault</code>: 是否默认应用到没有指定优先级的 Pod。</li></ul></li><li><p>使用 PriorityClass 的 Pod 定义:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">high-priority-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">high-priority</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li><strong>关键工作负载保障</strong>: 确保核心服务（如监控、日志）优先获得资源。</li><li><strong>抢占低优先级任务</strong>: 在资源紧张时，驱逐低优先级的任务以调度高优先级任务。</li></ul><h4 id="生产问题分析"><a href="#生产问题分析" class="headerlink" title="生产问题分析"></a><strong>生产问题分析</strong></h4><ul><li><strong>调度放大效应</strong>: 如图所示，当集群资源紧张或 Node 出现问题时，优先级调度可能导致某些 Pod（如低优先级的批量任务）无法被调度。</li><li><strong>长时间调度失败问题</strong>: 调度缓存（scheduler cache）滞后可能导致调度错误。</li></ul><hr><h3 id="2-多调度器（Multiple-Schedulers）"><a href="#2-多调度器（Multiple-Schedulers）" class="headerlink" title="2. 多调度器（Multiple Schedulers）"></a>2. <strong>多调度器（Multiple Schedulers）</strong></h3><p>Kubernetes 默认使用 <code>kube-scheduler</code> 作为调度器，但在某些场景下，我们可能需要自定义调度逻辑。这时可以部署多个调度器，每个调度器负责调度特定的 Pod 子集。</p><h4 id="关键概念-1"><a href="#关键概念-1" class="headerlink" title="关键概念"></a><strong>关键概念</strong></h4><ul><li><strong>调度器名称（SchedulerName）</strong>: 每个调度器需要有一个唯一的名称，Pod 可以通过 <code>spec.schedulerName</code> 指定其使用哪个调度器。</li><li><strong>自定义调度器</strong>: 使用调度框架（如 Kubernetes 的调度器扩展 API 或自定义调度器）实现需求。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol><li><p><strong>部署多个调度器</strong></p><ul><li>部署默认调度器 <code>kube-scheduler</code>。</li><li>部署一个自定义调度器。</li></ul><p>自定义调度器示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">custom-scheduler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">custom-scheduler</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">custom-scheduler-image</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--scheduler-name=custom-scheduler</span><br></code></pre></td></tr></table></figure></li><li><p><strong>指定 Pod 使用自定义调度器</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">custom-scheduled-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">custom-scheduler</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li><strong>隔离调度逻辑</strong>: 不同调度器负责不同类型的任务（如批量任务、在线服务）。</li><li><strong>性能优化</strong>: 当单一调度器无法满足高并发 Pod 创建需求时，使用多调度器分担调度压力。</li><li><strong>自定义调度需求</strong>: 特定业务场景下需要定制复杂的调度策略，如基于 GPU 资源、拓扑感知等。</li></ul><h4 id="生产问题分析-1"><a href="#生产问题分析-1" class="headerlink" title="生产问题分析"></a><strong>生产问题分析</strong></h4><ul><li><strong>小集群高并发调度问题</strong>: 如图所示，在高并发情况下，调度器可能因为缓存更新滞后导致调度失败，增加一个专用调度器可能缓解问题。</li><li><strong>危险 Pod 爆炸问题</strong>: 自定义调度器可以用来隔离潜在的危险 Pod，从而避免调度到非预期的 Node。</li></ul><hr><h3 id="3-总结生产经验"><a href="#3-总结生产经验" class="headerlink" title="3. 总结生产经验"></a>3. <strong>总结生产经验</strong></h3><p>根据图中的生产经验提示，我们可以结合优先级调度和多调度器功能来优化生产环境。</p><ul><li><strong>小集群高并发场景</strong>: 通过多调度器分摊调度压力，或优化调度器的缓存刷新机制。</li><li><strong>资源倾斜与放大效应</strong>: 使用 PriorityClass 控制任务优先级，同时监控 Pod 的分布，避免过载单一 Node。</li><li><strong>危险 Pod 防护</strong>: 结合资源配额（ResourceQuota）和自定义调度器，隔离潜在的恶意或异常工作负载。</li></ul><p>通过这些改进，可以有效提升系统的稳定性和调度效率，同时避免因调度问题引发的级联故障。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes_API_server</title>
    <link href="/2025/03/17/kubernetes-API-server/"/>
    <url>/2025/03/17/kubernetes-API-server/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-Kubernetes-API-Server：访问控制、限流与对象实现"><a href="#深入理解-Kubernetes-API-Server：访问控制、限流与对象实现" class="headerlink" title="深入理解 Kubernetes API Server：访问控制、限流与对象实现"></a>深入理解 Kubernetes API Server：访问控制、限流与对象实现</h1><p>kube-apiserver 是 Kubernetes 集群的”大脑”，负责处理所有请求，是集群管理的核心组件。本文将深入探讨 kube-apiserver 的访问控制机制（认证、鉴权、准入控制）、限流策略以及 APIServer 对象的实现原理。</p><span id="more"></span><h2 id="1-API-Server-的核心功能"><a href="#1-API-Server-的核心功能" class="headerlink" title="1. API Server 的核心功能"></a>1. API Server 的核心功能</h2><p>kube-apiserver 主要提供以下功能：</p><ul><li><strong>集群管理的 REST API 接口</strong>：提供认证授权、数据校验、集群状态变更等功能。</li><li><strong>模块间数据交互枢纽</strong>：其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001413236.png" class="" title="image-20250317001413236"><h2 id="2-访问控制"><a href="#2-访问控制" class="headerlink" title="2. 访问控制"></a>2. 访问控制</h2><img src="/2025/03/17/kubernetes-API-server/image-20250317001401046.png" class="" title="image-20250317001401046"><p>客户端（例如 <code>kubectl</code>、自定义控制器或其他 K8s 组件）发出的 API 请求首先到达 <code>kube-apiserver</code>。这些请求经过一系列处理步骤，最终被处理并存储到 <code>etcd</code> 中（或从 <code>etcd</code> 中检索）。</p><img src="/2025/03/17/kubernetes-API-server/image-20250317141928036.png" class="" title="image-20250317141928036"><ul><li><p><strong>Panic Recovery</strong>: 捕获并处理任何 panic，防止整个 apiserver 崩溃。</p></li><li><p><strong>Request Timeout</strong>: 设置请求的超时时间，防止请求无限期挂起。</p></li><li><p><strong>Authentication</strong>: 验证请求者的身份。K8s 支持多种认证机制，如 X.509 证书、Service Account Tokens、Bearer Tokens 等。</p></li><li><p><strong>Audit</strong>: 记录请求的审计日志，用于安全审计和故障排除。</p></li><li><p><strong>Impersonation</strong>: 允许一个用户或服务账户以另一个用户或服务账户的身份执行操作。</p></li><li><p><strong>Max-in-flight</strong>: 限制并发处理的请求数量，防止服务器过载。</p></li><li><p><strong>Authorization</strong>: 确定经过身份验证的用户是否有权限执行请求的操作。K8s 支持多种授权机制，如 RBAC (Role-Based Access Control)、ABAC (Attribute-Based Access Control) 等。</p></li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317141918159.png" class="" title="image-20250317141918159"><h3 id="2-1-认证（Authentication）"><a href="#2-1-认证（Authentication）" class="headerlink" title="2.1 认证（Authentication）"></a>2.1 认证（Authentication）</h3><p>在 Kubernetes 中，认证是指对请求的发送者（用户或服务）进行身份识别，以确保只有合法的实体可以访问 Kubernetes API Server。以下是 Kubernetes 支持的多种认证机制的详细说明：</p><hr><h4 id="1-X-509-证书"><a href="#1-X-509-证书" class="headerlink" title="1. X.509 证书"></a><strong>1. X.509 证书</strong></h4><p><strong>概念</strong>：<br>X.509 是一种基于公钥基础设施 (PKI) 的证书标准，通常用于安全通信。Kubernetes 支持通过客户端证书进行身份验证。</p><p><strong>工作原理</strong>：</p><ol><li>用户使用私钥和证书向 API Server 发起 HTTPS 请求。</li><li>API Server 使用信任的 CA 证书对客户端证书进行验证。</li><li>若验证通过，则认证成功。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>生成 CA 和用户证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 CA 私钥和证书</span><br>openssl genrsa -out ca.key 2048<br>openssl req -x509 -new -nodes -key ca.key -subj <span class="hljs-string">&quot;/CN=kube-ca&quot;</span> -days 10000 -out ca.crt<br><br><span class="hljs-comment"># 生成用户私钥和 CSR</span><br>openssl genrsa -out user.key 2048<br>openssl req -new -key user.key -subj <span class="hljs-string">&quot;/CN=my-user/O=my-group&quot;</span> -out user.csr<br><br><span class="hljs-comment"># 使用 CA 签发用户证书</span><br>openssl x509 -req -<span class="hljs-keyword">in</span> user.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out user.crt -days 10000 -extensions v3_ext<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --client-ca-file=/path/to/ca.crt<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong>：</p><ul><li>用户名（CN）由证书中的 <code>Common Name</code> 字段指定。</li><li>组（Group）由证书中的 <code>Organization</code> 字段指定。</li></ul><hr><h4 id="2-静态-Token-文件"><a href="#2-静态-Token-文件" class="headerlink" title="2. 静态 Token 文件"></a><strong>2. 静态 Token 文件</strong></h4><p><strong>概念</strong>：<br>静态 Token 是预定义的令牌，用于认证用户。它适合小型测试集群，但不推荐生产环境中使用。</p><p><strong>工作原理</strong>：</p><ol><li>用户请求中携带 <code>Authorization: Bearer &lt;token&gt;</code>。</li><li>API Server 从配置的 Token 文件中查找匹配的 Token。</li><li>若匹配成功，则认证通过。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>创建 Token 文件（CSV 格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csv">token1234,my-user,uid1234,&quot;group1,group2&quot;<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --token-auth-file=/path/to/tokens.csv<br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：简单易用，易于共享。</li><li><strong>缺点</strong>：缺乏安全性（Token 没有过期机制）。</li></ul><hr><h4 id="3-引导-Token-Bootstrap-Token"><a href="#3-引导-Token-Bootstrap-Token" class="headerlink" title="3. 引导 Token (Bootstrap Token)"></a><strong>3. 引导 Token (Bootstrap Token)</strong></h4><p><strong>概念</strong>：<br>引导 Token 是一种动态令牌，主要用于集群引导阶段（例如 <code>kubeadm join</code>）。Token 生命周期由 <code>kube-controller-manager</code> 管理。</p><p><strong>工作原理</strong>：</p><ol><li>Token 以 Kubernetes Secret 的形式存储于 <code>kube-system</code> 命名空间。</li><li>当客户端请求使用 Token 时，API Server 查询对应的 Secret 以验证其合法性。</li><li><code>TokenCleaner</code> 控制器会自动清理过期的 Token。</li></ol><p><strong>常见命令</strong>：</p><ul><li><p>查看引导 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm token list<br></code></pre></td></tr></table></figure></li><li><p>创建引导 Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubeadm token create<br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：动态管理，支持自动过期。</li><li><strong>缺点</strong>：只适合用于集群引导。</li></ul><hr><h4 id="4-静态密码文件"><a href="#4-静态密码文件" class="headerlink" title="4. 静态密码文件"></a><strong>4. 静态密码文件</strong></h4><p><strong>概念</strong>：<br>通过用户名和密码进行认证。这种方式简单但不安全，因此不推荐在生产环境中使用。</p><p><strong>配置方式</strong>：</p><ul><li><p>创建密码文件（CSV 格式）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csv">password1234,my-user,uid1234,&quot;group1,group2&quot;<br></code></pre></td></tr></table></figure></li><li><p>配置 API Server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --basic-auth-file=/path/to/passwords.csv<br></code></pre></td></tr></table></figure></li></ul><p><strong>缺点</strong>：</p><ul><li>用户名和密码以明文方式存储。</li><li>缺乏强制密码保护机制。</li></ul><hr><h4 id="5-Service-Account-Token"><a href="#5-Service-Account-Token" class="headerlink" title="5. Service Account Token"></a><strong>5. Service Account Token</strong></h4><p><strong>概念</strong>：<br>Service Account 是 Kubernetes 原生的认证机制，主要为 Pod 提供身份认证。</p><p><strong>工作原理</strong>：</p><ol><li>每个 Pod 都可以绑定一个 Service Account。</li><li>默认情况下，Service Account 的 Token 会自动挂载到 Pod 的文件系统路径 <code>/run/secrets/kubernetes.io/serviceaccount</code>。</li><li>Pod 使用 Token 与 API Server 通信。</li></ol><p><strong>优点</strong>：</p><ul><li>安全性高，自动管理。</li><li>适合 Pod 内部访问 API Server。</li></ul><hr><h4 id="6-OpenID-Connect-OIDC"><a href="#6-OpenID-Connect-OIDC" class="headerlink" title="6. OpenID Connect (OIDC)"></a><strong>6. OpenID Connect (OIDC)</strong></h4><p><strong>概念</strong>：<br>OIDC 是基于 OAuth 2.0 的身份认证协议，用于对接外部身份认证服务（例如 Google, Keycloak）。</p><p><strong>工作原理</strong>：</p><ol><li>用户向 OIDC 提供商请求 Token。</li><li>用户携带 Token 向 API Server 发起请求。</li><li>API Server 验证 Token 的签名及有效性。</li><li>验证成功后，返回认证成功。</li></ol><p><strong>配置方式</strong>：</p><ul><li>配置 API Server：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver \<br>  --oidc-issuer-url=https://issuer.example.com \<br>  --oidc-client-id=kubernetes \<br>  --oidc-username-claim=email \<br>  --oidc-groups-claim=<span class="hljs-built_in">groups</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>集成第三方身份认证系统。</li><li>支持复杂身份和组管理。</li></ul><hr><h4 id="7-Webhook-Token-认证"><a href="#7-Webhook-Token-认证" class="headerlink" title="7. Webhook Token 认证"></a><strong>7. Webhook Token 认证</strong></h4><p><strong>概念</strong>：<br>通过 Webhook 调用外部服务来验证 Token 的合法性。</p><p><strong>工作原理</strong>：</p><ol><li>用户携带 Token 向 API Server 发起请求。</li><li>API Server 将 Token 转发到配置的 Webhook 服务。</li><li>Webhook 服务返回认证结果。</li><li>API Server 根据认证结果决定是否通过。</li></ol><p><strong>配置方式</strong>：</p><ul><li><p>配置 Webhook：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># webhook-config.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://auth.example.com/authenticate</span><br><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-context</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">example-context</span><br></code></pre></td></tr></table></figure></li><li><p>启用 Webhook：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --authentication-token-webhook-config-file=/path/to/webhook-config.yaml<br></code></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>灵活性高，可以集成复杂的认证逻辑。</li></ul><hr><h4 id="8-匿名请求"><a href="#8-匿名请求" class="headerlink" title="8. 匿名请求"></a><strong>8. 匿名请求</strong></h4><p><strong>概念</strong>：<br>当未提供身份凭据时，API Server 将请求识别为匿名请求。匿名请求默认启用，但可以禁用。</p><p><strong>配置方式</strong>：</p><ul><li>禁用匿名请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --anonymous-auth=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：允许调试和测试。</li><li><strong>缺点</strong>：不适合生产环境，可能引发安全问题。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317145348516.png" class="" title="image-20250317145348516"><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="2-1-1-基于-Webhook-的认证服务集成"><a href="#2-1-1-基于-Webhook-的认证服务集成" class="headerlink" title="2.1.1 基于 Webhook 的认证服务集成"></a>2.1.1 基于 Webhook 的认证服务集成</h4><p>可以构建符合 Kubernetes 规范的自定义认证服务。以下是构建认证服务的要点：</p><ul><li><strong>规范</strong>：<ul><li>URL：<code>https://authn.example.com/authenticate</code></li><li>Method：<code>POST</code></li><li>Input：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TokenReview&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;spec&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(BEARERTOKEN)&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>Output：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TokenReview&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;authenticated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;janedoe@example.com&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;42&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;groups&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;developers&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;qa&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>以下为go代码示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//解码认证请求</span><br>decoder := json.NewDecoder(r.Body)<br><span class="hljs-keyword">var</span> tr authentication.TokenReview<br>err := decoder.Decode(&amp;tr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 转发认证请求至认证服务器(以github为例)</span><br>ts := oauth2.StaticTokenSource(<br>&amp;oauth2.Token&#123;AccessToken: tr.Spec.Token&#125;,<br>)<br>tc := oauth2.NewClient(oauth2.NoContext, ts)<br>client := github.NewClient(tc)<br>user, _, err := client.Users.Get(context.Background(), <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//...错误处理</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 认证结果返回给APIServer</span><br>w.WriteHeader(http.StatusOK)<br>trs := authentication.TokenReviewStatus&#123;<br>Authenticated: <span class="hljs-literal">true</span>,<br>User: authentication.UserInfo&#123;<br>Username: *user.Login,<br>UID:      *user.Login,<br>&#125;,<br>&#125;<br>json.NewEncoder(w).Encode(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;authentication.k8s.io/v1beta1&quot;</span>,<br><span class="hljs-string">&quot;kind&quot;</span>:       <span class="hljs-string">&quot;TokenReview&quot;</span>,<br><span class="hljs-string">&quot;status&quot;</span>:     trs,<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-1-2-keystone认证的陷阱"><a href="#2-1-2-keystone认证的陷阱" class="headerlink" title="2.1.2 keystone认证的陷阱"></a>2.1.2 keystone认证的陷阱</h4><p>Keystone 是很多企业的核心认证服务。Kubernetes 中使用 Keystone 作为认证插件可能会导致 Keystone 故障且无法恢复。<br>原因：gophercloud 针对过期 token 会一直 retry,导致服务无法恢复</p><p><strong>解决方案:</strong></p><ul><li>熔断</li><li>限流</li></ul><h3 id="2-2-授权"><a href="#2-2-授权" class="headerlink" title="2.2 授权"></a>2.2 授权</h3><p>授权阶段负责确定已认证的用户是否有权限执行请求的操作。Kubernetes 支持以下授权模式：</p><ul><li><strong>ABAC (Attribute-Based Access Control)</strong>：基于属性的访问控制，配置复杂，不推荐。</li><li><strong>RBAC (Role-Based Access Control)</strong>：基于角色的访问控制，推荐使用。</li><li><strong>Webhook</strong>：将授权决策委托给外部 Webhook 服务。</li><li><strong>Node</strong>：一种特殊用途的授权模式，用于授予 kubelet 访问特定资源的权限。</li></ul><h4 id="2-2-1-RBAC"><a href="#2-2-1-RBAC" class="headerlink" title="2.2.1 RBAC"></a>2.2.1 RBAC</h4><p>RBAC 的核心概念：</p><ul><li><strong>Role（角色）</strong>：定义了一组权限规则。</li><li><strong>ClusterRole（集群角色）</strong>：与 Role 类似，但作用于整个集群。</li><li><strong>RoleBinding（角色绑定）</strong>：将 Role 或 ClusterRole 与用户、组或 ServiceAccount 绑定。</li><li><strong>ClusterRoleBinding（集群角色绑定）</strong>：将 ClusterRole 与用户、组或 ServiceAccount 绑定。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001000991.png" class="" title="image-20250317001000991"><ul><li><strong>针对群组授权</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">read-secrets-global</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">Group</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">manager</span> <span class="hljs-comment"># &#x27;name&#x27; 是区分大小写的</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-reader</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-规划系统角色"><a href="#2-2-2-规划系统角色" class="headerlink" title="2.2.2 规划系统角色"></a>2.2.2 规划系统角色</h4><p>在规划 Kubernetes 集群的权限时，需要考虑以下角色：</p><ul><li><strong>管理员</strong>：拥有集群的最高权限。</li><li><strong>普通用户</strong>：拥有其创建的命名空间内资源的操作权限，对其他命名空间可能有只读权限。</li><li><strong>SystemAccount</strong>：用于 Kubernetes 组件或自定义应用与 API Server 通信。</li></ul><h4 id="2-2-3-实现自定义授权逻辑的方案"><a href="#2-2-3-实现自定义授权逻辑的方案" class="headerlink" title="2.2.3 实现自定义授权逻辑的方案"></a>2.2.3 实现自定义授权逻辑的方案</h4><ol><li>在集群创建时，创建自定义的 Role，例如 <code>namespace-creator</code>，定义用户可操作的对象和读写权限。</li><li>创建自定义的 Namespace 准入控制器，在 Namespace 创建请求被处理时，获取当前用户信息并将其添加到 Namespace 的 Annotation 中。</li><li>创建 RBAC 控制器，监视 Namespace 的创建事件，获取 Namespace 创建者信息，并在当前 Namespace 中创建 RoleBinding 对象，将 <code>namespace-creator</code> 角色与用户绑定。</li></ol><h4 id="2-2-4-权限相关的最佳实践"><a href="#2-2-4-权限相关的最佳实践" class="headerlink" title="2.2.4 权限相关的最佳实践"></a>2.2.4 权限相关的最佳实践</h4><ul><li>ClusterRole 是非命名空间绑定的，针对整个集群生效。</li><li>通常需要创建一个管理员角色，并且绑定给开发运营团队成员。</li><li>ThirdPartyResource 和 CustomResourceDefinition 是全局资源，普通用户创建<br>ThirdPartyResource 以后，需要管理员授予相应权限后才能真正操作该对象。</li><li>针对所有的角色管理，建议创建 spec，用源代码驱动。</li><li>权限是可以传递的，用户 A 可以将其对某对象的某操作，抽取成一个权限，并赋给用户 B。</li><li>防止海量的角色和角色绑定对象，因为大量的对象会导致鉴权效率低，同时给 apiserver 增加负担。</li><li>ServiceAccount 也需要授权的。</li><li>Tips：SSH 到 master 节点通过 insecure port 访问 apiserver 可绕过鉴权，当需要做管理操作又没有权限时可以使用（不推荐）</li></ul><p><strong>授权相关的坑：</strong><br>研发人员忘记在生产环境更新 rolebinding 导致权限不足</p><h3 id="2-3-准入控制"><a href="#2-3-准入控制" class="headerlink" title="2.3 准入控制"></a>2.3 准入控制</h3><p>准入控制在授权之后对请求进行进一步的验证或修改。与认证和授权不同，准入控制可以处理请求的内容，并且仅对创建、更新、删除或连接（如代理）等操作有效。</p><p>Kubernetes 内置了许多准入控制插件，例如：</p><ul><li><strong>AlwaysPullImages</strong>：强制拉取最新镜像。</li><li><strong>DenyEscalatingExec</strong>：禁止特权容器的 exec 和 attach 操作。</li><li><strong>ServiceAccount</strong>：自动创建默认 ServiceAccount。</li><li><strong>ResourceQuota</strong>：限制 Pod 的资源请求。</li><li><strong>LimitRanger</strong>：为 Pod 设置默认资源请求和限制。</li><li><strong>NamespaceLifecycle</strong>：确保处于 termination 状态的命名空间不再接收新的对象创建请求。</li><li><strong>PodSecurityPolicy</strong>：实施 Pod 安全策略。</li><li><strong>NodeRestriction</strong>：限制 kubelet 仅可访问 node、endpoint、pod、service 以及 secret、<br> configmap、PV 和 PVC 等相关的资源</li></ul><h4 id="2-3-1-准入控制插件的开发"><a href="#2-3-1-准入控制插件的开发" class="headerlink" title="2.3.1 准入控制插件的开发"></a>2.3.1 准入控制插件的开发</h4><p>除了默认的准入控制插件，Kubernetes 还支持自定义准入控制插件：</p><ul><li><strong>MutatingWebhookConfiguration</strong>：修改准入对象。</li><li><strong>ValidatingWebhookConfiguration</strong>：校验准入对象，但不修改。<br>准入控制例子：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span><br><span class="hljs-string">admissionregistration.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">MutatingWebhookConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ns-mutating.webhook.k8s.io</span><br><span class="hljs-attr">webhooks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">clientConfig:</span><br>    <span class="hljs-attr">caBundle:</span> &#123;&#123;<span class="hljs-string">.serverca_base64</span>&#125;&#125;<br>    <span class="hljs-attr">url:</span><br><span class="hljs-string">https://admission.local.tess.io/apis/admission.k8s.io/v1alpha1/ns-mutating</span><br>  <span class="hljs-attr">failurePolicy:</span> <span class="hljs-string">Fail</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ns-mutating.webhook.k8s.io</span><br>  <span class="hljs-attr">namespaceSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>     <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">apiVersions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">operations:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CREATE</span><br>    <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>    <span class="hljs-attr">sideEffects:</span> <span class="hljs-string">Unknown</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-配额管理"><a href="#2-3-2-配额管理" class="headerlink" title="2.3.2 配额管理"></a>2.3.2 配额管理</h4><p><strong>原因：</strong><br>资源有限，如何限定某个用户有多少资源？<br><strong>方案：</strong></p><ul><li>预定义每个Namespace的ResourceQuota，并把spec保存为configmap</li><li>创建ResourceQuota Controller</li><li>apiserver中开启ResourceQuota的admission plugin</li></ul><h2 id="3-限流"><a href="#3-限流" class="headerlink" title="3. 限流"></a>3. 限流</h2><p>限流是保护 API Server 免受过多请求影响的重要机制。</p><h3 id="3-1-传统限流算法"><a href="#3-1-传统限流算法" class="headerlink" title="3.1 传统限流算法"></a>3.1 传统限流算法</h3><ul><li><strong>计数器固定窗口算法</strong>：在固定时间窗口内对请求计数，超过阈值则拒绝。</li><li><strong>计数器滑动窗口算法</strong>：将固定窗口划分为多个小窗口，分别计数，窗口滑动时更新计数。</li><li><strong>漏斗算法</strong>：请求进入漏斗，以恒定速率流出，漏斗满时溢出。</li><li><strong>令牌桶算法</strong>：以恒定速率向令牌桶中放入令牌，请求消耗令牌，桶空时拒绝。</li></ul><h3 id="3-2-APIServer-中的限流"><a href="#3-2-APIServer-中的限流" class="headerlink" title="3.2 APIServer 中的限流"></a>3.2 APIServer 中的限流</h3><p>kube-apiserver 通过以下参数进行限流：</p><ul><li><code>--max-requests-inflight</code>：最大非 mutating 请求数。</li><li><code>--max-mutating-requests-inflight</code>：最大 mutating 请求数。</li><li>代码： <code>staging/src/k8s.io/apiserver/pkg/server/filters/maxinflight.go:WithMaxInFlightLimit()</code></li></ul><p>默认值：</p><table><thead><tr><th>节点数</th><th>max-requests-inflight</th><th>max-mutating-requests-inflight</th></tr></thead><tbody><tr><td>1000-3000</td><td>400&#x2F;1500</td><td>200&#x2F;500</td></tr><tr><td>&gt;3000</td><td>3000</td><td>1000</td></tr></tbody></table><h3 id="3-3-传统限流方法的局限性"><a href="#3-3-传统限流方法的局限性" class="headerlink" title="3.3 传统限流方法的局限性"></a>3.3 传统限流方法的局限性</h3><ul><li><strong>粒度粗</strong>：无法针对不同用户、场景进行精细化限流。</li><li><strong>单队列</strong>：所有请求共享限流资源，可能导致单个用户的行为影响整个系统。</li><li><strong>不公平</strong>：正常用户的请求可能被排在队尾，无法及时处理。</li><li><strong>无优先级</strong>：重要请求可能被限流，导致系统故障难以恢复。</li></ul><h3 id="3-4-API-Priority-and-Fairness-APF"><a href="#3-4-API-Priority-and-Fairness-APF" class="headerlink" title="3.4 API Priority and Fairness (APF)"></a>3.4 API Priority and Fairness (APF)</h3><p>APF 是 Kubernetes 1.18 引入的新特性，提供更细粒度的请求分类和隔离，以及有限的排队机制，避免短暂突发流量导致请求被拒绝。</p><h4 id="3-4-1-APF-的核心概念"><a href="#3-4-1-APF-的核心概念" class="headerlink" title="3.4.1 APF 的核心概念"></a>3.4.1 APF 的核心概念</h4><ul><li><strong>多等级 (Priority Level)</strong>：不同优先级的请求拥有独立的并发资源。</li><li><strong>多队列 (Multiple Queues)</strong>：每个优先级内部使用多个队列，通过公平排队算法避免单个 Flow 饿死其他 Flow。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001019487.png" class="" title="image-20250317001019487"><h4 id="3-4-2-关键概念"><a href="#3-4-2-关键概念" class="headerlink" title="3.4.2 关键概念"></a>3.4.2 关键概念</h4><ul><li><strong>FlowSchema</strong>：将请求分类到不同的 Flow。</li><li><strong>PriorityLevelConfiguration</strong>：定义每个优先级的并发限制和排队参数。</li><li><strong>Distinguisher</strong>：在 FlowSchema 内部进一步区分请求（例如，按用户或命名空间）。</li><li><strong>Shuffle Sharding</strong>：将请求分配到队列的算法，隔离低强度和高强度流量。</li><li><strong>Fair Queuing</strong>：从队列中选择请求的算法，确保同一优先级内不同 Flow 的公平性。</li></ul><h4 id="3-4-3-豁免请求"><a href="#3-4-3-豁免请求" class="headerlink" title="3.4.3 豁免请求"></a>3.4.3 豁免请求</h4><p>某些特别重要的请求（例如，<code>system:masters</code> 组的请求）不受 APF 限制。</p><h4 id="3-4-4-默认配置"><a href="#3-4-4-默认配置" class="headerlink" title="3.4.4 默认配置"></a>3.4.4 默认配置</h4><p>Kubernetes 提供了以下默认配置：</p><ul><li><code>system</code>：用于 <code>system:nodes</code> 组的请求。</li><li><code>leader-election</code>：用于内置控制器的领导者选举请求。</li><li><code>workload-high</code>：用于内置控制器的请求。</li><li><code>workload-low</code>：用于来自任何服务帐户的请求。</li><li><code>global-default</code>：处理所有其他流量。</li><li><code>exempt</code>：完全不受流控限制。</li><li><code>catch-all</code>：确保每个请求都被分类。</li></ul><h4 id="3-4-5-PriorityLevelConfiguration"><a href="#3-4-5-PriorityLevelConfiguration" class="headerlink" title="3.4.5 PriorityLevelConfiguration"></a>3.4.5 PriorityLevelConfiguration</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PriorityLevelConfiguration</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">global-default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">limited:</span><br>    <span class="hljs-attr">assuredConcurrencyShares:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">limitResponse:</span><br>      <span class="hljs-attr">queuing:</span><br>        <span class="hljs-attr">handSize:</span> <span class="hljs-number">6</span><br>        <span class="hljs-attr">queueLengthLimit:</span> <span class="hljs-number">50</span><br>        <span class="hljs-attr">queues:</span> <span class="hljs-number">128</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Queue</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">Limited</span><br></code></pre></td></tr></table></figure><h4 id="3-4-6-FlowSchema"><a href="#3-4-6-FlowSchema" class="headerlink" title="3.4.6 FlowSchema"></a>3.4.6 FlowSchema</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">flowcontrol.apiserver.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">FlowSchema</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-scheduler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">distinguisherMethod:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">ByNamespace</span><br>  <span class="hljs-attr">matchingPrecedence:</span> <span class="hljs-number">800</span><br>  <span class="hljs-attr">priorityLevelConfiguration:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">workload-high</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">resourceRules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>      <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">subjects:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">User</span><br>      <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-scheduler</span><br></code></pre></td></tr></table></figure><h4 id="3-4-7-调试"><a href="#3-4-7-调试" class="headerlink" title="3.4.7 调试"></a>3.4.7 调试</h4><p>可以使用以下命令调试 APF：</p><ul><li><code>/debug/api_priority_and_fairness/dump_priority_levels</code></li><li><code>/debug/api_priority_and_fairness/dump_queues</code></li><li><code>/debug/api_priority_and_fairness/dump_requests</code></li></ul><h2 id="4-高可用-APIServer"><a href="#4-高可用-APIServer" class="headerlink" title="4. 高可用 APIServer"></a>4. 高可用 APIServer</h2><h3 id="4-1-启动-apiserver-示例"><a href="#4-1-启动-apiserver-示例" class="headerlink" title="4.1 启动 apiserver 示例"></a>4.1 启动 apiserver 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-apiserver --feature-gates=AllAlpha=<span class="hljs-literal">true</span> --runtime-config=api/all=<span class="hljs-literal">true</span> \<br>--requestheader-allowed-names=front-proxy-client \<br>--client-ca-file=/etc/kubernetes/pki/ca.crt \<br>--allow-privileged=<span class="hljs-literal">true</span> \<br>--experimental-bootstrap-token-auth=<span class="hljs-literal">true</span> \<br>--storage-backend=etcd3 \<br>--requestheader-username-headers=X-Remote-User \<br>--requestheader-extra-headers-prefix=X-Remote-Extra- \<br>--service-account-key-file=/etc/kubernetes/pki/sa.pub \<br>--tls-cert-file=/etc/kubernetes/pki/apiserver.crt \<br>--tls-private-key-file=/etc/kubernetes/pki/apiserver.key \<br>--kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt \<br>--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt \<br>--enabled-hooks=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota \<br>--requestheader-group-headers=X-Remote-Group \<br>--kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key \<br>--secure-port=6443 \<br>--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \<br>--service-cluster-ip-range=10.96.0.0/12 \<br>--advertise-address=192.168.0.20 --etcd-servers=http://127.0.0.1:2379<br></code></pre></td></tr></table></figure><h3 id="4-2-构建高可用的多副本-apiserver"><a href="#4-2-构建高可用的多副本-apiserver" class="headerlink" title="4.2 构建高可用的多副本 apiserver"></a>4.2 构建高可用的多副本 apiserver</h3><p>apiserver是无状态的Rest Server,无状态所以方便Scale Up／down,在多个apiserver实例之上，配置负载均衡,证书可能需要加上Loadbalancer VIP重新生成</p><h3 id="4-3-其他最佳实践"><a href="#4-3-其他最佳实践" class="headerlink" title="4.3 其他最佳实践"></a>4.3 其他最佳实践</h3><ul><li><strong>预留充足的 CPU、内存资源</strong>。</li><li><strong>善用速率限制（RateLimit）</strong>。</li><li><strong>设置合适的缓存大小</strong>。</li><li><strong>客户端尽量使用长连接</strong>。</li><li><strong>访问 APIServer</strong>:<ul><li>外部客户：通过 LoadBalancer 访问。</li><li>内部客户端：优先访问 Cluster IP。</li></ul></li></ul><h2 id="5-搭建多租户的-Kubernetes-集群"><a href="#5-搭建多租户的-Kubernetes-集群" class="headerlink" title="5. 搭建多租户的 Kubernetes 集群"></a>5. 搭建多租户的 Kubernetes 集群</h2><h3 id="5-1-目标"><a href="#5-1-目标" class="headerlink" title="5.1 目标"></a>5.1 目标</h3><ul><li><strong>授信</strong>：认证和授权，确保只有可信用户才能访问集群，并防止用户越权操作。</li><li><strong>隔离</strong>：可见性隔离、资源隔离、应用访问隔离，确保不同租户之间的隔离性。</li><li><strong>资源管理</strong>：Quota 管理，控制每个租户的资源使用量。</li></ul><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h3><ul><li><strong>认证</strong>：与企业现有认证系统集成（例如，使用 Webhook 认证插件与 Microsoft Active Directory 集成）。</li><li><strong>授权</strong>：使用 RBAC 进行细粒度的权限控制。</li><li><strong>可见性隔离</strong>：通过命名空间对不同租户可见的资源进行隔离</li><li><strong>资源隔离</strong>：通过专有设备给特定租户使用</li><li><strong>应用访问隔离</strong>： 通过设置，只允许特定租户访问某些应用</li><li><strong>Quota 管理</strong>：通过 ResourceQuota 控制每个命名空间的资源使用。</li></ul><h2 id="6-APIServer-对象的实现"><a href="#6-APIServer-对象的实现" class="headerlink" title="6. APIServer 对象的实现"></a>6. APIServer 对象的实现</h2><h3 id="6-1-GKV-Group-Kind-Version"><a href="#6-1-GKV-Group-Kind-Version" class="headerlink" title="6.1  GKV (Group, Kind, Version)"></a>6.1  GKV (Group, Kind, Version)</h3><ul><li><strong>Group</strong>：API 资源的分组。</li><li><strong>Kind</strong>：API 资源的类型。</li><li><strong>Version</strong>：API 资源的版本（Internal version 和 External version）。</li></ul><img src="/2025/03/17/kubernetes-API-server/image-20250317001025889.png" class="" title="image-20250317001025889"><h3 id="6-2-定义-Group"><a href="#6-2-定义-Group" class="headerlink" title="6.2  定义 Group"></a>6.2  定义 Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apis/core/register.go</span><br><span class="hljs-keyword">package</span> core<br><span class="hljs-keyword">const</span> GroupName = <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// core group 的 GroupName 为空</span><br><span class="hljs-keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: runtime.APIVersionInternal&#125;<br><br><span class="hljs-keyword">var</span> (<br>SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)<br>AddToScheme   = SchemeBuilder.AddToScheme<br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addKnownTypes</span><span class="hljs-params">(scheme *runtime.Scheme)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := scheme.AddIgnoredConversionType(&amp;metav1.TypeMeta&#123;&#125;, &amp;metav1.TypeMeta&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>scheme.AddKnownTypes(SchemeGroupVersion,<br>&amp;Pod&#123;&#125;,<br>&amp;PodList&#123;&#125;,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-定义对象类型"><a href="#6-3-定义对象类型" class="headerlink" title="6.3 定义对象类型"></a>6.3 定义对象类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// types.go</span><br><span class="hljs-keyword">type</span> Pod <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br>Spec PodSpec <span class="hljs-string">`json:&quot;spec,omitempty&quot; protobuf:&quot;bytes,2,opt,name=spec&quot;`</span><br>Status PodStatus <span class="hljs-string">`json:&quot;status,omitempty&quot; protobuf:&quot;bytes,3,opt,name=status&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PodList <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ListMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span><br>Items []Pod <span class="hljs-string">`json:&quot;items&quot; protobuf:&quot;bytes,2,rep,name=items&quot;`</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-4-代码生成-Tags"><a href="#6-4-代码生成-Tags" class="headerlink" title="6.4 代码生成 Tags"></a>6.4 代码生成 Tags</h3><ul><li><strong>Global Tags</strong>：定义在 <code>doc.go</code> 中，例如 <code>// +k8s:deepcopy-gen=package</code>。</li><li><strong>Local Tags</strong>：定义在 <code>types.go</code> 中的每个对象里，例如 <code>// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>。</li></ul><h3 id="6-5-实现-etcd-storage"><a href="#6-5-实现-etcd-storage" class="headerlink" title="6.5  实现 etcd storage"></a>6.5  实现 etcd storage</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/configmap/storage/storage.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewREST</span><span class="hljs-params">(optsGetter generic.RESTOptionsGetter)</span></span> *REST &#123;<br>store := &amp;genericregistry.Store&#123;<br>NewFunc:                  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;api.ConfigMap&#123;&#125; &#125;,<br>NewListFunc:              <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> runtime.Object &#123; <span class="hljs-keyword">return</span> &amp;api.ConfigMapList&#123;&#125; &#125;,<br>DefaultQualifiedResource: api.Resource(<span class="hljs-string">&quot;configmaps&quot;</span>),<br>CreateStrategy:           configmap.Strategy,<br>UpdateStrategy:           configmap.Strategy,<br>DeleteStrategy:           configmap.Strategy,<br>TableConvertor:           printerstorage.TableConvertor&#123;TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)&#125;,<br>&#125;<br>options := &amp;generic.StoreOptions&#123;RESTOptions: optsGetter&#125;<br><span class="hljs-keyword">if</span> err := store.CompleteWithOptions(options); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err) <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Propagate error up</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;REST&#123;store&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-6-创建和更新对象时的业务逻辑-Strategy"><a href="#6-6-创建和更新对象时的业务逻辑-Strategy" class="headerlink" title="6.6  创建和更新对象时的业务逻辑-Strategy"></a>6.6  创建和更新对象时的业务逻辑-Strategy</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/registry/core/configmap/strategy.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> PrepareForCreate(ctx context.Context, obj runtime.Object) &#123;<br>_ = obj.(*api.ConfigMap)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> Validate(ctx context.Context, obj runtime.Object) field.ErrorList &#123;<br>cfg := obj.(*api.ConfigMap)<br><span class="hljs-keyword">return</span> validation.ValidateConfigMap(cfg)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(strategy)</span></span> PrepareForUpdate(ctx context.Context, newObj, oldObj runtime.Object) &#123;<br>_ = oldObj.(*api.ConfigMap)<br>_ = newObj.(*api.ConfigMap)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-7-subresource"><a href="#6-7-subresource" class="headerlink" title="6.7 subresource"></a>6.7 subresource</h3><p>内嵌在kubernetes对象中，有独立的操作逻辑的属性集合，如podstatus</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">statusStore.UpdateStrategy = pod.StatusStrategy<br><span class="hljs-keyword">var</span> StatusStrategy = podStatusStrategy&#123;Strategy&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(podStatusStrategy)</span></span> PrepareForUpdate(ctx context.Context, obj, old runtime.Object)<br>&#123;<br>newPod := obj.(*api.Pod)<br>oldPod := old.(*api.Pod)<br>newPod.Spec = oldPod.Spec<br>newPod.DeletionTimestamp = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// don&#x27;t allow the pods/status endpoint to touch owner references since old kubelets corrupt them in a way</span><br><span class="hljs-comment">// that breaks garbage collection</span><br>newPod.OwnerReferences = oldPod.OwnerReferences<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-8-注册-APIGroup"><a href="#6-8-注册-APIGroup" class="headerlink" title="6.8 注册 APIGroup"></a>6.8 注册 APIGroup</h3><ol><li>定义 Storage：<code>configMapStorage := configmapstore.NewREST(restOptionsGetter)</code>。</li><li>定义对象的 StorageMap：<code>apiGroupInfo.VersionedResourcesStorageMap[&quot;v1&quot;] = restStorageMap</code>。</li><li>将对象注册至 APIServer（挂载 handler）：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err :=<br>m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix,<br>&amp;apiGroupInfo); err != <span class="hljs-literal">nil</span> &#123;<br>    klog.Fatalf(<span class="hljs-string">&quot;Error in registering group versions: %v&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-9-代码生成"><a href="#6-9-代码生成" class="headerlink" title="6.9 代码生成"></a>6.9 代码生成</h3><p>Kubernetes 使用以下代码生成器：</p><ul><li><code>deepcopy-gen</code>：为对象生成 DeepCopy 方法。</li><li><code>client-gen</code>：创建 Clientset。</li><li><code>informer-gen</code>：创建 Informer 框架。</li><li><code>lister-gen</code>：创建 Lister 框架。</li><li><code>conversion-gen</code>：创建版本转换方法。</li></ul><p>代码生成器位于：<a href="https://github.com/kubernetes/code-generator">https://github.com/kubernetes/code-generator</a></p><p><code>hack/update-codegen.sh</code> 脚本用于生成代码。<br>命令示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;GOPATH&#125;</span>/bin/deepcopy-gen --input-dirs &#123;versioned-package-pach&#125; \<br>-O zz_generated.deepcopy \<br>--bounding-dirs &#123;output-package-path&#125; \<br>--go-header-file <span class="hljs-variable">$&#123;SCRIPT_ROOT&#125;</span>/hack/boilerplate.go.txt<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文深入探讨了 Kubernetes API Server 的内部机制，包括访问控制、限流策略和 APIServer 对象的实现。理解这些概念对于构建和管理 Kubernetes 集群至关重要。希望这篇博客能帮助你更好地理解 Kubernetes API Server 的工作原理。<br>apiserver 代码走读可以参考：<a href="https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d">https://cncamp.notion.site/kube-apiserver-10d5695cbbb14387b60c6d622005583d</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes架构原则与对象设计</title>
    <link href="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>这篇文章解析了 Kubernetes 的对象设计。</p><span id="more"></span><h3 id="1-云计算的演变：从虚拟机到容器"><a href="#1-云计算的演变：从虚拟机到容器" class="headerlink" title="1. 云计算的演变：从虚拟机到容器"></a>1. 云计算的演变：从虚拟机到容器</h3><p>云计算，简单来说，就是把计算资源（比如CPU、内存、存储、网络）放到“云”上，大家按需使用，不用自己买服务器、搭机房。</p><p>云计算平台大致经历了两个阶段：</p><ul><li><p><strong>第一阶段：虚拟化平台 (以 OpenStack 为代表)</strong></p><ul><li>想象一下，你有一台大电脑，通过虚拟化技术，把它“切”成很多小电脑（虚拟机），每个小电脑可以独立运行不同的应用。</li><li><strong>优点：</strong> 资源利用率提高了，不用每部署一个应用就买一台服务器。</li><li><strong>缺点：</strong> 虚拟机的创建和业务代码的部署是分开的，每次部署应用都要先创建虚拟机，再安装各种依赖，比较麻烦。而且，虚拟机的底层环境（操作系统、各种库）可能不一样，维护起来比较头疼。</li></ul></li><li><p><strong>第二阶段：基于进程的作业调度平台 (以谷歌 Borg 为代表)</strong></p><ul><li>Borg 是谷歌内部使用的容器集群管理系统，它直接管理进程，而不是虚拟机。</li><li><strong>优点：</strong> 资源利用率更高，应用部署更快，故障恢复也更快。</li><li><strong>缺点：</strong> Borg 的设计比较复杂，有一些不太合理的地方，比如：<ul><li>对象之间的依赖关系太强，不够灵活。</li><li>所有容器共享 IP，容易导致端口冲突。</li><li>给超级用户添加了太多复杂逻辑，系统变得臃肿。</li></ul></li></ul></li></ul><h3 id="2-谷歌-Borg：Kubernetes-的灵感之源"><a href="#2-谷歌-Borg：Kubernetes-的灵感之源" class="headerlink" title="2. 谷歌 Borg：Kubernetes 的灵感之源"></a>2. 谷歌 Borg：Kubernetes 的灵感之源</h3><p>Borg 在谷歌内部发挥了巨大作用，支撑了 Gmail、Google Docs、Web Search 等众多核心业务。</p><h4 id="2-1-Borg-的核心特性"><a href="#2-1-Borg-的核心特性" class="headerlink" title="2.1 Borg 的核心特性"></a>2.1 Borg 的核心特性</h4><ul><li><strong>高资源利用率：</strong> 通过共享服务器，在进程级别进行隔离，充分利用硬件资源。</li><li><strong>高可用性：</strong> 应用故障时，可以快速恢复，保证服务不中断。</li><li><strong>灵活的调度：</strong> 可以根据不同的应用需求，灵活地分配资源。</li><li><strong>方便易用：</strong> 提供了完善的工具，方便用户部署、管理应用。</li></ul><h4 id="2-2-Borg-的基本概念"><a href="#2-2-Borg-的基本概念" class="headerlink" title="2.2 Borg 的基本概念"></a>2.2 Borg 的基本概念</h4><ul><li><strong>Workload（工作负载）：</strong> 分为两种：<ul><li><strong>prod：</strong> 在线任务，比如网站、邮件服务等，对延迟敏感，需要长期运行。</li><li><strong>non-prod：</strong> 离线任务，比如数据分析、批量计算等，可以容忍一定的延迟。</li></ul></li><li><strong>Cell（单元）：</strong> 一个 Cell 包含一个 Borg 集群管理系统，用户不需要关心应用具体跑在哪台机器上，Borg 会自动分配资源、处理故障。</li><li><strong>Job 和 Task：</strong><ul><li><strong>Job：</strong> 用户提交的应用部署请求，包含一个或多个相同的 Task。</li><li><strong>Task：</strong> 运行相同应用程序的副本，Task 的数量就是应用的副本数。</li></ul></li><li><strong>Naming（命名）：</strong> Borg 通过 BNS（Borg Name Service）实现服务发现。例如：<code>50.jfoo.ubar.cc.borg.google.com</code> 表示在名为 <code>cc</code> 的 Cell 中，由用户 <code>uBar</code> 部署的名为 <code>jFoo</code> 的 Job 下的第 50 个 Task。</li></ul><h4 id="2-3-Borg-的架构"><a href="#2-3-Borg-的架构" class="headerlink" title="2.3 Borg 的架构"></a>2.3 Borg 的架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235410146.png" class="" title="image-20250316235410146"><pre class="mermaid">graph LR    subgraph Borg        A[客户端] --> B(Borgmaster)        B --> C{Scheduler}        B --> D[Borglet]        D --> E[应用程序进程]    end</pre><ul><li><strong>Borgmaster：</strong><ul><li>处理客户端请求（创建 Job、查询 Job 等）。</li><li>维护系统组件和服务状态。</li><li>与 Borglet 通信。</li></ul></li><li><strong>Scheduler：</strong><ul><li>负责调度 Task 到合适的机器上。</li><li>采用多种优化策略，提高调度效率。</li></ul></li><li><strong>Borglet：</strong><ul><li>部署在每台服务器上的 Agent。</li><li>接收 Borgmaster 的指令，管理 Task。</li></ul></li></ul><h4 id="2-4-Borg-的高可用性"><a href="#2-4-Borg-的高可用性" class="headerlink" title="2.4 Borg 的高可用性"></a>2.4 Borg 的高可用性</h4><ul><li><strong>应用高可用：</strong><ul><li>多副本部署，跨故障域（不同机器、机架、电源等）。</li><li>控制节点故障时的任务调度速率，避免网络分区误判。</li><li>记录详细信息，方便故障排查。</li><li><strong>关键原则：</strong> 即使 Borgmaster 或 Borglet 挂掉，也不能杀掉正在运行的服务。</li></ul></li><li><strong>Borg 系统自身高可用：</strong><ul><li>Borgmaster 多副本设计。</li><li>使用简单工具部署 Borg，避免过多外部依赖。</li><li>每个 Cell 的 Borg 独立部署，避免相互影响。</li></ul></li></ul><h4 id="2-5-Borg-的资源利用率"><a href="#2-5-Borg-的资源利用率" class="headerlink" title="2.5 Borg 的资源利用率"></a>2.5 Borg 的资源利用率</h4><ul><li><strong>混部：</strong> 在线任务（prod）和离线任务（non-prod）混合部署，充分利用资源。<ul><li>空闲时，离线任务可以使用更多资源。</li><li>繁忙时，在线任务优先执行。</li></ul></li><li><strong>效果：</strong><ul><li>98% 的服务器实现了混部。</li><li>90% 的服务器运行了超过 25 个 Task 和 4500 个线程。</li><li>相比独立部署，混合部署可以节省 20%-30% 的服务器。</li></ul></li></ul><h4 id="2-6-Borg-的调度原理"><a href="#2-6-Borg-的调度原理" class="headerlink" title="2.6 Borg 的调度原理"></a>2.6 Borg 的调度原理</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235416843.png" class="" title="image-20250316235416843"><pre class="mermaid">graph LR    A[machine] --> B(task)    B --> C[实际使用资源]    B --> D[保留资源]    B --> E[回收资源]    B --> F[限制资源]</pre><ul><li><strong>资源回收：</strong> 在 task 启动一段时间后，进行资源回收，将保留资源设置为实际使用资源加上一定的安全余量，并定期重新计算。</li></ul><h4 id="2-7-Borg-的隔离性"><a href="#2-7-Borg-的隔离性" class="headerlink" title="2.7 Borg 的隔离性"></a>2.7 Borg 的隔离性</h4><ul><li><strong>安全性隔离：</strong> 早期采用 Chroot jail，后期基于 Namespace。</li><li><strong>性能隔离：</strong> 采用基于 Cgroup 的容器技术。<ul><li>在线任务优先级高，离线任务优先级低。</li><li>通过抢占式调度，优先保障在线任务性能。</li><li>资源分为可压榨（如 CPU）和不可压榨（如内存）两种。</li></ul></li></ul><h3 id="3-Kubernetes：Borg-的开源版本"><a href="#3-Kubernetes：Borg-的开源版本" class="headerlink" title="3. Kubernetes：Borg 的开源版本"></a>3. Kubernetes：Borg 的开源版本</h3><p>Kubernetes（K8s）是谷歌开源的容器集群管理系统，是 Borg 的开源版本。</p><h4 id="3-1-K8s-的主要功能"><a href="#3-1-K8s-的主要功能" class="headerlink" title="3.1 K8s 的主要功能"></a>3.1 K8s 的主要功能</h4><ul><li>基于容器的应用部署、维护和滚动升级。</li><li>负载均衡和服务发现。</li><li>跨机器和跨地区的集群调度。</li><li>自动伸缩。</li><li>无状态服务和有状态服务。</li><li>插件机制保证扩展性。</li></ul><h4 id="3-2-命令式-vs-声明式"><a href="#3-2-命令式-vs-声明式" class="headerlink" title="3.2 命令式 vs 声明式"></a>3.2 命令式 vs 声明式</h4><ul><li><strong>命令式系统：</strong> 关注“如何做”，需要明确告诉系统每一步做什么。</li><li><strong>声明式系统：</strong> 关注“做什么”，只需要告诉系统你想要什么，系统会自动完成。</li></ul><p>Kubernetes 是一个声明式系统，具有以下特点：</p><ul><li><strong>声明式规范：</strong><ul><li>直接声明：直接告诉系统你的需求。</li><li>间接声明：把需求放在特定地方，系统会自动处理。</li></ul></li><li><strong>幂等性：</strong> 状态固定，每次操作返回相同结果。</li><li><strong>面向对象：</strong> 把一切抽象成对象。</li></ul><h4 id="3-3-Kubernetes-的核心对象"><a href="#3-3-Kubernetes-的核心对象" class="headerlink" title="3.3 Kubernetes 的核心对象"></a>3.3 Kubernetes 的核心对象</h4><ul><li><strong>Node：</strong> 计算节点的抽象。</li><li><strong>Namespace：</strong> 资源隔离的基本单位。</li><li><strong>Pod：</strong> 应用实例的抽象，包含镜像地址、资源需求等，是 K8s 最核心的对象。</li><li><strong>Service：</strong> 将应用发布成服务，本质上是负载均衡和域名服务的声明。</li></ul><h4 id="3-4-Kubernetes-的架构"><a href="#3-4-Kubernetes-的架构" class="headerlink" title="3.4 Kubernetes 的架构"></a>3.4 Kubernetes 的架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/kubernetes-cluster-architecture-2265122.svg" class="" title="image-20250316235421656"><ul><li><strong>Master Node（主节点）：</strong><ul><li><strong>API Server：</strong> 暴露 Kubernetes API，是集群的入口。</li><li><strong>Cluster Data Store (etcd)：</strong> 存储集群所有数据。</li><li><strong>Controller Manager：</strong> 运行各种控制器，确保集群状态与期望状态一致。</li><li><strong>Scheduler：</strong> 负责将 Pod 调度到合适的节点。</li></ul></li><li><strong>Worker Node（工作节点）：</strong><ul><li><strong>Kubelet：</strong> 管理 Pod 的生命周期，向 Master 节点汇报状态。</li><li><strong>Kube-proxy：</strong> 负责网络，维护网络规则，执行连接转发。</li><li><strong>Container Runtime：</strong> 负责运行容器（如 Docker）。</li></ul></li></ul><h4 id="3-5-Kubernetes-的其他组件"><a href="#3-5-Kubernetes-的其他组件" class="headerlink" title="3.5 Kubernetes 的其他组件"></a>3.5 Kubernetes 的其他组件</h4><ul><li><strong>etcd：</strong> 分布式 key-value 存储，用于服务发现、共享配置和一致性保障。</li><li><strong>APIServer：</strong> 提供集群管理的 REST API 接口，包括认证、授权、准入控制等。</li><li><strong>Controller Manager：</strong> 确保集群的真实状态与用户定义的期望状态一致。</li><li><strong>Scheduler：</strong> 监控未调度的 Pod，选择最佳节点进行调度。</li><li><strong>Kubelet：</strong> 从不同源获取 Pod 清单，并按需求启停 Pod。</li><li><strong>Kube-Proxy：</strong> 监控集群中用户发布的服务，并完成负载均衡配置。</li></ul><h4 id="3-6-Kubernetes-的常用-Add-ons"><a href="#3-6-Kubernetes-的常用-Add-ons" class="headerlink" title="3.6 Kubernetes 的常用 Add-ons"></a>3.6 Kubernetes 的常用 Add-ons</h4><ul><li><strong>kube-dns：</strong> 提供 DNS 服务。</li><li><strong>Ingress Controller：</strong> 提供外网入口。</li><li><strong>Metrics Server：</strong> 提供资源监控。</li><li><strong>Dashboard：</strong> 提供 GUI。</li><li><strong>Fluentd-Elasticsearch：</strong> 提供日志采集、存储与查询。</li></ul><h4 id="3-7-kubectl：Kubernetes-的命令行工具"><a href="#3-7-kubectl：Kubernetes-的命令行工具" class="headerlink" title="3.7 kubectl：Kubernetes 的命令行工具"></a>3.7 kubectl：Kubernetes 的命令行工具</h4><ul><li><strong>kubectl：</strong> 允许用户以命令行的方式与 Kubernetes 交互。</li><li><strong>kubeconfig：</strong> 配置文件，包含 apiserver 地址、用户信息等。</li><li><strong>常用命令：</strong><ul><li><code>kubectl get po -oyaml -w</code>：查看对象，输出 yaml 格式，并 watch 变化。</li><li><code>kubectl describe po &lt;pod_name&gt;</code>：展示资源的详细信息和相关 Event。</li><li><code>kubectl exec -it &lt;pod_name&gt; bash</code>：进入运行的容器。</li><li><code>kubectl logs &lt;pod_name&gt;</code>：查看 pod 的标准输出。</li></ul></li></ul><h3 id="4-深入理解-Kubernetes"><a href="#4-深入理解-Kubernetes" class="headerlink" title="4. 深入理解 Kubernetes"></a>4. 深入理解 Kubernetes</h3><h4 id="4-1-云计算的传统分类"><a href="#4-1-云计算的传统分类" class="headerlink" title="4.1 云计算的传统分类"></a>4.1 云计算的传统分类</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235428142.png" class="" title="image-20250316235428142"><ul><li><strong>IaaS (Infrastructure as a Service)：</strong> 提供基础设施，如虚拟机、存储、网络。</li><li><strong>PaaS (Platform as a Service)：</strong> 提供平台，如操作系统、运行时环境、数据库。</li><li><strong>SaaS (Software as a Service)：</strong> 提供软件，如邮件服务、CRM 系统。</li></ul><h4 id="4-2-Kubernetes-生态系统"><a href="#4-2-Kubernetes-生态系统" class="headerlink" title="4.2 Kubernetes 生态系统"></a>4.2 Kubernetes 生态系统</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235435441.png" class="" title="image-20250316235435441"><h4 id="4-3-Kubernetes-设计理念"><a href="#4-3-Kubernetes-设计理念" class="headerlink" title="4.3 Kubernetes 设计理念"></a>4.3 Kubernetes 设计理念</h4><ul><li><strong>可扩展性：</strong> 基于 CRD 的扩展，插件化的生态系统。</li><li><strong>高可用：</strong> 基于 replicaset、statefulset 的应用高可用，Kubernetes 组件本身高可用。</li><li><strong>可移植性：</strong> 多种 host OS 选择，多种基础架构的选择，多云和混合云。</li><li><strong>安全：</strong> 基于 TLS 提供服务，Serviceaccount 和 user，基于 Namespace 的隔离，secret，Taints，psp，networkpolicy。</li></ul><h4 id="4-4-Kubernetes-分层架构"><a href="#4-4-Kubernetes-分层架构" class="headerlink" title="4.4 Kubernetes 分层架构"></a>4.4 Kubernetes 分层架构</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235445064.png" class="" title="image-20250316235445064"><ul><li><strong>核心层：</strong> 提供 API 构建高层应用，提供插件式应用执行环境。</li><li><strong>应用层：</strong> 部署和路由。</li><li><strong>管理层：</strong> 系统度量、自动化、策略管理。</li><li><strong>接口层：</strong> kubectl 命令行工具、客户端 SDK 以及集群联邦。</li><li><strong>生态系统：</strong><ul><li>Kubernetes 外部：日志、监控、配置管理、CI&#x2F;CD 等。</li><li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider 等。</li></ul></li></ul><h4 id="4-5-API-设计原则"><a href="#4-5-API-设计原则" class="headerlink" title="4.5 API 设计原则"></a>4.5 API 设计原则</h4><ul><li>所有 API 都应是声明式的。</li><li>API 对象是彼此互补而且可组合的。</li><li>高层 API 以操作意图为基础设计。</li><li>低层 API 根据高层 API 的控制需要设计。</li><li>尽量避免简单封装。</li><li>API 操作复杂度与对象数量成正比。</li><li>API 对象状态不能依赖于网络连接状态。</li><li>尽量避免让操作机制依赖于全局状态。</li></ul><h4 id="4-6-Kubernetes-对象的组合"><a href="#4-6-Kubernetes-对象的组合" class="headerlink" title="4.6 Kubernetes 对象的组合"></a>4.6 Kubernetes 对象的组合</h4><img src="/2025/03/16/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20250316235450125.png" class="" title="image-20250316235450125"><pre class="mermaid">graph LR    A[Deployment] --> B(滚动升级策略)    A --> C(副本数)    A --> D[PodTemplate]    D --> E[Replicaset]    E --> F(版本信息)    E --> G(副本数)    E --> H[PodTemplate]    H --> I[Node]    H --> J[Pod]    H --> K[Service]    H --> L[Ingress]    I --> M(计算资源)    I --> N(健康状况)    J --> O(镜像地址)    J --> P(资源需求)    K --> Q(服务协议)    K --> R(服务端口)    L --> S(域名)    L --> T(访问 URL)    L --> U(目标服务)</pre><h4 id="4-7-架构设计原则"><a href="#4-7-架构设计原则" class="headerlink" title="4.7 架构设计原则"></a>4.7 架构设计原则</h4><ul><li>只有 APIServer 可以直接访问 etcd 存储。</li><li>单节点故障不应该影响集群的状态。</li><li>所有组件应该在内存中保持所需要的状态。</li><li>优先使用事件监听而不是轮询。</li></ul><h4 id="4-8-引导（Bootstrapping）原则"><a href="#4-8-引导（Bootstrapping）原则" class="headerlink" title="4.8 引导（Bootstrapping）原则"></a>4.8 引导（Bootstrapping）原则</h4><ul><li>Self-hosting 是目标。</li><li>减少依赖。</li><li>通过分层的原则管理依赖。</li><li>循环依赖问题的原则：<ul><li>接受其他方式的数据输入。</li><li>状态应该是可恢复或可重新发现的。</li><li>支持简单的启动临时实例来创建稳态运行所需要的状态。</li><li>自动重启异常退出的服务。</li></ul></li></ul><h4 id="4-9-核心技术概念和-API-对象"><a href="#4-9-核心技术概念和-API-对象" class="headerlink" title="4.9 核心技术概念和 API 对象"></a>4.9 核心技术概念和 API 对象</h4><ul><li><strong>API 对象：</strong> Kubernetes 集群中的管理操作单元。</li><li><strong>四大类属性：</strong><ul><li><strong>TypeMeta：</strong> 对象的类型定义（GKV 模型）。<ul><li>Group：对象的分组。</li><li>Kind：对象的基本类型。</li><li>Version：对象的版本。</li></ul></li><li><strong>MetaData：</strong> 对象的元数据。<ul><li>Namespace：对象的命名空间。</li><li>Name：对象的名称。</li><li>Label：对象的标签，用于识别和选择对象。</li><li>Annotation：对象的注解，用于记录附加信息。</li><li>Finalizer：资源锁，用于控制对象的删除。</li><li>ResourceVersion：乐观锁，用于并发访问对象。</li></ul></li><li><strong>Spec：</strong> 用户的期望状态。</li><li><strong>Status：</strong> 对象的实际状态。</li></ul></li></ul><h4 id="4-10-常用-Kubernetes-对象及其分组"><a href="#4-10-常用-Kubernetes-对象及其分组" class="headerlink" title="4.10 常用 Kubernetes 对象及其分组"></a>4.10 常用 Kubernetes 对象及其分组</h4><ul><li><strong>Node：</strong> Pod 运行的主机。</li><li><strong>Namespace：</strong> 资源和对象的抽象集合。</li><li><strong>Pod：</strong> 一组紧密关联的容器集合，共享 PID、IPC、Network 和 UTS namespace。<ul><li><strong>环境变量：</strong> 设置容器的环境变量。</li><li><strong>存储卷：</strong> 将外挂存储挂载到 Pod 内部。</li><li><strong>Pod 网络：</strong> 多个容器共享网络 Namespace。</li><li><strong>资源限制：</strong> 限制每个容器的 CPU 和内存使用。</li><li><strong>健康检查：</strong> 探测应用是否健康和就绪。</li></ul></li><li><strong>ConfigMap：</strong> 保存非机密性的数据到键值对中。</li><li><strong>Secret：</strong> 保存和传递密码、密钥、认证凭证等敏感信息。</li><li><strong>User Account &amp; Service Account：</strong><ul><li>User Account：为人提供账户标识。</li><li>Service Account：为计算机进程和 Pod 提供账户标识。</li></ul></li><li><strong>Service：</strong> 应用服务的抽象，通过 labels 提供负载均衡和服务发现。</li><li><strong>Replica Set：</strong> 定义 Pod 的副本数，保证指定数量的 Pod 正常运行。</li><li><strong>Deployment：</strong> 表示用户对 Kubernetes 集群的一次更新操作。</li><li><strong>StatefulSet：</strong> 用于管理有状态应用，每个 Pod 挂载自己独立的存储。</li><li><strong>Job：</strong> 控制批处理型任务。</li><li><strong>DaemonSet：</strong> 保证每个节点上都有一个 Pod 运行。</li><li><strong>PersistentVolume (PV) &amp; PersistentVolumeClaim (PVC)：</strong><ul><li>PV：集群中的一块存储卷。</li><li>PVC：用户对存储的请求。</li></ul></li><li><strong>CustomResourceDefinition (CRD)：</strong> 允许用户自定义对象。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言进阶</title>
    <link href="/2025/03/16/golang%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/03/16/golang%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>这篇博客将深入探讨 Go 语言的一些核心概念，包括并发编程中的线程加锁和调度、内存管理机制，以及依赖管理。这些概念是构建高性能、可扩展的 Go 应用程序的基础。</p><span id="more"></span><h3 id="1-线程加锁"><a href="#1-线程加锁" class="headerlink" title="1. 线程加锁"></a>1. 线程加锁</h3><p>在并发编程中，多个 goroutine（Go 语言的轻量级线程）可能会同时访问和修改共享资源。为了防止数据竞争和不一致，我们需要使用锁机制来协调对共享资源的访问。</p><p><strong>Go 语言的锁机制</strong></p><p>Go 语言不仅提供了基于 CSP（Communicating Sequential Processes）的通道（channel）通信模型，还支持基于共享内存的多线程数据访问。<code>sync</code> 包提供了多种锁原语，以满足不同的并发场景需求：</p><ul><li><strong><code>sync.Mutex</code>（互斥锁）</strong>:<ul><li>最基本的锁类型，用于保护临界区，确保同一时间只有一个 goroutine 可以访问共享资源。</li><li>使用 <code>Lock()</code> 方法加锁，<code>Unlock()</code> 方法解锁。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    counter <span class="hljs-type">int</span><br>    mutex   sync.Mutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span></span> &#123;<br>    mutex.Lock() <span class="hljs-comment">// 加锁</span><br>    counter++<br>    mutex.Unlock() <span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.RWMutex</code>（读写锁）</strong>:<ul><li>适用于读多写少的场景。</li><li>允许多个 goroutine 同时读取共享资源，但在写入时会阻塞所有其他 goroutine（包括读取和写入）。</li><li>使用 <code>RLock()</code> 和 <code>RUnlock()</code> 方法进行读锁定，<code>Lock()</code> 和 <code>Unlock()</code> 方法进行写锁定。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    data    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>    rwMutex sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readData</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    rwMutex.RLock() <span class="hljs-comment">// 读锁定</span><br>    <span class="hljs-keyword">defer</span> rwMutex.RUnlock()<br>    <span class="hljs-keyword">return</span> data[key]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeData</span><span class="hljs-params">(key, value <span class="hljs-type">string</span>)</span></span> &#123;<br>    rwMutex.Lock() <span class="hljs-comment">// 写锁定</span><br>    <span class="hljs-keyword">defer</span> rwMutex.Unlock()<br>    data[key] = value<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.WaitGroup</code></strong>:<ul><li>用于等待一组 goroutine 完成。</li><li><code>Add(n)</code> 方法增加等待的 goroutine 数量，<code>Done()</code> 方法表示一个 goroutine 完成，<code>Wait()</code> 方法阻塞直到所有 goroutine 完成。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 表示当前 goroutine 完成</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d starting\n&quot;</span>, id)<br>    <span class="hljs-comment">// 执行任务...</span><br>    fmt.Printf(<span class="hljs-string">&quot;Worker %d done\n&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 增加等待的 goroutine 数量</span><br>        <span class="hljs-keyword">go</span> worker(i, &amp;wg)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 阻塞，直到所有 goroutine 完成</span><br>    fmt.Println(<span class="hljs-string">&quot;All workers done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.Once</code></strong>:<ul><li>确保某个函数只执行一次，常用于单例模式的初始化。</li><li><code>Do(f)</code> 方法接收一个函数 <code>f</code> 作为参数，并保证 <code>f</code> 只会被调用一次。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>    once     sync.Once<br>    instance *MySingleton<br>)<br><br><span class="hljs-keyword">type</span> MySingleton <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *MySingleton &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// 保证只执行一次</span><br>        instance = &amp;MySingleton&#123;&#125;<br>        <span class="hljs-comment">// 初始化 instance...</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><code>sync.Cond</code>（条件变量）</strong>:<ul><li>用于协调多个 goroutine 在满足特定条件时等待或被唤醒。</li><li><code>Wait()</code> 方法阻塞当前 goroutine，直到其他 goroutine 调用 <code>Signal()</code> 或 <code>Broadcast()</code> 方法唤醒。</li><li><code>Signal()</code> 方法唤醒一个等待的 goroutine，<code>Broadcast()</code> 方法唤醒所有等待的 goroutine。</li><li>通常与互斥锁一起使用，以保护条件。</li><li>下面是 Kubernetes 中使用的 <code>sync.Cond</code> 示例：</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Type <span class="hljs-keyword">struct</span> &#123;<br>cond sync.Cond<br><span class="hljs-comment">// ... 其他字段</span><br>&#125;<br><br><span class="hljs-comment">// Add marks item as needing processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span></span> Add(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>q.cond.L.Lock()<br><span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><span class="hljs-comment">// ... 添加 item 到队列的逻辑 ...</span><br>q.cond.Signal() <span class="hljs-comment">// 唤醒一个等待的 goroutine</span><br>&#125;<br><br><span class="hljs-comment">// Get blocks until it can return an item to be processed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Type)</span></span> Get() (item <span class="hljs-keyword">interface</span>&#123;&#125;, shutdown <span class="hljs-type">bool</span>) &#123;<br>q.cond.L.Lock()<br><span class="hljs-keyword">defer</span> q.cond.L.Unlock()<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.queue) == <span class="hljs-number">0</span> &amp;&amp; !q.shuttingDown &#123;<br>q.cond.Wait() <span class="hljs-comment">// 等待条件满足（队列中有元素）</span><br>&#125;<br><span class="hljs-comment">// ... 从队列中取出 item 的逻辑 ...</span><br><span class="hljs-keyword">return</span> item, <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码示例：Kubernetes 中的锁应用</strong></p><ul><li><strong><code>sharedInformerFactory</code> 中的 <code>sync.Mutex</code></strong>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// Start initializes all requested informers.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    f.lock.Lock() <span class="hljs-comment">// 加锁</span><br>    <span class="hljs-keyword">defer</span> f.lock.Unlock() <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br>        <span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<br>            <span class="hljs-keyword">go</span> informer.Run(stopCh)<br>            f.startedInformers[informerType] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了 Kubernetes 的 <code>sharedInformerFactory</code> 如何使用互斥锁来保护 <code>informers</code> 和 <code>startedInformers</code> 字段，确保在启动 informer 时不会发生并发冲突。</p><ul><li><strong><code>PodClient</code> 中的 <code>sync.WaitGroup</code></strong>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// CreateBatch create a batch of pods. All pods are created before</span><br><span class="hljs-comment">// waiting.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PodClient)</span></span> CreateBatch(pods []*v1.Pod) []*v1.Pod &#123;<br>    ps := <span class="hljs-built_in">make</span>([]*v1.Pod, <span class="hljs-built_in">len</span>(pods))<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 增加等待的 goroutine 数量</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, pod *v1.Pod)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// 表示当前 goroutine 完成</span><br>            <span class="hljs-keyword">defer</span> GinkgoRecover()<br>            ps[i] = c.CreateSync(pod)<br>        &#125;(i, pod)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 阻塞，直到所有 goroutine 完成</span><br>    <span class="hljs-keyword">return</span> ps<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了 Kubernetes 的 <code>PodClient</code> 如何使用 <code>sync.WaitGroup</code> 来并发创建多个 Pod，并在所有 Pod 创建完成后返回结果。</p><h3 id="2-线程调度"><a href="#2-线程调度" class="headerlink" title="2. 线程调度"></a>2. 线程调度</h3><p>在操作系统层面，线程是调度的基本单位。理解线程调度对于理解 Go 语言的 goroutine 调度至关重要。</p><p><strong>进程与线程</strong></p><ul><li><strong>进程</strong>: 资源分配的基本单位。每个进程都有独立的内存空间、文件句柄、信号处理等。</li><li><strong>线程</strong>: 调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源（如内存空间），但有各自的栈和寄存器。</li></ul><p>在 Linux 中，无论是进程还是线程，都由 <code>task_struct</code> 结构体表示。从内核的角度来看，进程和线程没有本质区别。Glibc 提供的 <code>pthread</code> 库实现了 NPTL（Native POSIX Threading Library），为用户空间提供了线程支持。</p><p><strong>Linux 进程的内存模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235836393.png" class="" title="image-20250316235836393"><pre class="mermaid">graph LR    subgraph 虚拟地址空间        A[内核空间] --> B(参数环境变量)        B --> C[栈 Stack]        C --> D[未分配内存]        D --> E[堆 Heap]        E --> F[未初始化数据 BSS]        F --> G[已初始化数据 Data]        G --> H[程序代码 Text]    end      subgraph 物理内存        I[物理内存]    end    subgraph 磁盘        J[磁盘_虚拟内存]    end      H --> PGD    PGD --> PUD    PUD --> PMD    PMD --> PT    PT --> I    I -- 换出/换入 --> J      A -.->|用户空间不可见| I    style D fill:#f9f,stroke:#333,stroke-width:2px</pre><ul><li><strong>内核空间</strong>: 存放内核代码和数据，用户程序不能直接访问。</li><li><strong>栈 (Stack)</strong>: 存储局部变量、函数参数、返回值等。栈的大小是有限的，由操作系统或编译器决定。</li><li><strong>堆 (Heap)</strong>: 动态分配的内存区域，用于存储程序运行时创建的对象。</li><li><strong>BSS 段</strong>: 存储未初始化的全局变量和静态变量。</li><li><strong>数据段 (Data)</strong>: 存储已初始化的全局变量和静态变量。</li><li><strong>代码段 (Text)</strong>: 存储程序的机器指令。</li></ul><p><strong>CPU 对内存的访问</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235840260.png" class="" title="image-20250316235840260"><pre class="mermaid">graph LR    A[CPU] --> B(MMU)    B --> C{TLB}    C -- 命中 --> F[总线]    C -- 未命中 --> D[页表 PGD/PUD/PMD/PT]    D --> F    F --> E[物理内存]</pre><ol><li>CPU 发出虚拟地址。</li><li>MMU（Memory Management Unit）首先在 TLB（Translation Lookaside Buffer）中查找虚拟地址对应的物理地址。</li><li>如果 TLB 命中，则直接从 TLB 中获取物理地址。</li><li>如果 TLB 未命中，则 MMU 需要查询页表（PGD、PUD、PMD、PT）来获取物理地址，并将映射关系缓存到 TLB 中。</li><li>CPU 使用物理地址访问内存。</li></ol><p><strong>进程切换开销</strong></p><p>进程切换的开销主要包括：</p><ul><li><strong>直接开销</strong>:<ul><li>切换页表全局目录（PGD）。</li><li>切换内核态堆栈。</li><li>切换硬件上下文（寄存器等）。</li><li>刷新 TLB。</li><li>执行系统调度器的代码。</li></ul></li><li><strong>间接开销</strong>:<ul><li>CPU 缓存失效，导致访问内存的次数增加。</li></ul></li></ul><p><strong>线程切换开销</strong></p><p>线程切换比进程切换开销小，因为同一进程内的线程共享虚拟地址空间，不需要切换页表。但线程切换仍然需要内核参与，进行上下文切换。</p><p><strong>用户线程 vs. 内核线程</strong></p><ul><li><strong>用户线程</strong>: 在用户空间创建和管理，无需内核支持。创建和销毁速度快，但不能利用多核 CPU。</li><li><strong>内核线程</strong>: 由内核创建和管理，可以利用多核 CPU，但创建和销毁开销较大。</li></ul><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235844279.png" class="" title="image-20250316235844279"><pre class="mermaid">graph LR    subgraph 用户态        A[Process] --> B[User Thread]        A --> C[User Thread]        D[Process] --> E[User Thread]        D --> F[User Thread]        G[Process] --> H[User Thread]        G --> I[User Thread]    end    subgraph 内核态        B --> J[Kernel Thread]        C --> J        E --> K[Kernel Thread]        F --> K        H --> L[Kernel Thread]        I --> L    end    J --> M[CPU]    K --> M    L --> M</pre><p><strong>Goroutine</strong></p><p>Go 语言通过 GMP 模型实现了用户态线程（goroutine）：</p><ul><li><strong>G (Goroutine)</strong>: 代表一个 goroutine，拥有自己的栈空间、定时器等。初始栈大小为 2KB，可按需增长。</li><li><strong>M (Machine)</strong>: 代表内核线程，负责执行 goroutine。M 会保存 goroutine 的栈信息，以便在调度时恢复执行。</li><li><strong>P (Processor)</strong>: 代表逻辑处理器，负责调度 goroutine。P 维护一个本地 goroutine 队列，M 从 P 获取 goroutine 并执行。P 还负责部分内存管理。</li></ul><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235849700.png" class="" title="image-20250316235849700"><pre class="mermaid">graph LR    subgraph 全局资源        A(GRQ - 全局可运行G队列)        B(sudog - 阻塞队列)        C(gFree - 全局自由G列表)        D(pidle - 全局空闲P列表)    end    subgraph P的本地资源        E(LRQ - 本地可运行G队列)        F(gFree - 本地自由G列表)    end    A -- G --> E    B -- G --> M    C -- G --> C      D -- P --> D      E -- G --> M    F -- G --> F    M --> P    P --> CPU    G1(G - Grunnable) -- 状态 --> G2(G - Grunning)    G2 -- 状态 --> G3(G - Gwaiting)    G2 -- 状态 --> G4(G - Gsyscall)    G3 -- 状态 --> G1    G4 -- 状态 --> G1    G2 -- 状态 --> G5(G - Gdead)    G5 -- 状态 --> F    P1(P - Pidle) -- 状态 --> P2(P - Prunning)    P2 -- 状态 --> P3(P - Psyscall)    P3 -- 状态 --> P1</pre><p><strong>Goroutine 的创建过程</strong></p><ol><li>获取或创建新的 Goroutine 结构体：<ul><li>尝试从 P 的 <code>gFree</code> 列表中获取空闲的 Goroutine。</li><li>如果 <code>gFree</code> 列表为空，则通过 <code>runtime.malg</code> 创建一个新的 Goroutine 结构体。</li></ul></li><li>将函数参数复制到 Goroutine 的栈上。</li><li>更新 Goroutine 的调度信息，将其状态设置为 <code>_Grunnable</code>。</li><li>将 Goroutine 存储到全局变量 <code>allgs</code> 中。</li><li>将 Goroutine 放入运行队列：<ul><li>优先放入 P 的 <code>runnext</code> 字段，作为下一个要执行的 Goroutine。</li><li>如果 P 的本地运行队列已满，则将一部分 Goroutine 和待加入的 Goroutine 放入全局运行队列。</li></ul></li></ol><p><strong>调度器行为</strong></p><ol><li><strong>公平性</strong>: 如果全局运行队列中有待执行的 Goroutine，调度器会以一定概率从全局队列中选择 Goroutine 执行。</li><li><strong>本地队列</strong>: 调度器优先从 P 的本地运行队列中选择 Goroutine 执行。</li><li><strong>阻塞查找</strong>: 如果本地队列和全局队列都为空，调度器会通过 <code>runtime.findrunnable</code> 函数阻塞地查找可运行的 Goroutine：<ul><li>从本地队列、全局队列、网络轮询器中查找。</li><li>尝试从其他 P 的本地队列中窃取 Goroutine。</li></ul></li></ol><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><p>内存管理是程序设计中的关键问题。手动管理内存容易出错，而自动管理内存（垃圾回收）可能会影响性能。Go 语言采用了自动垃圾回收机制，并对内存管理进行了优化。</p><p><strong>堆内存管理</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235855215.png" class="" title="image-20250316235855215"><pre class="mermaid">graph LR    A{Mutator} --> B{Allocator}    B --> C{Heap}    C --> D{Object Header}    C --> E{Collector}    B --> E    style C fill:#ccf,stroke:#333,stroke-width:2px</pre><ul><li><strong>Mutator</strong>: 用户程序，通过 Allocator 申请内存。</li><li><strong>Allocator</strong>: 内存分配器，负责从堆中分配内存块。</li><li><strong>Heap</strong>: 堆，一块连续的内存区域，用于动态分配。</li><li><strong>Object Header</strong>: 对象头，存储对象的元数据（大小、是否被使用、下一个对象的地址等）。</li><li><strong>Collector</strong>: 垃圾回收器，负责回收不再使用的内存。</li></ul><p><strong>TCMalloc</strong></p><p>Go 语言的内存分配器借鉴了 TCMalloc（Thread-Caching Malloc）的思想。</p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235905932.png" class="" title="image-20250316235905932"><pre class="mermaid">graph LR    subgraph        A["Virtual Memory"]    end    subgraph "PageHeap"        B["PageHeap"] --> C["Span list 1 (1 page)"]        B --> D["Span list 2 (2 pages)"]        B --> E["... (3-127 pages)"]        B --> F["Span list 128 (128 pages = 1MB)"]        B --> G["Large span set (Large and medium object)"]    end      subgraph "CentralCache"      H["CentralCache"] --> I["Size class 0"]      H --> J["Size class 1"]      H --> K["..."]      H --> L["Size class n"]      I --> C      J --> D      L --> F    end    subgraph "ThreadCache"        M["ThreadCache 1"] --> N["Size class 0"]        M --> O["Size class 1"]        M --> P["..."]        M --> Q["Size class n"]        N --> FreeObject["(Free Object)"]    end      subgraph "ThreadCache"      R["ThreadCache 2"]    end    subgraph "ThreadCache"        S["ThreadCache n"]    end      M --> H    R --> H    S --> H    T["Application"] --> M    T --> R    T --> S</pre><ul><li><strong>page</strong>: 内存页，8KB 大小的内存块。Go 语言与操作系统之间的内存申请和释放都以 page 为单位。</li><li><strong>span</strong>: 内存块，由一个或多个连续的 page 组成。</li><li><strong>sizeclass</strong>: 空间规格，每个 span 都有一个 sizeclass，表示 span 中的 page 应该如何使用。</li><li><strong>object</strong>: 对象，用于存储变量数据的内存空间。一个 span 在初始化时会被分割成多个等大小的 object。</li></ul><p><strong>对象大小</strong></p><ul><li><strong>小对象</strong>: 0 ~ 256KB</li><li><strong>中对象</strong>: 256KB ~ 1MB</li><li><strong>大对象</strong>: &gt; 1MB</li></ul><p><strong>分配流程</strong></p><ul><li><strong>小对象</strong>: ThreadCache -&gt; CentralCache -&gt; HeapPage。通常情况下，ThreadCache 足够满足小对象的分配需求，无需访问 CentralCache 和 HeapPage。</li><li><strong>中对象</strong>: 直接从 PageHeap 中选择合适大小的 span。</li><li><strong>大对象</strong>: 从 large span set 中选择合适数量的 page 组成 span。</li></ul><p><strong>Go 语言内存分配</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235913087.png" class="" title="image-20250316235913087"><pre class="mermaid">graph LR    subgraph 虚拟内存        A[Virtual Memory]    end      subgraph arenas        B[arenas] --> C[heapArena]        B --> D[heapArena]        B --> E[...]        C --> F[span class 133]        C --> G[span class 134]        D --> H[span class 134]    end    subgraph mheap        I[mheap] --> J[free]        I --> K[scav]        I --> L[mcentral]        I --> B        L --> M[span class 0]        L --> N[span class 1]        L --> O[...]        M --> P[Span]        P --> Q[Pages]    end      subgraph mcache        R[mcache of P1] --> S[span class 0]        R --> T[span class 1]        R --> U[...]        S --> V[Free Object]    end    subgraph mcache        W[mcache of P2]    end    subgraph mcache        X[mcache of P3]    end      R --> L    W --> L    X --> L      Y[Application] --> R    Y --> W    Y --> X    Y --> LargeObject[(Large and medium object)]    Y --> TinyObject[(Tiny object)]    LargeObject --> B</pre><ul><li><strong><code>mcache</code></strong>: 小对象的内存分配直接从 <code>mcache</code> 获取。<code>mcache</code> 包含多个 size class（1 到 66），每个 class 有两个 span。span 大小为 8KB，根据 size class 的大小进行切分。</li><li><strong><code>mcentral</code></strong>: 当 <code>mcache</code> 中的 span 没有剩余空间时，会向 <code>mcentral</code> 申请一个 span。<code>mcentral</code> 如果没有符合条件的 span，则会向 <code>mheap</code> 申请。</li><li><strong><code>mheap</code></strong>: 当 <code>mheap</code> 没有足够的内存时，会向操作系统申请内存。<code>mheap</code> 将 span 组织成树结构，并分配到 <code>heapArena</code> 进行管理。<code>heapArena</code> 包含地址映射和 span 是否包含指针等位图信息。</li></ul><p><strong>内存回收</strong></p><p>常见的垃圾回收算法包括：</p><ul><li><strong>引用计数</strong>: 为每个对象维护一个引用计数，当引用计数为 0 时回收对象。<ul><li>优点：对象可以很快被回收。</li><li>缺点：无法处理循环引用，维护引用计数有开销。</li></ul></li><li><strong>标记-清除</strong>: 从根对象开始遍历所有可达对象，标记为“被引用”，未被标记的对象被回收。<ul><li>优点：可以处理循环引用。</li><li>缺点：需要 STW（Stop The World），暂停程序运行。</li></ul></li><li><strong>分代收集</strong>: 根据对象的生命周期将内存划分为不同的代，对不同代采用不同的回收频率。<ul><li>优点：提高回收效率。</li><li>缺点：实现复杂。</li></ul></li></ul><p>Go 语言采用<strong>标记-清除</strong>算法，并进行了优化。</p><p><strong><code>mspan</code></strong></p><ul><li><strong><code>allocBits</code></strong>: 记录了每块内存的分配情况。</li><li><strong><code>gcmarkBits</code></strong>: 记录了每块内存的引用情况。在标记阶段，有对象引用的内存块被标记为 1，没有的标记为 0。</li></ul><p>标记结束后，<code>allocBits</code> 指向 <code>gcmarkBits</code>，被标记的内存块保留，未标记的被回收。</p><p><strong>GC 工作流程</strong></p><p>Go 语言的 GC 大部分过程与用户代码并发执行。</p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235919958.png" class="" title="image-20250316235919958"><pre class="mermaid">graph LR    A[关闭 GC] --> B{栈扫描}    B -- 开启写屏障 --> C["STW (开启写屏障等准备工作)"]    C --> D["标记 (从全局空间和 goroutine 栈扫描变量)"]    D -- "三色标记，直到没有灰色对象" --> E["标记结束 (STW, 重新扫描 root 区域新变量)"]    E --> F["清除 (关闭 STW 和写屏障，清除白色对象)"]    F --> A</pre><ol><li><strong>Mark</strong>:<ul><li><strong>Mark Prepare</strong>: 初始化 GC 任务，开启写屏障（write barrier）和辅助 GC（mutator assist），统计 root 对象的数量。这个阶段需要 STW。</li><li><strong>GC Drains</strong>: 扫描所有 root 对象（全局指针和 goroutine 栈上的指针），将它们加入标记队列（灰色队列），并循环处理灰色队列中的对象，直到队列为空。这个阶段并发执行。</li><li><strong>Mark Termination</strong>: 完成标记工作，重新扫描全局指针和栈。由于 Mark 阶段与用户程序并发执行，可能会有新的对象分配和指针赋值，写屏障会记录这些变化，re-scan 阶段会再次检查。这个阶段需要 STW。</li></ul></li><li><strong>Sweep</strong>: 根据标记结果回收所有白色对象。这个阶段并发执行。</li><li><strong>Sweep Termination</strong>: 清扫未被清扫的 span。只有上一轮 GC 的清扫工作完成后，才能开始新一轮 GC。</li></ol><p><strong>三色标记</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235925383.png" class="" title="image-20250316235925383"><pre class="mermaid">graph LR    A["a"] --> B["b"]    A["a"] --> C["c"]    B["b"] --> D["d"]    subgraph "初始状态"        A1["a (白色)"] --> B1["b (白色)"]        A1["a (白色)"] --> C1["c (白色)"]        B1["b (白色)"] --> D1["d (白色)"]    end    subgraph "第一次遍历"        A2["a (灰色)"] --> B2["b (白色)"]        A2["a (灰色)"] --> C2["c (白色)"]        B2["b (白色)"] --> D2["d (白色)"]    end    subgraph "第二次遍历"        A3["a (黑色)"] --> B3["b (灰色)"]        A3["a (黑色)"] --> C3["c (灰色)"]        B3["b (灰色)"] --> D3["d (白色)"]    end    subgraph "第三次遍历"        A4["a (黑色)"] --> B4["b (黑色)"]        A4["a (黑色)"] --> C4["c (灰色)"]        B4["b (黑色)"] --> D4["d (白色)"]    end      subgraph "第四次遍历"        A5["a (黑色)"] --> B5["b (黑色)"]        A5["a (黑色)"] --> C5["c (黑色)"]        B5["b (黑色)"] --> D5["d (灰色)"]    end        subgraph "第五次遍历"        A6["a (黑色)"] --> B6["b (黑色)"]        A6["a (黑色)"] --> C6["c (黑色)"]        B6["b (黑色)"] --> D6["d (黑色)"]    end</pre><ol><li>GC 开始时，所有对象都被认为是白色（垃圾）。</li><li>从 root 对象开始遍历，可达对象被标记为灰色。</li><li>遍历所有灰色对象，将它们引用的对象标记为灰色，自身标记为黑色。</li><li>重复第 3 步，直到没有灰色对象，只剩下黑色和白色对象。白色对象即为垃圾。</li><li>对于黑色对象，如果在标记期间发生了写操作，写屏障会在赋值前将新对象标记为灰色。</li><li>标记过程中新分配的对象会被直接标记为黑色。</li></ol><p><strong>垃圾回收触发机制</strong></p><ul><li><strong>内存分配量达到阈值</strong>:<ul><li>每次内存分配时都会检查当前内存分配量是否达到阈值。</li><li>阈值 &#x3D; 上次 GC 内存分配量 * 内存增长率。</li><li>内存增长率由环境变量 <code>GOGC</code> 控制，默认为 100（即内存扩大一倍时触发 GC）。</li></ul></li><li><strong>定期触发</strong>: 默认情况下，每 2 分钟触发一次 GC。</li><li><strong>手动触发</strong>: 使用 <code>runtime.GC()</code> 函数手动触发 GC。</li></ul><h3 id="4-包引用与依赖管理"><a href="#4-包引用与依赖管理" class="headerlink" title="4. 包引用与依赖管理"></a>4. 包引用与依赖管理</h3><p>Go 语言的依赖管理经历了从 GOPATH 到 vendor，再到 Go Modules 的演变过程。</p><p><strong>GOPATH</strong></p><ul><li>通过环境变量 <code>GOPATH</code> 设置 Go 语言类库的目录。</li><li>问题：<ul><li>不同项目可能依赖同一库的不同版本。</li><li>代码被克隆后需要设置 <code>GOPATH</code> 才能编译。</li></ul></li></ul><p><strong>vendor</strong></p><ul><li>Go 1.6 版本引入了 <code>vendor</code> 目录。</li><li>每个项目创建一个 <code>vendor</code> 目录，并将依赖复制到该目录。</li><li>Go 语言项目会自动将 <code>vendor</code> 目录作为依赖路径。</li><li>优点：<ul><li>每个项目的 <code>vendor</code> 目录独立，可以灵活选择版本。</li><li><code>vendor</code> 目录与源代码一起提交，其他人克隆后可以直接编译。</li><li>编译期间无需下载依赖。</li></ul></li></ul><p><strong>vendor 管理工具</strong></p><ul><li>Godeps, Glide</li><li>Go 官方的依赖管理工具 Gopkg</li><li>Go Modules (gomod)</li></ul><p><strong>Go Modules (gomod)</strong></p><ul><li>通过 <code>go mod</code> 命令开启：<code>export GO111MODULE=on/off/auto</code></li><li>更灵活易用，基本统一了 Go 语言的依赖管理。</li></ul><p><strong>Go Modules 的目的</strong></p><ul><li>版本管理</li><li>防止篡改</li></ul><p><strong>Go Modules 使用</strong></p><ol><li>创建项目。</li><li>初始化 Go 模块：<code>go mod init</code></li><li>下载依赖包：<code>go mod download</code>（依赖包下载到 <code>$GOPATH/pkg</code>，如果没有设置 <code>GOPATH</code>，则下载到项目根目录下的 <code>pkg</code> 目录）。</li><li>在代码中使用依赖包，例如 <code>github.com/emicklei/go-restful</code>。</li><li>添加缺少的依赖并清理：<code>go mod tidy</code></li><li>将依赖复制到 <code>vendor</code> 目录：<code>go mod vendor</code></li></ol><p><strong><code>go.mod</code> 文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">module k8s.io/apiserver<br><br>go 1.13<br><br>require (<br>github.com/evanphx/json-patch v4.9.0+incompatible<br>github.com/go-openapi/jsonreference v0.19.3 // indirect<br>github.com/go-openapi/spec v0.19.3<br>github.com/gogo/protobuf v1.3.2<br>github.com/google/go-cmp v0.3.0<br>github.com/google/gofuzz v1.1.0<br>k8s.io/apimachinery v0.0.0-20210518100737-44f1264f7b6b<br>)<br><br>replace (<br>golang.org/x/crypto =&gt; golang.org/x/crypto v0.0.0-20200220183623-bac4c82f6975<br>golang.org/x/text =&gt; golang.org/x/text v0.3.2<br>k8s.io/api =&gt; k8s.io/api v0.0.0-20210518101910-53468e23a787<br>k8s.io/apimachinery =&gt; k8s.io/apimachinery v0.0.0-20210518100737-44f1264f7b6b<br>k8s.io/client-go =&gt; k8s.io/client-go v0.0.0-20210518104342-fa3acefe68f3<br>k8s.io/component-base =&gt; k8s.io/component-base v0.0.0-20210518111421-67c12a31a26a<br>)<br></code></pre></td></tr></table></figure><ul><li><code>module</code>: 定义模块的导入路径。</li><li><code>go</code>: 指定 Go 语言版本。</li><li><code>require</code>: 指定依赖包及其版本。</li><li><code>replace</code>: 替换依赖包。</li></ul><p><strong><code>GOPROXY</code> 和 <code>GOPRIVATE</code></strong></p><ul><li><strong><code>GOPROXY</code></strong>: 设置 Go 依赖的代理。<ul><li><code>export GOPROXY=https://goproxy.cn</code></li><li>设置 <code>GOPROXY</code> 后，默认所有依赖都会通过代理拉取，并进行 checksum 校验。</li></ul></li><li><strong><code>GOPRIVATE</code></strong>: 声明私有代码仓库，避免通过 <code>GOPROXY</code> 拉取。<ul><li><code>GOPRIVATE=*.corp.example.com</code></li><li><code>GONOPROXY=myrepo.corp.example.com</code></li><li><code>GOPROXY=proxy.example.com</code></li></ul></li></ul><h3 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5. Makefile"></a>5. Makefile</h3><p>Go 语言项目通常使用 Makefile 来组织编译过程。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ROOT=github.com/cncamp/golang<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: root</span><br><span class="hljs-section">root:</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: release</span><br><span class="hljs-section">release:</span><br>@echo <span class="hljs-string">&quot;building httpserver binary&quot;</span><br>@mkdir -p bin/amd64<br>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/amd64 .<br></code></pre></td></tr></table></figure><ul><li><code>.PHONY</code>: 声明伪目标。</li><li><code>release</code>: 定义构建目标，设置环境变量 <code>CGO_ENABLED</code>、<code>GOOS</code> 和 <code>GOARCH</code>，然后使用 <code>go build</code> 编译程序。</li></ul><h3 id="6-编写-HTTP-Server"><a href="#6-编写-HTTP-Server" class="headerlink" title="6. 编写 HTTP Server"></a>6. 编写 HTTP Server</h3><p><strong>理解 <code>net/http</code> 包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">healthz</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>io.WriteString(w, <span class="hljs-string">&quot;ok\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/healthz&quot;</span>, healthz) <span class="hljs-comment">// 注册处理函数</span><br>err := http.ListenAndServe(<span class="hljs-string">&quot;:80&quot;</span>, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 监听端口，使用默认的 DefaultServeMux</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>http.HandleFunc</code>: 注册处理函数，将 URL 路径与处理函数关联起来。</li><li><code>http.ListenAndServe</code>: 启动 HTTP 服务器，监听指定端口。第二个参数为 <code>nil</code> 时，使用默认的 <code>DefaultServeMux</code>。</li><li><code>healthz</code>: 处理函数，接收 <code>http.ResponseWriter</code> 和 <code>http.Request</code> 作为参数。</li></ul><p><strong>阻塞 IO 模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235937032.png" class="" title="image-20250316235937032"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    Note over 应用进程,系统内核: 进程阻塞于 recvfrom 调用    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据    Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>非阻塞 IO 模型</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235942132.png" class="" title="image-20250316235942132"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    系统内核-->>应用进程: 返回错误    Note over 应用进程: 进程重复调用 recvfrom    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文尚未就绪    系统内核-->>应用进程: 返回错误    Note over 应用进程: ...    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据     Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>IO 多路复用</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235948370.png" class="" title="image-20250316235948370"><pre class="mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程->>系统内核: select/poll (系统调用)    Note over 系统内核: 数据报文尚未就绪    Note over 应用进程,系统内核: 进程阻塞于 select/poll 调用，等待有可读的 socket    系统内核-->>应用进程: 返回可读    应用进程->>系统内核: recvfrom (系统调用)    Note over 系统内核: 数据报文就绪    系统内核->>应用进程: 拷贝数据    Note over 应用进程,系统内核: 数据复制到进程缓冲区期间，进程阻塞    应用进程->>应用进程: 处理数据报文    系统内核-->>应用进程: 返回 OK (拷贝完成)</pre><p><strong>异步 IO</strong></p><img src="/2025/03/16/golang%E8%BF%9B%E9%98%B6/image-20250316235953003.png" class="" title="image-20250316235953003"><pre><code class="language-mermaid">sequenceDiagram    participant 应用进程    participant 系统内核    应用进程-&gt;&gt;系统内核: 异步 IO 读 (系统调用)    Note over 系统内核: 数据报文尚未就绪  </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言基础与实践</title>
    <link href="/2025/03/16/golang/"/>
    <url>/2025/03/16/golang/</url>
    
    <content type="html"><![CDATA[<p>Golang 基本使用。</p><span id="more"></span><h3 id="一、统一思想：12-因素应用宣言"><a href="#一、统一思想：12-因素应用宣言" class="headerlink" title="一、统一思想：12 因素应用宣言"></a>一、统一思想：12 因素应用宣言</h3><p>在深入学习 Go 语言之前，我们先来了解一下构建云原生应用的指导原则——12 因素应用宣言（The Twelve-Factor App）。这套方法论由 Heroku 平台的开发者总结，旨在帮助开发者构建可扩展、可维护、易部署的云原生应用。</p><ol><li><p><strong>基准代码 (Codebase)</strong>：一份基准代码，多份部署。使用版本控制系统（如 Git）管理代码，确保不同环境（开发、测试、生产）使用同一份代码的不同版本。</p></li><li><p><strong>依赖 (Dependencies)</strong>：显式声明依赖关系。使用依赖管理工具（如 Go Modules）管理项目依赖，确保依赖的明确性和可重复性。</p></li><li><p><strong>配置 (Config)</strong>：在环境中存储配置。将配置信息（如数据库连接、API 密钥）存储在环境变量中，而不是硬编码在代码中，提高应用的可移植性和安全性。</p></li><li><p><strong>后端服务 (Backing Services)</strong>：把后端服务当作附加资源。将数据库、消息队列、缓存等后端服务视为可插拔的资源，通过 URL 或配置信息进行连接，方便应用的迁移和扩展。</p></li><li><p><strong>构建，发布，运行 (Build, Release, Run)</strong>：严格分离构建和运行。将应用构建、发布和运行三个阶段分离，确保每个阶段的独立性和可重复性。</p></li><li><p><strong>进程 (Processes)</strong>：以一个或多个无状态进程运行应用。将应用设计为无状态进程，方便水平扩展和故障恢复。</p></li><li><p><strong>端口绑定 (Port Binding)</strong>：通过端口绑定提供服务。应用通过绑定端口对外提供服务，不依赖于特定的 Web 服务器或容器。</p></li><li><p><strong>并发 (Concurrency)</strong>：通过进程模型进行扩展。利用进程或线程模型实现应用的并发，提高应用的吞吐量和响应速度。</p></li><li><p><strong>易处理 (Disposability)</strong>：快速启动和优雅终止可最大化健壮性。应用应能够快速启动和优雅终止，方便部署、重启和故障恢复。</p></li><li><p><strong>开发环境与线上环境等价 (Dev&#x2F;Prod Parity)</strong>：尽可能地保持开发、预发布、线上环境相同。使用相同的操作系统、依赖和配置，减少环境差异导致的问题。</p></li><li><p><strong>日志 (Logs)</strong>：把日志当作事件流。将应用的日志输出到标准输出（stdout），由外部系统（如日志收集器）进行处理和分析。</p></li><li><p><strong>管理进程 (Admin Processes)</strong>：后台管理任务当作一次性进程运行。将后台管理任务（如数据库迁移、数据备份）作为一次性进程运行，与应用的主进程分离。</p></li></ol><p><strong>面试知识点：</strong></p><ul><li>什么是 12 因素应用宣言？它的核心原则是什么？</li><li>为什么要在环境中存储配置？这样做有什么好处？</li><li>如何理解应用的无状态性？无状态应用有什么优势？</li></ul><h3 id="二、Go-语言的诞生与设计哲学"><a href="#二、Go-语言的诞生与设计哲学" class="headerlink" title="二、Go 语言的诞生与设计哲学"></a>二、Go 语言的诞生与设计哲学</h3><h4 id="1-为什么需要-Go-语言？"><a href="#1-为什么需要-Go-语言？" class="headerlink" title="1. 为什么需要 Go 语言？"></a>1. 为什么需要 Go 语言？</h4><p>在 Go 语言出现之前，开发者面临着一些挑战：</p><ul><li><strong>硬件发展与软件瓶颈</strong>：硬件性能不断提升，但软件开发效率却没有同步提升。</li><li><strong>现有语言的不足</strong>：<ul><li>C&#x2F;C++ 等原生语言缺乏好的依赖管理，编译速度慢。</li><li>Java&#x2F;C# 等语言过于庞大，启动速度慢，内存占用高。</li><li>现有语言对并发编程的支持不够友好，难以充分利用多核处理器。</li></ul></li></ul><p>Go 语言的出现，正是为了解决这些问题。</p><h4 id="2-Go-语言的设计哲学"><a href="#2-Go-语言的设计哲学" class="headerlink" title="2. Go 语言的设计哲学"></a>2. Go 语言的设计哲学</h4><p>Go 语言的设计哲学可以用以下几个关键词概括：</p><ul><li><strong>Less is exponentially more</strong>（少即是多）：Go 语言追求简洁，避免过度设计，减少不必要的复杂性。</li><li><strong>Do Less, Enable More</strong>（做更少，成更多）：Go 语言提供了一套精简但强大的工具集，让开发者能够更高效地完成工作。</li><li><strong>面向工程</strong>：Go 语言的设计目标是解决实际工程问题，而不是追求学术上的完美。</li><li><strong>正交性</strong>：Go 语言的特性之间相互独立，组合起来却能发挥强大的威力。</li></ul><h4 id="3-Go-语言的主要特性"><a href="#3-Go-语言的主要特性" class="headerlink" title="3. Go 语言的主要特性"></a>3. Go 语言的主要特性</h4><ul><li><strong>编译型语言</strong>：Go 语言是一种编译型语言，可以将代码编译成机器码，执行效率高。</li><li><strong>静态类型</strong>：Go 语言是一种静态类型语言，在编译时进行类型检查，可以减少运行时错误。</li><li><strong>垃圾回收</strong>：Go 语言内置垃圾回收机制，开发者无需手动管理内存，降低了开发难度。</li><li><strong>并发编程</strong>：Go 语言通过 goroutine 和 channel 提供了强大的并发编程支持，可以轻松编写高并发程序。</li><li><strong>简洁的语法</strong>：Go 语言的语法简洁明了，易于学习和使用。</li><li><strong>丰富的标准库</strong>：Go 语言提供了丰富的标准库，涵盖了网络编程、系统编程、数据处理等多个领域。</li></ul><h4 id="4-Go-语言不支持的特性"><a href="#4-Go-语言不支持的特性" class="headerlink" title="4. Go 语言不支持的特性"></a>4. Go 语言不支持的特性</h4><p>为了保持语言的简洁性和一致性，Go 语言有意不支持一些常见的特性：</p><ul><li><strong>函数重载和操作符重载</strong>：避免代码的歧义和复杂性。</li><li><strong>隐式类型转换</strong>：减少潜在的错误和不确定性。</li><li><strong>继承</strong>：Go 语言使用组合来实现代码复用，而不是继承。</li><li><strong>异常处理</strong>：Go 语言使用显式的错误处理机制（error），而不是异常。</li><li><strong>断言</strong>：Go 语言鼓励开发者编写更健壮的代码，而不是依赖断言来捕获错误。</li><li><strong>静态变量</strong>：Go 语言不支持静态变量，避免全局状态带来的问题。</li></ul><p><strong>面试知识点：</strong></p><ul><li>Go 语言的设计目标是什么？它解决了哪些问题？</li><li>Go 语言有哪些主要的特性？这些特性有什么优势？</li><li>为什么 Go 语言不支持某些常见的特性（如继承、异常）？</li></ul><h3 id="三、Go-语言环境搭建与基础"><a href="#三、Go-语言环境搭建与基础" class="headerlink" title="三、Go 语言环境搭建与基础"></a>三、Go 语言环境搭建与基础</h3><h4 id="1-下载与安装"><a href="#1-下载与安装" class="headerlink" title="1. 下载与安装"></a>1. 下载与安装</h4><ul><li>访问 Go 语言官网（<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a>）下载对应平台的安装包。</li><li>按照官方文档的指引进行安装。</li></ul><h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h4><ul><li><strong>GOROOT</strong>：Go 语言的安装目录。</li><li><strong>GOPATH</strong>：Go 语言的工作目录，用于存放项目代码、依赖包和可执行文件。<ul><li><code>src</code>：存放项目源代码。</li><li><code>pkg</code>：存放编译后的包文件。</li><li><code>bin</code>：存放可执行文件。</li></ul></li><li><strong>GOOS</strong>：目标操作系统（如 linux、windows、darwin）。</li><li><strong>GOARCH</strong>：目标处理器架构（如 amd64、arm64）。</li><li><strong>GOPROXY</strong>：Go 模块代理，用于加速依赖包的下载。国内用户建议设置为 <code>https://goproxy.cn</code>。</li></ul><h4 id="3-IDE-设置"><a href="#3-IDE-设置" class="headerlink" title="3. IDE 设置"></a>3. IDE 设置</h4><ul><li>推荐使用 VS Code，并安装 Go 插件。</li><li>其他可选的 IDE 包括：<ul><li>Goland（JetBrains 出品，收费）</li><li>Vim、Sublime Text 等（需要配置相关插件）</li></ul></li></ul><h4 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h4><ul><li><code>go build</code>：编译 Go 程序。<ul><li><code>-o</code>：指定输出文件名。</li><li><code>GOOS</code> 和 <code>GOARCH</code> 环境变量可以用于交叉编译。</li></ul></li><li><code>go run</code>：编译并运行 Go 程序。</li><li><code>go test</code>：运行测试。<ul><li><code>./...</code>：运行当前目录及子目录下的所有测试。</li><li><code>-v</code>：显示详细的测试输出。</li></ul></li><li><code>go vet</code>：静态代码检查，发现潜在的错误。</li><li><code>go fmt</code>：格式化 Go 代码。</li><li><code>go get</code>：下载并安装依赖包。</li><li><code>go mod</code>：Go 模块管理工具。</li><li><code>go doc</code>：查看文档。</li><li><code>go env</code>：查看 Go 环境变量。</li></ul><h4 id="5-代码版本控制"><a href="#5-代码版本控制" class="headerlink" title="5. 代码版本控制"></a>5. 代码版本控制</h4><ul><li>推荐使用 Git 进行代码版本控制。</li><li>将代码托管到 GitHub、GitLab 等平台。</li></ul><h4 id="6-Golang-Playground"><a href="#6-Golang-Playground" class="headerlink" title="6. Golang Playground"></a>6. Golang Playground</h4><ul><li>官方 Playground：<a href="https://play.golang.org/">https://play.golang.org/</a></li><li>国内可访问的 Playground：<a href="https://goplay.tools/">https://goplay.tools/</a></li></ul><p><strong>面试知识点：</strong></p><ul><li><code>go build</code> 和 <code>go run</code> 有什么区别？</li><li><code>go vet</code> 可以检查出哪些类型的错误？</li><li>如何使用 Go Modules 管理项目依赖？</li><li>如何进行交叉编译？</li></ul><h3 id="四、Go-语言控制结构"><a href="#四、Go-语言控制结构" class="headerlink" title="四、Go 语言控制结构"></a>四、Go 语言控制结构</h3><h4 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition1 &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2 &#123;<br>    <span class="hljs-comment">// do something else</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// catch-all or default</span><br>&#125;<br><br><span class="hljs-comment">// 简短语句</span><br><span class="hljs-keyword">if</span> v := x - <span class="hljs-number">100</span>; v &lt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-switch-语句"><a href="#2-switch-语句" class="headerlink" title="2. switch 语句"></a>2. switch 语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br><span class="hljs-keyword">case</span> val1:<br>    <span class="hljs-comment">// 空分支</span><br><span class="hljs-keyword">case</span> val2:<br>    <span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">// 执行 case3 中的代码</span><br><span class="hljs-keyword">case</span> val3:<br>    f()<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 计数器循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>    sum += sum<br>&#125;<br><br><span class="hljs-comment">// 无限循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// for-range 循环</span><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> myString &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> myArray &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>Go 语言中如何实现类似于 while 循环的功能？</li><li>for-range 循环遍历不同类型的数据时，有哪些需要注意的地方？</li></ul><h3 id="五、Go-语言常用数据结构"><a href="#五、Go-语言常用数据结构" class="headerlink" title="五、Go 语言常用数据结构"></a>五、Go 语言常用数据结构</h3><h4 id="1-变量与常量"><a href="#1-变量与常量" class="headerlink" title="1. 变量与常量"></a>1. 变量与常量</h4><ul><li><strong>常量</strong>：使用 <code>const</code> 关键字定义。</li><li><strong>变量</strong>：使用 <code>var</code> 关键字定义。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> name <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Go&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-变量定义与初始化"><a href="#2-变量定义与初始化" class="headerlink" title="2. 变量定义与初始化"></a>2. 变量定义与初始化</h4><ul><li><strong>变量声明</strong>：<code>var identifier type</code></li><li><strong>变量初始化</strong>：<code>var i, j int = 1, 2</code></li><li><strong>短变量声明</strong>：<code>c, python, java := true, false, &quot;no!&quot;</code> （只能在函数内部使用）</li></ul><h4 id="3-类型转换与推导"><a href="#3-类型转换与推导" class="headerlink" title="3. 类型转换与推导"></a>3. 类型转换与推导</h4><ul><li><strong>类型转换</strong>：<code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</li><li><strong>类型推导</strong>：在声明变量时不指定类型，Go 编译器会根据右值的类型自动推导。</li></ul><h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h4><ul><li><strong>定义</strong>：<code>var identifier [len]type</code></li><li><strong>特点</strong>：相同类型、长度固定、连续内存。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myArray := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-切片-slice"><a href="#5-切片-slice" class="headerlink" title="5. 切片 (slice)"></a>5. 切片 (slice)</h4><ul><li><strong>定义</strong>：<code>var identifier []type</code></li><li><strong>特点</strong>：对数组的引用、动态长度、连续内存。</li><li><strong>常用方法</strong>：<ul><li><code>append</code>：追加元素。</li><li><code>make</code>：创建切片。</li><li>切片操作：<code>myArray[1:3]</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>mySlice = <span class="hljs-built_in">append</span>(mySlice, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h4 id="6-make-和-new"><a href="#6-make-和-new" class="headerlink" title="6. make 和 new"></a>6. make 和 new</h4><ul><li><strong>new</strong>：返回指针地址。</li><li><strong>make</strong>：返回第一个元素，可预设内存空间。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mySlice1 := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>) <span class="hljs-comment">// 返回 *[]int</span><br>mySlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 返回 []int，长度为 0</span><br>mySlice3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 返回 []int，长度为 10，容量为 20</span><br></code></pre></td></tr></table></figure><h4 id="7-Map"><a href="#7-Map" class="headerlink" title="7. Map"></a>7. Map</h4><ul><li><strong>声明</strong>：<code>var map1 map[keytype]valuetype</code></li><li><strong>特点</strong>：键值对、无序。</li><li><strong>常用方法</strong>：<ul><li><code>make</code>：创建 Map。</li><li><code>delete</code>：删除键值对。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-built_in">delete</span>(myMap, <span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="8-访问-Map-元素"><a href="#8-访问-Map-元素" class="headerlink" title="8. 访问 Map 元素"></a>8. 访问 Map 元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 按 Key 取值</span><br>value, exists := myMap[<span class="hljs-string">&quot;a&quot;</span>]<br><span class="hljs-keyword">if</span> exists &#123;<br>    <span class="hljs-built_in">println</span>(value)<br>&#125;<br><br><span class="hljs-comment">// 遍历 Map</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> myMap &#123;<br>    <span class="hljs-built_in">println</span>(k, v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-结构体和指针"><a href="#9-结构体和指针" class="headerlink" title="9. 结构体和指针"></a>9. 结构体和指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMyType</span><span class="hljs-params">(t *MyType)</span></span> &#123;<br><span class="hljs-built_in">println</span>(t.Name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>printMyType(&amp;t) <span class="hljs-comment">// 传入指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>type … struct</code> 关键字自定义结构体</li><li>Go 语言支持指针，但不支持指针运算</li><li>指针变量的值为内存地址</li><li>未赋值的指针为 <code>nil</code></li></ul><h4 id="10-结构体标签"><a href="#10-结构体标签" class="headerlink" title="10. 结构体标签"></a>10. 结构体标签</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyType <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mt := MyType&#123;Name: <span class="hljs-string">&quot;test&quot;</span>&#125;<br>myType := reflect.TypeOf(mt)<br>name := myType.Field(<span class="hljs-number">0</span>)<br>tag := name.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br><span class="hljs-built_in">println</span>(tag)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）</li><li>使用场景：Kubernetes APIServer 对所有资源的定义都用 Json tag 和 protoBuff tag</li><li><code>NodeName string  json:&quot;nodeName,omitempty&quot; protobuf:&quot;bytes,10,opt,name=nodeName&quot;</code></li></ul><h4 id="11-类型别名"><a href="#11-类型别名" class="headerlink" title="11. 类型别名"></a>11. 类型别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Service Type string describes ingress methods for a service</span><br><span class="hljs-keyword">type</span> ServiceType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// ServiceTypeClusterIP means a service will only be accessible inside the</span><br><span class="hljs-comment">// cluster, via the ClusterIP.</span><br>ServiceTypeClusterIP ServiceType = <span class="hljs-string">&quot;ClusterIP&quot;</span><br><br><span class="hljs-comment">// ServiceTypeNodePort means a service will be exposed on one port of</span><br><span class="hljs-comment">// every node, in addition to &#x27;ClusterIP&#x27; type.</span><br>ServiceTypeNodePort ServiceType = <span class="hljs-string">&quot;NodePort&quot;</span><br><br><span class="hljs-comment">// ServiceTypeLoadBalancer means a service will be exposed via an</span><br><span class="hljs-comment">// external load balancer (if the cloud provider supports it), in addition</span><br><span class="hljs-comment">// to &#x27;NodePort&#x27; type.</span><br>ServiceTypeLoadBalancer ServiceType = <span class="hljs-string">&quot;LoadBalancer&quot;</span><br><br><span class="hljs-comment">// ServiceTypeExternalName means a service consists of only a reference to</span><br><span class="hljs-comment">// an external name that kubedns or equivalent will return as a CNAME</span><br><span class="hljs-comment">// record, with no exposing or proxying of any pods involved.</span><br>ServiceTypeExternalName ServiceType = <span class="hljs-string">&quot;ExternalName&quot;</span><br>)<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>数组和切片有什么区别？</li><li><code>make</code> 和 <code>new</code> 有什么区别？</li><li>如何判断一个 Map 中是否存在某个键？</li><li>结构体标签有什么作用？</li></ul><h3 id="课后练习-1-1"><a href="#课后练习-1-1" class="headerlink" title="课后练习 1.1"></a>课后练习 1.1</h3><ul><li>安装 Go</li><li>安装 IDE 并安装 Go 语言插件</li><li>编写一个小程序</li></ul><p>给定一个字符串数组<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;stupid&quot;,&quot;and&quot;,&quot;weak&quot;]</code><br>用 <code>for</code> 循环遍历该数组并修改为<br><code>[&quot;I&quot;,&quot;am&quot;,&quot;smart&quot;,&quot;and&quot;,&quot;strong&quot;]</code></p><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;am&quot;</span>, <span class="hljs-string">&quot;stupid&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;weak&quot;</span>&#125;<br>replacements := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;stupid&quot;</span>: <span class="hljs-string">&quot;smart&quot;</span>,<br><span class="hljs-string">&quot;weak&quot;</span>:   <span class="hljs-string">&quot;strong&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> words &#123;<br><span class="hljs-keyword">if</span> replacement, ok := replacements[word]; ok &#123;<br>words[i] = replacement<br>&#125;<br>&#125;<br><br>fmt.Println(words) <span class="hljs-comment">// 输出 [&quot;I&quot;, &quot;am&quot;, &quot;smart&quot;, &quot;and&quot;, &quot;strong&quot;]</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六、Go-语言函数"><a href="#六、Go-语言函数" class="headerlink" title="六、Go 语言函数"></a>六、Go 语言函数</h3><h4 id="1-main-函数"><a href="#1-main-函数" class="headerlink" title="1. main 函数"></a>1. main 函数</h4><ul><li>每个 Go 程序都应该有一个 <code>main</code> 包。</li><li><code>main</code> 包里的 <code>main</code> 函数是程序的入口。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-参数解析"><a href="#2-参数解析" class="headerlink" title="2. 参数解析"></a>2. 参数解析</h4><ul><li><code>main</code> 函数没有参数，不同于其他语言的<code>[]string args</code>。</li><li>可以使用 <code>os.Args</code> 获取命令行参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>args := os.Args<br>fmt.Println(<span class="hljs-string">&quot;Arguments:&quot;</span>, args)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>flag</code> 包解析命令行参数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name := flag.String(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;specify the name you want to say hi&quot;</span>)<br>flag.Parse()<br>fmt.Println(<span class="hljs-string">&quot;Hello,&quot;</span>, *name)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-init-函数"><a href="#3-init-函数" class="headerlink" title="3. init 函数"></a>3. init 函数</h4><ul><li><code>init</code> 函数会在包初始化时自动执行。</li><li>谨慎使用 <code>init</code> 函数，避免循环依赖和不可重复运行的问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> myVariable = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>myVariable = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h4><ul><li><strong>多值返回</strong>：函数可以返回多个值。</li><li><strong>命名返回值</strong>：可以给返回值命名，并在函数体中直接使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(sum <span class="hljs-type">int</span>)</span></span> (x, y <span class="hljs-type">int</span>) &#123;<br>    x = sum * <span class="hljs-number">4</span> / <span class="hljs-number">9</span><br>    y = sum - x<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 裸返回，返回已命名的 x 和 y</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-调用者忽略部分返回值"><a href="#5-调用者忽略部分返回值" class="headerlink" title="5. 调用者忽略部分返回值"></a>5. 调用者忽略部分返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">result, _ = strconv.Atoi(origStr) <span class="hljs-comment">// 忽略错误返回值</span><br></code></pre></td></tr></table></figure><h4 id="6-传递变长参数"><a href="#6-传递变长参数" class="headerlink" title="6. 传递变长参数"></a>6. 传递变长参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []Type, elems ...Type)</span></span> []Type <span class="hljs-comment">// 接收任意多个 Type 类型的参数</span><br></code></pre></td></tr></table></figure><h4 id="7-内置函数"><a href="#7-内置函数" class="headerlink" title="7. 内置函数"></a>7. 内置函数</h4><table><thead><tr><th align="left">函数名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>close</code></td><td align="left">管道关闭</td></tr><tr><td align="left"><code>len</code>, <code>cap</code></td><td align="left">返回数组、切片、Map 的长度或容量</td></tr><tr><td align="left"><code>new</code>, <code>make</code></td><td align="left">内存分配</td></tr><tr><td align="left"><code>copy</code>, <code>append</code></td><td align="left">操作切片</td></tr><tr><td align="left"><code>panic</code>, <code>recover</code></td><td align="left">错误处理</td></tr><tr><td align="left"><code>print</code>, <code>println</code></td><td align="left">打印</td></tr><tr><td align="left"><code>complex</code>, <code>real</code>, <code>imag</code></td><td align="left">操作复数</td></tr></tbody></table><h4 id="8-回调函数-Callback"><a href="#8-回调函数-Callback" class="headerlink" title="8. 回调函数 (Callback)"></a>8. 回调函数 (Callback)</h4><ul><li>将函数作为参数传递给其他函数，并在其他函数内部调用执行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doOperation</span><span class="hljs-params">(y <span class="hljs-type">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>) &#123;<br>    f(y, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increase</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;increase result is:&quot;</span>, a+b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    doOperation(<span class="hljs-number">1</span>, increase)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9. 闭包"></a>9. 闭包</h4><ul><li>匿名函数，可以访问其外部作用域的变量。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        sum += x<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pos, neg := adder(), adder()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<br>            pos(i),<br>            neg(<span class="hljs-number">-2</span>*i),<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-方法"><a href="#10-方法" class="headerlink" title="10. 方法"></a>10. 方法</h4><ul><li>作用在接收者上的函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-传值还是传指针"><a href="#11-传值还是传指针" class="headerlink" title="11. 传值还是传指针"></a>11. 传值还是传指针</h4><ul><li>Go 语言只有一种规则-传值</li><li>函数内修改参数的值不会影响函数外原始变量的值</li><li>可以传递指针参数将变量地址传递给调用函数，Go 语言会<br>复制该指针作为函数内的地址，但指向同一地址</li><li>思考：当我们写代码的时候，函数的参数传递应该用<code>struct</code><br>还是<code>pointer</code>？<ul><li>如果需要修改参数的值，或者参数较大，传递指针更高效。</li><li>如果不需要修改参数的值，且参数较小，传递值更安全。</li></ul></li></ul><h4 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h4><ul><li>接口定义一组方法集合。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>    Abs() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(-f)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a Abser<br>    f := MyFloat(-math.Sqrt2)<br>    v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>    a = f  <span class="hljs-comment">// MyFloat 实现了 Abser</span><br>    a = &amp;v <span class="hljs-comment">// *Vertex 实现了 Abser</span><br><br>    <span class="hljs-comment">// a = v // 错误：Vertex 没有实现 Abser（Abs 方法的接收者是 *Vertex）</span><br><br>    fmt.Println(a.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-注意事项"><a href="#13-注意事项" class="headerlink" title="13. 注意事项"></a>13. 注意事项</h4><ul><li><code>Interface</code> 是可能为 <code>nil</code> 的，所以针对 <code>interface</code> 的使用一定要预先判空，否则会引起程序 <code>crash(nil panic)</code></li><li><code>Struct</code> 初始化意味着空间分配，对 <code>struct</code> 的引用不会出现空指针</li></ul><h4 id="14-反射机制"><a href="#14-反射机制" class="headerlink" title="14. 反射机制"></a>14. 反射机制</h4><ul><li><code>reflect.TypeOf()</code> 返回被检查对象的类型</li><li><code>reflect.ValueOf()</code> 返回被检查对象的值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">10</span>)<br>myMap[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;b&quot;</span><br>t := reflect.TypeOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;type:&quot;</span>, t)<br>v := reflect.ValueOf(myMap)<br>fmt.Println(<span class="hljs-string">&quot;value:&quot;</span>, v)<br></code></pre></td></tr></table></figure><h4 id="15-基于-struct-的反射"><a href="#15-基于-struct-的反射" class="headerlink" title="15. 基于 struct 的反射"></a>15. 基于 struct 的反射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// struct</span><br>myStruct := T&#123;A: <span class="hljs-string">&quot;a&quot;</span>&#125;<br>v1 := reflect.ValueOf(myStruct)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumField(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Field %d: %v\n&quot;</span>, i, v1.Field(i))<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v1.NumMethod(); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Method %d: %v\n&quot;</span>, i, v1.Method(i))<br>&#125;<br><br><span class="hljs-comment">// 需要注意receive是struct还是指针</span><br>result := v1.Method(<span class="hljs-number">0</span>).Call(<span class="hljs-literal">nil</span>)<br>fmt.Println(<span class="hljs-string">&quot;result:&quot;</span>, result)<br></code></pre></td></tr></table></figure><h4 id="16-Go-语言中的面向对象编程"><a href="#16-Go-语言中的面向对象编程" class="headerlink" title="16. Go 语言中的面向对象编程"></a>16. Go 语言中的面向对象编程</h4><ul><li>可见性控制<ul><li><code>public</code>-常量、变量、类型、接口、结构、函数等的名称大写</li><li><code>private</code> -非大写就只能在包内使用</li></ul></li><li>继承<ul><li>通过组合实现，内嵌一个或多个<code>struct</code></li></ul></li><li>多态<ul><li>通过接口实现，通过接口定义方法集，编写多套实现</li></ul></li></ul><h4 id="17-Json-编解码"><a href="#17-Json-编解码" class="headerlink" title="17. Json 编解码"></a>17. Json 编解码</h4><ul><li><code>Unmarshal</code>: 从 <code>string</code> 转换至 <code>struct</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unmarshal2Struct</span><span class="hljs-params">(humanStr <span class="hljs-type">string</span>)</span></span> Human &#123;<br>h := Human&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;h)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">println</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Marshal</code>: 从 <code>struct</code> 转换至 <code>string</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">marshal2JsonString</span><span class="hljs-params">(h Human)</span></span> <span class="hljs-type">string</span> &#123;<br>h.Age = <span class="hljs-number">30</span><br>updatedBytes, err := json.Marshal(&amp;h)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">println</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(updatedBytes)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>json</code> 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 类型保存任意对象</li><li>可通过如下逻辑解析任意 <code>json</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> obj <span class="hljs-keyword">interface</span>&#123;&#125;<br>err := json.Unmarshal([]<span class="hljs-type">byte</span>(humanStr), &amp;obj)<br>objMap, ok := obj.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> objMap &#123;<br><span class="hljs-keyword">switch</span> value := v.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is string, value is %v\n&quot;</span>, k, value)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">interface</span>&#123;&#125;:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is interface&#123;&#125;, value is %v\n&quot;</span>, k, value)<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;type of %s is wrong, value is %v\n&quot;</span>, k, value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>面试知识点：</strong></p><ul><li>Go 语言中如何实现函数的重载？</li><li>什么是闭包？闭包有什么作用？</li><li>Go 语言中的方法和普通函数有什么区别？</li><li>Go 语言中如何实现接口？接口和抽象类有什么区别？</li><li>什么是反射？反射有什么作用？</li><li>如何使用 <code>encoding/json</code> 包进行 JSON 编解码？</li></ul><h3 id="六、常用语法"><a href="#六、常用语法" class="headerlink" title="六、常用语法"></a>六、常用语法</h3><h4 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1. 错误处理"></a>1. 错误处理</h4><p>Go 语言无内置 <code>exceptio</code> 机制，只提供 <code>error</code> 接口供定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可通过 <code>errors.New</code> 或 <code>fmt.Errorf</code> 创建新的 <code>error</code></li><li><code>var errNotFound error = errors.New(&quot;NotFound&quot;)</code></li><li>通常应用程序对 <code>error</code> 的处理大部分是判断 <code>error</code> 是否为 <code>nil</code><br>如需将 <code>error</code> 归类，通常交给应用程序自定义，比如 <code>kubernetes</code> 自定义了与 <code>apiserver</code> 交互的不同类型错误</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StatusError <span class="hljs-keyword">struct</span> &#123;<br>ErrStatus metav1.Status<br>&#125;<br><br><span class="hljs-keyword">var</span> _ <span class="hljs-type">error</span> = &amp;StatusError&#123;&#125;<br><br><span class="hljs-comment">// Error implements the Error interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *StatusError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.ErrStatus.Message<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-defer"><a href="#2-defer" class="headerlink" title="2. defer"></a>2. defer</h4><ul><li>函数返回之前执行某个语句或函数</li><li>等同于Java 和C# 的finally</li><li>常见的 <code>defer</code> 使用场景：记得关闭你打开的资源<ul><li><code>defer file.Close()</code></li><li><code>defer mu.Unlock()</code></li><li><code>defer println(&quot;&quot;)</code></li></ul></li></ul><h4 id="3-Panic-和-recover"><a href="#3-Panic-和-recover" class="headerlink" title="3. Panic 和 recover"></a>3. Panic 和 recover</h4><ul><li><code>panic</code>: 可在系统出现不可恢复错误时主动调用 <code>panic</code>, <code>panic</code> 会使当前线程直接 <code>crash</code></li><li><code>defer</code>: 保证执行并把控制权交还给接收到 <code>panic</code> 的函数调用者</li><li><code>recover</code>: 函数从 <code>panic</code> 或 错误场景中恢复</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer func is called&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;a panic is triggered&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七. 多线程"></a>七. 多线程</h3><h4 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h4><ul><li>并发（concurrency）<ul><li>两个或多个事件在同一时间间隔发生</li></ul></li><li>并行（parallellism）<ul><li>两个或者多个事件在同一时刻发生</li></ul></li></ul><h4 id="2-协程"><a href="#2-协程" class="headerlink" title="2. 协程"></a>2. 协程</h4><ul><li>进程：<ul><li>分配系统资源（CPU 时间、内存等）基本单位</li><li>有独立的内存空间，切换开销大</li></ul></li><li>线程：进程的一个执行流，是 CPU 调度并能独立运行的的基本单位<ul><li>同一进程中的多线程共享内存空间，线程切换代价小</li><li>多线程通信方便</li><li>从内核层面来看线程其实也是一种特殊的进程，它跟父进程共享了打开的文件和文件系统信息，共<br>享了地址空间和信号处理函数</li></ul></li><li>协程<ul><li>Go语言中的轻量级线程实现</li><li>Golang 在<code>runtime</code>、系统调用等多方面对<code>goroutine</code> 调度进行了封装和处理，当遇到长时间执行<br>或者进行系统调用时，会主动把当前<code>goroutine</code> 的<code>CPU (P)</code> 转让出去，让其他<code>goroutine</code> 能被调度<br>并执行，也就是<code>Golang</code> 从语言层面支持了协程</li></ul></li></ul><h4 id="3-Communicating-Sequential-Process"><a href="#3-Communicating-Sequential-Process" class="headerlink" title="3. Communicating Sequential Process"></a>3. Communicating Sequential Process</h4><ul><li>CSP<ul><li>描述两个独立的并发实体通过共享的通讯<code>channel</code>进行通信的并发模型。</li></ul></li><li>Go 协程 <code>goroutine</code><ul><li>是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协<br>作式调度。</li><li>是一种绿色线程，微线程，它与<code>Coroutine</code>协程也有区别，能够在发现堵塞后启动新的微线程。</li></ul></li><li>通道 <code>channel</code><ul><li>类似<code>Unix</code>的<code>Pipe</code>，用于协程之间通讯和同步。</li><li>协程之间虽然解耦，但是它们和<code>Channel</code>有着耦合。</li></ul></li></ul><h4 id="4-线程和协程的差异"><a href="#4-线程和协程的差异" class="headerlink" title="4. 线程和协程的差异"></a>4. 线程和协程的差异</h4><ul><li>每个 <code>goroutine</code> (协程) 默认占用内存远比 <code>Java</code> 、<code>C</code> 的线程少<ul><li><code>goroutine</code>：<code>2KB</code></li><li>线程：<code>8MB</code></li></ul></li><li>线程&#x2F;<code>goroutine</code> 切换开销方面，<code>goroutine</code> 远比线程小<ul><li>线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、<code>PC</code>、<code>SP</code>…等寄存器的刷新</li><li><code>goroutine</code>：只有三个寄存器的值修改-<code>PC</code> &#x2F; <code>SP</code> &#x2F; <code>DX</code>.</li></ul></li><li>GOMAXPROCS<ul><li>控制并行线程数量</li></ul></li></ul><h4 id="5-协程示例"><a href="#5-协程示例" class="headerlink" title="5. 协程示例"></a>5. 协程示例</h4><ul><li>启动新协程：<code>go functionName()</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> fmt.Println(i)<br>&#125;<br>time.Sleep(time.Second)<br></code></pre></td></tr></table></figure><h4 id="6-channel-多线程通信"><a href="#6-channel-多线程通信" class="headerlink" title="6. channel - 多线程通信"></a>6. channel - 多线程通信</h4><ul><li><code>Channel</code> 是多个协程之间通讯的管道</li><li>一端发送数据，一端接收数据</li><li>同一时间只有一个协程可以访问数据，无共享内存模式可能出现的内存竞争</li><li>协调协程的执行顺序</li><li>声明方式<ul><li><code>var identifier chan datatype</code></li></ul></li><li>操作符<code>&lt;-</code></li><li>示例</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello from goroutine&quot;</span>)<br>ch &lt;- <span class="hljs-number">0</span> <span class="hljs-comment">//数据写入Channel</span><br>&#125;()<br>i := &lt;-ch <span class="hljs-comment">//从Channel中取数据并赋值</span><br></code></pre></td></tr></table></figure><h4 id="7-通道缓冲"><a href="#7-通道缓冲" class="headerlink" title="7. 通道缓冲"></a>7. 通道缓冲</h4><ul><li>基于 <code>Channel</code> 的通信是同步的</li><li>当缓冲区满时，数据的发送是阻塞的</li><li>通过 <code>make</code> 关键字创建通道时可定义缓冲区容量，默认缓冲区容量为 0</li><li>下面两个定义的区别？<ul><li><code>ch:= make(chan int)</code></li><li><code>ch:= make(chan int,1)</code></li></ul></li></ul><h4 id="8-遍历通道缓冲区"><a href="#8-遍历通道缓冲区" class="headerlink" title="8. 遍历通道缓冲区"></a>8. 遍历通道缓冲区</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>rand.Seed(time.Now().UnixNano())<br>n := rand.Intn(<span class="hljs-number">10</span>) <span class="hljs-comment">// n will be between 0 and 10</span><br>fmt.Println(<span class="hljs-string">&quot;putting: &quot;</span>, n)<br>ch &lt;- n<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;hello from main&quot;</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(<span class="hljs-string">&quot;receiving: &quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-单向通道"><a href="#9-单向通道" class="headerlink" title="9. 单向通道"></a>9. 单向通道</h4><ul><li>只发送通道<ul><li><code>var sendOnly chan&lt;- int</code></li></ul></li><li>只接收通道<ul><li><code>var readOnly &lt;-chan int</code></li></ul></li><li><code>Istio webhook controller</code><ul><li><code>func (w *WebhookCertPatcher) runWebhookController(stopChan &lt;-chan struct&#123;&#125;) &#123;&#125;</code></li></ul></li><li>如何用: 双向通道转换</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> prod(c)<br><span class="hljs-keyword">go</span> consume(c)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prod</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>ch &lt;- <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consume</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>&lt;-ch<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-关闭通道"><a href="#10-关闭通道" class="headerlink" title="10. 关闭通道"></a>10. 关闭通道</h4><ul><li>通道无需每次关闭</li><li>关闭的作用是告诉接收者该通道再无新数据发送</li><li>只有发送方需要关闭通道</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br><span class="hljs-keyword">if</span> v, notClosed := &lt;-ch; notClosed &#123;<br>fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-select"><a href="#11-select" class="headerlink" title="11. select"></a>11. select</h4><ul><li>当多个协程同时运行时，可通过 <code>select</code> 轮询多个通道</li><li>如果所有通道都阻塞则等待，如定义了 <code>default</code> 则执行 <code>default</code></li><li>如多个通道就绪则随机选择</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v := &lt;-ch1:<br>...<br><span class="hljs-keyword">case</span> v := &lt;-ch2:<br>...<br><span class="hljs-keyword">default</span>:<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-定时器-Timer"><a href="#12-定时器-Timer" class="headerlink" title="12. 定时器 Timer"></a>12. 定时器 Timer</h4><ul><li><code>time.Ticker</code> 以指定的时间间隔重复的向通道 <code>C</code> 发送时间值</li><li>使用场景<ul><li>为协程设定超时时间</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">timer := time.NewTimer(time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// check normal channel</span><br><span class="hljs-keyword">case</span> &lt;-ch:<br>fmt.Println(<span class="hljs-string">&quot;received from ch&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-timer.C:<br>fmt.Println(<span class="hljs-string">&quot;timeout waiting from channel ch&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-上下文-Context"><a href="#13-上下文-Context" class="headerlink" title="13. 上下文 Context"></a>13. 上下文 Context</h4><ul><li>超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作</li><li><code>Context</code> 是设置截止日期、同步信号，传递请求相关值的结构体</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">interface</span> &#123;<br>Deadline() (deadline time.Time, ok <span class="hljs-type">bool</span>)<br>Done() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>Err() <span class="hljs-type">error</span><br>Value(key <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用法<ul><li><code>context.Background</code></li><li><code>context.TODO</code></li><li><code>context.WithDeadline</code></li><li><code>context.WithValue</code></li><li><code>context.WithCancel</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如何停止一个子协程</span><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-done:<br>            fmt.Println(<span class="hljs-string">&quot;done channel is triggerred, exit child go routine&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;()<br><span class="hljs-built_in">close</span>(done)<br><br><span class="hljs-comment">// 基于 Context 停止子协程</span><br><span class="hljs-comment">// Context 是 Go 语言对 go routine 和 timer 的封装</span><br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><span class="hljs-keyword">go</span> process(ctx, <span class="hljs-number">100</span>*time.Millisecond)<br>&lt;-ctx.Done()<br>fmt.Println(<span class="hljs-string">&quot;main:&quot;</span>, ctx.Err())<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ctx context.Context, duration time.Duration)</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(duration):<br>        fmt.Println(<span class="hljs-string">&quot;process successfully&quot;</span>)<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>        fmt.Println(<span class="hljs-string">&quot;process cancelled&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>context</code> 包, 可以取消 <code>goroutine</code> 的执行, 或者给 <code>goroutine</code> 设置 Deadline, 超时后 <code>goroutine</code> 会退出。</li></ul><p><strong>面试知识点:</strong></p><ul><li>Go 语言中如何实现并发编程？</li><li><code>goroutine</code> 和线程有什么区别？</li><li><code>channel</code> 的作用是什么？如何使用 <code>channel</code> 进行协程间通信？</li><li>如何实现一个有缓冲的 <code>channel</code>？</li><li>如何使用 <code>select</code> 语句处理多个 <code>channel</code>？</li><li>如何使用 <code>context</code> 包取消 <code>goroutine</code> 的执行？</li></ul><h3 id="课后练习-1-2"><a href="#课后练习-1-2" class="headerlink" title="课后练习 1.2"></a>课后练习 1.2</h3><ul><li>基于 <code>Channel</code> 编写一个简单的单线程生产者消费者模型<ul><li>队列：<br>队列长度 10，队列元素类型为 <code>int</code></li><li>生产者：<br>每 1 秒往队列中放入一个类型为 <code>int</code> 的元素，队列满时生产者可以阻塞</li><li>消费者：<br>每一秒从队列中获取一个元素并打印，队列为空时消费者阻塞</li></ul></li></ul><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>ch &lt;- i<br>fmt.Println(<span class="hljs-string">&quot;Produced:&quot;</span>, i)<br>i++<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>i := &lt;-ch<br>fmt.Println(<span class="hljs-string">&quot;Consumed:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 缓冲大小为 10 的 channel</span><br><br><span class="hljs-keyword">go</span> producer(ch)<br><span class="hljs-keyword">go</span> consumer(ch)<br><br><span class="hljs-keyword">select</span> &#123;&#125; <span class="hljs-comment">// 阻塞主 goroutine，防止程序退出</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八、Go-Modules"><a href="#八、Go-Modules" class="headerlink" title="八、Go Modules"></a>八、Go Modules</h3><h4 id="1-为什么需要-Go-Modules"><a href="#1-为什么需要-Go-Modules" class="headerlink" title="1. 为什么需要 Go Modules"></a>1. 为什么需要 Go Modules</h4><p>在 Go 1.11 版本之前，Go 语言的依赖管理一直是一个痛点。<code>GOPATH</code> 模式存在以下问题：</p><ul><li><strong>项目必须放在 <code>$GOPATH/src</code> 目录下</strong>：限制了项目存放的位置，不够灵活。</li><li><strong>没有版本控制</strong>：无法指定项目依赖的特定版本，容易出现版本冲突。</li><li><strong>无法处理 vendor 依赖</strong>：无法将依赖包复制到项目内部，不利于项目的独立性和可移植性。</li></ul><p>Go Modules 的出现，解决了这些问题，成为了 Go 语言官方推荐的依赖管理方式。</p><h4 id="2-Go-Modules-的主要特性"><a href="#2-Go-Modules-的主要特性" class="headerlink" title="2. Go Modules 的主要特性"></a>2. Go Modules 的主要特性</h4><ul><li><strong>项目可以放在任何位置</strong>：不再受限于 <code>$GOPATH/src</code> 目录。</li><li><strong>版本控制</strong>：可以指定项目依赖的特定版本，解决了版本冲突问题。</li><li><strong>vendor 支持</strong>：可以将依赖包复制到项目内部的 <code>vendor</code> 目录，提高了项目的独立性和可移植性。</li><li><strong>模块代理</strong>：可以通过设置 <code>GOPROXY</code> 环境变量，使用模块代理加速依赖包的下载。</li></ul><h4 id="3-Go-Modules-的基本使用"><a href="#3-Go-Modules-的基本使用" class="headerlink" title="3. Go Modules 的基本使用"></a>3. Go Modules 的基本使用</h4><ul><li><strong>初始化模块</strong>：在项目根目录下执行 <code>go mod init &lt;module_name&gt;</code>，创建 <code>go.mod</code> 文件。</li><li><strong>添加依赖</strong>：执行 <code>go get &lt;package_name&gt;@&lt;version&gt;</code>，会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li><li><strong>构建项目</strong>：执行 <code>go build</code>，会自动下载并构建依赖。</li><li><strong>运行项目</strong>：执行 <code>go run</code>，会自动下载、构建并运行项目。</li><li><strong>整理依赖</strong>：执行 <code>go mod tidy</code>，会移除未使用的依赖，并更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</li><li><strong>vendor 依赖</strong>：执行 <code>go mod vendor</code>，会将依赖包复制到项目内部的 <code>vendor</code> 目录。</li></ul><p><strong>面试知识点：</strong></p><ul><li>Go Modules 解决了 <code>GOPATH</code> 模式的哪些问题？</li><li><code>go.mod</code> 和 <code>go.sum</code> 文件有什么作用？</li><li>如何使用 Go Modules 添加、更新和删除依赖？</li><li>如何使用 vendor 依赖？</li></ul><h3 id="九、Go-语言与云原生"><a href="#九、Go-语言与云原生" class="headerlink" title="九、Go 语言与云原生"></a>九、Go 语言与云原生</h3><p>Go 语言的特性使其非常适合云原生应用开发：</p><ul><li><strong>高效的编译和执行速度</strong>：Go 语言的编译速度快，生成的二进制文件小，启动速度快，非常适合云原生环境下的快速部署和弹性伸缩。</li><li><strong>强大的并发编程支持</strong>：Go 语言的 goroutine 和 channel 机制，可以轻松编写高并发程序，充分利用多核处理器，提高应用的吞吐量和响应速度。</li><li><strong>简洁的语法和丰富的标准库</strong>：Go 语言的语法简洁易学，标准库功能丰富，可以减少开发者的工作量，提高开发效率。</li><li><strong>跨平台编译</strong>：Go 语言支持交叉编译，可以方便地为不同的操作系统和处理器架构构建应用。</li><li><strong>容器友好</strong>：Go 语言生成的二进制文件不依赖于外部库，非常适合打包成 Docker 镜像，方便部署和管理。</li></ul><p>Go 语言已经成为云原生领域的主流语言，许多知名的云原生项目都是用 Go 语言开发的，例如：</p><ul><li><strong>Docker</strong>：容器引擎。</li><li><strong>Kubernetes</strong>：容器编排平台。</li><li><strong>Istio</strong>：服务网格。</li><li><strong>Etcd</strong>：分布式键值存储。</li><li><strong>Prometheus</strong>：监控系统。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker核心技术</title>
    <link href="/2025/03/16/docker/"/>
    <url>/2025/03/16/docker/</url>
    
    <content type="html"><![CDATA[<p>Cgroups,Namespace,Union FS</p> <span id="more"></span><h3 id="1-从系统架构谈起：传统分层架构-vs-微服务"><a href="#1-从系统架构谈起：传统分层架构-vs-微服务" class="headerlink" title="1. 从系统架构谈起：传统分层架构 vs 微服务"></a>1. 从系统架构谈起：传统分层架构 vs 微服务</h3><p>在深入 Docker 之前，我们先来聊聊系统架构的演变。</p><h4 id="传统分层架构"><a href="#传统分层架构" class="headerlink" title="传统分层架构"></a>传统分层架构</h4><p>传统的单体应用通常采用分层架构，如下图所示：</p><img src="/2025/03/16/docker/image-20250316235507888.png" class="" title="image-20250316235507888"><pre class="mermaid">graph LR    A[Presentation Layer] --> B(Business Logic Layer)    B --> C(Data Access Layer)    C --> D{Database}</pre><p><strong>优点：</strong></p><ul><li>对于简单的系统，易于部署、测试和横向扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>对于复杂的系统：<ul><li>难以理解整体</li><li>不易快速维护</li><li>启动和部署慢</li><li>变更引起的回归问题多</li><li>难以持续集成和持续部署</li></ul></li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>为了解决传统分层架构的痛点，微服务架构应运而生。它将一个庞大的系统分解成多个独立的小服务，每个服务负责特定的业务功能。</p><img src="/2025/03/16/docker/image-20250316235512635.png" class="" title="image-20250316235512635"><pre class="mermaid">graph LR    subgraph Microservices        A[Service 1] -->|API| B(API Gateway)        C[Service 2] -->|API| B        D[Service 3] -->|API| B    end    B --> E{External Services}</pre><p><strong>优点：</strong></p><ul><li>系统部署更快，更易理解和维护。</li><li>不同服务可由不同团队维护，分工更细。</li><li>可自主选择技术栈。</li><li>易于持续集成和持续部署。</li><li>每个微服务独立扩展。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂性（分布式部署）。</li><li>需要处理分布式系统的复杂问题（如进程间通信、部分失败）。</li><li>分布式事务更复杂（失败回滚）。</li><li>测试和部署监控更复杂。</li></ul><h4 id="微服务改造"><a href="#微服务改造" class="headerlink" title="微服务改造"></a>微服务改造</h4><p>将单体应用拆分成微服务，可以遵循以下原则：</p><ul><li><strong>分离业务逻辑：</strong> 审视并发现可以分离的业务逻辑。</li><li><strong>寻找隔离模块：</strong> 寻找天生隔离的代码模块（可借助静态代码分析工具）。</li><li><strong>考虑性能需求：</strong> 不同并发规模、不同内存需求的模块可分离成不同的微服务。</li></ul><p>一些常用的可微服务化的组件：</p><ul><li>用户和账户管理</li><li>授权和会话管理</li><li>系统配置</li><li>通知和通讯服务</li><li>照片、多媒体、元数据等</li></ul><p><strong>分解原则：</strong> 基于 size, scope and capabilities</p><h4 id="微服务间通讯"><a href="#微服务间通讯" class="headerlink" title="微服务间通讯"></a>微服务间通讯</h4><p>微服务之间通常有两种通讯方式：</p><ol><li><p><strong>点对点：</strong></p><ul><li>多用于系统内部组件间通讯。</li><li>存在大量重复模块（如认证授权）。</li><li>缺少统一规范（如监控、审计）。</li><li>后期维护成本高。</li></ul></li><li><p><strong>API 网关：</strong></p><ul><li>基于一个轻量级的 message gateway。</li><li>新 API 通过注册至 Gateway 实现。</li><li>整合实现 Common function。</li></ul></li></ol><h3 id="2-理解-Docker"><a href="#2-理解-Docker" class="headerlink" title="2. 理解 Docker"></a>2. 理解 Docker</h3><p>Docker 是一种容器化技术，可以将应用程序及其依赖项打包到一个可移植的容器中，从而实现快速部署、一致的运行环境和高效的资源利用。</p><h4 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h4><ul><li>Docker 基于 Linux 内核的 Cgroup、Namespace 以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li><li>Docker 容器独立于宿主机和其他容器。</li><li>Docker 在容器的基础上进行了进一步的封装，简化了容器的创建和维护。</li></ul><h4 id="为什么要用-Docker？"><a href="#为什么要用-Docker？" class="headerlink" title="为什么要用 Docker？"></a>为什么要用 Docker？</h4><ul><li><strong>更高效地利用系统资源：</strong> 容器共享宿主机内核，资源开销更小。</li><li><strong>更快速的启动时间：</strong> 容器启动只需几秒钟，远快于虚拟机。</li><li><strong>一致的运行环境：</strong> 容器打包了应用程序及其依赖项，保证在不同环境中的一致性。</li><li><strong>持续交付和部署：</strong> 容器易于构建、测试和部署，方便实现持续交付。</li><li><strong>更轻松地迁移：</strong> 容器可轻松迁移到不同的平台和环境。</li><li><strong>更轻松地维护和扩展：</strong> 容器易于管理和扩展，可根据需求动态调整资源。</li></ul><h4 id="虚拟机和容器运行态的对比"><a href="#虚拟机和容器运行态的对比" class="headerlink" title="虚拟机和容器运行态的对比"></a>虚拟机和容器运行态的对比</h4><img src="/2025/03/16/docker/image-20250316235519406.png" class="" title="image-20250316235519406"><pre class="mermaid">graph LR    subgraph 虚拟机        A[虚拟机 1] --> B(Hypervisor)        C[虚拟机 2] --> B        D[虚拟机 3] --> B        B --> E(Host OS)        E --> F{Hardware}    end    subgraph 容器        G[容器 1] --> H(Docker Engine)        I[容器 2] --> H        J[容器 3] --> H        H --> K(Host OS)        K --> L{Hardware}    end</pre><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机上千个容器</td><td>一般几十个</td></tr></tbody></table><h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><p>在 Ubuntu 上安装 Docker 的步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 更新 apt 包索引</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 2. 安装依赖包</span><br><span class="hljs-built_in">sudo</span> apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg-agent \<br>    software-properties-common<br><br><span class="hljs-comment"># 3. 添加 Docker 的官方 GPG 密钥</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> apt-key add -<br><br><span class="hljs-comment"># 4. 设置稳定版仓库</span><br><span class="hljs-built_in">sudo</span> add-apt-repository \<br>   <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">   <span class="hljs-subst">$(lsb_release -cs)</span> \</span><br><span class="hljs-string">   stable&quot;</span><br><br><span class="hljs-comment"># 5. 再次更新 apt 包索引</span><br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 6. 安装 Docker Engine</span><br><span class="hljs-built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul><li><strong>启动容器：</strong><ul><li><code>docker run</code>：创建并启动一个新的容器。<ul><li><code>-it</code>：交互式运行。</li><li><code>-d</code>：后台运行。</li><li><code>-p</code>：端口映射。</li><li><code>-v</code>：磁盘挂载。</li></ul></li><li><code>docker start</code>：启动已终止的容器。</li></ul></li><li><strong>停止容器：</strong><ul><li><code>docker stop</code>：停止正在运行的容器。</li></ul></li><li><strong>查看容器进程：</strong><ul><li><code>docker ps</code>：列出正在运行的容器。</li><li><code>docker ps -a</code>：列出所有容器（包括已停止的）。</li></ul></li><li><strong>查看容器细节</strong></li></ul><pre><code class="hljs">* `docker inspect &lt;containerid&gt;`</code></pre><ul><li><strong>进入容器</strong><ul><li><code>docker attach</code></li><li><code>nsenter</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PID=$(docker inspect --format <span class="hljs-string">&quot;&#123;&#123; .State.Pid &#125;&#125;&quot;</span><br>&lt;container&gt;)<br>$ nsenter --target <span class="hljs-variable">$PID</span> --mount --uts --ipc --net --pid<br></code></pre></td></tr></table></figure></li><li><strong>拷贝文件至容器内</strong><ul><li><code>docker cp file1 &lt;containerid&gt;:/file-to-path</code></li></ul></li></ul><h4 id="初识容器"><a href="#初识容器" class="headerlink" title="初识容器"></a>初识容器</h4><p>让我们通过一个简单的例子来体验 Docker 的魅力。</p><ol><li><p><strong>编写 Dockerfile：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">ENV</span> MY_SERVICE_PORT=<span class="hljs-number">80</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> bin/amd64/httpserver /httpserver</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> /httpserver</span><br></code></pre></td></tr></table></figure><ul><li><code>FROM</code>：指定基础镜像（这里使用 Ubuntu）。</li><li><code>ENV</code>：设置环境变量。</li><li><code>ADD</code>：将本地文件复制到容器中。</li><li><code>ENTRYPOINT</code>：指定容器启动时执行的命令。</li></ul></li><li><p><strong>构建镜像：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t cncamp/httpserver:<span class="hljs-variable">$&#123;tag&#125;</span> .<br>docker push cncamp/httpserver:v1.0<br></code></pre></td></tr></table></figure><ul><li><code>-t</code>：指定镜像的名称和标签。</li><li><code>.</code>：表示 Dockerfile 所在的当前目录。</li></ul></li><li><p><strong>运行容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d cncamp/httpserver:v1.0<br></code></pre></td></tr></table></figure></li></ol><h4 id="容器标准"><a href="#容器标准" class="headerlink" title="容器标准"></a>容器标准</h4><p>为了规范容器技术的发展，业界制定了 OCI（Open Container Initiative）标准。</p><ul><li><strong>OCI 是什么？</strong><ul><li>一个轻量级开放式管理组织。</li><li>主要定义两个规范：<ul><li><strong>Runtime Specification：</strong> 定义如何解压文件系统包并在运行时运行。</li><li><strong>Image Specification：</strong> 定义如何打包镜像、生成清单、文件系统序列化文件和镜像配置。</li></ul></li></ul></li></ul><h4 id="容器主要特性"><a href="#容器主要特性" class="headerlink" title="容器主要特性"></a>容器主要特性</h4><ul><li><strong>安全性：</strong> 容器提供了隔离的运行环境，增强了安全性。</li><li><strong>便携性：</strong> 容器可在不同平台和环境中轻松迁移。</li><li><strong>隔离性：</strong> 容器之间相互隔离，互不影响。</li><li><strong>可配额：</strong> 可对容器的资源使用进行限制。</li></ul><h3 id="3-Docker-核心技术：Namespace、Cgroups、UnionFS"><a href="#3-Docker-核心技术：Namespace、Cgroups、UnionFS" class="headerlink" title="3. Docker 核心技术：Namespace、Cgroups、UnionFS"></a>3. Docker 核心技术：Namespace、Cgroups、UnionFS</h3><p>Docker 的核心技术主要包括 Namespace、Cgroups 和 UnionFS。</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>Namespace 是 Linux 内核提供的一种资源隔离方案。它可以为进程分配不同的 Namespace，保证不同 Namespace 下的资源独立分配，进程彼此隔离。</p><ul><li><p><strong>Linux 内核代码中 Namespace 的实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进程数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    ...<br>    <span class="hljs-comment">/* namespaces */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> *<span class="hljs-title">nsproxy</span>;</span><br>    ...<br>&#125;<br><br><span class="hljs-comment">// Namespace 数据结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> &#123;</span><br>    <span class="hljs-type">atomic_t</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uts_namespace</span> *<span class="hljs-title">uts_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ipc_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mnt_namespace</span> *<span class="hljs-title">mnt_ns</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns_for_children</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net_ns</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Linux 对 Namespace 操作方法：</strong></p><ul><li><code>clone</code>：创建新进程时，可通过 <code>flags</code> 参数指定需要新建的 Namespace 类型。</li><li><code>setns</code>：将调用进程加入某个已存在的 Namespace。</li><li><code>unshare</code>：将调用进程移动到新的 Namespace。</li></ul></li><li><p><strong>Namespace 类型：</strong></p><table><thead><tr><th>Namespace 类型</th><th>隔离资源</th><th>Kernel 版本</th></tr></thead><tbody><tr><td>IPC</td><td>System V IPC 和 POSIX 消息队列</td><td>2.6.19</td></tr><tr><td>Network</td><td>网络设备、网络协议栈、网络端口等</td><td>2.6.29</td></tr><tr><td>PID</td><td>进程</td><td>2.6.14</td></tr><tr><td>Mount</td><td>挂载点</td><td>2.4.19</td></tr><tr><td>UTS</td><td>主机名和域名</td><td>2.6.19</td></tr><tr><td>User</td><td>用户和用户组</td><td>3.8</td></tr></tbody></table></li><li><p><strong>Namespace 常用操作：</strong></p><ul><li>查看当前系统的 namespace：<code>lsns -t &lt;type&gt;</code></li><li>查看某进程的 namespace：<code>ls -la /proc/&lt;pid&gt;/ns/</code></li><li>进入某 namespace 运行命令：<code>nsenter -t &lt;pid&gt; -n ip addr</code></li></ul></li><li><p><strong>Namespace 练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在新 network namespace 执行 sleep 指令</span><br>unshare -fn <span class="hljs-built_in">sleep</span> 60<br><br><span class="hljs-comment"># 查看进程信息</span><br>ps -ef | grep <span class="hljs-built_in">sleep</span><br><br><span class="hljs-comment"># 查看网络 Namespace</span><br>lsns -t net<br><br><span class="hljs-comment"># 进入该进程所在 Namespace 查看网络配置</span><br>nsenter -t &lt;pid&gt; -n ip a<br></code></pre></td></tr></table></figure></li></ul><h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><p>Cgroups（Control Groups）是 Linux 下用于对一个或一组进程进行资源控制和监控的机制。它可以对 CPU 使用时间、内存、磁盘 I&#x2F;O 等进程所需的资源进行限制。</p><ul><li><p><strong>Linux 内核代码中 Cgroups 的实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CGROUPS</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">cgroups</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cg_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span> &#123;</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Set of subsystem states, one for each subsystem. This array is</span><br><span class="hljs-comment">    * immutable after creation apart from the init_css_set during</span><br><span class="hljs-comment">    * subsystem registration (at boot time).</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">subsys</span>[<span class="hljs-title">CGROUP_SUBSYS_COUNT</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>Cgroups 子系统：</strong></p><table><thead><tr><th>子系统</th><th>作用</th></tr></thead><tbody><tr><td>blkio</td><td>限制每个块设备的输入输出</td></tr><tr><td>cpu</td><td>使用调度程序为 cgroup 任务提供 CPU 的访问</td></tr><tr><td>cpuacct</td><td>产生 cgroup 任务的 CPU 资源报告</td></tr><tr><td>cpuset</td><td>为 cgroup 任务分配单独的 CPU 和内存</td></tr><tr><td>devices</td><td>允许或拒绝 cgroup 任务对设备的访问</td></tr><tr><td>freezer</td><td>暂停和恢复 cgroup 任务</td></tr><tr><td>memory</td><td>设置每个 cgroup 的内存限制以及产生内存资源报告</td></tr><tr><td>net_cls</td><td>标记每个网络包以供 cgroup 方便使用</td></tr><tr><td>ns</td><td>名称空间子系统</td></tr><tr><td>pid</td><td>进程标识子系统</td></tr></tbody></table></li><li><p><strong>CPU 子系统：</strong></p><ul><li><code>cpu.shares</code>：可出让的能获得 CPU 使用时间的相对值。</li><li><code>cpu.cfs_period_us</code>：时间周期长度（微秒）。</li><li><code>cpu.cfs_quota_us</code>：当前 Cgroup 在 <code>cfs_period_us</code> 时间内最多能使用的 CPU 时间数（微秒）。</li><li><code>cpu.stat</code>：Cgroup 内的进程使用的 CPU 时间统计。<ul><li><code>nr_periods</code>：经过 <code>cpu.cfs_period_us</code> 的时间周期数量。</li><li><code>nr_throttled</code>：进程受限次数。</li><li><code>throttled_time</code>：进程被限制使用 CPU 的总用时（纳秒）。</li></ul></li></ul></li><li><p><strong>Linux 调度器：</strong></p><ul><li><strong>Stop 调度器（<code>stop_sched_class</code>）：</strong> 优先级最高，可抢占其他所有进程。</li><li><strong>Deadline 调度器（<code>dl_sched_class</code>）：</strong> 使用红黑树，按绝对截止期限排序进程。</li><li><strong>RT 调度器（<code>rt_sched_class</code>）：</strong> 实时调度器，为每个优先级维护一个队列。</li><li><strong>CFS 调度器（<code>cfs_sched_class</code>）：</strong> 完全公平调度器，采用完全公平调度算法，引入虚拟运行时间概念。</li><li><strong>IDLE-Task 调度器（<code>idle_sched_class</code>）：</strong> 空闲调度器，每个 CPU 都有一个 idle 线程。</li></ul></li><li><p><strong>CFS 调度器：</strong></p><ul><li>维护任务提供处理器时间方面的平衡。</li><li>通过虚拟运行时间（vruntime）来实现平衡。</li><li><code>vruntime = 实际运行时间 * 1024 / 进程权重</code></li><li>进程按各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间。</li></ul><img src="/2025/03/16/docker/image-20250316235528868.png" class="" title="image-20250316235528868"></li></ul><pre class="mermaid">graph LR    subgraph 红黑树    A[vruntime 最小] --> B    B --> C    C --> D    D --> E[vruntime 最大]    end</pre><ul><li><p><strong>CFS 进程调度：</strong></p><ol><li>时钟周期开始时，调用 <code>__schedule()</code> 函数。</li><li><code>__schedule()</code> 调用 <code>pick_next_task()</code> 选择最合适的进程（红黑树最左边的节点）。</li><li>通过 <code>context_switch()</code> 切换到新的地址空间，保证进程运行。</li><li>时钟周期结束时，调用 <code>entity_tick()</code> 函数更新进程负载、状态和 vruntime。</li><li>将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，决定是否触发调度。</li></ol></li><li><p><strong>CPU 子系统练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cgroup cpu 子系统目录中创建目录结构</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu<br><span class="hljs-built_in">mkdir</span> cpudemo<br><span class="hljs-built_in">cd</span> cpudemo<br><br><span class="hljs-comment"># 运行 busyloop</span><br><br><span class="hljs-comment"># 查看 CPU 使用情况</span><br>top<br><br><span class="hljs-comment"># 通过 cgroup 限制 cpu</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/cpu/cpudemo<br><br><span class="hljs-comment"># 把进程添加到 cgroup 进程配置组</span><br><span class="hljs-built_in">echo</span> $(ps -ef | grep busyloop | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>) &gt; cgroup.procs<br><br><span class="hljs-comment"># 设置 cpuquota</span><br><span class="hljs-built_in">echo</span> 10000 &gt; cpu.cfs_quota_us<br><br><span class="hljs-comment"># 再次查看 CPU 使用情况</span><br>top<br></code></pre></td></tr></table></figure></li><li><p><strong>cpuacct 子系统：</strong></p><ul><li><code>cpuacct.usage</code>：Cgroup 及其子 Cgroup 下进程使用 CPU 的时间（纳秒）。</li><li><code>cpuacct.stat</code>：Cgroup 及其子 Cgroup 下进程使用的 CPU 时间（用户态和内核态）。</li></ul></li><li><p><strong>Memory 子系统：</strong></p><ul><li><code>memory.usage_in_bytes</code>：Cgroup 下进程使用的内存。</li><li><code>memory.max_usage_in_bytes</code>：Cgroup 下进程使用内存的最大值。</li><li><code>memory.limit_in_bytes</code>：设置 Cgroup 下进程最多能使用的内存。</li><li><code>memory.soft_limit_in_bytes</code>：软限制，系统内存足够时优先回收超过限额的内存。</li><li><code>memory.oom_control</code>：设置是否在 Cgroup 中使用 OOM Killer。</li></ul></li><li><p><strong>Cgroup driver：</strong></p><ul><li><strong>systemd：</strong> 当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup 管理器。</li><li><strong>cgroupfs：</strong> Docker 默认使用 cgroupfs 作为 cgroup 驱动。<ul><li><strong>存在问题：</strong> 在 systemd 作为 init system 的系统中，可能存在两套 group driver，导致管理混乱。</li><li><strong>建议：</strong> 将 kubelet 的 <code>--cgroup-driver</code> 设置为 <code>systemd</code>。</li></ul></li></ul></li><li><p><strong>课后练习 3.1：Memory 子系统练习</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 cgroup memory 子系统目录中创建目录结构</span><br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory<br><span class="hljs-built_in">mkdir</span> memorydemo<br><span class="hljs-built_in">cd</span> memorydemo<br><br><span class="hljs-comment"># 运行 malloc（在 linux 机器 make build）</span><br><br><span class="hljs-comment"># 查看内存使用情况</span><br>watch <span class="hljs-string">&#x27;ps -aux|grep malloc|grep -v grep&#x27;</span><br><br><span class="hljs-comment"># 通过 cgroup 限制 memory</span><br><span class="hljs-comment"># 把进程添加到 cgroup 进程配置组</span><br><span class="hljs-built_in">echo</span> $(ps -ef | grep malloc | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>) &gt; cgroup.procs<br><br><span class="hljs-comment"># 设置 memory.limit_in_bytes</span><br><span class="hljs-built_in">echo</span> 104960000 &gt; memory.limit_in_bytes<br><br><span class="hljs-comment"># 等待进程被 oom kill</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Union-FS"><a href="#Union-FS" class="headerlink" title="Union FS"></a>Union FS</h4><p>Union FS 是一种将不同目录挂载到同一个虚拟文件系统下的文件系统。</p><ul><li><p><strong>特点：</strong></p><ul><li>支持为每一个成员目录设定 readonly、readwrite 和 whiteout-able 权限。</li><li>文件系统分层，对 readonly 权限的 branch 可以逻辑上进行修改（增量地，不影响 readonly 部分）。</li></ul></li><li><p><strong>用途：</strong></p><ul><li>将多个 disk 挂到同一个目录下。</li><li>将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起。</li></ul><img src="/2025/03/16/docker/image-20250316235535631.png" class="" title="image-20250316235535631"></li></ul><pre class="mermaid">graph LR    subgraph Union FS        A[Read-Only Layer 1] --> C(Merged View)        B[Read-Write Layer 2] --> C    end</pre><h4 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h4><p>Dockerfile 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile-java:</span><br><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y default-jre</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./app.jar /app.jar</span><br><span class="hljs-keyword">EntryPoint</span><span class="language-bash"> [<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;app1.jar&quot;</span>]</span><br><br><span class="hljs-comment"># Dockerfile-elasticsearch:</span><br><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt install -y default-jre</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget elasticseach</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> untar elasticseach</span><br><span class="hljs-keyword">EntryPoint</span><span class="language-bash">: [<span class="hljs-string">&quot;./elasticseach&quot;</span>]</span><br></code></pre></td></tr></table></figure><pre class="mermaid">graph LR    subgraph "myapp:v1.0"        A["BaseImage(ubuntu)"] --> B("install default-jre")        B --> C("copy app1.jar")        C --> D("EntryPoint: [Java, app1.jar]")    end    subgraph "elasticsearch:v7.14"        E["BaseImage(ubuntu)"] --> F("install default-jre")        F --> G("wget elasticseach")        G --> H("untar elasticseach")        H --> I("EntryPoint: [./elasticseach]")    end    subgraph "通用层"    A --> B    E --> F    end</pre><img src="/2025/03/16/docker/image-20250316235712098.png" class="" title="image-20250316235712098"><h4 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h4><p>典型的 Linux 文件系统组成：</p><ul><li><strong>Bootfs（boot file system）：</strong><ul><li>Bootloader：引导加载 kernel。</li><li>Kernel：当 kernel 被加载到内存中后 umount bootfs。</li></ul></li><li><strong>rootfs（root file system）：</strong><ul><li><code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件。</li><li>不同的 linux 发行版，bootfs 基本一致，但 rootfs 会有差别。</li></ul></li></ul><p><strong>Docker 启动：</strong></p><ul><li>Linux：启动后，首先将 rootfs 设置为 readonly，进行一系列检查，然后将其切换为 “readwrite” 供用户使用。</li><li>Docker：初始化时也是将 rootfs 以 readonly 方式加载并检查，然后利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上。</li></ul><img src="/2025/03/16/docker/image-20250316235736584.png" class="" title="image-20250316235736584"><pre class="mermaid">graph LR    subgraph Docker File System        A["Read-Only Layer 1 (Base Image)"] --> C(Container Layer - Read-Write)        B[Read-Only Layer 2] --> C        C --> D{Running Container}    end</pre><p><strong>写操作：</strong></p><ul><li><strong>写时复制（Copy-on-Write）：</strong><ul><li>一个镜像可以被多个容器使用，不需要在内存和磁盘上做多个拷贝。</li><li>需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改。</li><li>不同容器对文件的修改相互独立。</li></ul></li><li><strong>用时分配：</strong><ul><li>按需分配空间，而非提前分配。</li></ul></li></ul><h4 id="容器存储驱动"><a href="#容器存储驱动" class="headerlink" title="容器存储驱动"></a>容器存储驱动</h4><table><thead><tr><th>存储驱动</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>AUFS</td><td>Docker 最早支持的驱动类型，稳定性高</td><td>未进入主线内核，只能在有限场合下使用。实现上具有多层结构，在层比较多的场景下，做写时复制有时会需要比较长的时间</td><td>少 I&#x2F;O 的场景</td></tr><tr><td>OverlayFS</td><td>并入主线内核，可在几乎所有发行版本上使用。实现上只有两层，性能比 AUFS 高</td><td>写时复制机制需要复制整个文件，不能只针对修改部分进行复制，对大文件操作会需要比较长的时间。其中 Overlay 在 Docker 的后续版本中被移除</td><td>少 I&#x2F;O 的场景</td></tr><tr><td>Device Mapper</td><td>并入主线内核，针对块操作，性能比较高。修改文件时只需复制需要修改的块，效率高</td><td>不同容器之间不能共享缓存。在 Docker 的后续版本中会被移除</td><td>I&#x2F;O 密集场景</td></tr><tr><td>BtrFS</td><td>并入主线内核，虽然是文件级操作系统，但是可以对块进行操作。</td><td>需要消耗比较多的内存，稳定性相对比较差</td><td>需要支持 Snapshot 等比较特</td></tr><tr><td>ZFS</td><td>不同的容器之间可以共享缓存，多个容器访问相同的文件能够共享一个单一的 Page Cache。</td><td>在频繁写操作的场景下，会产生比较严重的磁盘碎片。需要消耗比较多的内存，另外稳定性相对比较差</td><td>容器高密度部署的场景</td></tr></tbody></table><p><strong>以 OverlayFS 为例：</strong></p><ul><li>OverlayFS 是一种与 AUFS 类似的联合文件系统，属于文件级的存储驱动。</li><li>包含最初的 Overlay 和更新更稳定的 overlay2。</li><li>Overlay 只有两层：upper 层和 lower 层。<ul><li>Lower 层：镜像层。</li><li>Upper 层：容器可写层。</li></ul></li></ul><p><strong>OverlayFS 文件系统练习：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> upper lower merged work<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from lower&quot;</span> &gt; lower/in_lower.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from upper&quot;</span> &gt; upper/in_upper.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from lower&quot;</span> &gt; lower/in_both.txt<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from upper&quot;</span> &gt; upper/in_both.txt<br><span class="hljs-built_in">sudo</span> mount -t overlay overlay -o lowerdir=`<span class="hljs-built_in">pwd</span>`/lower,upperdir=`<span class="hljs-built_in">pwd</span>`/upper,workdir=`<span class="hljs-built_in">pwd</span>`/work `<span class="hljs-built_in">pwd</span>`/merged<br><span class="hljs-built_in">cat</span> merged/in_both.txt<br><span class="hljs-built_in">rm</span> merged/in_both.txt<br><span class="hljs-built_in">rm</span> merged/in_lower.txt<br><span class="hljs-built_in">rm</span> merged/in_upper.txt<br></code></pre></td></tr></table></figure><h4 id="OCI-容器标准"><a href="#OCI-容器标准" class="headerlink" title="OCI 容器标准"></a>OCI 容器标准</h4><ul><li><strong>Open Container Initiative：</strong><ul><li>OCI 组织于 2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织。</li><li>OCI 定义了镜像标准（Runtime Specification）、运行时标准（Image Specification）和分发标准（Distribution Specification）。<ul><li>镜像标准：定义应用如何打包。</li><li>运行时标准：定义如何解压应用包并运行。</li><li>分发标准：定义如何分发容器镜像。</li></ul></li></ul></li></ul><h4 id="Docker-引擎架构"><a href="#Docker-引擎架构" class="headerlink" title="Docker 引擎架构"></a>Docker 引擎架构</h4><img src="/2025/03/16/docker/image-20250316235742348.png" class="" title="image-20250316235742348"><pre class="mermaid">graph LR    A[Docker Client] --> B(Docker Daemon)    B --> C{Images}    B --> D{Containers}    B --> E{Networks}    B --> F{Volumes}</pre><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li><p><strong>Null（<code>--net=None</code>）：</strong></p><ul><li>把容器放入独立的网络空间但不做任何网络配置。</li><li>用户需要通过运行 docker network 命令来完成网络配置。</li></ul></li><li><p><strong>Host：</strong></p><ul><li>使用主机网络名空间，复用主机网络。</li></ul></li><li><p><strong>Container：</strong></p><ul><li>重用其他容器的网络。</li></ul></li><li><p><strong>Bridge（<code>--net=bridge</code>）：</strong></p><ul><li>使用 Linux 网桥和 iptables 提供容器互联。</li><li>Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint。</li></ul><img src="/2025/03/16/docker/image-20250316235751842.png" class="" title="image-20250316235751842"></li></ul><pre class="mermaid">graph LR    subgraph Host        A[Container 1] -->|veth pair| B(docker0 bridge)        C[Container 2] -->|veth pair| B        B --> D{External Network}    end</pre><ul><li><p><strong>Overlay（libnetwork, libkv）：</strong></p><ul><li>通过网络封包实现。</li></ul></li><li><p><strong>Remote (work with remote drivers)</strong></p><ul><li>Underlay<ul><li>使用现有底层网络，为每一个容器配置可路由的网络 IP。</li></ul></li><li>Overlay<ul><li>通过网络封包实现。</li></ul></li></ul></li><li><p><strong>Null 模式</strong></p><ul><li>Null 模式是一个空实现；</li><li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /var/run/netns<br>find -L /var/run/netns -<span class="hljs-built_in">type</span> l -delete<br><span class="hljs-built_in">ln</span> -s /proc/<span class="hljs-variable">$pid</span>/ns/net /var/run/netns/<span class="hljs-variable">$pid</span><br>ip <span class="hljs-built_in">link</span> add A <span class="hljs-built_in">type</span> veth peer name B<br>brctl addif br0 A<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> A up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> B netns <span class="hljs-variable">$pid</span><br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev B name eth0<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip addr add<br><span class="hljs-variable">$SETIP</span>/<span class="hljs-variable">$SETMASK</span> dev eth0<br>ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$pid</span> ip route add default via<br><span class="hljs-variable">$GATEWAY</span><br></code></pre></td></tr></table></figure></li><li><p><strong>默认模式– 网桥和 NAT</strong></p></li><li><img src="/2025/03/16/docker/image-20250316235758666.png" class="" title="image-20250316235758666"><pre class="mermaid">    graph LR    subgraph Host A        A[Container 1] -->|eth0 172.17.0.2| B(veth)        B --> C(docker0 172.17.0.1/16)        D[Container 2] -->|eth0 172.17.0.3| E(veth)        E --> C        C -->|NAT| F(eth0 192.168.0.101)    end</pre><ul><li>为主机 eth0 分配 IP 192.168.0.101。</li><li>启动 docker daemon，查看主机 iptables。<ul><li><code>POSTROUTING -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code></li></ul></li><li>在主机启动容器：<ul><li><code>docker run -d --name ssh -p 2333:22 centos-ssh</code></li><li>Docker 会以标准模式配置网络：<ul><li>创建 veth pair。</li><li>将 veth pair 的一端连接到 docker0 网桥。</li><li>veth pair 的另外一端设置为容器名空间的 eth0。</li><li>为容器名空间的 eth0 分配 ip。</li><li>主机上的 Iptables 规则：<code>PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp --dport 2333 -j DNAT --to-destination 172.17.0.2:22</code>。</li></ul></li></ul></li></ul></li><li><p><strong>Underlay</strong></p><img src="/2025/03/16/docker/image-20250316235807168.png" class="" title="image-20250316235807168"><pre class="mermaid">  graph LR    subgraph Host A        A[Container 1] -->|eth0 10.249.67.31| B(veth)        B --> C(mydr0 10.249.67.30)        D[Container 2] -->|eth0 10.249.67.32| E(veth)        E --> C        C -->|eth0| F{External Network}    end</pre><ul><li>采用 Linux 网桥设备（<code>brctl</code>），通过物理网络连通容器。</li><li>创建新的网桥设备 mydr0。</li><li>将主机网卡加入网桥。</li><li>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 mydr0。</li><li>启动容器。</li><li>创建 veth 对，并且把一个 peer 添加到网桥 mydr0。</li><li>配置容器把 veth 的另一个 peer 分配给容器网卡。</li></ul></li><li><p><strong>Docker Libnetwork Overlay</strong></p><ul><li>Docker overlay 网络驱动原生支持多主机网络。</li><li>Libnetwork 是一个内置的基于 VXLAN 的网络驱动。</li></ul></li></ul><h4 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h4><img src="/2025/03/16/docker/image-20250316235814269.png" class="" title="image-20250316235814269"><pre class="mermaid">graph LR    subgraph Host 1        A[VM 1] --> B(VXLAN Tunnel Endpoint)        B -->|VXLAN Encapsulation| C(Underlay Network)    end    subgraph Host 2        C --> D(VXLAN Tunnel Endpoint)        D --> E[VM 2]    end</pre><h4 id="Overlay-network-sample-–-Flannel"><a href="#Overlay-network-sample-–-Flannel" class="headerlink" title="Overlay network sample – Flannel"></a>Overlay network sample – Flannel</h4><img src="/2025/03/16/docker/image-20250316235818388.png" class="" title="image-20250316235818388"><pre class="mermaid">graph LR    subgraph Host 1        A[Pod 1] -->|Bridge| B(Flannel)        B -->|UDP Encapsulation| C(Underlay Network)    end    subgraph Host 2        C --> D(Flannel)        D -->|Bridge| E[Pod 2]    end</pre><ul><li>同一主机内的 Pod 可以使用网桥进行通信。</li><li>不同主机上的 Pod 将通过 flanneld 将其流量封装在 UDP 数据包中。</li></ul><h4 id="Flannel-packet-sample"><a href="#Flannel-packet-sample" class="headerlink" title="Flannel packet sample"></a>Flannel packet sample</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">Outer</span> Ethernet <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Outer</span> IP <span class="hljs-keyword">Header</span>]<br>[UDP <span class="hljs-keyword">Header</span>]<br>[VXLAN <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Inner</span> Ethernet <span class="hljs-keyword">Header</span>]<br>[<span class="hljs-keyword">Inner</span> IP <span class="hljs-keyword">Header</span>]<br>[Payload]<br></code></pre></td></tr></table></figure><h4 id="创建-docker-镜像"><a href="#创建-docker-镜像" class="headerlink" title="创建 docker 镜像"></a>创建 docker 镜像</h4><ul><li><strong>定义 dockerfile</strong><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-comment"># so apt - get doesn&#x27;t complain</span><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND=noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/^exit 101/exit 0/&#x27;</span> /usr/sbin/policy-rc.d</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> \</span><br><span class="language-bash">apt-get update &amp;&amp; \</span><br><span class="language-bash">apt-get install -y ca-certificates &amp;&amp; \</span><br><span class="language-bash">apt-get install -y curl &amp;&amp; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> ./bin/eic eic</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/eic&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><strong>docker build</strong></li></ul><h3 id="4-Dockerfile-的最佳实践"><a href="#4-Dockerfile-的最佳实践" class="headerlink" title="4. Dockerfile 的最佳实践"></a>4. Dockerfile 的最佳实践</h3><h4 id="回顾-12-Factor-之进程"><a href="#回顾-12-Factor-之进程" class="headerlink" title="回顾 12 Factor 之进程"></a>回顾 12 Factor 之进程</h4><ul><li>运行环境中，应用程序通常是以一个和多个进程运行的。</li><li>12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）。</li><li>任何需要持久化的数据都要存储在后端服务内，比如数据库。</li><li>应在构建阶段将源代码编译成待执行应用。</li><li>Session Sticky 是 12-Factor 极力反对的。</li><li>Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</li></ul><p>Docker 遵循以上原则管理和构建应用。</p><h4 id="理解构建上下文（Build-Context）"><a href="#理解构建上下文（Build-Context）" class="headerlink" title="理解构建上下文（Build Context）"></a>理解构建上下文（Build Context）</h4><ul><li>当运行 <code>docker build</code> 命令时，当前工作目录被称为构建上下文。</li><li><code>docker build</code> 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 <code>-f</code> 指定 Dockerfile。<ul><li><code>docker build -f ./Dockerfile</code></li></ul></li><li>当 <code>docker build</code> 运行时，首先会把构建上下文传输给 docker daemon。</li><li>可以通过 <code>.dockerignore</code> 文件从编译上下文排除某些文件。</li></ul><h4 id="镜像构建日志"><a href="#镜像构建日志" class="headerlink" title="镜像构建日志"></a>镜像构建日志</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker build $GOPATH/src/github.com/cncamp/golang/httpserver/<br>Sending build context to Docker daemon <span class="hljs-number">14.57</span>MB<br>Step <span class="hljs-number">1</span>/<span class="hljs-number">4</span> : <span class="hljs-type">FROM</span> ubuntu<br><span class="hljs-comment">---&gt; cf0f3ca922e0</span><br>Step <span class="hljs-number">2</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ENV</span> MY_SERVICE_PORT=<span class="hljs-number">80</span><br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; a7d824f74410</span><br>Step <span class="hljs-number">3</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ADD</span> bin/amd64/httpserver /httpserver<br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; 00bb47fce704</span><br>Step <span class="hljs-number">4</span>/<span class="hljs-number">4</span> : <span class="hljs-type">ENTRYPOINT</span> /httpserver<br><span class="hljs-comment">---&gt; Using cache</span><br><span class="hljs-comment">---&gt; f77ee3366d08</span><br>Successfully built f77ee3366d08<br></code></pre></td></tr></table></figure><h4 id="Build-Cache"><a href="#Build-Cache" class="headerlink" title="Build Cache"></a>Build Cache</h4><ul><li><p>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p></li><li><p>通常 Docker 简单判断 Dockerfile 中的指令与镜像。</p></li><li><p>针对 <code>ADD</code> 和 <code>COPY</code> 指令，Docker 会比较文件的 checksum。</p></li><li><p>其他指令（如 <code>RUN apt-get -y update</code>），Docker 简单比较指令字串。</p></li><li><p>当某一层 cache 失效，所有后续层级的 cache 均一并失效。</p></li></ul><h4 id="多段构建（Multi-stage-build）"><a href="#多段构建（Multi-stage-build）" class="headerlink" title="多段构建（Multi-stage build）"></a>多段构建（Multi-stage build）</h4><p>多段构建是减少镜像层级、缩小镜像体积的有效方式。它允许您在一个 Dockerfile 中使用多个 <code>FROM</code> 指令，每个 <code>FROM</code> 指令都可以使用不同的基础镜像，并且可以从之前的构建阶段复制文件到当前阶段。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 第一阶段：构建阶段</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.16</span>-alpine AS build<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache git</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go get github.com/golang/dep/cmd/dep</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /go/src/project/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> dep ensure -vendor-only</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /go/src/project/</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o /bin/project  <span class="hljs-comment"># 只有这个二进制文件是最终需要的</span></span><br><br><span class="hljs-comment"># 第二阶段：运行阶段</span><br><span class="hljs-keyword">FROM</span> scratch<br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=build /bin/project /bin/project</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/project&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><strong>第一阶段 (build)：</strong><ul><li>使用 <code>golang:1.16-alpine</code> 作为基础镜像。</li><li>安装依赖、复制代码、编译项目。</li><li>最终生成可执行文件 <code>/bin/project</code>。</li></ul></li><li><strong>第二阶段 (无基础镜像)：</strong><ul><li>使用 <code>scratch</code> 作为基础镜像（一个空的镜像）。</li><li>从第一阶段（<code>build</code>）复制 <code>/bin/project</code> 到当前阶段。</li><li>设置 <code>ENTRYPOINT</code> 和 <code>CMD</code>。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>最终镜像只包含运行所需的二进制文件，极大地减小了镜像体积。</li><li>避免了将编译工具、依赖库等不必要的文件包含在最终镜像中。</li></ul><h4 id="Dockerfile-常用指令"><a href="#Dockerfile-常用指令" class="headerlink" title="Dockerfile 常用指令"></a>Dockerfile 常用指令</h4><ul><li><p><strong><code>FROM</code>：</strong> 选择基础镜像，推荐使用 Alpine Linux（体积小）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>LABEL</code>：</strong> 按标签组织项目。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> multi.label1=<span class="hljs-string">&quot;value1&quot;</span> multi.label2=<span class="hljs-string">&quot;value2&quot;</span> other=<span class="hljs-string">&quot;value3&quot;</span></span><br></code></pre></td></tr></table></figure><p>配合 <code>label filter</code> 可过滤镜像查询结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images -f label=multi.label1=<span class="hljs-string">&quot;value1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>RUN</code>：</strong> 执行命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y &lt;package&gt;</span><br></code></pre></td></tr></table></figure><ul><li>最常见的用法是 <code>RUN apt-get update &amp;&amp; apt-get install</code>，这两条命令应该永远用 <code>&amp;&amp;</code> 连接，以避免缓存导致的问题。</li></ul></li><li><p><strong><code>CMD</code>：</strong> 容器镜像中包含应用的运行命令（需要带参数）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>...]</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>EXPOSE</code>：</strong> 发布端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br></code></pre></td></tr></table></figure><ul><li>是镜像创建者和使用者的约定。</li><li><code>docker run -P</code> 时，Docker 会自动映射 <code>EXPOSE</code> 的端口到主机大端口。</li></ul></li><li><p><strong><code>ENV</code>：</strong> 设置环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...<br></code></pre></td></tr></table></figure></li><li><p><strong><code>ADD</code>：</strong> 从源地址（文件、目录或者 URL）复制文件到目标路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 路径中有空格时使用</span></span><br></code></pre></td></tr></table></figure><ul><li><code>ADD</code> 支持 Go 风格的通配符，如 <code>ADD check* /testdir/</code>。</li><li><code>src</code> 如果是文件，则必须包含在编译上下文中。</li><li><code>src</code> 如果是 URL：<ul><li>如果 <code>dest</code> 结尾没有 <code>/</code>，则 <code>dest</code> 是目标文件名。</li><li>如果 <code>dest</code> 结尾有 <code>/</code>，则 <code>dest</code> 是目标目录名。</li></ul></li><li>如果 <code>src</code> 是一个目录，则所有文件都会被复制至 <code>dest</code>。</li><li>如果 <code>src</code> 是一个本地压缩文件，则在 <code>ADD</code> 的同时完整解压操作。</li><li>如果 <code>dest</code> 不存在，则 <code>ADD</code> 指令会创建目标目录。</li><li>应尽量减少通过 <code>ADD URL</code> 添加 remote 文件，建议使用 <code>curl</code> 或者 <code>wget &amp;&amp; untar</code>。</li></ul></li><li><p><strong><code>COPY</code>：</strong> 从源地址（文件、目录）复制文件到目标路径。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,... <span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 路径中有空格时使用</span></span><br></code></pre></td></tr></table></figure><ul><li><code>COPY</code> 的使用与 <code>ADD</code> 类似，但有如下区别：<ul><li><code>COPY</code> 只支持本地文件的复制，不支持 URL。</li><li><code>COPY</code> 不解压文件。</li><li><code>COPY</code> 可以用于多阶段编译场景。</li></ul></li><li><code>COPY</code> 语义上更直白，复制本地文件时，优先使用 <code>COPY</code>。</li></ul></li><li><p><strong><code>ENTRYPOINT</code>：</strong> 定义可以执行的容器镜像入口命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  <span class="hljs-comment"># docker run 参数追加模式</span></span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2              <span class="hljs-comment"># docker run 参数替换模式</span></span><br></code></pre></td></tr></table></figure><ul><li><code>docker run --entrypoint</code> 可替换 Dockerfile 中定义的 <code>ENTRYPOINT</code>。</li><li>最佳实践：用 <code>ENTRYPOINT</code> 定义镜像主命令，并通过 <code>CMD</code> 定义主要参数。<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;s3cmd&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;--help&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>VOLUME</code>：</strong> 将指定目录定义为外挂存储卷，Dockerfile 中在该指令之后所有对同一目录的修改都无效。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>等价于 <code>docker run -v /data</code>，可通过 <code>docker inspect</code> 查看主机的 mount point。</p></li><li><p><strong><code>USER</code>：</strong> 切换运行镜像的用户和用户组。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">USER</span> &lt;<span class="hljs-keyword">user</span>&gt;[:&lt;group&gt;]<br></code></pre></td></tr></table></figure></li><li><p><strong><code>WORKDIR</code>：</strong> 等价于 <code>cd</code>，切换工作目录。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span><br></code></pre></td></tr></table></figure></li><li><p><strong>其他非常用指令：</strong></p><ul><li><code>ARG</code></li><li><code>ONBUILD</code></li><li><code>STOPSIGNAL</code></li><li><code>HEALTHCHECK</code></li><li><code>SHELL</code></li></ul></li></ul><h4 id="Dockerfile-最佳实践总结"><a href="#Dockerfile-最佳实践总结" class="headerlink" title="Dockerfile 最佳实践总结"></a>Dockerfile 最佳实践总结</h4><ul><li><strong>不要安装无效软件包。</strong></li><li><strong>简化镜像中同时运行的进程数：</strong> 理想状况下，每个镜像应该只有一个进程。</li><li><strong>最小化层级数：</strong><ul><li>最新的 Docker 只有 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 创建新层。</li><li>多条 <code>RUN</code> 命令可通过连接符连接成一条指令集。</li><li>通过多段构建减少镜像层数。</li></ul></li><li><strong>把多行参数按字母排序。</strong></li><li><strong>编写 dockerfile 的时候，应该把变更频率低的编译指令优先构建。</strong></li><li><strong>复制文件时，每个文件应独立复制。</strong></li></ul><p><strong>目标：</strong> 易管理、少漏洞、镜像小、层级少、利用缓存。</p><h4 id="多进程的容器镜像"><a href="#多进程的容器镜像" class="headerlink" title="多进程的容器镜像"></a>多进程的容器镜像</h4><ul><li><strong>选择适当的 init 进程：</strong><ul><li>需要捕获 <code>SIGTERM</code> 信号并完成子进程的优雅终止。</li><li>负责清理退出的子进程以避免僵尸进程。</li></ul></li><li><strong>开源项目：</strong> <a href="https://github.com/krallin/tini">https://github.com/krallin/tini</a></li></ul><h3 id="5-Docker-镜像管理"><a href="#5-Docker-镜像管理" class="headerlink" title="5. Docker 镜像管理"></a>5. Docker 镜像管理</h3><ul><li><code>docker save/load</code>：保存和加载镜像。</li><li><code>docker tag</code>：为镜像打标签。</li><li><code>docker push/pull</code>：推送和拉取镜像。</li></ul><h4 id="基于-Docker-镜像的版本管理"><a href="#基于-Docker-镜像的版本管理" class="headerlink" title="基于 Docker 镜像的版本管理"></a>基于 Docker 镜像的版本管理</h4><ul><li><p><strong><code>docker tag</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag &lt;image_id&gt; &lt;repository&gt;/&lt;image_name&gt;:&lt;tag&gt;<br></code></pre></td></tr></table></figure><ul><li><code>hub.docker.com</code>：镜像仓库地址（如果不填，默认为 <code>hub.docker.com</code>）。</li><li><code>cncamp</code>：repository。</li><li><code>httpserver</code>：镜像名。</li><li><code>v1.0</code>：tag（常用来记录版本信息）。</li></ul></li><li><p><strong>Docker tag 与 GitHub 的版本管理合力：</strong></p><p>以 Kubernetes 为例：</p><ol><li><strong>开发分支：</strong> <code>git checkout master</code></li><li><strong>Release 分支：</strong> <code>git checkout -b release-1.21</code></li><li><strong>版本发布：</strong><ul><li>以 release branch 为基础构建镜像，并为镜像标记版本信息：<code>docker tag &lt;image_id&gt; k8s.io/kubernetes/apiserver:v1.21</code></li><li>在 GitHub 中保存 release 代码快照：<code>git tag v1.21</code></li></ul></li></ol></li></ul><h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4><ul><li><p><strong>Docker Hub：</strong> <a href="https://hub.docker.com/">https://hub.docker.com/</a></p></li><li><p><strong>创建私有镜像仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run -d -p 5000:5000 registry<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-Docker-优势与劣势"><a href="#6-Docker-优势与劣势" class="headerlink" title="6. Docker 优势与劣势"></a>6. Docker 优势与劣势</h3><h4 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h4><ul><li><strong>封装性：</strong><ul><li>应用扩缩容时可以秒速启动。</li><li>资源利用率高。</li><li>方便的 CPU、内存资源调整。</li><li>能实现秒级快速回滚。</li><li>一键启动所有依赖服务。</li><li>镜像一次编译，随处使用。</li><li>测试、生产环境高度一致。</li></ul></li><li><strong>隔离性：</strong><ul><li>应用的运行环境和宿主机环境无关，完全由镜像控制。</li><li>多个应用版本可以并存在机器上。</li></ul></li><li><strong>社区活跃：</strong><ul><li>Docker 命令简单、易用，社区十分活跃，且周边组件丰富。</li></ul></li></ul><h4 id="Docker-劣势"><a href="#Docker-劣势" class="headerlink" title="Docker 劣势"></a>Docker 劣势</h4><ul><li><strong>隔离性不如虚拟机：</strong> 容器共享宿主机内核，隔离性相对较弱。</li><li><strong>安全性：</strong> 如果容器内的应用存在漏洞，可能会影响到宿主机或其他容器。</li><li><strong>网络配置复杂：</strong> 跨主机容器网络配置相对复杂。</li><li><strong>资源限制：</strong> 虽然可以使用 Cgroups 进行资源限制，但配置和管理相对复杂。</li><li><strong>持久化存储：</strong> 容器的持久化存储需要额外的配置和管理。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker,k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2025/03/14/%E5%89%91%E6%8C%87offer/"/>
    <url>/2025/03/14/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<p>剑指 offer 算法刷题记录（Golang 版）</p><span id="more"></span><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><strong>从尾到头打印链表</strong></h2><p>描述</p><p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p>如输入{1,2,3}的链表如下图:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626506480516/103D87B58E565E87DEFA9DD0B822C55F" alt="img"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(head *ListNode)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>stack=<span class="hljs-built_in">append</span>(stack, head.Val)<br>        head = head.Next<br>&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&#123;<br>        res = <span class="hljs-built_in">append</span>(res, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>思路解释：</p><p>从尾到头的顺序，很容易想到栈的结构，后进先出即可。具体步骤如下：</p><ol><li>初始化一个空的栈 <code>stack</code> 和结果数组 <code>res</code>。</li><li>遍历链表，将每个节点的值压入栈中。</li><li>遍历栈，将栈顶元素弹出并添加到结果数组中，直到栈为空。</li><li>返回结果数组 <code>res</code>。</li></ol><p>这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是链表的长度。</p><p>好的，下面是对你提供的链表反转问题的总结：</p><h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><p>题目</p><p>给定一个单链表的头节点，反转该链表，并返回反转后的链表的头节点。</p><p><strong>示例：</strong></p><ul><li>输入：<code>&#123;1, 2, 3&#125;</code></li><li>输出：<code>&#123;3, 2, 1&#125;</code></li></ul><p>思路</p><p>链表反转的思路可以用一个非常经典的比喻来理解：<strong>想象你有一堆牌，你需要把它们的顺序颠倒过来。</strong></p><ol><li><p><strong>三个指针：</strong> 我们需要三个指针来完成这个任务：</p><ul><li><code>prev</code>：指向已经反转好的链表的头节点。初始时，它指向 <code>nil</code>，因为最开始还没有反转任何节点。</li><li><code>current</code>：指向当前正在处理的节点。</li><li><code>next</code>：指向 <code>current</code> 节点的下一个节点，用于在断开 <code>current</code> 节点的 <code>Next</code> 指针之前，保存后续节点的引用，防止链表断裂。</li></ul></li><li><p><strong>迭代反转：</strong> 遍历链表，对于每个 <code>current</code> 节点，执行以下操作：</p><ul><li><strong>保存 <code>next</code>：</strong> 首先，用 <code>next</code> 指针保存 <code>current.Next</code>，因为接下来要修改 <code>current.Next</code>。</li><li><strong>反转指针：</strong> 将 <code>current.Next</code> 指向 <code>prev</code>，实现反转。</li><li><strong>移动指针：</strong> 将 <code>prev</code> 移动到 <code>current</code>，<code>current</code> 移动到 <code>next</code>，为处理下一个节点做准备。</li></ul></li><li><p><strong>新的头节点：</strong> 当 <code>current</code> 指针到达链表末尾（<code>nil</code>）时，<code>prev</code> 指针指向的就是反转后链表的头节点。</p></li></ol><p><strong>图解：</strong></p><p>假设链表为 <code>1 -&gt; 2 -&gt; 3 -&gt; nil</code></p><ol><li>初始状态：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> nil<br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ol start="2"><li>第一次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">1</span> -&gt; nil<br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 -&gt; 3 -&gt; nil</code> (1 指向 nil)</p><ol start="3"><li>第二次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 &lt;- 3 -&gt; nil</code> (2 指向 1)</p><ol start="4"><li>第三次迭代：</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">next</span> <span class="hljs-operator">=</span> current.Next  // next <span class="hljs-operator">=</span> nil<br>current.Next <span class="hljs-operator">=</span> prev  // <span class="hljs-number">3</span> -&gt; <span class="hljs-number">2</span><br><span class="hljs-attribute">prev</span> <span class="hljs-operator">=</span> current       // prev <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">current</span> <span class="hljs-operator">=</span> next       // current <span class="hljs-operator">=</span> nil<br></code></pre></td></tr></table></figure><p>链表变为：<code>1 &lt;- 2 &lt;- 3</code> (3 指向 2)</p><ol start="5"><li>循环结束：<code>current</code> 为 <code>nil</code>，<code>prev</code> 指向新的头节点 <code>3</code>。</li></ol><p>算法代码 (Go)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-comment">// write code here</span><br><span class="hljs-keyword">var</span> prev *ListNode = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">var</span> current *ListNode = head<br><span class="hljs-keyword">for</span> current != <span class="hljs-literal">nil</span> &#123;<br>next := current.Next <span class="hljs-comment">// 保存下一个节点</span><br>current.Next = prev  <span class="hljs-comment">// 反转指针</span><br>prev = current       <span class="hljs-comment">// 移动 prev 指针</span><br>current = next       <span class="hljs-comment">// 移动 current 指针</span><br>&#125;<br><span class="hljs-keyword">return</span> prev <span class="hljs-comment">// prev 指向新的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li><strong>适用场景：</strong> 这种反转链表的方法适用于单链表结构。它是一种原地反转算法，只需要常数级别的额外空间（三个指针），因此空间复杂度为 O(1)。时间复杂度为 O(n)，因为需要遍历链表一次。</li><li><strong>算法类型：</strong> 链表操作</li><li><strong>技巧：</strong> 使用多个指针来辅助完成链表结构的修改是非常常见的技巧。一定要理清指针的指向关系，防止链表断裂。</li><li><strong>易错点：</strong> 在反转指针之前，一定要先保存下一个节点的引用，否则链表会断裂。</li><li><strong>变体：</strong> 链表反转有很多变体，例如反转链表的一部分（指定起始和结束位置）。基本思路都是类似的，需要仔细处理指针的指向。</li></ul><p>好的，下面是对你提供的题目和代码的总结：</p><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>题目描述</p><p>输入两个递增的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>数据范围：</strong></p><ul><li>单个链表的长度 <code>n</code> 满足 <code>0 &lt;= n &lt;= 1000</code></li><li>节点值满足 <code>-1000 &lt;= 节点值 &lt;= 1000</code></li></ul><p><strong>要求：</strong></p><ul><li>空间复杂度 O(1)</li><li>时间复杂度 O(n)</li></ul><p>解题思路</p><p>这道题的解题思路非常经典，就是<strong>迭代</strong>比较两个链表的当前节点，将较小的节点添加到新的链表中。  由于输入链表是递增的，所以我们只需要比较两个链表的头节点，将较小的节点作为新链表的头节点，然后递归地处理剩余的链表即可。</p><p>具体步骤如下：</p><ol><li><p><strong>初始化：</strong></p><ul><li>创建一个哑节点（dummy node），作为合并后链表的头节点。哑节点不存储实际数据，只是为了方便操作。</li><li>创建一个指针 <code>current</code>，指向哑节点，用于构建合并后的链表。</li></ul></li><li><p><strong>迭代比较：</strong></p><ul><li>循环比较 <code>pHead1</code> 和 <code>pHead2</code> 指向的节点的值，直到其中一个链表为空。</li><li>如果 <code>pHead1.Val &lt;= pHead2.Val</code>，则将 <code>pHead1</code> 指向的节点添加到 <code>current</code> 的 <code>Next</code> 指针，并将 <code>pHead1</code> 向后移动一位。</li><li>否则，将 <code>pHead2</code> 指向的节点添加到 <code>current</code> 的 <code>Next</code> 指针，并将 <code>pHead2</code> 向后移动一位。</li><li>将 <code>current</code> 指针向后移动一位。</li></ul></li><li><p><strong>处理剩余节点：</strong></p><ul><li>当其中一个链表为空时，将另一个链表剩余的节点直接添加到 <code>current</code> 的 <code>Next</code> 指针。</li></ul></li><li><p><strong>返回结果：</strong></p><ul><li>返回哑节点的 <code>Next</code> 指针，即合并后的链表的头节点。</li></ul></li></ol><p><strong>为什么使用哑节点？</strong></p><p>使用哑节点可以避免对头节点的特殊处理，使代码更加简洁。如果没有哑节点，我们需要判断合并后的链表的头节点是 <code>pHead1</code> 还是 <code>pHead2</code>，这会增加代码的复杂性。</p><p>代码实现 (Go)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param pHead1 ListNode类</span><br><span class="hljs-comment"> * @param pHead2 ListNode类</span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Merge</span><span class="hljs-params">(pHead1 *ListNode, pHead2 *ListNode)</span></span> *ListNode &#123;<br>dummy := &amp;ListNode&#123;&#125; <span class="hljs-comment">// 创建哑节点</span><br>current := dummy     <span class="hljs-comment">// current 指针指向哑节点</span><br><br><span class="hljs-comment">// 循环比较两个链表的节点</span><br><span class="hljs-keyword">for</span> pHead1 != <span class="hljs-literal">nil</span> &amp;&amp; pHead2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pHead1.Val &lt;= pHead2.Val &#123;<br>current.Next = pHead1 <span class="hljs-comment">// 将 pHead1 的节点添加到新链表</span><br>pHead1 = pHead1.Next    <span class="hljs-comment">// pHead1 向后移动</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>current.Next = pHead2 <span class="hljs-comment">// 将 pHead2 的节点添加到新链表</span><br>pHead2 = pHead2.Next    <span class="hljs-comment">// pHead2 向后移动</span><br>&#125;<br>current = current.Next <span class="hljs-comment">// current 向后移动</span><br>&#125;<br><br><span class="hljs-comment">// 处理剩余节点</span><br><span class="hljs-keyword">if</span> pHead1 != <span class="hljs-literal">nil</span> &#123;<br>current.Next = pHead1 <span class="hljs-comment">// 将 pHead1 剩余的节点添加到新链表</span><br>&#125;<br><span class="hljs-keyword">if</span> pHead2 != <span class="hljs-literal">nil</span> &#123;<br>current.Next = pHead2 <span class="hljs-comment">// 将 pHead2 剩余的节点添加到新链表</span><br>&#125;<br><br><span class="hljs-keyword">return</span> dummy.Next <span class="hljs-comment">// 返回新链表的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><strong>时间复杂度：</strong> O(n)，其中 n 是两个链表的总长度。我们需要遍历两个链表的所有节点。</li><li><strong>空间复杂度：</strong> O(1)。我们只使用了常量级的额外空间，例如哑节点和 <code>current</code> 指针。</li></ul><p>适用题目类型</p><p>这种合并排序链表的思路，通常适用于以下类型的题目：</p><ul><li><strong>涉及到两个或多个有序数据结构的合并问题。</strong>  例如，合并 k 个排序链表。</li><li><strong>需要保持合并后的数据结构仍然有序的问题。</strong></li><li><strong>对空间复杂度有要求的题目。</strong>  由于该算法的空间复杂度为 O(1)，因此非常适合对空间复杂度有严格限制的题目。</li></ul><p><strong>举例：</strong></p><ul><li><strong>LeetCode 23. 合并 K 个排序链表</strong></li><li><strong>类似本题的变种，例如要求合并后链表为降序排列。</strong></li></ul><p>好的，我们来一起梳理一下这道寻找链表公共节点的题目。我会用易懂的方式解释思路，并提供带有详细注释的 Golang 代码。</p><h2 id="寻找链表的第一个公共节点"><a href="#寻找链表的第一个公共节点" class="headerlink" title="寻找链表的第一个公共节点"></a>寻找链表的第一个公共节点</h2><p><strong>题目描述：</strong></p><p>给定两个无环的单向链表，找到它们的第一个公共节点。如果不存在公共节点，则返回 <code>nil</code>。</p><p><strong>要求：</strong></p><ul><li>空间复杂度为 O(1)。</li><li>时间复杂度为 O(n)。</li></ul><p>思路解析</p><p>想象一下，你在两条不同的河流上划船。两条河流最终汇入同一条河流，那么汇入点就是它们的第一个公共点。</p><ol><li><strong>长度差：</strong> 首先，我们需要知道两条河流（链表）的长度差。如果一条河流比另一条长，我们需要让较长的河流先划一段时间，直到它们到达同一起跑线。</li><li><strong>同步前进：</strong> 然后，两条河流同时开始划船，每次都前进一步。当两条船在同一个位置时，我们就找到了它们的第一个公共点。</li><li><strong>没有公共点：</strong> 如果两条河流一直没有相遇，那么它们就没有公共点。</li></ol><p><strong>图解：</strong></p><p>假设我们有两个链表：</p><ul><li>链表 A: <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code></li><li>链表 B: <code>      a -&gt; b -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</code></li></ul><p>它们的第一个公共节点是 <code>4</code>。</p><p>用 Mermaid 图表示如下：</p><pre class="mermaid">graph LR    A1(1) --> A2(2)    A2 --> A3(3)    A3 --> A4(4)    A4 --> A5(5)    A5 --> A6(6)    A6 --> A7(7)    B1(a) --> B2(b)    B2 --> A4</pre><p><strong>步骤：</strong></p><ol><li>计算链表 A 的长度（lenA &#x3D; 7）。</li><li>计算链表 B 的长度（lenB &#x3D; 2 + 5 &#x3D; 7）。</li><li>计算长度差（diff &#x3D; lenA - lenB &#x3D; 0）。</li><li>因为长度相等，所以不需要移动任何链表的头指针。</li><li>同时遍历链表 A 和链表 B，直到找到相同的节点（即节点 4）。</li></ol><p>Golang 代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> . <span class="hljs-string">&quot;nc_tools&quot;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * type ListNode struct&#123;</span><br><span class="hljs-comment"> *   Val int</span><br><span class="hljs-comment"> *   Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param pHead1 ListNode类</span><br><span class="hljs-comment"> * @param pHead2 ListNode类</span><br><span class="hljs-comment"> * @return ListNode类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(pHead1 *ListNode, pHead2 *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-comment">// 1. 判空处理：如果任一链表为空，则没有公共节点</span><br><span class="hljs-keyword">if</span> pHead1 == <span class="hljs-literal">nil</span> || pHead2 == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 2. 获取两个链表的长度</span><br>len1 := GetLength(pHead1)<br>len2 := GetLength(pHead2)<br><br><span class="hljs-comment">// 3. 计算长度差，让较长的链表先走几步</span><br>diff := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> len1 &gt; len2 &#123;<br>diff = len1 - len2<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; diff; i++ &#123;<br>pHead1 = pHead1.Next <span class="hljs-comment">// 移动 pHead1 到同一起跑线</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>diff = len2 - len1<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; diff; i++ &#123;<br>pHead2 = pHead2.Next <span class="hljs-comment">// 移动 pHead2 到同一起跑线</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 同时遍历两个链表，查找相同节点</span><br><span class="hljs-keyword">for</span> pHead1 != <span class="hljs-literal">nil</span> &amp;&amp; pHead2 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pHead1 == pHead2 &#123; <span class="hljs-comment">// 直接比较指针，如果指针相同则找到公共节点</span><br><span class="hljs-keyword">return</span> pHead1<br>&#125;<br>pHead1 = pHead1.Next <span class="hljs-comment">// 同时移动 pHead1</span><br>pHead2 = pHead2.Next <span class="hljs-comment">// 同时移动 pHead2</span><br>&#125;<br><br><span class="hljs-comment">// 5. 如果没有找到公共节点，则返回 nil</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// GetLength 获取链表的长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">int</span> &#123;<br>length := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>length++        <span class="hljs-comment">// 累加长度</span><br>head = head.Next <span class="hljs-comment">// 移动到下一个节点</span><br>&#125;<br><span class="hljs-keyword">return</span> length<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释</p><ol><li><strong>判空处理：</strong>  如果任何一个链表为空，那么它们不可能有公共节点，直接返回 <code>nil</code>。</li><li><strong>获取链表长度：</strong>  <code>GetLength</code> 函数用于计算链表的长度。</li><li><strong>调整起始位置：</strong>  计算长度差，并让较长的链表先移动，直到两个链表在同一起跑线上。</li><li><strong>同步遍历：</strong>  同时遍历两个链表，比较节点是否相同。如果找到相同的节点，则返回该节点。</li><li><strong>没有公共节点：</strong>  如果遍历完整个链表都没有找到公共节点，则返回 <code>nil</code>。</li></ol><p>适用场景</p><p>这种方法特别适用于以下场景：</p><ul><li>寻找两个单链表的第一个公共节点。</li><li>要求时间复杂度为 O(n)，空间复杂度为 O(1)。</li><li>链表没有环。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 etcd</title>
    <link href="/2025/03/13/etcd/"/>
    <url>/2025/03/13/etcd/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解-etcd：一个分布式键值存储系统"><a href="#深入理解-etcd：一个分布式键值存储系统" class="headerlink" title="深入理解 etcd：一个分布式键值存储系统"></a>深入理解 etcd：一个分布式键值存储系统</h1> <span id="more"></span><img src="/2025/03/13/etcd/image-20250315134912712.png" class="" title="image-20250315134912712"><p>好的，根据您提供的内容，我整理了一篇关于 Kubernetes 控制平面组件 etcd 的技术博客，内容如下：</p><h1 id="深入理解-Kubernetes-基石：etcd-详解"><a href="#深入理解-Kubernetes-基石：etcd-详解" class="headerlink" title="深入理解 Kubernetes 基石：etcd 详解"></a>深入理解 Kubernetes 基石：etcd 详解</h1><p><strong>作者：</strong> 孟凡杰（前 eBay 资深架构师）</p><p><strong>引言</strong></p><p>在 Kubernetes（K8s）集群中，etcd 扮演着至关重要的角色。它是整个集群的“大脑”，负责存储集群状态、配置信息以及进行服务发现。本文将深入探讨 etcd 的核心概念、功能、使用场景、Raft 协议、存储机制、高可用方案以及在 Kubernetes 中的应用，帮助您全面理解这一关键组件。</p><h2 id="什么是-etcd？"><a href="#什么是-etcd？" class="headerlink" title="什么是 etcd？"></a>什么是 etcd？</h2><p>etcd 是由 CoreOS（现已被 Red Hat 收购）开发的一个开源、分布式、高可用的键值存储系统。它基于 Raft 一致性算法，确保数据在多个节点之间保持一致性，即使在部分节点故障的情况下也能正常运行。</p><p>etcd 的主要特点：</p><ul><li><strong>键值对存储：</strong> 数据以键值对的形式存储在分层目录结构中，类似于文件系统。</li><li><strong>变更监测：</strong> 可以监测特定键或目录的变化，并在发生变化时做出反应。</li><li><strong>简单易用：</strong> 提供 HTTP+JSON 的 API，易于使用 curl 等工具进行访问。</li><li><strong>安全可靠：</strong> 支持 SSL 客户端证书认证，使用 Raft 算法保证数据一致性。</li><li><strong>高性能：</strong> 单实例每秒可处理数千次读写操作。</li></ul><h2 id="etcd-的核心功能"><a href="#etcd-的核心功能" class="headerlink" title="etcd 的核心功能"></a>etcd 的核心功能</h2><p>etcd 主要提供以下功能：</p><ol><li><strong>基本的键值存储：</strong> 存储和检索数据。</li><li><strong>监听机制：</strong> 监听键或目录的变化，实现实时通知。</li><li><strong>键的过期及续约：</strong> 用于监控和服务发现，确保服务的可用性。</li><li><strong>原子 Compare And Swap (CAS) 和 Compare And Delete (CAD)：</strong> 用于实现分布式锁和领导者选举。</li></ol><h2 id="etcd-的典型应用场景"><a href="#etcd-的典型应用场景" class="headerlink" title="etcd 的典型应用场景"></a>etcd 的典型应用场景</h2><p>etcd 在分布式系统中有着广泛的应用，常见的场景包括：</p><ol><li><strong>服务注册与发现：</strong> 服务提供者将自己的信息注册到 etcd，服务消费者通过 etcd 发现可用的服务实例。</li><li><strong>消息发布与订阅：</strong> 构建配置共享中心，实现配置的集中管理和动态更新。</li><li><strong>分布式锁：</strong> 利用 CAS 或 CAD 操作实现分布式锁，协调多个进程对共享资源的访问。</li><li><strong>领导者选举：</strong> 在分布式系统中选举出一个领导者，负责协调和管理其他节点。</li><li><strong>键值对存储:</strong> 作为数据库存储集群数据。</li></ol><p><strong>服务注册与发现示例（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000021831.png" class="" title="image-20250317000021831"><pre class="mermaid">graph LR    subgraph 服务注册        A[服务提供者] --> B(向 etcd 注册服务)    end    subgraph 服务发现        C[服务消费者] --> D(从 etcd 查询服务)    end    B --> E[etcd]    D --> E    subgraph 服务绑定        F[服务消费者] --> G[服务提供者]    end</pre><p><strong>消息发布与订阅示例（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000027311.png" class="" title="image-20250317000027311"><pre class="mermaid">graph LR    subgraph 消息发布        A[生产者] --> B(向 etcd 发布消息)    end    subgraph 消息订阅        C[服务消费者] --> D(从 etcd 订阅消息)    end    B --> E[etcd]    D --> E</pre><h2 id="etcd-的安装与使用"><a href="#etcd-的安装与使用" class="headerlink" title="etcd 的安装与使用"></a>etcd 的安装与使用</h2><p>etcd 的安装非常简单，可以从 GitHub Releases 页面下载预编译的二进制文件，解压后即可运行。</p><p><strong>安装步骤（示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ETCD_VER=v3.4.17<br>DOWNLOAD_URL=https://github.com/etcd-io/etcd/releases/download<br><span class="hljs-built_in">rm</span> -f /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br><span class="hljs-built_in">rm</span> -rf /tmp/etcd-download-test &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /tmp/etcd-download-test<br>curl -L <span class="hljs-variable">$&#123;DOWNLOAD_URL&#125;</span>/<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -o /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br>tar xzvf /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1<br><span class="hljs-built_in">rm</span> -f /tmp/etcd-<span class="hljs-variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><p><strong>常用客户端工具：</strong></p><ul><li><strong>etcdctl：</strong> 命令行客户端工具，用于与 etcd 集群交互。</li><li><strong>go-etcd：</strong> Go 语言客户端库。</li><li><strong>jetcd：</strong> Java 客户端库。</li><li><strong>python-etcd：</strong> Python 客户端库。</li></ul><p><strong>基本数据读写操作（etcdctl 示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 写入数据</span><br>etcdctl --endpoints=localhost:12379 put /a b<br><br><span class="hljs-comment"># 读取数据</span><br>etcdctl --endpoints=localhost:12379 get /a<br><br><span class="hljs-comment"># 按 key 的前缀查询数据</span><br>etcdctl --endpoints=localhost:12379 get --prefix /<br><br><span class="hljs-comment"># 只显示键值</span><br>etcdctl --endpoints=localhost:12379 get --prefix / --keys-only --debug<br></code></pre></td></tr></table></figure><h2 id="深入理解-Raft-一致性协议"><a href="#深入理解-Raft-一致性协议" class="headerlink" title="深入理解 Raft 一致性协议"></a>深入理解 Raft 一致性协议</h2><p>etcd 的数据一致性是基于 Raft 协议实现的。Raft 是一种易于理解的分布式一致性算法，它将一致性问题分解为几个子问题：</p><ol><li><strong>领导者选举（Leader Election）：</strong> 初始启动或领导者失效时，集群中的节点会通过投票选举出一个新的领导者。</li><li><strong>日志复制（Log Replication）：</strong> 领导者接收客户端的请求，并将请求作为日志条目复制到其他节点。</li><li><strong>安全性（Safety）：</strong> 确保每个节点都执行相同序列的命令，保证数据的一致性。</li></ol><p><strong>Raft 协议角色：</strong></p><ul><li><strong>Leader（领导者）：</strong> 负责接收客户端请求、日志复制和向 Follower 发送心跳。</li><li><strong>Follower（跟随者）：</strong> 接收 Leader 的日志并复制到本地，参与投票选举 Leader。</li><li><strong>Candidate（候选者）：</strong> 在 Leader 选举过程中，Follower 会转变为 Candidate，发起投票。</li><li><strong>Learner:</strong> 新加入的节点，只接收数据而不参与投票，因此增加<br>learner节点时，集群的quorum不变。</li></ul><p><strong>Raft 协议流程（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000031277.png" class="" title="image-20250317000031277"><pre class="mermaid">graph LR    subgraph 客户端请求        A[客户端] --> B[Leader]    end    subgraph Leader 处理        B --> C[将请求追加到本地日志]        B --> D[通过心跳将日志同步给 Follower]    end    subgraph Follower 处理        D --> E[Follower 接收日志并记录]        E --> F[向 Leader 发送 ACK]    end    subgraph Leader 提交        B -- 收到多数 Follower ACK --> G[将日志设置为已提交]        G --> H[通知客户端]        B -- 下次心跳 --> I[通知 Follower 提交日志]    end</pre><p><strong>Raft 协议失效处理：</strong></p><ol><li><strong>Leader 失效：</strong> Follower 在超时时间内未收到 Leader 心跳，会发起选举。</li><li><strong>Follower 失效：</strong> 重新加入集群后，从 Leader 复制日志。</li><li><strong>多个 Candidate：</strong> 随机等待一段时间后再次发起投票。</li></ol><p><strong>WAL 日志：</strong></p><p>etcd 使用预写式日志（WAL）来记录所有的数据变更。WAL 日志是二进制格式的，包含以下字段：</p><ul><li><strong>type：</strong> 0 表示 Normal，1 表示 ConfChange（配置变更）。</li><li><strong>term：</strong> 主节点任期，每次主节点变更时递增。</li><li><strong>index：</strong> 变更序号，严格有序递增。</li><li><strong>data：</strong> Raft 请求对象的 pb 结构。</li></ul><h2 id="etcd-的存储机制"><a href="#etcd-的存储机制" class="headerlink" title="etcd 的存储机制"></a>etcd 的存储机制</h2><p>etcd v3 的存储分为两部分：</p><ol><li><strong>内存索引（kvindex）：</strong> 基于 Google 开源的 btree 实现，用于加速查询。</li><li><strong>后端存储（backend）：</strong> 目前使用 boltdb，一个单机的支持事务的 KV 存储。</li></ol><p>etcd 在 boltdb 中存储的 key 是 reversion，value 是 etcd 自己的 key-value 组合，实现了多版本机制。</p><p><strong>reversion:</strong> 由两部分组成:</p><ol><li><strong>main rev：</strong> 每次事务进行加一。</li><li><strong>sub rev:</strong> 同一个事务中的每次操作加一。</li></ol><p><strong>存储机制示意图（Mermaid 流程图）：</strong></p><img src="/2025/03/13/etcd/image-20250317000035671.png" class="" title="image-20250317000035671"><pre class="mermaid">graph LR    subgraph etcd v3 存储        A[客户端请求] --> B[Leader]        B --> C["一致性模块 (Raft)"]        C --> D["预检查 (鉴权, 包大小等)"]        C --> E["配额, 限速, 选主, 日志复制"]        E --> F["写 WAL 日志"]        F --> G["写 raftLog (内存)"]        G --> H["收到半数确认, 更新 MatchIndex, Apply"]        H --> I["MVCC 模块"]        I --> J["treeIndex (内存索引)"]        I --> K["BoltDB (后端存储)"]    end</pre><h2 id="etcd-的-Watch-机制"><a href="#etcd-的-Watch-机制" class="headerlink" title="etcd 的 Watch 机制"></a>etcd 的 Watch 机制</h2><p>etcd v3 的 Watch 机制支持监听特定 key 或范围（模拟目录结构）。每个 WatchableStore 包含两种 watcherGroup：</p><ol><li><strong>synced：</strong> watcher 数据已同步完毕，等待新的变更。</li><li><strong>unsynced：</strong> watcher 数据同步落后于当前最新变更，还在追赶。</li></ol><p>etcd 会启动一个后台 goroutine 持续同步 unsynced 的 watcher，然后将其迁移到 synced 组。</p><img src="/2025/03/13/etcd/image-20250317001558102.png" class="" title="image-20250317001558102"><h2 id="etcd-的高可用方案"><a href="#etcd-的高可用方案" class="headerlink" title="etcd 的高可用方案"></a>etcd 的高可用方案</h2><p>为了确保 etcd 集群的高可用性，通常采用以下方案：</p><ol><li><strong>多节点部署：</strong> 部署 3 个或 5 个 etcd 节点，形成集群。</li><li><strong>故障转移：</strong> 当 Leader 节点故障时，其他节点会通过 Raft 协议选举出新的 Leader。</li><li><strong>数据备份：</strong> 定期创建快照，并将快照上传到网络存储设备，以防数据丢失。</li></ol><p><strong>高可用 etcd 解决方案：</strong></p><ul><li><strong>etcd-operator：</strong> CoreOS 开源的基于 Kubernetes CRD 的 etcd 集群配置工具（已归档）。</li></ul><img src="/2025/03/13/etcd/image-20250317001627420.png" class="" title="image-20250317001627420"><ul><li><strong>Etcd statefulset Helm chart：</strong> Bitnami 提供的 Helm chart，用于在 Kubernetes 上部署高可用 etcd 集群。</li></ul><p><strong>使用 Bitnami Helm chart 安装 etcd 高可用集群（示例）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 helm</span><br><span class="hljs-comment"># 参考 https://github.com/helm/helm/releases</span><br><br><span class="hljs-comment"># 通过 helm 安装 etcd</span><br>helm repo add bitnami https://charts.bitnami.com/bitnami<br>helm install my-release bitnami/etcd<br></code></pre></td></tr></table></figure><h2 id="etcd-在-Kubernetes-中的应用"><a href="#etcd-在-Kubernetes-中的应用" class="headerlink" title="etcd 在 Kubernetes 中的应用"></a>etcd 在 Kubernetes 中的应用</h2><p>etcd 是 Kubernetes 的后端存储，用于存储集群的所有状态信息。</p><ul><li>对于每一个 Kubernetes Object，都有对应的 <code>storage.go</code> 文件负责对象的存储操作（例如 <code>pkg/registry/core/pod/storage/storage.go</code>）。</li><li>API Server 启动脚本中会指定 etcd servers 集群的地址。</li><li>早期 API server 对 etcd 做简单的 Ping check，现在已经改为真实的 etcd api call。</li></ul><p><strong>Kubernetes 对象在 etcd 中的存储路径示例：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-regexp">/registry/</span>namespaces<span class="hljs-operator">/</span>calico<span class="hljs-operator">-</span>apiserver<br><span class="hljs-regexp">/registry/</span>networkpolicies<span class="hljs-regexp">/calico-apiserver/</span>allow<span class="hljs-operator">-</span>apiserver<br><span class="hljs-regexp">/registry/</span><span class="hljs-keyword">operator</span>.tigera.io<span class="hljs-regexp">/tigerastatuses/</span>apiserver<br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/calico-apiserver/</span>calico<span class="hljs-operator">-</span>apiserver<span class="hljs-operator">-</span>77dffffcdf<span class="hljs-operator">-</span>g2tcx<br><span class="hljs-regexp">/registry/</span>pods<span class="hljs-regexp">/default/</span>toolbox<span class="hljs-operator">-</span>68f79dd5f8<span class="hljs-operator">-</span>4664n<br></code></pre></td></tr></table></figure><p><strong>Kubernetes 集群中 etcd 的部署拓扑：</strong></p><ol><li><p><strong>堆叠式（Stacked）：</strong> 控制平面和 etcd 成员位于同一节点。</p><ul><li>优点：易于建立和管理。</li><li>缺点：存在耦合失败的风险。</li></ul></li><li><p><strong>外部（External）：</strong> 控制平面和 etcd 成员解耦。</p><ul><li>优点：降低耦合失败的风险。</li><li>缺点：需要更多的主机。</li></ul><img src="/2025/03/13/etcd/image-20250317001643290.png" class="" title="image-20250317001643290"></li></ol><img src="/2025/03/13/etcd/image-20250317001741454.png" class="" title="image-20250317001741454"><img src="/2025/03/13/etcd/image-20250317001746455.png" class="" title="image-20250317001746455"><h2 id="最佳实践和优化"><a href="#最佳实践和优化" class="headerlink" title="最佳实践和优化"></a>最佳实践和优化</h2><ol><li><strong>集群规模：</strong> 建议使用 3 或 5 个 etcd 节点，根据集群规模进行调整。</li><li><strong>网络延迟：</strong> 尽量将 etcd 集群部署在同一地域，减少网络延迟。</li><li><strong>磁盘 I&#x2F;O：</strong> 使用 SSD，并将 etcd 数据存放在单独的磁盘。</li><li><strong>日志文件大小：</strong> 定期创建快照，并设置合理的存储配额。</li><li><strong>历史版本压缩：</strong> 自动压缩历史版本，释放存储空间。</li><li><strong>碎片整理：</strong> 定期消除存储碎片。</li><li><strong>数据备份：</strong> 定期创建快照，并上传到网络存储设备。</li></ol><img src="/2025/03/13/etcd/image-20250317001853663.png" class="" title="image-20250317001853663"><ol><li><strong>参数优化：</strong> 根据网络延迟调整心跳周期和选举超时时间。</li><li><strong>安全性：</strong> 启用 peer 和 client 之间的 TLS 加密，并考虑数据加密。</li><li><strong>事件分离：</strong> 对于大规模集群，可以将事件存储在单独的 etcd 集群中。</li></ol><h2 id="etcd-常见问题与解决方案"><a href="#etcd-常见问题与解决方案" class="headerlink" title="etcd 常见问题与解决方案"></a>etcd 常见问题与解决方案</h2><ol><li><strong>频繁的leader election</strong>： 检查网络，查看是否有丢包现象</li><li><strong>etcd 分裂</strong>：检查集群配置。</li><li><strong>etcd 不响应</strong>： 检查磁盘，网络。</li><li><strong>与apiserver之间的链路阻塞</strong>: 检查客户端并发。</li><li><strong>磁盘暴涨</strong>： 检查是否有大量数据写入。</li><li><strong>少数etcd 成员Down</strong>:  检查 down 掉的 etcd 日志。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的Cgroup</title>
    <link href="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/"/>
    <url>/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/</url>
    
    <content type="html"><![CDATA[<p><strong>cgroup（Control Groups）</strong> 是 Linux 内核中的一项重要功能，用于管理和限制系统资源的使用。它允许用户按照需求对 CPU、内存、I&#x2F;O 等资源进行精细化的控制，从而为容器化技术（如 Docker 和 Kubernetes）提供了基础支持。</p><span id="more"></span><p>Linux 的 cgroup 有两个版本：<strong>cgroup v1</strong> 和 <strong>cgroup v2</strong>。随着 Linux 内核的发展，cgroup v2 在功能和设计上对 v1 做了很多改进。本文将详细探讨 cgroup v1 和 v2 的区别，并提供技术细节和实际应用示例。</p><hr><h2 id="什么是-cgroup？"><a href="#什么是-cgroup？" class="headerlink" title="什么是 cgroup？"></a>什么是 cgroup？</h2><p>cgroup 是 Linux 内核的一项功能，用于：</p><ol><li><strong>资源限制</strong>：限制某些进程可以使用的资源量（如 CPU、内存等）。</li><li><strong>资源优先级</strong>：为不同的进程分配不同的资源优先级。</li><li><strong>资源计费</strong>：跟踪进程使用的资源量。</li><li><strong>进程管理</strong>：将一组进程组织为一个组，并对其统一管理。</li></ol><p>它的主要应用场景包括：</p><ul><li>容器技术（如 Docker、Kubernetes）。</li><li>虚拟化技术。</li><li>系统性能调优。</li></ul><hr><h2 id="cgroup-v1-和-v2-的区别"><a href="#cgroup-v1-和-v2-的区别" class="headerlink" title="cgroup v1 和 v2 的区别"></a>cgroup v1 和 v2 的区别</h2><h3 id="1-文件结构对比"><a href="#1-文件结构对比" class="headerlink" title="1.文件结构对比"></a>1.<strong>文件结构对比</strong></h3><h4 id="cgroup-v1-的文件结构"><a href="#cgroup-v1-的文件结构" class="headerlink" title="cgroup v1 的文件结构"></a>cgroup v1 的文件结构</h4><p>在 cgroup v1 中，每种资源（如 CPU、内存、I&#x2F;O）都有独立的子系统，每个子系统都有自己的目录和控制文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/<br>├── cpu/<br>│   ├── cpu.cfs_quota_us<br>│   ├── cpu.cfs_period_us<br>│   ├── tasks<br>│   └── ...<br>├── memory/<br>│   ├── memory.limit_in_bytes<br>│   ├── memory.usage_in_bytes<br>│   ├── tasks<br>│   └── ...<br>└── blkio/<br>    ├── blkio.throttle.read_bps_device<br>    ├── blkio.throttle.write_bps_device<br>    ├── tasks<br>    └── ...<br></code></pre></td></tr></table></figure><ul><li>每个子系统（如 <code>cpu</code>、<code>memory</code>）管理自己的资源。</li><li>配置文件分散在不同的目录中，容易导致配置冲突。</li></ul><h4 id="cgroup-v2-的文件结构"><a href="#cgroup-v2-的文件结构" class="headerlink" title="cgroup v2 的文件结构"></a>cgroup v2 的文件结构</h4><p>在 cgroup v2 中，所有控制器共享一个统一的层次结构和文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/sys/fs/cgroup/<br>├── cgroup.controllers<br>├── cgroup.procs<br>├── cgroup.subtree_control<br>├── cpu.max<br>├── memory.max<br>├── io.max<br>└── ...<br></code></pre></td></tr></table></figure><ul><li>统一的文件结构，所有资源控制参数（如 CPU、内存、I&#x2F;O）都在同一目录下。</li><li>减少了配置冲突，更加简洁和高效。</li></ul><hr><h3 id="2-资源控制参数对比"><a href="#2-资源控制参数对比" class="headerlink" title="2. 资源控制参数对比"></a>2. <strong>资源控制参数对比</strong></h3><p>以下是 cgroup v1 和 v2 在资源控制方面的主要参数对比：</p><h4 id="CPU-控制参数"><a href="#CPU-控制参数" class="headerlink" title="CPU 控制参数"></a>CPU 控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>设置 CPU 时间配额</td><td><code>cpu.cfs_quota_us</code></td><td><code>cpu.max</code></td></tr><tr><td>设置 CPU 时间周期</td><td><code>cpu.cfs_period_us</code></td><td><code>cpu.max</code></td></tr><tr><td>设置 CPU 权重（优先级）</td><td><code>cpu.shares</code></td><td><code>cpu.weight</code></td></tr></tbody></table><ul><li>在 cgroup v2 中，<code>cpu.max</code> 替代了 <code>cpu.cfs_quota_us</code> 和 <code>cpu.cfs_period_us</code>，格式为 <code>&lt;quota&gt; &lt;period&gt;</code>。</li><li><code>cpu.weight</code> 替代了 <code>cpu.shares</code>，用于设置 CPU 权重。</li></ul><h4 id="内存控制参数"><a href="#内存控制参数" class="headerlink" title="内存控制参数"></a>内存控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>设置内存上限</td><td><code>memory.limit_in_bytes</code></td><td><code>memory.max</code></td></tr><tr><td>设置内存软限制</td><td><code>memory.soft_limit_in_bytes</code></td><td>不支持</td></tr><tr><td>内存使用量</td><td><code>memory.usage_in_bytes</code></td><td><code>memory.current</code></td></tr></tbody></table><ul><li>cgroup v2 简化了内存控制，废弃了一些复杂的参数（如软限制）。</li></ul><h4 id="I-O-控制参数"><a href="#I-O-控制参数" class="headerlink" title="I&#x2F;O 控制参数"></a>I&#x2F;O 控制参数</h4><table><thead><tr><th><strong>功能</strong></th><th><strong>cgroup v1 参数</strong></th><th><strong>cgroup v2 参数</strong></th></tr></thead><tbody><tr><td>限制读写带宽</td><td><code>blkio.throttle.read_bps_device</code></td><td><code>io.max</code></td></tr><tr><td>限制 IOPS</td><td><code>blkio.throttle.write_iops_device</code></td><td><code>io.max</code></td></tr></tbody></table><ul><li>cgroup v2 使用 <code>io.max</code> 统一配置 I&#x2F;O 带宽和 IOPS 限制。</li></ul><hr><h2 id="控制-CPU-使用率示例："><a href="#控制-CPU-使用率示例：" class="headerlink" title="控制 CPU 使用率示例："></a>控制 CPU 使用率示例：</h2><p>运行以下 Go 程序，会吃掉两个 CPU：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">for</span> &#123;<br>                &#125;<br>        &#125;()<br>        <span class="hljs-keyword">for</span> &#123;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">go build -o busyloop</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./busyloop<br></code></pre></td></tr></table></figure><p>此时运行<code>top</code>命令，会显示 200%CPU 占用。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">PID</span> USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                <br><span class="hljs-attribute">426388</span> cadmin    <span class="hljs-number">20</span>   <span class="hljs-number">0</span>  <span class="hljs-number">702356</span>   <span class="hljs-number">1024</span>    <span class="hljs-number">640</span> R <span class="hljs-number">210</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0</span>   <span class="hljs-number">0</span>:<span class="hljs-number">18</span>.<span class="hljs-number">75</span> busyloop  <br></code></pre></td></tr></table></figure><p>他的 PID 号是<code>426388</code>，我们可以<code>mkdir /sys/fs/cgroup/cpudemo</code>，然后将它添加到<code>cpu.procs</code>中。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> <span class="hljs-keyword">ps</span> -ef|<span class="hljs-keyword">grep</span> busyloop|<span class="hljs-keyword">grep</span> -v <span class="hljs-keyword">grep</span>|awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> &gt; cgroup.procs<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;100000 1000000&quot;</span> &gt; cpu.<span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><p>此时限制 100000&#x2F;1000000 就是使用 10% 的 CPU 了。</p><hr><h2 id="如何检查系统使用的是-cgroup-v1-还是-v2？"><a href="#如何检查系统使用的是-cgroup-v1-还是-v2？" class="headerlink" title="如何检查系统使用的是 cgroup v1 还是 v2？"></a>如何检查系统使用的是 cgroup v1 还是 v2？</h2><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount | grep cgroup<br></code></pre></td></tr></table></figure><ul><li>如果输出中包含 <code>cgroup2</code>，说明系统使用的是 cgroup v2。</li><li>如果输出中包含多个子系统（如 <code>cpu</code>、<code>memory</code> 等），说明使用的是 cgroup v1。</li></ul><hr><h2 id="可视化对比"><a href="#可视化对比" class="headerlink" title="可视化对比"></a>可视化对比</h2><p>以下是 cgroup v1 和 v2 的结构对比：</p><img src="/2025/03/13/Linux%E4%B8%AD%E7%9A%84Cgroup/image-20250315141042299.png" class="" title="image-20250315141042299"><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft协议</title>
    <link href="/2025/03/13/Raft%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/03/13/Raft%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>Raft 协议是一种分布式一致性协议，主要用于实现多个节点之间的一致性，为系统提供强一致性保证。本文描述了 Raft 的四种角色、选举机制、日志复制机制以及 <code>Learner</code> 角色的用途和场景。</p><span id="more"></span><hr><h3 id="Raft-协议的角色"><a href="#Raft-协议的角色" class="headerlink" title="Raft 协议的角色"></a><strong>Raft 协议的角色</strong></h3><p>在 Raft 协议中，一个节点可以处于以下四个角色之一：</p><ol><li><p><strong>Follower</strong>（跟随者）</p><ul><li>默认状态，每个节点在初始阶段或者重新加入集群时都会处于该状态。</li><li>被动接收来自 Leader 的心跳包（heartbeat）或日志更新请求。</li><li>如果一段时间（<code>Election Timeout</code>）内没有接收到 Leader 的心跳包，会转变为 Candidate。</li></ul></li><li><p><strong>Candidate</strong>（候选者）</p><ul><li>当一个 Follower 超过 <code>Election Timeout</code> 没有接收到心跳包时，会变为 Candidate 并发起选举。</li><li>向其他节点广播请求投票（<code>RequestVote</code>）。</li><li>如果获得超过半数的节点投票，即成为 Leader。</li><li>如果选举超时且没有节点获胜，会重新开始下一轮选举。</li></ul></li><li><p><strong>Leader</strong>（领导者）</p><ul><li>集群中的核心角色，处理客户端请求，管理日志复制并维持系统一致性。</li><li>定期向 Follower 发送心跳包，表明自己是当前的 Leader。</li><li>负责接收并提交客户端的写操作（通过日志复制机制实现）。</li></ul></li><li><p><strong>Learner</strong>（学习者）</p><ul><li>一个特殊角色，负责接收日志更新但不参与选举或投票。</li><li>通常用于读取副本（read-only replica），主要目的是增加系统的容错性和可扩展性。</li><li>在一些场景下，Learner 扮演只读节点的角色，例如为了避免对选举过程产生影响，同时满足读扩展需求。</li></ul></li></ol><hr><h3 id="Raft-的-Leader-选举"><a href="#Raft-的-Leader-选举" class="headerlink" title="Raft 的 Leader 选举"></a><strong>Raft 的 Leader 选举</strong></h3><p>起初，所有节点的状态都是 Follower。每个 Follower 都会设置一个随机的 <code>Election Timeout</code>，当这个时间段内没有收到 Leader 的心跳包时，将会发起选举。选举机制如下：</p><ol><li><p><strong>依次选举：</strong></p><ul><li>某个节点首先触发选举状态，变为 Candidate。</li><li>Candidate 向其他节点广播请求投票的消息（<code>RequestVote</code>）。</li><li>其他节点根据候选者的任期（term）和日志完整性决定是否投票给该候选者。</li><li>如果 Candidate 获得集群中过半数节点的选票，则当选 Leader，并开始发送心跳包。</li></ul></li><li><p><strong>冲突处理：</strong></p><ul><li>如果两个或多个节点同时发起选举，且得票数相同，最终导致没有节点获得多数投票，则会进入下一轮选举。</li><li>在进入下一轮选举时，每个节点会重新设置一个随机的 <code>Election Timeout</code>，从而减少下一次选举冲突的概率。</li></ul></li><li><p><strong>Leader 的权威性：</strong><br>当 Leader 当选后，会定期发送心跳包（<code>AppendEntries</code> RPC）。如果其他节点接收到心跳包，则会重置自己的 Election Timeout，确保不会触发新一轮选举。</p></li></ol><hr><h3 id="Raft-的日志复制机制"><a href="#Raft-的日志复制机制" class="headerlink" title="Raft 的日志复制机制"></a><strong>Raft 的日志复制机制</strong></h3><p>当集群中选出了 Leader 后，Leader 开始接收客户端的请求，并通过日志复制机制（Log Replication）确保所有节点状态一致。</p><h4 id="弱一致性："><a href="#弱一致性：" class="headerlink" title="弱一致性："></a><strong>弱一致性：</strong></h4><ol><li>客户端发送请求到 Leader。</li><li>Leader 将操作记录为日志条目，并将其同步到所有 Follower 节点的日志中。</li><li>一旦操作被写入 Leader 的日志，Leader 会直接向客户端返回确认。</li><li>Leader 后续再通知 Follower 提交（Commit）该日志操作。<ul><li>弱一致性具有较低的延迟，但无法保证所有节点都立即同步完成。</li></ul></li></ol><h4 id="强一致性："><a href="#强一致性：" class="headerlink" title="强一致性："></a><strong>强一致性：</strong></h4><ol><li>客户端发送请求到 Leader。</li><li>Leader 将操作记录到自身的日志，然后将该日志条目复制到 Follower 节点。</li><li>Follower 收到日志条目后，会向 Leader 发送确认（ack）信息。</li><li>当 Leader 收到大多数（过半数）节点的确认后，Leader 可以提交（commit）该日志操作，并将结果返回客户端。<ul><li>通过等待大多数节点的确认，确保一致性（即强一致性）。</li></ul></li></ol><p>总结：为了在不同场景下平衡性能和一致性要求，弱一致性和强一致性可以根据系统需求进行选择。</p><hr><h3 id="为什么需要-Learner？有什么应用场景？"><a href="#为什么需要-Learner？有什么应用场景？" class="headerlink" title="为什么需要 Learner？有什么应用场景？"></a><strong>为什么需要 Learner？有什么应用场景？</strong></h3><h4 id="1-什么是-Learner？"><a href="#1-什么是-Learner？" class="headerlink" title="1. 什么是 Learner？"></a><strong>1. 什么是 Learner？</strong></h4><p>Learner 是 Raft 协议中一个特殊的角色：</p><ul><li>Learner 节点被设计为一个只读节点（Read-Only）。</li><li>Learner 不参与选举过程，也不会被要求投票。</li><li>Learner 只接收 Leader 发送的日志复制数据，只用作数据同步，用于扩展系统的读性能或提升容错性。</li></ul><h4 id="2-Learner-的应用场景："><a href="#2-Learner-的应用场景：" class="headerlink" title="2. Learner 的应用场景："></a><strong>2. Learner 的应用场景：</strong></h4><ul><li><p><strong>非核心节点：</strong><br>在一个分布式系统中，为了扩展读取性能，我们可能希望新增更多副本节点。但这些节点不一定需要参与选举和投票。采用 Learner 角色可以减轻选举过程的压力，并不会直接影响一致性协议的核心流程。</p></li><li><p><strong>数据同步：</strong><br>在分布式存储系统中，某些节点因为距离（比如跨地域部署）或硬件性能问题无法及时响应，但仍需要同步集群的最新日志状态。Learner 可以被用作这样的从属节点。</p></li><li><p><strong>新节点加入：</strong><br>通过 Learner 角色将新节点加入到集群中，可以避免直接参与选举和投票所带来的干扰，并且在数据同步完成后，节点可以变为 Follower 正式加入集群。</p></li><li><p><strong>备份和容灾：</strong><br>Learner 节点可以被用于构建灾备集群。其日志内容与主集群一致，在灾难发生时可以切换为 Leader，以实现数据恢复和服务接管。</p></li><li><p><strong>读扩展：</strong><br>通过增加 Learner 节点，可以显著提升系统的读性能，因为这些节点专用于处理只读请求而不会承担写操作（日志复制除外）。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
